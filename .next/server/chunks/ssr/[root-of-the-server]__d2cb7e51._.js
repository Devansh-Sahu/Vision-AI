module.exports=[602150,355707,212439,252920,297651,181977,a=>{"use strict";var b=a.i(187924),c=a.i(572131),d=a.i(750104),e=a.i(30553),f="Progress",[g,h]=(0,d.createContextScope)(f),[i,j]=g(f),k=c.forwardRef((a,c)=>{var d,f;let{__scopeProgress:g,value:h=null,max:j,getValueLabel:k=n,...l}=a;(j||0===j)&&!q(j)&&console.error((d=`${j}`,`Invalid prop \`max\` of value \`${d}\` supplied to \`Progress\`. Only numbers greater than 0 are valid max values. Defaulting to \`100\`.`));let m=q(j)?j:100;null===h||r(h,m)||console.error((f=`${h}`,`Invalid prop \`value\` of value \`${f}\` supplied to \`Progress\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or 100 if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`));let s=r(h,m)?h:null,t=p(s)?k(s,m):void 0;return(0,b.jsx)(i,{scope:g,value:s,max:m,children:(0,b.jsx)(e.Primitive.div,{"aria-valuemax":m,"aria-valuemin":0,"aria-valuenow":p(s)?s:void 0,"aria-valuetext":t,role:"progressbar","data-state":o(s,m),"data-value":s??void 0,"data-max":m,...l,ref:c})})});k.displayName=f;var l="ProgressIndicator",m=c.forwardRef((a,c)=>{let{__scopeProgress:d,...f}=a,g=j(l,d);return(0,b.jsx)(e.Primitive.div,{"data-state":o(g.value,g.max),"data-value":g.value??void 0,"data-max":g.max,...f,ref:c})});function n(a,b){return`${Math.round(a/b*100)}%`}function o(a,b){return null==a?"indeterminate":a===b?"complete":"loading"}function p(a){return"number"==typeof a}function q(a){return p(a)&&!isNaN(a)&&a>0}function r(a,b){return p(a)&&!isNaN(a)&&a<=b&&a>=0}m.displayName=l;var s=a.i(497895);function t({className:a,value:c,...d}){return(0,b.jsx)(k,{"data-slot":"progress",className:(0,s.cn)("bg-primary/20 relative h-2 w-full overflow-hidden rounded-full",a),...d,children:(0,b.jsx)(m,{"data-slot":"progress-indicator",className:"bg-primary h-full w-full flex-1 transition-all",style:{transform:`translateX(-${100-(c||0)}%)`}})})}a.s(["Progress",()=>t],602150);var u=a.i(170106);let v=(0,u.default)("VideoOff",[["path",{d:"M10.66 6H14a2 2 0 0 1 2 2v2.5l5.248-3.062A.5.5 0 0 1 22 7.87v8.196",key:"w8jjjt"}],["path",{d:"M16 16a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h2",key:"1xawa7"}],["path",{d:"m2 2 20 20",key:"1ooewy"}]]);a.s(["VideoOff",()=>v],355707);let w=(0,u.default)("Volume2",[["path",{d:"M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",key:"uqj9uw"}],["path",{d:"M16 9a5 5 0 0 1 0 6",key:"1q6k2b"}],["path",{d:"M19.364 18.364a9 9 0 0 0 0-12.728",key:"ijwkga"}]]);a.s(["Volume2",()=>w],212439);let x=(0,u.default)("VolumeX",[["path",{d:"M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",key:"uqj9uw"}],["line",{x1:"22",x2:"16",y1:"9",y2:"15",key:"1ewh16"}],["line",{x1:"16",x2:"22",y1:"9",y2:"15",key:"5ykzw1"}]]);a.s(["VolumeX",()=>x],252920);let y=(0,u.default)("Gauge",[["path",{d:"m12 14 4-4",key:"9kzdfg"}],["path",{d:"M3.34 19a10 10 0 1 1 17.32 0",key:"19p75a"}]]);a.s(["Gauge",()=>y],297651);let z=.6,A=.4,B=["cow","buffalo","elephant","wrong_way_vehicle","pedestrian","broken_vehicle"];function C(a=20){return{samples:[],windowSize:a,average:100}}function D(a,b){let c=[...a.samples,b];c.length>a.windowSize&&c.shift();let d=c.reduce((a,b)=>a+b,0)/c.length;return{...a,samples:c,average:d}}function E(a,b,c){let d=a?Math.max(0,100-c):0,e=function(a){if(0===a.length)return 0;let b=0;for(let c of a){let a=100*c.confidence;B.includes(c.objectClass)&&(a=Math.min(100,1.3*a)),a*=({critical:1,high:.8,medium:.5,low:.3})[c.severity],b=Math.max(b,a)}return Math.round(b)}(b),f=Math.round(d*z+e*A),g="safe";f>=70?g="high-risk":f>=40&&(g="caution");let h=c<50||b.some(a=>"critical"===a.severity||"high"===a.severity),i=null;if(h){if(c<50&&b.length>0)i=`DANGER: Drowsy driving detected + ${b[0].objectClass} on road!`;else if(c<50)i="ALERT: Drowsiness detected - Please take a break!";else if(b.length>0){let a=b.find(a=>"critical"===a.severity);i=a?`DANGER: ${a.objectClass.replace("_"," ")} detected ahead!`:`WARNING: ${b[0].objectClass.replace("_"," ")} detected on road`}}return{overallStatus:g,riskScore:f,alertnessRisk:d,hazardRisk:e,timestamp:Date.now(),shouldAlert:h,alertMessage:i}}function F(a){switch(a){case"safe":return"text-success";case"caution":return"text-warning";case"high-risk":return"text-destructive"}}a.s(["assessRisk",()=>E,"createAlertnessWindow",()=>C,"getStatusColor",()=>F,"updateAlertnessWindow",()=>D],181977)},55844,(a,b,c)=>{"use strict";var d={};function e(a,b){!b.unsigned&&--a;let c=b.unsigned?0:-Math.pow(2,a),d=Math.pow(2,a)-1,e=b.moduloBitLength?Math.pow(2,b.moduloBitLength):Math.pow(2,a),f=b.moduloBitLength?Math.pow(2,b.moduloBitLength-1):Math.pow(2,a-1);return function(a,g){g||(g={});let h=+a;if(g.enforceRange){if(!Number.isFinite(h))throw TypeError("Argument is not a finite number");if((h=(h<0?-1:1)*Math.floor(Math.abs(h)))<c||h>d)throw TypeError("Argument is not in byte range");return h}if(!isNaN(h)&&g.clamp){var i;return(h=(i=h)%1==.5&&(1&i)==0?Math.floor(i):Math.round(i))<c&&(h=c),h>d&&(h=d),h}if(!Number.isFinite(h)||0===h)return 0;if(h=(h<0?-1:1)*Math.floor(Math.abs(h))%e,!b.unsigned&&h>=f)return h-e;if(b.unsigned){if(h<0)h+=e;else if(-0===h)return 0}return h}}b.exports=d,d.void=function(){},d.boolean=function(a){return!!a},d.byte=e(8,{unsigned:!1}),d.octet=e(8,{unsigned:!0}),d.short=e(16,{unsigned:!1}),d["unsigned short"]=e(16,{unsigned:!0}),d.long=e(32,{unsigned:!1}),d["unsigned long"]=e(32,{unsigned:!0}),d["long long"]=e(32,{unsigned:!1,moduloBitLength:64}),d["unsigned long long"]=e(32,{unsigned:!0,moduloBitLength:64}),d.double=function(a){let b=+a;if(!Number.isFinite(b))throw TypeError("Argument is not a finite floating-point value");return b},d["unrestricted double"]=function(a){let b=+a;if(isNaN(b))throw TypeError("Argument is NaN");return b},d.float=d.double,d["unrestricted float"]=d["unrestricted double"],d.DOMString=function(a,b){return(b||(b={}),b.treatNullAsEmptyString&&null===a)?"":String(a)},d.ByteString=function(a,b){let c,d=String(a);for(let a=0;void 0!==(c=d.codePointAt(a));++a)if(c>255)throw TypeError("Argument is not a valid bytestring");return d},d.USVString=function(a){let b=String(a),c=b.length,d=[];for(let a=0;a<c;++a){let e=b.charCodeAt(a);if(e<55296||e>57343)d.push(String.fromCodePoint(e));else if(56320<=e&&e<=57343)d.push(String.fromCodePoint(65533));else if(a===c-1)d.push(String.fromCodePoint(65533));else{let c=b.charCodeAt(a+1);if(56320<=c&&c<=57343){let b=1023&e,f=1023&c;d.push(String.fromCodePoint(65536+1024*b+f)),++a}else d.push(String.fromCodePoint(65533))}}return d.join("")},d.Date=function(a,b){if(!(a instanceof Date))throw TypeError("Argument is not a Date object");if(!isNaN(a))return a},d.RegExp=function(a,b){return a instanceof RegExp||(a=new RegExp(a)),a}},721905,(a,b,c)=>{"use strict";b.exports.mixin=function(a,b){let c=Object.getOwnPropertyNames(b);for(let d=0;d<c.length;++d)Object.defineProperty(a,c[d],Object.getOwnPropertyDescriptor(b,c[d]))},b.exports.wrapperSymbol=Symbol("wrapper"),b.exports.implSymbol=Symbol("impl"),b.exports.wrapperForImpl=function(a){return a[b.exports.wrapperSymbol]},b.exports.implForWrapper=function(a){return a[b.exports.implSymbol]}},992097,(a,b,c)=>{b.exports=a.x("punycode",()=>require("punycode"))},545736,a=>{a.v(JSON.parse('[[[0,44],"disallowed_STD3_valid"],[[45,46],"valid"],[[47,47],"disallowed_STD3_valid"],[[48,57],"valid"],[[58,64],"disallowed_STD3_valid"],[[65,65],"mapped",[97]],[[66,66],"mapped",[98]],[[67,67],"mapped",[99]],[[68,68],"mapped",[100]],[[69,69],"mapped",[101]],[[70,70],"mapped",[102]],[[71,71],"mapped",[103]],[[72,72],"mapped",[104]],[[73,73],"mapped",[105]],[[74,74],"mapped",[106]],[[75,75],"mapped",[107]],[[76,76],"mapped",[108]],[[77,77],"mapped",[109]],[[78,78],"mapped",[110]],[[79,79],"mapped",[111]],[[80,80],"mapped",[112]],[[81,81],"mapped",[113]],[[82,82],"mapped",[114]],[[83,83],"mapped",[115]],[[84,84],"mapped",[116]],[[85,85],"mapped",[117]],[[86,86],"mapped",[118]],[[87,87],"mapped",[119]],[[88,88],"mapped",[120]],[[89,89],"mapped",[121]],[[90,90],"mapped",[122]],[[91,96],"disallowed_STD3_valid"],[[97,122],"valid"],[[123,127],"disallowed_STD3_valid"],[[128,159],"disallowed"],[[160,160],"disallowed_STD3_mapped",[32]],[[161,167],"valid",[],"NV8"],[[168,168],"disallowed_STD3_mapped",[32,776]],[[169,169],"valid",[],"NV8"],[[170,170],"mapped",[97]],[[171,172],"valid",[],"NV8"],[[173,173],"ignored"],[[174,174],"valid",[],"NV8"],[[175,175],"disallowed_STD3_mapped",[32,772]],[[176,177],"valid",[],"NV8"],[[178,178],"mapped",[50]],[[179,179],"mapped",[51]],[[180,180],"disallowed_STD3_mapped",[32,769]],[[181,181],"mapped",[956]],[[182,182],"valid",[],"NV8"],[[183,183],"valid"],[[184,184],"disallowed_STD3_mapped",[32,807]],[[185,185],"mapped",[49]],[[186,186],"mapped",[111]],[[187,187],"valid",[],"NV8"],[[188,188],"mapped",[49,8260,52]],[[189,189],"mapped",[49,8260,50]],[[190,190],"mapped",[51,8260,52]],[[191,191],"valid",[],"NV8"],[[192,192],"mapped",[224]],[[193,193],"mapped",[225]],[[194,194],"mapped",[226]],[[195,195],"mapped",[227]],[[196,196],"mapped",[228]],[[197,197],"mapped",[229]],[[198,198],"mapped",[230]],[[199,199],"mapped",[231]],[[200,200],"mapped",[232]],[[201,201],"mapped",[233]],[[202,202],"mapped",[234]],[[203,203],"mapped",[235]],[[204,204],"mapped",[236]],[[205,205],"mapped",[237]],[[206,206],"mapped",[238]],[[207,207],"mapped",[239]],[[208,208],"mapped",[240]],[[209,209],"mapped",[241]],[[210,210],"mapped",[242]],[[211,211],"mapped",[243]],[[212,212],"mapped",[244]],[[213,213],"mapped",[245]],[[214,214],"mapped",[246]],[[215,215],"valid",[],"NV8"],[[216,216],"mapped",[248]],[[217,217],"mapped",[249]],[[218,218],"mapped",[250]],[[219,219],"mapped",[251]],[[220,220],"mapped",[252]],[[221,221],"mapped",[253]],[[222,222],"mapped",[254]],[[223,223],"deviation",[115,115]],[[224,246],"valid"],[[247,247],"valid",[],"NV8"],[[248,255],"valid"],[[256,256],"mapped",[257]],[[257,257],"valid"],[[258,258],"mapped",[259]],[[259,259],"valid"],[[260,260],"mapped",[261]],[[261,261],"valid"],[[262,262],"mapped",[263]],[[263,263],"valid"],[[264,264],"mapped",[265]],[[265,265],"valid"],[[266,266],"mapped",[267]],[[267,267],"valid"],[[268,268],"mapped",[269]],[[269,269],"valid"],[[270,270],"mapped",[271]],[[271,271],"valid"],[[272,272],"mapped",[273]],[[273,273],"valid"],[[274,274],"mapped",[275]],[[275,275],"valid"],[[276,276],"mapped",[277]],[[277,277],"valid"],[[278,278],"mapped",[279]],[[279,279],"valid"],[[280,280],"mapped",[281]],[[281,281],"valid"],[[282,282],"mapped",[283]],[[283,283],"valid"],[[284,284],"mapped",[285]],[[285,285],"valid"],[[286,286],"mapped",[287]],[[287,287],"valid"],[[288,288],"mapped",[289]],[[289,289],"valid"],[[290,290],"mapped",[291]],[[291,291],"valid"],[[292,292],"mapped",[293]],[[293,293],"valid"],[[294,294],"mapped",[295]],[[295,295],"valid"],[[296,296],"mapped",[297]],[[297,297],"valid"],[[298,298],"mapped",[299]],[[299,299],"valid"],[[300,300],"mapped",[301]],[[301,301],"valid"],[[302,302],"mapped",[303]],[[303,303],"valid"],[[304,304],"mapped",[105,775]],[[305,305],"valid"],[[306,307],"mapped",[105,106]],[[308,308],"mapped",[309]],[[309,309],"valid"],[[310,310],"mapped",[311]],[[311,312],"valid"],[[313,313],"mapped",[314]],[[314,314],"valid"],[[315,315],"mapped",[316]],[[316,316],"valid"],[[317,317],"mapped",[318]],[[318,318],"valid"],[[319,320],"mapped",[108,183]],[[321,321],"mapped",[322]],[[322,322],"valid"],[[323,323],"mapped",[324]],[[324,324],"valid"],[[325,325],"mapped",[326]],[[326,326],"valid"],[[327,327],"mapped",[328]],[[328,328],"valid"],[[329,329],"mapped",[700,110]],[[330,330],"mapped",[331]],[[331,331],"valid"],[[332,332],"mapped",[333]],[[333,333],"valid"],[[334,334],"mapped",[335]],[[335,335],"valid"],[[336,336],"mapped",[337]],[[337,337],"valid"],[[338,338],"mapped",[339]],[[339,339],"valid"],[[340,340],"mapped",[341]],[[341,341],"valid"],[[342,342],"mapped",[343]],[[343,343],"valid"],[[344,344],"mapped",[345]],[[345,345],"valid"],[[346,346],"mapped",[347]],[[347,347],"valid"],[[348,348],"mapped",[349]],[[349,349],"valid"],[[350,350],"mapped",[351]],[[351,351],"valid"],[[352,352],"mapped",[353]],[[353,353],"valid"],[[354,354],"mapped",[355]],[[355,355],"valid"],[[356,356],"mapped",[357]],[[357,357],"valid"],[[358,358],"mapped",[359]],[[359,359],"valid"],[[360,360],"mapped",[361]],[[361,361],"valid"],[[362,362],"mapped",[363]],[[363,363],"valid"],[[364,364],"mapped",[365]],[[365,365],"valid"],[[366,366],"mapped",[367]],[[367,367],"valid"],[[368,368],"mapped",[369]],[[369,369],"valid"],[[370,370],"mapped",[371]],[[371,371],"valid"],[[372,372],"mapped",[373]],[[373,373],"valid"],[[374,374],"mapped",[375]],[[375,375],"valid"],[[376,376],"mapped",[255]],[[377,377],"mapped",[378]],[[378,378],"valid"],[[379,379],"mapped",[380]],[[380,380],"valid"],[[381,381],"mapped",[382]],[[382,382],"valid"],[[383,383],"mapped",[115]],[[384,384],"valid"],[[385,385],"mapped",[595]],[[386,386],"mapped",[387]],[[387,387],"valid"],[[388,388],"mapped",[389]],[[389,389],"valid"],[[390,390],"mapped",[596]],[[391,391],"mapped",[392]],[[392,392],"valid"],[[393,393],"mapped",[598]],[[394,394],"mapped",[599]],[[395,395],"mapped",[396]],[[396,397],"valid"],[[398,398],"mapped",[477]],[[399,399],"mapped",[601]],[[400,400],"mapped",[603]],[[401,401],"mapped",[402]],[[402,402],"valid"],[[403,403],"mapped",[608]],[[404,404],"mapped",[611]],[[405,405],"valid"],[[406,406],"mapped",[617]],[[407,407],"mapped",[616]],[[408,408],"mapped",[409]],[[409,411],"valid"],[[412,412],"mapped",[623]],[[413,413],"mapped",[626]],[[414,414],"valid"],[[415,415],"mapped",[629]],[[416,416],"mapped",[417]],[[417,417],"valid"],[[418,418],"mapped",[419]],[[419,419],"valid"],[[420,420],"mapped",[421]],[[421,421],"valid"],[[422,422],"mapped",[640]],[[423,423],"mapped",[424]],[[424,424],"valid"],[[425,425],"mapped",[643]],[[426,427],"valid"],[[428,428],"mapped",[429]],[[429,429],"valid"],[[430,430],"mapped",[648]],[[431,431],"mapped",[432]],[[432,432],"valid"],[[433,433],"mapped",[650]],[[434,434],"mapped",[651]],[[435,435],"mapped",[436]],[[436,436],"valid"],[[437,437],"mapped",[438]],[[438,438],"valid"],[[439,439],"mapped",[658]],[[440,440],"mapped",[441]],[[441,443],"valid"],[[444,444],"mapped",[445]],[[445,451],"valid"],[[452,454],"mapped",[100,382]],[[455,457],"mapped",[108,106]],[[458,460],"mapped",[110,106]],[[461,461],"mapped",[462]],[[462,462],"valid"],[[463,463],"mapped",[464]],[[464,464],"valid"],[[465,465],"mapped",[466]],[[466,466],"valid"],[[467,467],"mapped",[468]],[[468,468],"valid"],[[469,469],"mapped",[470]],[[470,470],"valid"],[[471,471],"mapped",[472]],[[472,472],"valid"],[[473,473],"mapped",[474]],[[474,474],"valid"],[[475,475],"mapped",[476]],[[476,477],"valid"],[[478,478],"mapped",[479]],[[479,479],"valid"],[[480,480],"mapped",[481]],[[481,481],"valid"],[[482,482],"mapped",[483]],[[483,483],"valid"],[[484,484],"mapped",[485]],[[485,485],"valid"],[[486,486],"mapped",[487]],[[487,487],"valid"],[[488,488],"mapped",[489]],[[489,489],"valid"],[[490,490],"mapped",[491]],[[491,491],"valid"],[[492,492],"mapped",[493]],[[493,493],"valid"],[[494,494],"mapped",[495]],[[495,496],"valid"],[[497,499],"mapped",[100,122]],[[500,500],"mapped",[501]],[[501,501],"valid"],[[502,502],"mapped",[405]],[[503,503],"mapped",[447]],[[504,504],"mapped",[505]],[[505,505],"valid"],[[506,506],"mapped",[507]],[[507,507],"valid"],[[508,508],"mapped",[509]],[[509,509],"valid"],[[510,510],"mapped",[511]],[[511,511],"valid"],[[512,512],"mapped",[513]],[[513,513],"valid"],[[514,514],"mapped",[515]],[[515,515],"valid"],[[516,516],"mapped",[517]],[[517,517],"valid"],[[518,518],"mapped",[519]],[[519,519],"valid"],[[520,520],"mapped",[521]],[[521,521],"valid"],[[522,522],"mapped",[523]],[[523,523],"valid"],[[524,524],"mapped",[525]],[[525,525],"valid"],[[526,526],"mapped",[527]],[[527,527],"valid"],[[528,528],"mapped",[529]],[[529,529],"valid"],[[530,530],"mapped",[531]],[[531,531],"valid"],[[532,532],"mapped",[533]],[[533,533],"valid"],[[534,534],"mapped",[535]],[[535,535],"valid"],[[536,536],"mapped",[537]],[[537,537],"valid"],[[538,538],"mapped",[539]],[[539,539],"valid"],[[540,540],"mapped",[541]],[[541,541],"valid"],[[542,542],"mapped",[543]],[[543,543],"valid"],[[544,544],"mapped",[414]],[[545,545],"valid"],[[546,546],"mapped",[547]],[[547,547],"valid"],[[548,548],"mapped",[549]],[[549,549],"valid"],[[550,550],"mapped",[551]],[[551,551],"valid"],[[552,552],"mapped",[553]],[[553,553],"valid"],[[554,554],"mapped",[555]],[[555,555],"valid"],[[556,556],"mapped",[557]],[[557,557],"valid"],[[558,558],"mapped",[559]],[[559,559],"valid"],[[560,560],"mapped",[561]],[[561,561],"valid"],[[562,562],"mapped",[563]],[[563,563],"valid"],[[564,566],"valid"],[[567,569],"valid"],[[570,570],"mapped",[11365]],[[571,571],"mapped",[572]],[[572,572],"valid"],[[573,573],"mapped",[410]],[[574,574],"mapped",[11366]],[[575,576],"valid"],[[577,577],"mapped",[578]],[[578,578],"valid"],[[579,579],"mapped",[384]],[[580,580],"mapped",[649]],[[581,581],"mapped",[652]],[[582,582],"mapped",[583]],[[583,583],"valid"],[[584,584],"mapped",[585]],[[585,585],"valid"],[[586,586],"mapped",[587]],[[587,587],"valid"],[[588,588],"mapped",[589]],[[589,589],"valid"],[[590,590],"mapped",[591]],[[591,591],"valid"],[[592,680],"valid"],[[681,685],"valid"],[[686,687],"valid"],[[688,688],"mapped",[104]],[[689,689],"mapped",[614]],[[690,690],"mapped",[106]],[[691,691],"mapped",[114]],[[692,692],"mapped",[633]],[[693,693],"mapped",[635]],[[694,694],"mapped",[641]],[[695,695],"mapped",[119]],[[696,696],"mapped",[121]],[[697,705],"valid"],[[706,709],"valid",[],"NV8"],[[710,721],"valid"],[[722,727],"valid",[],"NV8"],[[728,728],"disallowed_STD3_mapped",[32,774]],[[729,729],"disallowed_STD3_mapped",[32,775]],[[730,730],"disallowed_STD3_mapped",[32,778]],[[731,731],"disallowed_STD3_mapped",[32,808]],[[732,732],"disallowed_STD3_mapped",[32,771]],[[733,733],"disallowed_STD3_mapped",[32,779]],[[734,734],"valid",[],"NV8"],[[735,735],"valid",[],"NV8"],[[736,736],"mapped",[611]],[[737,737],"mapped",[108]],[[738,738],"mapped",[115]],[[739,739],"mapped",[120]],[[740,740],"mapped",[661]],[[741,745],"valid",[],"NV8"],[[746,747],"valid",[],"NV8"],[[748,748],"valid"],[[749,749],"valid",[],"NV8"],[[750,750],"valid"],[[751,767],"valid",[],"NV8"],[[768,831],"valid"],[[832,832],"mapped",[768]],[[833,833],"mapped",[769]],[[834,834],"valid"],[[835,835],"mapped",[787]],[[836,836],"mapped",[776,769]],[[837,837],"mapped",[953]],[[838,846],"valid"],[[847,847],"ignored"],[[848,855],"valid"],[[856,860],"valid"],[[861,863],"valid"],[[864,865],"valid"],[[866,866],"valid"],[[867,879],"valid"],[[880,880],"mapped",[881]],[[881,881],"valid"],[[882,882],"mapped",[883]],[[883,883],"valid"],[[884,884],"mapped",[697]],[[885,885],"valid"],[[886,886],"mapped",[887]],[[887,887],"valid"],[[888,889],"disallowed"],[[890,890],"disallowed_STD3_mapped",[32,953]],[[891,893],"valid"],[[894,894],"disallowed_STD3_mapped",[59]],[[895,895],"mapped",[1011]],[[896,899],"disallowed"],[[900,900],"disallowed_STD3_mapped",[32,769]],[[901,901],"disallowed_STD3_mapped",[32,776,769]],[[902,902],"mapped",[940]],[[903,903],"mapped",[183]],[[904,904],"mapped",[941]],[[905,905],"mapped",[942]],[[906,906],"mapped",[943]],[[907,907],"disallowed"],[[908,908],"mapped",[972]],[[909,909],"disallowed"],[[910,910],"mapped",[973]],[[911,911],"mapped",[974]],[[912,912],"valid"],[[913,913],"mapped",[945]],[[914,914],"mapped",[946]],[[915,915],"mapped",[947]],[[916,916],"mapped",[948]],[[917,917],"mapped",[949]],[[918,918],"mapped",[950]],[[919,919],"mapped",[951]],[[920,920],"mapped",[952]],[[921,921],"mapped",[953]],[[922,922],"mapped",[954]],[[923,923],"mapped",[955]],[[924,924],"mapped",[956]],[[925,925],"mapped",[957]],[[926,926],"mapped",[958]],[[927,927],"mapped",[959]],[[928,928],"mapped",[960]],[[929,929],"mapped",[961]],[[930,930],"disallowed"],[[931,931],"mapped",[963]],[[932,932],"mapped",[964]],[[933,933],"mapped",[965]],[[934,934],"mapped",[966]],[[935,935],"mapped",[967]],[[936,936],"mapped",[968]],[[937,937],"mapped",[969]],[[938,938],"mapped",[970]],[[939,939],"mapped",[971]],[[940,961],"valid"],[[962,962],"deviation",[963]],[[963,974],"valid"],[[975,975],"mapped",[983]],[[976,976],"mapped",[946]],[[977,977],"mapped",[952]],[[978,978],"mapped",[965]],[[979,979],"mapped",[973]],[[980,980],"mapped",[971]],[[981,981],"mapped",[966]],[[982,982],"mapped",[960]],[[983,983],"valid"],[[984,984],"mapped",[985]],[[985,985],"valid"],[[986,986],"mapped",[987]],[[987,987],"valid"],[[988,988],"mapped",[989]],[[989,989],"valid"],[[990,990],"mapped",[991]],[[991,991],"valid"],[[992,992],"mapped",[993]],[[993,993],"valid"],[[994,994],"mapped",[995]],[[995,995],"valid"],[[996,996],"mapped",[997]],[[997,997],"valid"],[[998,998],"mapped",[999]],[[999,999],"valid"],[[1000,1000],"mapped",[1001]],[[1001,1001],"valid"],[[1002,1002],"mapped",[1003]],[[1003,1003],"valid"],[[1004,1004],"mapped",[1005]],[[1005,1005],"valid"],[[1006,1006],"mapped",[1007]],[[1007,1007],"valid"],[[1008,1008],"mapped",[954]],[[1009,1009],"mapped",[961]],[[1010,1010],"mapped",[963]],[[1011,1011],"valid"],[[1012,1012],"mapped",[952]],[[1013,1013],"mapped",[949]],[[1014,1014],"valid",[],"NV8"],[[1015,1015],"mapped",[1016]],[[1016,1016],"valid"],[[1017,1017],"mapped",[963]],[[1018,1018],"mapped",[1019]],[[1019,1019],"valid"],[[1020,1020],"valid"],[[1021,1021],"mapped",[891]],[[1022,1022],"mapped",[892]],[[1023,1023],"mapped",[893]],[[1024,1024],"mapped",[1104]],[[1025,1025],"mapped",[1105]],[[1026,1026],"mapped",[1106]],[[1027,1027],"mapped",[1107]],[[1028,1028],"mapped",[1108]],[[1029,1029],"mapped",[1109]],[[1030,1030],"mapped",[1110]],[[1031,1031],"mapped",[1111]],[[1032,1032],"mapped",[1112]],[[1033,1033],"mapped",[1113]],[[1034,1034],"mapped",[1114]],[[1035,1035],"mapped",[1115]],[[1036,1036],"mapped",[1116]],[[1037,1037],"mapped",[1117]],[[1038,1038],"mapped",[1118]],[[1039,1039],"mapped",[1119]],[[1040,1040],"mapped",[1072]],[[1041,1041],"mapped",[1073]],[[1042,1042],"mapped",[1074]],[[1043,1043],"mapped",[1075]],[[1044,1044],"mapped",[1076]],[[1045,1045],"mapped",[1077]],[[1046,1046],"mapped",[1078]],[[1047,1047],"mapped",[1079]],[[1048,1048],"mapped",[1080]],[[1049,1049],"mapped",[1081]],[[1050,1050],"mapped",[1082]],[[1051,1051],"mapped",[1083]],[[1052,1052],"mapped",[1084]],[[1053,1053],"mapped",[1085]],[[1054,1054],"mapped",[1086]],[[1055,1055],"mapped",[1087]],[[1056,1056],"mapped",[1088]],[[1057,1057],"mapped",[1089]],[[1058,1058],"mapped",[1090]],[[1059,1059],"mapped",[1091]],[[1060,1060],"mapped",[1092]],[[1061,1061],"mapped",[1093]],[[1062,1062],"mapped",[1094]],[[1063,1063],"mapped",[1095]],[[1064,1064],"mapped",[1096]],[[1065,1065],"mapped",[1097]],[[1066,1066],"mapped",[1098]],[[1067,1067],"mapped",[1099]],[[1068,1068],"mapped",[1100]],[[1069,1069],"mapped",[1101]],[[1070,1070],"mapped",[1102]],[[1071,1071],"mapped",[1103]],[[1072,1103],"valid"],[[1104,1104],"valid"],[[1105,1116],"valid"],[[1117,1117],"valid"],[[1118,1119],"valid"],[[1120,1120],"mapped",[1121]],[[1121,1121],"valid"],[[1122,1122],"mapped",[1123]],[[1123,1123],"valid"],[[1124,1124],"mapped",[1125]],[[1125,1125],"valid"],[[1126,1126],"mapped",[1127]],[[1127,1127],"valid"],[[1128,1128],"mapped",[1129]],[[1129,1129],"valid"],[[1130,1130],"mapped",[1131]],[[1131,1131],"valid"],[[1132,1132],"mapped",[1133]],[[1133,1133],"valid"],[[1134,1134],"mapped",[1135]],[[1135,1135],"valid"],[[1136,1136],"mapped",[1137]],[[1137,1137],"valid"],[[1138,1138],"mapped",[1139]],[[1139,1139],"valid"],[[1140,1140],"mapped",[1141]],[[1141,1141],"valid"],[[1142,1142],"mapped",[1143]],[[1143,1143],"valid"],[[1144,1144],"mapped",[1145]],[[1145,1145],"valid"],[[1146,1146],"mapped",[1147]],[[1147,1147],"valid"],[[1148,1148],"mapped",[1149]],[[1149,1149],"valid"],[[1150,1150],"mapped",[1151]],[[1151,1151],"valid"],[[1152,1152],"mapped",[1153]],[[1153,1153],"valid"],[[1154,1154],"valid",[],"NV8"],[[1155,1158],"valid"],[[1159,1159],"valid"],[[1160,1161],"valid",[],"NV8"],[[1162,1162],"mapped",[1163]],[[1163,1163],"valid"],[[1164,1164],"mapped",[1165]],[[1165,1165],"valid"],[[1166,1166],"mapped",[1167]],[[1167,1167],"valid"],[[1168,1168],"mapped",[1169]],[[1169,1169],"valid"],[[1170,1170],"mapped",[1171]],[[1171,1171],"valid"],[[1172,1172],"mapped",[1173]],[[1173,1173],"valid"],[[1174,1174],"mapped",[1175]],[[1175,1175],"valid"],[[1176,1176],"mapped",[1177]],[[1177,1177],"valid"],[[1178,1178],"mapped",[1179]],[[1179,1179],"valid"],[[1180,1180],"mapped",[1181]],[[1181,1181],"valid"],[[1182,1182],"mapped",[1183]],[[1183,1183],"valid"],[[1184,1184],"mapped",[1185]],[[1185,1185],"valid"],[[1186,1186],"mapped",[1187]],[[1187,1187],"valid"],[[1188,1188],"mapped",[1189]],[[1189,1189],"valid"],[[1190,1190],"mapped",[1191]],[[1191,1191],"valid"],[[1192,1192],"mapped",[1193]],[[1193,1193],"valid"],[[1194,1194],"mapped",[1195]],[[1195,1195],"valid"],[[1196,1196],"mapped",[1197]],[[1197,1197],"valid"],[[1198,1198],"mapped",[1199]],[[1199,1199],"valid"],[[1200,1200],"mapped",[1201]],[[1201,1201],"valid"],[[1202,1202],"mapped",[1203]],[[1203,1203],"valid"],[[1204,1204],"mapped",[1205]],[[1205,1205],"valid"],[[1206,1206],"mapped",[1207]],[[1207,1207],"valid"],[[1208,1208],"mapped",[1209]],[[1209,1209],"valid"],[[1210,1210],"mapped",[1211]],[[1211,1211],"valid"],[[1212,1212],"mapped",[1213]],[[1213,1213],"valid"],[[1214,1214],"mapped",[1215]],[[1215,1215],"valid"],[[1216,1216],"disallowed"],[[1217,1217],"mapped",[1218]],[[1218,1218],"valid"],[[1219,1219],"mapped",[1220]],[[1220,1220],"valid"],[[1221,1221],"mapped",[1222]],[[1222,1222],"valid"],[[1223,1223],"mapped",[1224]],[[1224,1224],"valid"],[[1225,1225],"mapped",[1226]],[[1226,1226],"valid"],[[1227,1227],"mapped",[1228]],[[1228,1228],"valid"],[[1229,1229],"mapped",[1230]],[[1230,1230],"valid"],[[1231,1231],"valid"],[[1232,1232],"mapped",[1233]],[[1233,1233],"valid"],[[1234,1234],"mapped",[1235]],[[1235,1235],"valid"],[[1236,1236],"mapped",[1237]],[[1237,1237],"valid"],[[1238,1238],"mapped",[1239]],[[1239,1239],"valid"],[[1240,1240],"mapped",[1241]],[[1241,1241],"valid"],[[1242,1242],"mapped",[1243]],[[1243,1243],"valid"],[[1244,1244],"mapped",[1245]],[[1245,1245],"valid"],[[1246,1246],"mapped",[1247]],[[1247,1247],"valid"],[[1248,1248],"mapped",[1249]],[[1249,1249],"valid"],[[1250,1250],"mapped",[1251]],[[1251,1251],"valid"],[[1252,1252],"mapped",[1253]],[[1253,1253],"valid"],[[1254,1254],"mapped",[1255]],[[1255,1255],"valid"],[[1256,1256],"mapped",[1257]],[[1257,1257],"valid"],[[1258,1258],"mapped",[1259]],[[1259,1259],"valid"],[[1260,1260],"mapped",[1261]],[[1261,1261],"valid"],[[1262,1262],"mapped",[1263]],[[1263,1263],"valid"],[[1264,1264],"mapped",[1265]],[[1265,1265],"valid"],[[1266,1266],"mapped",[1267]],[[1267,1267],"valid"],[[1268,1268],"mapped",[1269]],[[1269,1269],"valid"],[[1270,1270],"mapped",[1271]],[[1271,1271],"valid"],[[1272,1272],"mapped",[1273]],[[1273,1273],"valid"],[[1274,1274],"mapped",[1275]],[[1275,1275],"valid"],[[1276,1276],"mapped",[1277]],[[1277,1277],"valid"],[[1278,1278],"mapped",[1279]],[[1279,1279],"valid"],[[1280,1280],"mapped",[1281]],[[1281,1281],"valid"],[[1282,1282],"mapped",[1283]],[[1283,1283],"valid"],[[1284,1284],"mapped",[1285]],[[1285,1285],"valid"],[[1286,1286],"mapped",[1287]],[[1287,1287],"valid"],[[1288,1288],"mapped",[1289]],[[1289,1289],"valid"],[[1290,1290],"mapped",[1291]],[[1291,1291],"valid"],[[1292,1292],"mapped",[1293]],[[1293,1293],"valid"],[[1294,1294],"mapped",[1295]],[[1295,1295],"valid"],[[1296,1296],"mapped",[1297]],[[1297,1297],"valid"],[[1298,1298],"mapped",[1299]],[[1299,1299],"valid"],[[1300,1300],"mapped",[1301]],[[1301,1301],"valid"],[[1302,1302],"mapped",[1303]],[[1303,1303],"valid"],[[1304,1304],"mapped",[1305]],[[1305,1305],"valid"],[[1306,1306],"mapped",[1307]],[[1307,1307],"valid"],[[1308,1308],"mapped",[1309]],[[1309,1309],"valid"],[[1310,1310],"mapped",[1311]],[[1311,1311],"valid"],[[1312,1312],"mapped",[1313]],[[1313,1313],"valid"],[[1314,1314],"mapped",[1315]],[[1315,1315],"valid"],[[1316,1316],"mapped",[1317]],[[1317,1317],"valid"],[[1318,1318],"mapped",[1319]],[[1319,1319],"valid"],[[1320,1320],"mapped",[1321]],[[1321,1321],"valid"],[[1322,1322],"mapped",[1323]],[[1323,1323],"valid"],[[1324,1324],"mapped",[1325]],[[1325,1325],"valid"],[[1326,1326],"mapped",[1327]],[[1327,1327],"valid"],[[1328,1328],"disallowed"],[[1329,1329],"mapped",[1377]],[[1330,1330],"mapped",[1378]],[[1331,1331],"mapped",[1379]],[[1332,1332],"mapped",[1380]],[[1333,1333],"mapped",[1381]],[[1334,1334],"mapped",[1382]],[[1335,1335],"mapped",[1383]],[[1336,1336],"mapped",[1384]],[[1337,1337],"mapped",[1385]],[[1338,1338],"mapped",[1386]],[[1339,1339],"mapped",[1387]],[[1340,1340],"mapped",[1388]],[[1341,1341],"mapped",[1389]],[[1342,1342],"mapped",[1390]],[[1343,1343],"mapped",[1391]],[[1344,1344],"mapped",[1392]],[[1345,1345],"mapped",[1393]],[[1346,1346],"mapped",[1394]],[[1347,1347],"mapped",[1395]],[[1348,1348],"mapped",[1396]],[[1349,1349],"mapped",[1397]],[[1350,1350],"mapped",[1398]],[[1351,1351],"mapped",[1399]],[[1352,1352],"mapped",[1400]],[[1353,1353],"mapped",[1401]],[[1354,1354],"mapped",[1402]],[[1355,1355],"mapped",[1403]],[[1356,1356],"mapped",[1404]],[[1357,1357],"mapped",[1405]],[[1358,1358],"mapped",[1406]],[[1359,1359],"mapped",[1407]],[[1360,1360],"mapped",[1408]],[[1361,1361],"mapped",[1409]],[[1362,1362],"mapped",[1410]],[[1363,1363],"mapped",[1411]],[[1364,1364],"mapped",[1412]],[[1365,1365],"mapped",[1413]],[[1366,1366],"mapped",[1414]],[[1367,1368],"disallowed"],[[1369,1369],"valid"],[[1370,1375],"valid",[],"NV8"],[[1376,1376],"disallowed"],[[1377,1414],"valid"],[[1415,1415],"mapped",[1381,1410]],[[1416,1416],"disallowed"],[[1417,1417],"valid",[],"NV8"],[[1418,1418],"valid",[],"NV8"],[[1419,1420],"disallowed"],[[1421,1422],"valid",[],"NV8"],[[1423,1423],"valid",[],"NV8"],[[1424,1424],"disallowed"],[[1425,1441],"valid"],[[1442,1442],"valid"],[[1443,1455],"valid"],[[1456,1465],"valid"],[[1466,1466],"valid"],[[1467,1469],"valid"],[[1470,1470],"valid",[],"NV8"],[[1471,1471],"valid"],[[1472,1472],"valid",[],"NV8"],[[1473,1474],"valid"],[[1475,1475],"valid",[],"NV8"],[[1476,1476],"valid"],[[1477,1477],"valid"],[[1478,1478],"valid",[],"NV8"],[[1479,1479],"valid"],[[1480,1487],"disallowed"],[[1488,1514],"valid"],[[1515,1519],"disallowed"],[[1520,1524],"valid"],[[1525,1535],"disallowed"],[[1536,1539],"disallowed"],[[1540,1540],"disallowed"],[[1541,1541],"disallowed"],[[1542,1546],"valid",[],"NV8"],[[1547,1547],"valid",[],"NV8"],[[1548,1548],"valid",[],"NV8"],[[1549,1551],"valid",[],"NV8"],[[1552,1557],"valid"],[[1558,1562],"valid"],[[1563,1563],"valid",[],"NV8"],[[1564,1564],"disallowed"],[[1565,1565],"disallowed"],[[1566,1566],"valid",[],"NV8"],[[1567,1567],"valid",[],"NV8"],[[1568,1568],"valid"],[[1569,1594],"valid"],[[1595,1599],"valid"],[[1600,1600],"valid",[],"NV8"],[[1601,1618],"valid"],[[1619,1621],"valid"],[[1622,1624],"valid"],[[1625,1630],"valid"],[[1631,1631],"valid"],[[1632,1641],"valid"],[[1642,1645],"valid",[],"NV8"],[[1646,1647],"valid"],[[1648,1652],"valid"],[[1653,1653],"mapped",[1575,1652]],[[1654,1654],"mapped",[1608,1652]],[[1655,1655],"mapped",[1735,1652]],[[1656,1656],"mapped",[1610,1652]],[[1657,1719],"valid"],[[1720,1721],"valid"],[[1722,1726],"valid"],[[1727,1727],"valid"],[[1728,1742],"valid"],[[1743,1743],"valid"],[[1744,1747],"valid"],[[1748,1748],"valid",[],"NV8"],[[1749,1756],"valid"],[[1757,1757],"disallowed"],[[1758,1758],"valid",[],"NV8"],[[1759,1768],"valid"],[[1769,1769],"valid",[],"NV8"],[[1770,1773],"valid"],[[1774,1775],"valid"],[[1776,1785],"valid"],[[1786,1790],"valid"],[[1791,1791],"valid"],[[1792,1805],"valid",[],"NV8"],[[1806,1806],"disallowed"],[[1807,1807],"disallowed"],[[1808,1836],"valid"],[[1837,1839],"valid"],[[1840,1866],"valid"],[[1867,1868],"disallowed"],[[1869,1871],"valid"],[[1872,1901],"valid"],[[1902,1919],"valid"],[[1920,1968],"valid"],[[1969,1969],"valid"],[[1970,1983],"disallowed"],[[1984,2037],"valid"],[[2038,2042],"valid",[],"NV8"],[[2043,2047],"disallowed"],[[2048,2093],"valid"],[[2094,2095],"disallowed"],[[2096,2110],"valid",[],"NV8"],[[2111,2111],"disallowed"],[[2112,2139],"valid"],[[2140,2141],"disallowed"],[[2142,2142],"valid",[],"NV8"],[[2143,2207],"disallowed"],[[2208,2208],"valid"],[[2209,2209],"valid"],[[2210,2220],"valid"],[[2221,2226],"valid"],[[2227,2228],"valid"],[[2229,2274],"disallowed"],[[2275,2275],"valid"],[[2276,2302],"valid"],[[2303,2303],"valid"],[[2304,2304],"valid"],[[2305,2307],"valid"],[[2308,2308],"valid"],[[2309,2361],"valid"],[[2362,2363],"valid"],[[2364,2381],"valid"],[[2382,2382],"valid"],[[2383,2383],"valid"],[[2384,2388],"valid"],[[2389,2389],"valid"],[[2390,2391],"valid"],[[2392,2392],"mapped",[2325,2364]],[[2393,2393],"mapped",[2326,2364]],[[2394,2394],"mapped",[2327,2364]],[[2395,2395],"mapped",[2332,2364]],[[2396,2396],"mapped",[2337,2364]],[[2397,2397],"mapped",[2338,2364]],[[2398,2398],"mapped",[2347,2364]],[[2399,2399],"mapped",[2351,2364]],[[2400,2403],"valid"],[[2404,2405],"valid",[],"NV8"],[[2406,2415],"valid"],[[2416,2416],"valid",[],"NV8"],[[2417,2418],"valid"],[[2419,2423],"valid"],[[2424,2424],"valid"],[[2425,2426],"valid"],[[2427,2428],"valid"],[[2429,2429],"valid"],[[2430,2431],"valid"],[[2432,2432],"valid"],[[2433,2435],"valid"],[[2436,2436],"disallowed"],[[2437,2444],"valid"],[[2445,2446],"disallowed"],[[2447,2448],"valid"],[[2449,2450],"disallowed"],[[2451,2472],"valid"],[[2473,2473],"disallowed"],[[2474,2480],"valid"],[[2481,2481],"disallowed"],[[2482,2482],"valid"],[[2483,2485],"disallowed"],[[2486,2489],"valid"],[[2490,2491],"disallowed"],[[2492,2492],"valid"],[[2493,2493],"valid"],[[2494,2500],"valid"],[[2501,2502],"disallowed"],[[2503,2504],"valid"],[[2505,2506],"disallowed"],[[2507,2509],"valid"],[[2510,2510],"valid"],[[2511,2518],"disallowed"],[[2519,2519],"valid"],[[2520,2523],"disallowed"],[[2524,2524],"mapped",[2465,2492]],[[2525,2525],"mapped",[2466,2492]],[[2526,2526],"disallowed"],[[2527,2527],"mapped",[2479,2492]],[[2528,2531],"valid"],[[2532,2533],"disallowed"],[[2534,2545],"valid"],[[2546,2554],"valid",[],"NV8"],[[2555,2555],"valid",[],"NV8"],[[2556,2560],"disallowed"],[[2561,2561],"valid"],[[2562,2562],"valid"],[[2563,2563],"valid"],[[2564,2564],"disallowed"],[[2565,2570],"valid"],[[2571,2574],"disallowed"],[[2575,2576],"valid"],[[2577,2578],"disallowed"],[[2579,2600],"valid"],[[2601,2601],"disallowed"],[[2602,2608],"valid"],[[2609,2609],"disallowed"],[[2610,2610],"valid"],[[2611,2611],"mapped",[2610,2620]],[[2612,2612],"disallowed"],[[2613,2613],"valid"],[[2614,2614],"mapped",[2616,2620]],[[2615,2615],"disallowed"],[[2616,2617],"valid"],[[2618,2619],"disallowed"],[[2620,2620],"valid"],[[2621,2621],"disallowed"],[[2622,2626],"valid"],[[2627,2630],"disallowed"],[[2631,2632],"valid"],[[2633,2634],"disallowed"],[[2635,2637],"valid"],[[2638,2640],"disallowed"],[[2641,2641],"valid"],[[2642,2648],"disallowed"],[[2649,2649],"mapped",[2582,2620]],[[2650,2650],"mapped",[2583,2620]],[[2651,2651],"mapped",[2588,2620]],[[2652,2652],"valid"],[[2653,2653],"disallowed"],[[2654,2654],"mapped",[2603,2620]],[[2655,2661],"disallowed"],[[2662,2676],"valid"],[[2677,2677],"valid"],[[2678,2688],"disallowed"],[[2689,2691],"valid"],[[2692,2692],"disallowed"],[[2693,2699],"valid"],[[2700,2700],"valid"],[[2701,2701],"valid"],[[2702,2702],"disallowed"],[[2703,2705],"valid"],[[2706,2706],"disallowed"],[[2707,2728],"valid"],[[2729,2729],"disallowed"],[[2730,2736],"valid"],[[2737,2737],"disallowed"],[[2738,2739],"valid"],[[2740,2740],"disallowed"],[[2741,2745],"valid"],[[2746,2747],"disallowed"],[[2748,2757],"valid"],[[2758,2758],"disallowed"],[[2759,2761],"valid"],[[2762,2762],"disallowed"],[[2763,2765],"valid"],[[2766,2767],"disallowed"],[[2768,2768],"valid"],[[2769,2783],"disallowed"],[[2784,2784],"valid"],[[2785,2787],"valid"],[[2788,2789],"disallowed"],[[2790,2799],"valid"],[[2800,2800],"valid",[],"NV8"],[[2801,2801],"valid",[],"NV8"],[[2802,2808],"disallowed"],[[2809,2809],"valid"],[[2810,2816],"disallowed"],[[2817,2819],"valid"],[[2820,2820],"disallowed"],[[2821,2828],"valid"],[[2829,2830],"disallowed"],[[2831,2832],"valid"],[[2833,2834],"disallowed"],[[2835,2856],"valid"],[[2857,2857],"disallowed"],[[2858,2864],"valid"],[[2865,2865],"disallowed"],[[2866,2867],"valid"],[[2868,2868],"disallowed"],[[2869,2869],"valid"],[[2870,2873],"valid"],[[2874,2875],"disallowed"],[[2876,2883],"valid"],[[2884,2884],"valid"],[[2885,2886],"disallowed"],[[2887,2888],"valid"],[[2889,2890],"disallowed"],[[2891,2893],"valid"],[[2894,2901],"disallowed"],[[2902,2903],"valid"],[[2904,2907],"disallowed"],[[2908,2908],"mapped",[2849,2876]],[[2909,2909],"mapped",[2850,2876]],[[2910,2910],"disallowed"],[[2911,2913],"valid"],[[2914,2915],"valid"],[[2916,2917],"disallowed"],[[2918,2927],"valid"],[[2928,2928],"valid",[],"NV8"],[[2929,2929],"valid"],[[2930,2935],"valid",[],"NV8"],[[2936,2945],"disallowed"],[[2946,2947],"valid"],[[2948,2948],"disallowed"],[[2949,2954],"valid"],[[2955,2957],"disallowed"],[[2958,2960],"valid"],[[2961,2961],"disallowed"],[[2962,2965],"valid"],[[2966,2968],"disallowed"],[[2969,2970],"valid"],[[2971,2971],"disallowed"],[[2972,2972],"valid"],[[2973,2973],"disallowed"],[[2974,2975],"valid"],[[2976,2978],"disallowed"],[[2979,2980],"valid"],[[2981,2983],"disallowed"],[[2984,2986],"valid"],[[2987,2989],"disallowed"],[[2990,2997],"valid"],[[2998,2998],"valid"],[[2999,3001],"valid"],[[3002,3005],"disallowed"],[[3006,3010],"valid"],[[3011,3013],"disallowed"],[[3014,3016],"valid"],[[3017,3017],"disallowed"],[[3018,3021],"valid"],[[3022,3023],"disallowed"],[[3024,3024],"valid"],[[3025,3030],"disallowed"],[[3031,3031],"valid"],[[3032,3045],"disallowed"],[[3046,3046],"valid"],[[3047,3055],"valid"],[[3056,3058],"valid",[],"NV8"],[[3059,3066],"valid",[],"NV8"],[[3067,3071],"disallowed"],[[3072,3072],"valid"],[[3073,3075],"valid"],[[3076,3076],"disallowed"],[[3077,3084],"valid"],[[3085,3085],"disallowed"],[[3086,3088],"valid"],[[3089,3089],"disallowed"],[[3090,3112],"valid"],[[3113,3113],"disallowed"],[[3114,3123],"valid"],[[3124,3124],"valid"],[[3125,3129],"valid"],[[3130,3132],"disallowed"],[[3133,3133],"valid"],[[3134,3140],"valid"],[[3141,3141],"disallowed"],[[3142,3144],"valid"],[[3145,3145],"disallowed"],[[3146,3149],"valid"],[[3150,3156],"disallowed"],[[3157,3158],"valid"],[[3159,3159],"disallowed"],[[3160,3161],"valid"],[[3162,3162],"valid"],[[3163,3167],"disallowed"],[[3168,3169],"valid"],[[3170,3171],"valid"],[[3172,3173],"disallowed"],[[3174,3183],"valid"],[[3184,3191],"disallowed"],[[3192,3199],"valid",[],"NV8"],[[3200,3200],"disallowed"],[[3201,3201],"valid"],[[3202,3203],"valid"],[[3204,3204],"disallowed"],[[3205,3212],"valid"],[[3213,3213],"disallowed"],[[3214,3216],"valid"],[[3217,3217],"disallowed"],[[3218,3240],"valid"],[[3241,3241],"disallowed"],[[3242,3251],"valid"],[[3252,3252],"disallowed"],[[3253,3257],"valid"],[[3258,3259],"disallowed"],[[3260,3261],"valid"],[[3262,3268],"valid"],[[3269,3269],"disallowed"],[[3270,3272],"valid"],[[3273,3273],"disallowed"],[[3274,3277],"valid"],[[3278,3284],"disallowed"],[[3285,3286],"valid"],[[3287,3293],"disallowed"],[[3294,3294],"valid"],[[3295,3295],"disallowed"],[[3296,3297],"valid"],[[3298,3299],"valid"],[[3300,3301],"disallowed"],[[3302,3311],"valid"],[[3312,3312],"disallowed"],[[3313,3314],"valid"],[[3315,3328],"disallowed"],[[3329,3329],"valid"],[[3330,3331],"valid"],[[3332,3332],"disallowed"],[[3333,3340],"valid"],[[3341,3341],"disallowed"],[[3342,3344],"valid"],[[3345,3345],"disallowed"],[[3346,3368],"valid"],[[3369,3369],"valid"],[[3370,3385],"valid"],[[3386,3386],"valid"],[[3387,3388],"disallowed"],[[3389,3389],"valid"],[[3390,3395],"valid"],[[3396,3396],"valid"],[[3397,3397],"disallowed"],[[3398,3400],"valid"],[[3401,3401],"disallowed"],[[3402,3405],"valid"],[[3406,3406],"valid"],[[3407,3414],"disallowed"],[[3415,3415],"valid"],[[3416,3422],"disallowed"],[[3423,3423],"valid"],[[3424,3425],"valid"],[[3426,3427],"valid"],[[3428,3429],"disallowed"],[[3430,3439],"valid"],[[3440,3445],"valid",[],"NV8"],[[3446,3448],"disallowed"],[[3449,3449],"valid",[],"NV8"],[[3450,3455],"valid"],[[3456,3457],"disallowed"],[[3458,3459],"valid"],[[3460,3460],"disallowed"],[[3461,3478],"valid"],[[3479,3481],"disallowed"],[[3482,3505],"valid"],[[3506,3506],"disallowed"],[[3507,3515],"valid"],[[3516,3516],"disallowed"],[[3517,3517],"valid"],[[3518,3519],"disallowed"],[[3520,3526],"valid"],[[3527,3529],"disallowed"],[[3530,3530],"valid"],[[3531,3534],"disallowed"],[[3535,3540],"valid"],[[3541,3541],"disallowed"],[[3542,3542],"valid"],[[3543,3543],"disallowed"],[[3544,3551],"valid"],[[3552,3557],"disallowed"],[[3558,3567],"valid"],[[3568,3569],"disallowed"],[[3570,3571],"valid"],[[3572,3572],"valid",[],"NV8"],[[3573,3584],"disallowed"],[[3585,3634],"valid"],[[3635,3635],"mapped",[3661,3634]],[[3636,3642],"valid"],[[3643,3646],"disallowed"],[[3647,3647],"valid",[],"NV8"],[[3648,3662],"valid"],[[3663,3663],"valid",[],"NV8"],[[3664,3673],"valid"],[[3674,3675],"valid",[],"NV8"],[[3676,3712],"disallowed"],[[3713,3714],"valid"],[[3715,3715],"disallowed"],[[3716,3716],"valid"],[[3717,3718],"disallowed"],[[3719,3720],"valid"],[[3721,3721],"disallowed"],[[3722,3722],"valid"],[[3723,3724],"disallowed"],[[3725,3725],"valid"],[[3726,3731],"disallowed"],[[3732,3735],"valid"],[[3736,3736],"disallowed"],[[3737,3743],"valid"],[[3744,3744],"disallowed"],[[3745,3747],"valid"],[[3748,3748],"disallowed"],[[3749,3749],"valid"],[[3750,3750],"disallowed"],[[3751,3751],"valid"],[[3752,3753],"disallowed"],[[3754,3755],"valid"],[[3756,3756],"disallowed"],[[3757,3762],"valid"],[[3763,3763],"mapped",[3789,3762]],[[3764,3769],"valid"],[[3770,3770],"disallowed"],[[3771,3773],"valid"],[[3774,3775],"disallowed"],[[3776,3780],"valid"],[[3781,3781],"disallowed"],[[3782,3782],"valid"],[[3783,3783],"disallowed"],[[3784,3789],"valid"],[[3790,3791],"disallowed"],[[3792,3801],"valid"],[[3802,3803],"disallowed"],[[3804,3804],"mapped",[3755,3737]],[[3805,3805],"mapped",[3755,3745]],[[3806,3807],"valid"],[[3808,3839],"disallowed"],[[3840,3840],"valid"],[[3841,3850],"valid",[],"NV8"],[[3851,3851],"valid"],[[3852,3852],"mapped",[3851]],[[3853,3863],"valid",[],"NV8"],[[3864,3865],"valid"],[[3866,3871],"valid",[],"NV8"],[[3872,3881],"valid"],[[3882,3892],"valid",[],"NV8"],[[3893,3893],"valid"],[[3894,3894],"valid",[],"NV8"],[[3895,3895],"valid"],[[3896,3896],"valid",[],"NV8"],[[3897,3897],"valid"],[[3898,3901],"valid",[],"NV8"],[[3902,3906],"valid"],[[3907,3907],"mapped",[3906,4023]],[[3908,3911],"valid"],[[3912,3912],"disallowed"],[[3913,3916],"valid"],[[3917,3917],"mapped",[3916,4023]],[[3918,3921],"valid"],[[3922,3922],"mapped",[3921,4023]],[[3923,3926],"valid"],[[3927,3927],"mapped",[3926,4023]],[[3928,3931],"valid"],[[3932,3932],"mapped",[3931,4023]],[[3933,3944],"valid"],[[3945,3945],"mapped",[3904,4021]],[[3946,3946],"valid"],[[3947,3948],"valid"],[[3949,3952],"disallowed"],[[3953,3954],"valid"],[[3955,3955],"mapped",[3953,3954]],[[3956,3956],"valid"],[[3957,3957],"mapped",[3953,3956]],[[3958,3958],"mapped",[4018,3968]],[[3959,3959],"mapped",[4018,3953,3968]],[[3960,3960],"mapped",[4019,3968]],[[3961,3961],"mapped",[4019,3953,3968]],[[3962,3968],"valid"],[[3969,3969],"mapped",[3953,3968]],[[3970,3972],"valid"],[[3973,3973],"valid",[],"NV8"],[[3974,3979],"valid"],[[3980,3983],"valid"],[[3984,3986],"valid"],[[3987,3987],"mapped",[3986,4023]],[[3988,3989],"valid"],[[3990,3990],"valid"],[[3991,3991],"valid"],[[3992,3992],"disallowed"],[[3993,3996],"valid"],[[3997,3997],"mapped",[3996,4023]],[[3998,4001],"valid"],[[4002,4002],"mapped",[4001,4023]],[[4003,4006],"valid"],[[4007,4007],"mapped",[4006,4023]],[[4008,4011],"valid"],[[4012,4012],"mapped",[4011,4023]],[[4013,4013],"valid"],[[4014,4016],"valid"],[[4017,4023],"valid"],[[4024,4024],"valid"],[[4025,4025],"mapped",[3984,4021]],[[4026,4028],"valid"],[[4029,4029],"disallowed"],[[4030,4037],"valid",[],"NV8"],[[4038,4038],"valid"],[[4039,4044],"valid",[],"NV8"],[[4045,4045],"disallowed"],[[4046,4046],"valid",[],"NV8"],[[4047,4047],"valid",[],"NV8"],[[4048,4049],"valid",[],"NV8"],[[4050,4052],"valid",[],"NV8"],[[4053,4056],"valid",[],"NV8"],[[4057,4058],"valid",[],"NV8"],[[4059,4095],"disallowed"],[[4096,4129],"valid"],[[4130,4130],"valid"],[[4131,4135],"valid"],[[4136,4136],"valid"],[[4137,4138],"valid"],[[4139,4139],"valid"],[[4140,4146],"valid"],[[4147,4149],"valid"],[[4150,4153],"valid"],[[4154,4159],"valid"],[[4160,4169],"valid"],[[4170,4175],"valid",[],"NV8"],[[4176,4185],"valid"],[[4186,4249],"valid"],[[4250,4253],"valid"],[[4254,4255],"valid",[],"NV8"],[[4256,4293],"disallowed"],[[4294,4294],"disallowed"],[[4295,4295],"mapped",[11559]],[[4296,4300],"disallowed"],[[4301,4301],"mapped",[11565]],[[4302,4303],"disallowed"],[[4304,4342],"valid"],[[4343,4344],"valid"],[[4345,4346],"valid"],[[4347,4347],"valid",[],"NV8"],[[4348,4348],"mapped",[4316]],[[4349,4351],"valid"],[[4352,4441],"valid",[],"NV8"],[[4442,4446],"valid",[],"NV8"],[[4447,4448],"disallowed"],[[4449,4514],"valid",[],"NV8"],[[4515,4519],"valid",[],"NV8"],[[4520,4601],"valid",[],"NV8"],[[4602,4607],"valid",[],"NV8"],[[4608,4614],"valid"],[[4615,4615],"valid"],[[4616,4678],"valid"],[[4679,4679],"valid"],[[4680,4680],"valid"],[[4681,4681],"disallowed"],[[4682,4685],"valid"],[[4686,4687],"disallowed"],[[4688,4694],"valid"],[[4695,4695],"disallowed"],[[4696,4696],"valid"],[[4697,4697],"disallowed"],[[4698,4701],"valid"],[[4702,4703],"disallowed"],[[4704,4742],"valid"],[[4743,4743],"valid"],[[4744,4744],"valid"],[[4745,4745],"disallowed"],[[4746,4749],"valid"],[[4750,4751],"disallowed"],[[4752,4782],"valid"],[[4783,4783],"valid"],[[4784,4784],"valid"],[[4785,4785],"disallowed"],[[4786,4789],"valid"],[[4790,4791],"disallowed"],[[4792,4798],"valid"],[[4799,4799],"disallowed"],[[4800,4800],"valid"],[[4801,4801],"disallowed"],[[4802,4805],"valid"],[[4806,4807],"disallowed"],[[4808,4814],"valid"],[[4815,4815],"valid"],[[4816,4822],"valid"],[[4823,4823],"disallowed"],[[4824,4846],"valid"],[[4847,4847],"valid"],[[4848,4878],"valid"],[[4879,4879],"valid"],[[4880,4880],"valid"],[[4881,4881],"disallowed"],[[4882,4885],"valid"],[[4886,4887],"disallowed"],[[4888,4894],"valid"],[[4895,4895],"valid"],[[4896,4934],"valid"],[[4935,4935],"valid"],[[4936,4954],"valid"],[[4955,4956],"disallowed"],[[4957,4958],"valid"],[[4959,4959],"valid"],[[4960,4960],"valid",[],"NV8"],[[4961,4988],"valid",[],"NV8"],[[4989,4991],"disallowed"],[[4992,5007],"valid"],[[5008,5017],"valid",[],"NV8"],[[5018,5023],"disallowed"],[[5024,5108],"valid"],[[5109,5109],"valid"],[[5110,5111],"disallowed"],[[5112,5112],"mapped",[5104]],[[5113,5113],"mapped",[5105]],[[5114,5114],"mapped",[5106]],[[5115,5115],"mapped",[5107]],[[5116,5116],"mapped",[5108]],[[5117,5117],"mapped",[5109]],[[5118,5119],"disallowed"],[[5120,5120],"valid",[],"NV8"],[[5121,5740],"valid"],[[5741,5742],"valid",[],"NV8"],[[5743,5750],"valid"],[[5751,5759],"valid"],[[5760,5760],"disallowed"],[[5761,5786],"valid"],[[5787,5788],"valid",[],"NV8"],[[5789,5791],"disallowed"],[[5792,5866],"valid"],[[5867,5872],"valid",[],"NV8"],[[5873,5880],"valid"],[[5881,5887],"disallowed"],[[5888,5900],"valid"],[[5901,5901],"disallowed"],[[5902,5908],"valid"],[[5909,5919],"disallowed"],[[5920,5940],"valid"],[[5941,5942],"valid",[],"NV8"],[[5943,5951],"disallowed"],[[5952,5971],"valid"],[[5972,5983],"disallowed"],[[5984,5996],"valid"],[[5997,5997],"disallowed"],[[5998,6000],"valid"],[[6001,6001],"disallowed"],[[6002,6003],"valid"],[[6004,6015],"disallowed"],[[6016,6067],"valid"],[[6068,6069],"disallowed"],[[6070,6099],"valid"],[[6100,6102],"valid",[],"NV8"],[[6103,6103],"valid"],[[6104,6107],"valid",[],"NV8"],[[6108,6108],"valid"],[[6109,6109],"valid"],[[6110,6111],"disallowed"],[[6112,6121],"valid"],[[6122,6127],"disallowed"],[[6128,6137],"valid",[],"NV8"],[[6138,6143],"disallowed"],[[6144,6149],"valid",[],"NV8"],[[6150,6150],"disallowed"],[[6151,6154],"valid",[],"NV8"],[[6155,6157],"ignored"],[[6158,6158],"disallowed"],[[6159,6159],"disallowed"],[[6160,6169],"valid"],[[6170,6175],"disallowed"],[[6176,6263],"valid"],[[6264,6271],"disallowed"],[[6272,6313],"valid"],[[6314,6314],"valid"],[[6315,6319],"disallowed"],[[6320,6389],"valid"],[[6390,6399],"disallowed"],[[6400,6428],"valid"],[[6429,6430],"valid"],[[6431,6431],"disallowed"],[[6432,6443],"valid"],[[6444,6447],"disallowed"],[[6448,6459],"valid"],[[6460,6463],"disallowed"],[[6464,6464],"valid",[],"NV8"],[[6465,6467],"disallowed"],[[6468,6469],"valid",[],"NV8"],[[6470,6509],"valid"],[[6510,6511],"disallowed"],[[6512,6516],"valid"],[[6517,6527],"disallowed"],[[6528,6569],"valid"],[[6570,6571],"valid"],[[6572,6575],"disallowed"],[[6576,6601],"valid"],[[6602,6607],"disallowed"],[[6608,6617],"valid"],[[6618,6618],"valid",[],"XV8"],[[6619,6621],"disallowed"],[[6622,6623],"valid",[],"NV8"],[[6624,6655],"valid",[],"NV8"],[[6656,6683],"valid"],[[6684,6685],"disallowed"],[[6686,6687],"valid",[],"NV8"],[[6688,6750],"valid"],[[6751,6751],"disallowed"],[[6752,6780],"valid"],[[6781,6782],"disallowed"],[[6783,6793],"valid"],[[6794,6799],"disallowed"],[[6800,6809],"valid"],[[6810,6815],"disallowed"],[[6816,6822],"valid",[],"NV8"],[[6823,6823],"valid"],[[6824,6829],"valid",[],"NV8"],[[6830,6831],"disallowed"],[[6832,6845],"valid"],[[6846,6846],"valid",[],"NV8"],[[6847,6911],"disallowed"],[[6912,6987],"valid"],[[6988,6991],"disallowed"],[[6992,7001],"valid"],[[7002,7018],"valid",[],"NV8"],[[7019,7027],"valid"],[[7028,7036],"valid",[],"NV8"],[[7037,7039],"disallowed"],[[7040,7082],"valid"],[[7083,7085],"valid"],[[7086,7097],"valid"],[[7098,7103],"valid"],[[7104,7155],"valid"],[[7156,7163],"disallowed"],[[7164,7167],"valid",[],"NV8"],[[7168,7223],"valid"],[[7224,7226],"disallowed"],[[7227,7231],"valid",[],"NV8"],[[7232,7241],"valid"],[[7242,7244],"disallowed"],[[7245,7293],"valid"],[[7294,7295],"valid",[],"NV8"],[[7296,7359],"disallowed"],[[7360,7367],"valid",[],"NV8"],[[7368,7375],"disallowed"],[[7376,7378],"valid"],[[7379,7379],"valid",[],"NV8"],[[7380,7410],"valid"],[[7411,7414],"valid"],[[7415,7415],"disallowed"],[[7416,7417],"valid"],[[7418,7423],"disallowed"],[[7424,7467],"valid"],[[7468,7468],"mapped",[97]],[[7469,7469],"mapped",[230]],[[7470,7470],"mapped",[98]],[[7471,7471],"valid"],[[7472,7472],"mapped",[100]],[[7473,7473],"mapped",[101]],[[7474,7474],"mapped",[477]],[[7475,7475],"mapped",[103]],[[7476,7476],"mapped",[104]],[[7477,7477],"mapped",[105]],[[7478,7478],"mapped",[106]],[[7479,7479],"mapped",[107]],[[7480,7480],"mapped",[108]],[[7481,7481],"mapped",[109]],[[7482,7482],"mapped",[110]],[[7483,7483],"valid"],[[7484,7484],"mapped",[111]],[[7485,7485],"mapped",[547]],[[7486,7486],"mapped",[112]],[[7487,7487],"mapped",[114]],[[7488,7488],"mapped",[116]],[[7489,7489],"mapped",[117]],[[7490,7490],"mapped",[119]],[[7491,7491],"mapped",[97]],[[7492,7492],"mapped",[592]],[[7493,7493],"mapped",[593]],[[7494,7494],"mapped",[7426]],[[7495,7495],"mapped",[98]],[[7496,7496],"mapped",[100]],[[7497,7497],"mapped",[101]],[[7498,7498],"mapped",[601]],[[7499,7499],"mapped",[603]],[[7500,7500],"mapped",[604]],[[7501,7501],"mapped",[103]],[[7502,7502],"valid"],[[7503,7503],"mapped",[107]],[[7504,7504],"mapped",[109]],[[7505,7505],"mapped",[331]],[[7506,7506],"mapped",[111]],[[7507,7507],"mapped",[596]],[[7508,7508],"mapped",[7446]],[[7509,7509],"mapped",[7447]],[[7510,7510],"mapped",[112]],[[7511,7511],"mapped",[116]],[[7512,7512],"mapped",[117]],[[7513,7513],"mapped",[7453]],[[7514,7514],"mapped",[623]],[[7515,7515],"mapped",[118]],[[7516,7516],"mapped",[7461]],[[7517,7517],"mapped",[946]],[[7518,7518],"mapped",[947]],[[7519,7519],"mapped",[948]],[[7520,7520],"mapped",[966]],[[7521,7521],"mapped",[967]],[[7522,7522],"mapped",[105]],[[7523,7523],"mapped",[114]],[[7524,7524],"mapped",[117]],[[7525,7525],"mapped",[118]],[[7526,7526],"mapped",[946]],[[7527,7527],"mapped",[947]],[[7528,7528],"mapped",[961]],[[7529,7529],"mapped",[966]],[[7530,7530],"mapped",[967]],[[7531,7531],"valid"],[[7532,7543],"valid"],[[7544,7544],"mapped",[1085]],[[7545,7578],"valid"],[[7579,7579],"mapped",[594]],[[7580,7580],"mapped",[99]],[[7581,7581],"mapped",[597]],[[7582,7582],"mapped",[240]],[[7583,7583],"mapped",[604]],[[7584,7584],"mapped",[102]],[[7585,7585],"mapped",[607]],[[7586,7586],"mapped",[609]],[[7587,7587],"mapped",[613]],[[7588,7588],"mapped",[616]],[[7589,7589],"mapped",[617]],[[7590,7590],"mapped",[618]],[[7591,7591],"mapped",[7547]],[[7592,7592],"mapped",[669]],[[7593,7593],"mapped",[621]],[[7594,7594],"mapped",[7557]],[[7595,7595],"mapped",[671]],[[7596,7596],"mapped",[625]],[[7597,7597],"mapped",[624]],[[7598,7598],"mapped",[626]],[[7599,7599],"mapped",[627]],[[7600,7600],"mapped",[628]],[[7601,7601],"mapped",[629]],[[7602,7602],"mapped",[632]],[[7603,7603],"mapped",[642]],[[7604,7604],"mapped",[643]],[[7605,7605],"mapped",[427]],[[7606,7606],"mapped",[649]],[[7607,7607],"mapped",[650]],[[7608,7608],"mapped",[7452]],[[7609,7609],"mapped",[651]],[[7610,7610],"mapped",[652]],[[7611,7611],"mapped",[122]],[[7612,7612],"mapped",[656]],[[7613,7613],"mapped",[657]],[[7614,7614],"mapped",[658]],[[7615,7615],"mapped",[952]],[[7616,7619],"valid"],[[7620,7626],"valid"],[[7627,7654],"valid"],[[7655,7669],"valid"],[[7670,7675],"disallowed"],[[7676,7676],"valid"],[[7677,7677],"valid"],[[7678,7679],"valid"],[[7680,7680],"mapped",[7681]],[[7681,7681],"valid"],[[7682,7682],"mapped",[7683]],[[7683,7683],"valid"],[[7684,7684],"mapped",[7685]],[[7685,7685],"valid"],[[7686,7686],"mapped",[7687]],[[7687,7687],"valid"],[[7688,7688],"mapped",[7689]],[[7689,7689],"valid"],[[7690,7690],"mapped",[7691]],[[7691,7691],"valid"],[[7692,7692],"mapped",[7693]],[[7693,7693],"valid"],[[7694,7694],"mapped",[7695]],[[7695,7695],"valid"],[[7696,7696],"mapped",[7697]],[[7697,7697],"valid"],[[7698,7698],"mapped",[7699]],[[7699,7699],"valid"],[[7700,7700],"mapped",[7701]],[[7701,7701],"valid"],[[7702,7702],"mapped",[7703]],[[7703,7703],"valid"],[[7704,7704],"mapped",[7705]],[[7705,7705],"valid"],[[7706,7706],"mapped",[7707]],[[7707,7707],"valid"],[[7708,7708],"mapped",[7709]],[[7709,7709],"valid"],[[7710,7710],"mapped",[7711]],[[7711,7711],"valid"],[[7712,7712],"mapped",[7713]],[[7713,7713],"valid"],[[7714,7714],"mapped",[7715]],[[7715,7715],"valid"],[[7716,7716],"mapped",[7717]],[[7717,7717],"valid"],[[7718,7718],"mapped",[7719]],[[7719,7719],"valid"],[[7720,7720],"mapped",[7721]],[[7721,7721],"valid"],[[7722,7722],"mapped",[7723]],[[7723,7723],"valid"],[[7724,7724],"mapped",[7725]],[[7725,7725],"valid"],[[7726,7726],"mapped",[7727]],[[7727,7727],"valid"],[[7728,7728],"mapped",[7729]],[[7729,7729],"valid"],[[7730,7730],"mapped",[7731]],[[7731,7731],"valid"],[[7732,7732],"mapped",[7733]],[[7733,7733],"valid"],[[7734,7734],"mapped",[7735]],[[7735,7735],"valid"],[[7736,7736],"mapped",[7737]],[[7737,7737],"valid"],[[7738,7738],"mapped",[7739]],[[7739,7739],"valid"],[[7740,7740],"mapped",[7741]],[[7741,7741],"valid"],[[7742,7742],"mapped",[7743]],[[7743,7743],"valid"],[[7744,7744],"mapped",[7745]],[[7745,7745],"valid"],[[7746,7746],"mapped",[7747]],[[7747,7747],"valid"],[[7748,7748],"mapped",[7749]],[[7749,7749],"valid"],[[7750,7750],"mapped",[7751]],[[7751,7751],"valid"],[[7752,7752],"mapped",[7753]],[[7753,7753],"valid"],[[7754,7754],"mapped",[7755]],[[7755,7755],"valid"],[[7756,7756],"mapped",[7757]],[[7757,7757],"valid"],[[7758,7758],"mapped",[7759]],[[7759,7759],"valid"],[[7760,7760],"mapped",[7761]],[[7761,7761],"valid"],[[7762,7762],"mapped",[7763]],[[7763,7763],"valid"],[[7764,7764],"mapped",[7765]],[[7765,7765],"valid"],[[7766,7766],"mapped",[7767]],[[7767,7767],"valid"],[[7768,7768],"mapped",[7769]],[[7769,7769],"valid"],[[7770,7770],"mapped",[7771]],[[7771,7771],"valid"],[[7772,7772],"mapped",[7773]],[[7773,7773],"valid"],[[7774,7774],"mapped",[7775]],[[7775,7775],"valid"],[[7776,7776],"mapped",[7777]],[[7777,7777],"valid"],[[7778,7778],"mapped",[7779]],[[7779,7779],"valid"],[[7780,7780],"mapped",[7781]],[[7781,7781],"valid"],[[7782,7782],"mapped",[7783]],[[7783,7783],"valid"],[[7784,7784],"mapped",[7785]],[[7785,7785],"valid"],[[7786,7786],"mapped",[7787]],[[7787,7787],"valid"],[[7788,7788],"mapped",[7789]],[[7789,7789],"valid"],[[7790,7790],"mapped",[7791]],[[7791,7791],"valid"],[[7792,7792],"mapped",[7793]],[[7793,7793],"valid"],[[7794,7794],"mapped",[7795]],[[7795,7795],"valid"],[[7796,7796],"mapped",[7797]],[[7797,7797],"valid"],[[7798,7798],"mapped",[7799]],[[7799,7799],"valid"],[[7800,7800],"mapped",[7801]],[[7801,7801],"valid"],[[7802,7802],"mapped",[7803]],[[7803,7803],"valid"],[[7804,7804],"mapped",[7805]],[[7805,7805],"valid"],[[7806,7806],"mapped",[7807]],[[7807,7807],"valid"],[[7808,7808],"mapped",[7809]],[[7809,7809],"valid"],[[7810,7810],"mapped",[7811]],[[7811,7811],"valid"],[[7812,7812],"mapped",[7813]],[[7813,7813],"valid"],[[7814,7814],"mapped",[7815]],[[7815,7815],"valid"],[[7816,7816],"mapped",[7817]],[[7817,7817],"valid"],[[7818,7818],"mapped",[7819]],[[7819,7819],"valid"],[[7820,7820],"mapped",[7821]],[[7821,7821],"valid"],[[7822,7822],"mapped",[7823]],[[7823,7823],"valid"],[[7824,7824],"mapped",[7825]],[[7825,7825],"valid"],[[7826,7826],"mapped",[7827]],[[7827,7827],"valid"],[[7828,7828],"mapped",[7829]],[[7829,7833],"valid"],[[7834,7834],"mapped",[97,702]],[[7835,7835],"mapped",[7777]],[[7836,7837],"valid"],[[7838,7838],"mapped",[115,115]],[[7839,7839],"valid"],[[7840,7840],"mapped",[7841]],[[7841,7841],"valid"],[[7842,7842],"mapped",[7843]],[[7843,7843],"valid"],[[7844,7844],"mapped",[7845]],[[7845,7845],"valid"],[[7846,7846],"mapped",[7847]],[[7847,7847],"valid"],[[7848,7848],"mapped",[7849]],[[7849,7849],"valid"],[[7850,7850],"mapped",[7851]],[[7851,7851],"valid"],[[7852,7852],"mapped",[7853]],[[7853,7853],"valid"],[[7854,7854],"mapped",[7855]],[[7855,7855],"valid"],[[7856,7856],"mapped",[7857]],[[7857,7857],"valid"],[[7858,7858],"mapped",[7859]],[[7859,7859],"valid"],[[7860,7860],"mapped",[7861]],[[7861,7861],"valid"],[[7862,7862],"mapped",[7863]],[[7863,7863],"valid"],[[7864,7864],"mapped",[7865]],[[7865,7865],"valid"],[[7866,7866],"mapped",[7867]],[[7867,7867],"valid"],[[7868,7868],"mapped",[7869]],[[7869,7869],"valid"],[[7870,7870],"mapped",[7871]],[[7871,7871],"valid"],[[7872,7872],"mapped",[7873]],[[7873,7873],"valid"],[[7874,7874],"mapped",[7875]],[[7875,7875],"valid"],[[7876,7876],"mapped",[7877]],[[7877,7877],"valid"],[[7878,7878],"mapped",[7879]],[[7879,7879],"valid"],[[7880,7880],"mapped",[7881]],[[7881,7881],"valid"],[[7882,7882],"mapped",[7883]],[[7883,7883],"valid"],[[7884,7884],"mapped",[7885]],[[7885,7885],"valid"],[[7886,7886],"mapped",[7887]],[[7887,7887],"valid"],[[7888,7888],"mapped",[7889]],[[7889,7889],"valid"],[[7890,7890],"mapped",[7891]],[[7891,7891],"valid"],[[7892,7892],"mapped",[7893]],[[7893,7893],"valid"],[[7894,7894],"mapped",[7895]],[[7895,7895],"valid"],[[7896,7896],"mapped",[7897]],[[7897,7897],"valid"],[[7898,7898],"mapped",[7899]],[[7899,7899],"valid"],[[7900,7900],"mapped",[7901]],[[7901,7901],"valid"],[[7902,7902],"mapped",[7903]],[[7903,7903],"valid"],[[7904,7904],"mapped",[7905]],[[7905,7905],"valid"],[[7906,7906],"mapped",[7907]],[[7907,7907],"valid"],[[7908,7908],"mapped",[7909]],[[7909,7909],"valid"],[[7910,7910],"mapped",[7911]],[[7911,7911],"valid"],[[7912,7912],"mapped",[7913]],[[7913,7913],"valid"],[[7914,7914],"mapped",[7915]],[[7915,7915],"valid"],[[7916,7916],"mapped",[7917]],[[7917,7917],"valid"],[[7918,7918],"mapped",[7919]],[[7919,7919],"valid"],[[7920,7920],"mapped",[7921]],[[7921,7921],"valid"],[[7922,7922],"mapped",[7923]],[[7923,7923],"valid"],[[7924,7924],"mapped",[7925]],[[7925,7925],"valid"],[[7926,7926],"mapped",[7927]],[[7927,7927],"valid"],[[7928,7928],"mapped",[7929]],[[7929,7929],"valid"],[[7930,7930],"mapped",[7931]],[[7931,7931],"valid"],[[7932,7932],"mapped",[7933]],[[7933,7933],"valid"],[[7934,7934],"mapped",[7935]],[[7935,7935],"valid"],[[7936,7943],"valid"],[[7944,7944],"mapped",[7936]],[[7945,7945],"mapped",[7937]],[[7946,7946],"mapped",[7938]],[[7947,7947],"mapped",[7939]],[[7948,7948],"mapped",[7940]],[[7949,7949],"mapped",[7941]],[[7950,7950],"mapped",[7942]],[[7951,7951],"mapped",[7943]],[[7952,7957],"valid"],[[7958,7959],"disallowed"],[[7960,7960],"mapped",[7952]],[[7961,7961],"mapped",[7953]],[[7962,7962],"mapped",[7954]],[[7963,7963],"mapped",[7955]],[[7964,7964],"mapped",[7956]],[[7965,7965],"mapped",[7957]],[[7966,7967],"disallowed"],[[7968,7975],"valid"],[[7976,7976],"mapped",[7968]],[[7977,7977],"mapped",[7969]],[[7978,7978],"mapped",[7970]],[[7979,7979],"mapped",[7971]],[[7980,7980],"mapped",[7972]],[[7981,7981],"mapped",[7973]],[[7982,7982],"mapped",[7974]],[[7983,7983],"mapped",[7975]],[[7984,7991],"valid"],[[7992,7992],"mapped",[7984]],[[7993,7993],"mapped",[7985]],[[7994,7994],"mapped",[7986]],[[7995,7995],"mapped",[7987]],[[7996,7996],"mapped",[7988]],[[7997,7997],"mapped",[7989]],[[7998,7998],"mapped",[7990]],[[7999,7999],"mapped",[7991]],[[8000,8005],"valid"],[[8006,8007],"disallowed"],[[8008,8008],"mapped",[8000]],[[8009,8009],"mapped",[8001]],[[8010,8010],"mapped",[8002]],[[8011,8011],"mapped",[8003]],[[8012,8012],"mapped",[8004]],[[8013,8013],"mapped",[8005]],[[8014,8015],"disallowed"],[[8016,8023],"valid"],[[8024,8024],"disallowed"],[[8025,8025],"mapped",[8017]],[[8026,8026],"disallowed"],[[8027,8027],"mapped",[8019]],[[8028,8028],"disallowed"],[[8029,8029],"mapped",[8021]],[[8030,8030],"disallowed"],[[8031,8031],"mapped",[8023]],[[8032,8039],"valid"],[[8040,8040],"mapped",[8032]],[[8041,8041],"mapped",[8033]],[[8042,8042],"mapped",[8034]],[[8043,8043],"mapped",[8035]],[[8044,8044],"mapped",[8036]],[[8045,8045],"mapped",[8037]],[[8046,8046],"mapped",[8038]],[[8047,8047],"mapped",[8039]],[[8048,8048],"valid"],[[8049,8049],"mapped",[940]],[[8050,8050],"valid"],[[8051,8051],"mapped",[941]],[[8052,8052],"valid"],[[8053,8053],"mapped",[942]],[[8054,8054],"valid"],[[8055,8055],"mapped",[943]],[[8056,8056],"valid"],[[8057,8057],"mapped",[972]],[[8058,8058],"valid"],[[8059,8059],"mapped",[973]],[[8060,8060],"valid"],[[8061,8061],"mapped",[974]],[[8062,8063],"disallowed"],[[8064,8064],"mapped",[7936,953]],[[8065,8065],"mapped",[7937,953]],[[8066,8066],"mapped",[7938,953]],[[8067,8067],"mapped",[7939,953]],[[8068,8068],"mapped",[7940,953]],[[8069,8069],"mapped",[7941,953]],[[8070,8070],"mapped",[7942,953]],[[8071,8071],"mapped",[7943,953]],[[8072,8072],"mapped",[7936,953]],[[8073,8073],"mapped",[7937,953]],[[8074,8074],"mapped",[7938,953]],[[8075,8075],"mapped",[7939,953]],[[8076,8076],"mapped",[7940,953]],[[8077,8077],"mapped",[7941,953]],[[8078,8078],"mapped",[7942,953]],[[8079,8079],"mapped",[7943,953]],[[8080,8080],"mapped",[7968,953]],[[8081,8081],"mapped",[7969,953]],[[8082,8082],"mapped",[7970,953]],[[8083,8083],"mapped",[7971,953]],[[8084,8084],"mapped",[7972,953]],[[8085,8085],"mapped",[7973,953]],[[8086,8086],"mapped",[7974,953]],[[8087,8087],"mapped",[7975,953]],[[8088,8088],"mapped",[7968,953]],[[8089,8089],"mapped",[7969,953]],[[8090,8090],"mapped",[7970,953]],[[8091,8091],"mapped",[7971,953]],[[8092,8092],"mapped",[7972,953]],[[8093,8093],"mapped",[7973,953]],[[8094,8094],"mapped",[7974,953]],[[8095,8095],"mapped",[7975,953]],[[8096,8096],"mapped",[8032,953]],[[8097,8097],"mapped",[8033,953]],[[8098,8098],"mapped",[8034,953]],[[8099,8099],"mapped",[8035,953]],[[8100,8100],"mapped",[8036,953]],[[8101,8101],"mapped",[8037,953]],[[8102,8102],"mapped",[8038,953]],[[8103,8103],"mapped",[8039,953]],[[8104,8104],"mapped",[8032,953]],[[8105,8105],"mapped",[8033,953]],[[8106,8106],"mapped",[8034,953]],[[8107,8107],"mapped",[8035,953]],[[8108,8108],"mapped",[8036,953]],[[8109,8109],"mapped",[8037,953]],[[8110,8110],"mapped",[8038,953]],[[8111,8111],"mapped",[8039,953]],[[8112,8113],"valid"],[[8114,8114],"mapped",[8048,953]],[[8115,8115],"mapped",[945,953]],[[8116,8116],"mapped",[940,953]],[[8117,8117],"disallowed"],[[8118,8118],"valid"],[[8119,8119],"mapped",[8118,953]],[[8120,8120],"mapped",[8112]],[[8121,8121],"mapped",[8113]],[[8122,8122],"mapped",[8048]],[[8123,8123],"mapped",[940]],[[8124,8124],"mapped",[945,953]],[[8125,8125],"disallowed_STD3_mapped",[32,787]],[[8126,8126],"mapped",[953]],[[8127,8127],"disallowed_STD3_mapped",[32,787]],[[8128,8128],"disallowed_STD3_mapped",[32,834]],[[8129,8129],"disallowed_STD3_mapped",[32,776,834]],[[8130,8130],"mapped",[8052,953]],[[8131,8131],"mapped",[951,953]],[[8132,8132],"mapped",[942,953]],[[8133,8133],"disallowed"],[[8134,8134],"valid"],[[8135,8135],"mapped",[8134,953]],[[8136,8136],"mapped",[8050]],[[8137,8137],"mapped",[941]],[[8138,8138],"mapped",[8052]],[[8139,8139],"mapped",[942]],[[8140,8140],"mapped",[951,953]],[[8141,8141],"disallowed_STD3_mapped",[32,787,768]],[[8142,8142],"disallowed_STD3_mapped",[32,787,769]],[[8143,8143],"disallowed_STD3_mapped",[32,787,834]],[[8144,8146],"valid"],[[8147,8147],"mapped",[912]],[[8148,8149],"disallowed"],[[8150,8151],"valid"],[[8152,8152],"mapped",[8144]],[[8153,8153],"mapped",[8145]],[[8154,8154],"mapped",[8054]],[[8155,8155],"mapped",[943]],[[8156,8156],"disallowed"],[[8157,8157],"disallowed_STD3_mapped",[32,788,768]],[[8158,8158],"disallowed_STD3_mapped",[32,788,769]],[[8159,8159],"disallowed_STD3_mapped",[32,788,834]],[[8160,8162],"valid"],[[8163,8163],"mapped",[944]],[[8164,8167],"valid"],[[8168,8168],"mapped",[8160]],[[8169,8169],"mapped",[8161]],[[8170,8170],"mapped",[8058]],[[8171,8171],"mapped",[973]],[[8172,8172],"mapped",[8165]],[[8173,8173],"disallowed_STD3_mapped",[32,776,768]],[[8174,8174],"disallowed_STD3_mapped",[32,776,769]],[[8175,8175],"disallowed_STD3_mapped",[96]],[[8176,8177],"disallowed"],[[8178,8178],"mapped",[8060,953]],[[8179,8179],"mapped",[969,953]],[[8180,8180],"mapped",[974,953]],[[8181,8181],"disallowed"],[[8182,8182],"valid"],[[8183,8183],"mapped",[8182,953]],[[8184,8184],"mapped",[8056]],[[8185,8185],"mapped",[972]],[[8186,8186],"mapped",[8060]],[[8187,8187],"mapped",[974]],[[8188,8188],"mapped",[969,953]],[[8189,8189],"disallowed_STD3_mapped",[32,769]],[[8190,8190],"disallowed_STD3_mapped",[32,788]],[[8191,8191],"disallowed"],[[8192,8202],"disallowed_STD3_mapped",[32]],[[8203,8203],"ignored"],[[8204,8205],"deviation",[]],[[8206,8207],"disallowed"],[[8208,8208],"valid",[],"NV8"],[[8209,8209],"mapped",[8208]],[[8210,8214],"valid",[],"NV8"],[[8215,8215],"disallowed_STD3_mapped",[32,819]],[[8216,8227],"valid",[],"NV8"],[[8228,8230],"disallowed"],[[8231,8231],"valid",[],"NV8"],[[8232,8238],"disallowed"],[[8239,8239],"disallowed_STD3_mapped",[32]],[[8240,8242],"valid",[],"NV8"],[[8243,8243],"mapped",[8242,8242]],[[8244,8244],"mapped",[8242,8242,8242]],[[8245,8245],"valid",[],"NV8"],[[8246,8246],"mapped",[8245,8245]],[[8247,8247],"mapped",[8245,8245,8245]],[[8248,8251],"valid",[],"NV8"],[[8252,8252],"disallowed_STD3_mapped",[33,33]],[[8253,8253],"valid",[],"NV8"],[[8254,8254],"disallowed_STD3_mapped",[32,773]],[[8255,8262],"valid",[],"NV8"],[[8263,8263],"disallowed_STD3_mapped",[63,63]],[[8264,8264],"disallowed_STD3_mapped",[63,33]],[[8265,8265],"disallowed_STD3_mapped",[33,63]],[[8266,8269],"valid",[],"NV8"],[[8270,8274],"valid",[],"NV8"],[[8275,8276],"valid",[],"NV8"],[[8277,8278],"valid",[],"NV8"],[[8279,8279],"mapped",[8242,8242,8242,8242]],[[8280,8286],"valid",[],"NV8"],[[8287,8287],"disallowed_STD3_mapped",[32]],[[8288,8288],"ignored"],[[8289,8291],"disallowed"],[[8292,8292],"ignored"],[[8293,8293],"disallowed"],[[8294,8297],"disallowed"],[[8298,8303],"disallowed"],[[8304,8304],"mapped",[48]],[[8305,8305],"mapped",[105]],[[8306,8307],"disallowed"],[[8308,8308],"mapped",[52]],[[8309,8309],"mapped",[53]],[[8310,8310],"mapped",[54]],[[8311,8311],"mapped",[55]],[[8312,8312],"mapped",[56]],[[8313,8313],"mapped",[57]],[[8314,8314],"disallowed_STD3_mapped",[43]],[[8315,8315],"mapped",[8722]],[[8316,8316],"disallowed_STD3_mapped",[61]],[[8317,8317],"disallowed_STD3_mapped",[40]],[[8318,8318],"disallowed_STD3_mapped",[41]],[[8319,8319],"mapped",[110]],[[8320,8320],"mapped",[48]],[[8321,8321],"mapped",[49]],[[8322,8322],"mapped",[50]],[[8323,8323],"mapped",[51]],[[8324,8324],"mapped",[52]],[[8325,8325],"mapped",[53]],[[8326,8326],"mapped",[54]],[[8327,8327],"mapped",[55]],[[8328,8328],"mapped",[56]],[[8329,8329],"mapped",[57]],[[8330,8330],"disallowed_STD3_mapped",[43]],[[8331,8331],"mapped",[8722]],[[8332,8332],"disallowed_STD3_mapped",[61]],[[8333,8333],"disallowed_STD3_mapped",[40]],[[8334,8334],"disallowed_STD3_mapped",[41]],[[8335,8335],"disallowed"],[[8336,8336],"mapped",[97]],[[8337,8337],"mapped",[101]],[[8338,8338],"mapped",[111]],[[8339,8339],"mapped",[120]],[[8340,8340],"mapped",[601]],[[8341,8341],"mapped",[104]],[[8342,8342],"mapped",[107]],[[8343,8343],"mapped",[108]],[[8344,8344],"mapped",[109]],[[8345,8345],"mapped",[110]],[[8346,8346],"mapped",[112]],[[8347,8347],"mapped",[115]],[[8348,8348],"mapped",[116]],[[8349,8351],"disallowed"],[[8352,8359],"valid",[],"NV8"],[[8360,8360],"mapped",[114,115]],[[8361,8362],"valid",[],"NV8"],[[8363,8363],"valid",[],"NV8"],[[8364,8364],"valid",[],"NV8"],[[8365,8367],"valid",[],"NV8"],[[8368,8369],"valid",[],"NV8"],[[8370,8373],"valid",[],"NV8"],[[8374,8376],"valid",[],"NV8"],[[8377,8377],"valid",[],"NV8"],[[8378,8378],"valid",[],"NV8"],[[8379,8381],"valid",[],"NV8"],[[8382,8382],"valid",[],"NV8"],[[8383,8399],"disallowed"],[[8400,8417],"valid",[],"NV8"],[[8418,8419],"valid",[],"NV8"],[[8420,8426],"valid",[],"NV8"],[[8427,8427],"valid",[],"NV8"],[[8428,8431],"valid",[],"NV8"],[[8432,8432],"valid",[],"NV8"],[[8433,8447],"disallowed"],[[8448,8448],"disallowed_STD3_mapped",[97,47,99]],[[8449,8449],"disallowed_STD3_mapped",[97,47,115]],[[8450,8450],"mapped",[99]],[[8451,8451],"mapped",[176,99]],[[8452,8452],"valid",[],"NV8"],[[8453,8453],"disallowed_STD3_mapped",[99,47,111]],[[8454,8454],"disallowed_STD3_mapped",[99,47,117]],[[8455,8455],"mapped",[603]],[[8456,8456],"valid",[],"NV8"],[[8457,8457],"mapped",[176,102]],[[8458,8458],"mapped",[103]],[[8459,8462],"mapped",[104]],[[8463,8463],"mapped",[295]],[[8464,8465],"mapped",[105]],[[8466,8467],"mapped",[108]],[[8468,8468],"valid",[],"NV8"],[[8469,8469],"mapped",[110]],[[8470,8470],"mapped",[110,111]],[[8471,8472],"valid",[],"NV8"],[[8473,8473],"mapped",[112]],[[8474,8474],"mapped",[113]],[[8475,8477],"mapped",[114]],[[8478,8479],"valid",[],"NV8"],[[8480,8480],"mapped",[115,109]],[[8481,8481],"mapped",[116,101,108]],[[8482,8482],"mapped",[116,109]],[[8483,8483],"valid",[],"NV8"],[[8484,8484],"mapped",[122]],[[8485,8485],"valid",[],"NV8"],[[8486,8486],"mapped",[969]],[[8487,8487],"valid",[],"NV8"],[[8488,8488],"mapped",[122]],[[8489,8489],"valid",[],"NV8"],[[8490,8490],"mapped",[107]],[[8491,8491],"mapped",[229]],[[8492,8492],"mapped",[98]],[[8493,8493],"mapped",[99]],[[8494,8494],"valid",[],"NV8"],[[8495,8496],"mapped",[101]],[[8497,8497],"mapped",[102]],[[8498,8498],"disallowed"],[[8499,8499],"mapped",[109]],[[8500,8500],"mapped",[111]],[[8501,8501],"mapped",[1488]],[[8502,8502],"mapped",[1489]],[[8503,8503],"mapped",[1490]],[[8504,8504],"mapped",[1491]],[[8505,8505],"mapped",[105]],[[8506,8506],"valid",[],"NV8"],[[8507,8507],"mapped",[102,97,120]],[[8508,8508],"mapped",[960]],[[8509,8510],"mapped",[947]],[[8511,8511],"mapped",[960]],[[8512,8512],"mapped",[8721]],[[8513,8516],"valid",[],"NV8"],[[8517,8518],"mapped",[100]],[[8519,8519],"mapped",[101]],[[8520,8520],"mapped",[105]],[[8521,8521],"mapped",[106]],[[8522,8523],"valid",[],"NV8"],[[8524,8524],"valid",[],"NV8"],[[8525,8525],"valid",[],"NV8"],[[8526,8526],"valid"],[[8527,8527],"valid",[],"NV8"],[[8528,8528],"mapped",[49,8260,55]],[[8529,8529],"mapped",[49,8260,57]],[[8530,8530],"mapped",[49,8260,49,48]],[[8531,8531],"mapped",[49,8260,51]],[[8532,8532],"mapped",[50,8260,51]],[[8533,8533],"mapped",[49,8260,53]],[[8534,8534],"mapped",[50,8260,53]],[[8535,8535],"mapped",[51,8260,53]],[[8536,8536],"mapped",[52,8260,53]],[[8537,8537],"mapped",[49,8260,54]],[[8538,8538],"mapped",[53,8260,54]],[[8539,8539],"mapped",[49,8260,56]],[[8540,8540],"mapped",[51,8260,56]],[[8541,8541],"mapped",[53,8260,56]],[[8542,8542],"mapped",[55,8260,56]],[[8543,8543],"mapped",[49,8260]],[[8544,8544],"mapped",[105]],[[8545,8545],"mapped",[105,105]],[[8546,8546],"mapped",[105,105,105]],[[8547,8547],"mapped",[105,118]],[[8548,8548],"mapped",[118]],[[8549,8549],"mapped",[118,105]],[[8550,8550],"mapped",[118,105,105]],[[8551,8551],"mapped",[118,105,105,105]],[[8552,8552],"mapped",[105,120]],[[8553,8553],"mapped",[120]],[[8554,8554],"mapped",[120,105]],[[8555,8555],"mapped",[120,105,105]],[[8556,8556],"mapped",[108]],[[8557,8557],"mapped",[99]],[[8558,8558],"mapped",[100]],[[8559,8559],"mapped",[109]],[[8560,8560],"mapped",[105]],[[8561,8561],"mapped",[105,105]],[[8562,8562],"mapped",[105,105,105]],[[8563,8563],"mapped",[105,118]],[[8564,8564],"mapped",[118]],[[8565,8565],"mapped",[118,105]],[[8566,8566],"mapped",[118,105,105]],[[8567,8567],"mapped",[118,105,105,105]],[[8568,8568],"mapped",[105,120]],[[8569,8569],"mapped",[120]],[[8570,8570],"mapped",[120,105]],[[8571,8571],"mapped",[120,105,105]],[[8572,8572],"mapped",[108]],[[8573,8573],"mapped",[99]],[[8574,8574],"mapped",[100]],[[8575,8575],"mapped",[109]],[[8576,8578],"valid",[],"NV8"],[[8579,8579],"disallowed"],[[8580,8580],"valid"],[[8581,8584],"valid",[],"NV8"],[[8585,8585],"mapped",[48,8260,51]],[[8586,8587],"valid",[],"NV8"],[[8588,8591],"disallowed"],[[8592,8682],"valid",[],"NV8"],[[8683,8691],"valid",[],"NV8"],[[8692,8703],"valid",[],"NV8"],[[8704,8747],"valid",[],"NV8"],[[8748,8748],"mapped",[8747,8747]],[[8749,8749],"mapped",[8747,8747,8747]],[[8750,8750],"valid",[],"NV8"],[[8751,8751],"mapped",[8750,8750]],[[8752,8752],"mapped",[8750,8750,8750]],[[8753,8799],"valid",[],"NV8"],[[8800,8800],"disallowed_STD3_valid"],[[8801,8813],"valid",[],"NV8"],[[8814,8815],"disallowed_STD3_valid"],[[8816,8945],"valid",[],"NV8"],[[8946,8959],"valid",[],"NV8"],[[8960,8960],"valid",[],"NV8"],[[8961,8961],"valid",[],"NV8"],[[8962,9000],"valid",[],"NV8"],[[9001,9001],"mapped",[12296]],[[9002,9002],"mapped",[12297]],[[9003,9082],"valid",[],"NV8"],[[9083,9083],"valid",[],"NV8"],[[9084,9084],"valid",[],"NV8"],[[9085,9114],"valid",[],"NV8"],[[9115,9166],"valid",[],"NV8"],[[9167,9168],"valid",[],"NV8"],[[9169,9179],"valid",[],"NV8"],[[9180,9191],"valid",[],"NV8"],[[9192,9192],"valid",[],"NV8"],[[9193,9203],"valid",[],"NV8"],[[9204,9210],"valid",[],"NV8"],[[9211,9215],"disallowed"],[[9216,9252],"valid",[],"NV8"],[[9253,9254],"valid",[],"NV8"],[[9255,9279],"disallowed"],[[9280,9290],"valid",[],"NV8"],[[9291,9311],"disallowed"],[[9312,9312],"mapped",[49]],[[9313,9313],"mapped",[50]],[[9314,9314],"mapped",[51]],[[9315,9315],"mapped",[52]],[[9316,9316],"mapped",[53]],[[9317,9317],"mapped",[54]],[[9318,9318],"mapped",[55]],[[9319,9319],"mapped",[56]],[[9320,9320],"mapped",[57]],[[9321,9321],"mapped",[49,48]],[[9322,9322],"mapped",[49,49]],[[9323,9323],"mapped",[49,50]],[[9324,9324],"mapped",[49,51]],[[9325,9325],"mapped",[49,52]],[[9326,9326],"mapped",[49,53]],[[9327,9327],"mapped",[49,54]],[[9328,9328],"mapped",[49,55]],[[9329,9329],"mapped",[49,56]],[[9330,9330],"mapped",[49,57]],[[9331,9331],"mapped",[50,48]],[[9332,9332],"disallowed_STD3_mapped",[40,49,41]],[[9333,9333],"disallowed_STD3_mapped",[40,50,41]],[[9334,9334],"disallowed_STD3_mapped",[40,51,41]],[[9335,9335],"disallowed_STD3_mapped",[40,52,41]],[[9336,9336],"disallowed_STD3_mapped",[40,53,41]],[[9337,9337],"disallowed_STD3_mapped",[40,54,41]],[[9338,9338],"disallowed_STD3_mapped",[40,55,41]],[[9339,9339],"disallowed_STD3_mapped",[40,56,41]],[[9340,9340],"disallowed_STD3_mapped",[40,57,41]],[[9341,9341],"disallowed_STD3_mapped",[40,49,48,41]],[[9342,9342],"disallowed_STD3_mapped",[40,49,49,41]],[[9343,9343],"disallowed_STD3_mapped",[40,49,50,41]],[[9344,9344],"disallowed_STD3_mapped",[40,49,51,41]],[[9345,9345],"disallowed_STD3_mapped",[40,49,52,41]],[[9346,9346],"disallowed_STD3_mapped",[40,49,53,41]],[[9347,9347],"disallowed_STD3_mapped",[40,49,54,41]],[[9348,9348],"disallowed_STD3_mapped",[40,49,55,41]],[[9349,9349],"disallowed_STD3_mapped",[40,49,56,41]],[[9350,9350],"disallowed_STD3_mapped",[40,49,57,41]],[[9351,9351],"disallowed_STD3_mapped",[40,50,48,41]],[[9352,9371],"disallowed"],[[9372,9372],"disallowed_STD3_mapped",[40,97,41]],[[9373,9373],"disallowed_STD3_mapped",[40,98,41]],[[9374,9374],"disallowed_STD3_mapped",[40,99,41]],[[9375,9375],"disallowed_STD3_mapped",[40,100,41]],[[9376,9376],"disallowed_STD3_mapped",[40,101,41]],[[9377,9377],"disallowed_STD3_mapped",[40,102,41]],[[9378,9378],"disallowed_STD3_mapped",[40,103,41]],[[9379,9379],"disallowed_STD3_mapped",[40,104,41]],[[9380,9380],"disallowed_STD3_mapped",[40,105,41]],[[9381,9381],"disallowed_STD3_mapped",[40,106,41]],[[9382,9382],"disallowed_STD3_mapped",[40,107,41]],[[9383,9383],"disallowed_STD3_mapped",[40,108,41]],[[9384,9384],"disallowed_STD3_mapped",[40,109,41]],[[9385,9385],"disallowed_STD3_mapped",[40,110,41]],[[9386,9386],"disallowed_STD3_mapped",[40,111,41]],[[9387,9387],"disallowed_STD3_mapped",[40,112,41]],[[9388,9388],"disallowed_STD3_mapped",[40,113,41]],[[9389,9389],"disallowed_STD3_mapped",[40,114,41]],[[9390,9390],"disallowed_STD3_mapped",[40,115,41]],[[9391,9391],"disallowed_STD3_mapped",[40,116,41]],[[9392,9392],"disallowed_STD3_mapped",[40,117,41]],[[9393,9393],"disallowed_STD3_mapped",[40,118,41]],[[9394,9394],"disallowed_STD3_mapped",[40,119,41]],[[9395,9395],"disallowed_STD3_mapped",[40,120,41]],[[9396,9396],"disallowed_STD3_mapped",[40,121,41]],[[9397,9397],"disallowed_STD3_mapped",[40,122,41]],[[9398,9398],"mapped",[97]],[[9399,9399],"mapped",[98]],[[9400,9400],"mapped",[99]],[[9401,9401],"mapped",[100]],[[9402,9402],"mapped",[101]],[[9403,9403],"mapped",[102]],[[9404,9404],"mapped",[103]],[[9405,9405],"mapped",[104]],[[9406,9406],"mapped",[105]],[[9407,9407],"mapped",[106]],[[9408,9408],"mapped",[107]],[[9409,9409],"mapped",[108]],[[9410,9410],"mapped",[109]],[[9411,9411],"mapped",[110]],[[9412,9412],"mapped",[111]],[[9413,9413],"mapped",[112]],[[9414,9414],"mapped",[113]],[[9415,9415],"mapped",[114]],[[9416,9416],"mapped",[115]],[[9417,9417],"mapped",[116]],[[9418,9418],"mapped",[117]],[[9419,9419],"mapped",[118]],[[9420,9420],"mapped",[119]],[[9421,9421],"mapped",[120]],[[9422,9422],"mapped",[121]],[[9423,9423],"mapped",[122]],[[9424,9424],"mapped",[97]],[[9425,9425],"mapped",[98]],[[9426,9426],"mapped",[99]],[[9427,9427],"mapped",[100]],[[9428,9428],"mapped",[101]],[[9429,9429],"mapped",[102]],[[9430,9430],"mapped",[103]],[[9431,9431],"mapped",[104]],[[9432,9432],"mapped",[105]],[[9433,9433],"mapped",[106]],[[9434,9434],"mapped",[107]],[[9435,9435],"mapped",[108]],[[9436,9436],"mapped",[109]],[[9437,9437],"mapped",[110]],[[9438,9438],"mapped",[111]],[[9439,9439],"mapped",[112]],[[9440,9440],"mapped",[113]],[[9441,9441],"mapped",[114]],[[9442,9442],"mapped",[115]],[[9443,9443],"mapped",[116]],[[9444,9444],"mapped",[117]],[[9445,9445],"mapped",[118]],[[9446,9446],"mapped",[119]],[[9447,9447],"mapped",[120]],[[9448,9448],"mapped",[121]],[[9449,9449],"mapped",[122]],[[9450,9450],"mapped",[48]],[[9451,9470],"valid",[],"NV8"],[[9471,9471],"valid",[],"NV8"],[[9472,9621],"valid",[],"NV8"],[[9622,9631],"valid",[],"NV8"],[[9632,9711],"valid",[],"NV8"],[[9712,9719],"valid",[],"NV8"],[[9720,9727],"valid",[],"NV8"],[[9728,9747],"valid",[],"NV8"],[[9748,9749],"valid",[],"NV8"],[[9750,9751],"valid",[],"NV8"],[[9752,9752],"valid",[],"NV8"],[[9753,9753],"valid",[],"NV8"],[[9754,9839],"valid",[],"NV8"],[[9840,9841],"valid",[],"NV8"],[[9842,9853],"valid",[],"NV8"],[[9854,9855],"valid",[],"NV8"],[[9856,9865],"valid",[],"NV8"],[[9866,9873],"valid",[],"NV8"],[[9874,9884],"valid",[],"NV8"],[[9885,9885],"valid",[],"NV8"],[[9886,9887],"valid",[],"NV8"],[[9888,9889],"valid",[],"NV8"],[[9890,9905],"valid",[],"NV8"],[[9906,9906],"valid",[],"NV8"],[[9907,9916],"valid",[],"NV8"],[[9917,9919],"valid",[],"NV8"],[[9920,9923],"valid",[],"NV8"],[[9924,9933],"valid",[],"NV8"],[[9934,9934],"valid",[],"NV8"],[[9935,9953],"valid",[],"NV8"],[[9954,9954],"valid",[],"NV8"],[[9955,9955],"valid",[],"NV8"],[[9956,9959],"valid",[],"NV8"],[[9960,9983],"valid",[],"NV8"],[[9984,9984],"valid",[],"NV8"],[[9985,9988],"valid",[],"NV8"],[[9989,9989],"valid",[],"NV8"],[[9990,9993],"valid",[],"NV8"],[[9994,9995],"valid",[],"NV8"],[[9996,10023],"valid",[],"NV8"],[[10024,10024],"valid",[],"NV8"],[[10025,10059],"valid",[],"NV8"],[[10060,10060],"valid",[],"NV8"],[[10061,10061],"valid",[],"NV8"],[[10062,10062],"valid",[],"NV8"],[[10063,10066],"valid",[],"NV8"],[[10067,10069],"valid",[],"NV8"],[[10070,10070],"valid",[],"NV8"],[[10071,10071],"valid",[],"NV8"],[[10072,10078],"valid",[],"NV8"],[[10079,10080],"valid",[],"NV8"],[[10081,10087],"valid",[],"NV8"],[[10088,10101],"valid",[],"NV8"],[[10102,10132],"valid",[],"NV8"],[[10133,10135],"valid",[],"NV8"],[[10136,10159],"valid",[],"NV8"],[[10160,10160],"valid",[],"NV8"],[[10161,10174],"valid",[],"NV8"],[[10175,10175],"valid",[],"NV8"],[[10176,10182],"valid",[],"NV8"],[[10183,10186],"valid",[],"NV8"],[[10187,10187],"valid",[],"NV8"],[[10188,10188],"valid",[],"NV8"],[[10189,10189],"valid",[],"NV8"],[[10190,10191],"valid",[],"NV8"],[[10192,10219],"valid",[],"NV8"],[[10220,10223],"valid",[],"NV8"],[[10224,10239],"valid",[],"NV8"],[[10240,10495],"valid",[],"NV8"],[[10496,10763],"valid",[],"NV8"],[[10764,10764],"mapped",[8747,8747,8747,8747]],[[10765,10867],"valid",[],"NV8"],[[10868,10868],"disallowed_STD3_mapped",[58,58,61]],[[10869,10869],"disallowed_STD3_mapped",[61,61]],[[10870,10870],"disallowed_STD3_mapped",[61,61,61]],[[10871,10971],"valid",[],"NV8"],[[10972,10972],"mapped",[10973,824]],[[10973,11007],"valid",[],"NV8"],[[11008,11021],"valid",[],"NV8"],[[11022,11027],"valid",[],"NV8"],[[11028,11034],"valid",[],"NV8"],[[11035,11039],"valid",[],"NV8"],[[11040,11043],"valid",[],"NV8"],[[11044,11084],"valid",[],"NV8"],[[11085,11087],"valid",[],"NV8"],[[11088,11092],"valid",[],"NV8"],[[11093,11097],"valid",[],"NV8"],[[11098,11123],"valid",[],"NV8"],[[11124,11125],"disallowed"],[[11126,11157],"valid",[],"NV8"],[[11158,11159],"disallowed"],[[11160,11193],"valid",[],"NV8"],[[11194,11196],"disallowed"],[[11197,11208],"valid",[],"NV8"],[[11209,11209],"disallowed"],[[11210,11217],"valid",[],"NV8"],[[11218,11243],"disallowed"],[[11244,11247],"valid",[],"NV8"],[[11248,11263],"disallowed"],[[11264,11264],"mapped",[11312]],[[11265,11265],"mapped",[11313]],[[11266,11266],"mapped",[11314]],[[11267,11267],"mapped",[11315]],[[11268,11268],"mapped",[11316]],[[11269,11269],"mapped",[11317]],[[11270,11270],"mapped",[11318]],[[11271,11271],"mapped",[11319]],[[11272,11272],"mapped",[11320]],[[11273,11273],"mapped",[11321]],[[11274,11274],"mapped",[11322]],[[11275,11275],"mapped",[11323]],[[11276,11276],"mapped",[11324]],[[11277,11277],"mapped",[11325]],[[11278,11278],"mapped",[11326]],[[11279,11279],"mapped",[11327]],[[11280,11280],"mapped",[11328]],[[11281,11281],"mapped",[11329]],[[11282,11282],"mapped",[11330]],[[11283,11283],"mapped",[11331]],[[11284,11284],"mapped",[11332]],[[11285,11285],"mapped",[11333]],[[11286,11286],"mapped",[11334]],[[11287,11287],"mapped",[11335]],[[11288,11288],"mapped",[11336]],[[11289,11289],"mapped",[11337]],[[11290,11290],"mapped",[11338]],[[11291,11291],"mapped",[11339]],[[11292,11292],"mapped",[11340]],[[11293,11293],"mapped",[11341]],[[11294,11294],"mapped",[11342]],[[11295,11295],"mapped",[11343]],[[11296,11296],"mapped",[11344]],[[11297,11297],"mapped",[11345]],[[11298,11298],"mapped",[11346]],[[11299,11299],"mapped",[11347]],[[11300,11300],"mapped",[11348]],[[11301,11301],"mapped",[11349]],[[11302,11302],"mapped",[11350]],[[11303,11303],"mapped",[11351]],[[11304,11304],"mapped",[11352]],[[11305,11305],"mapped",[11353]],[[11306,11306],"mapped",[11354]],[[11307,11307],"mapped",[11355]],[[11308,11308],"mapped",[11356]],[[11309,11309],"mapped",[11357]],[[11310,11310],"mapped",[11358]],[[11311,11311],"disallowed"],[[11312,11358],"valid"],[[11359,11359],"disallowed"],[[11360,11360],"mapped",[11361]],[[11361,11361],"valid"],[[11362,11362],"mapped",[619]],[[11363,11363],"mapped",[7549]],[[11364,11364],"mapped",[637]],[[11365,11366],"valid"],[[11367,11367],"mapped",[11368]],[[11368,11368],"valid"],[[11369,11369],"mapped",[11370]],[[11370,11370],"valid"],[[11371,11371],"mapped",[11372]],[[11372,11372],"valid"],[[11373,11373],"mapped",[593]],[[11374,11374],"mapped",[625]],[[11375,11375],"mapped",[592]],[[11376,11376],"mapped",[594]],[[11377,11377],"valid"],[[11378,11378],"mapped",[11379]],[[11379,11379],"valid"],[[11380,11380],"valid"],[[11381,11381],"mapped",[11382]],[[11382,11383],"valid"],[[11384,11387],"valid"],[[11388,11388],"mapped",[106]],[[11389,11389],"mapped",[118]],[[11390,11390],"mapped",[575]],[[11391,11391],"mapped",[576]],[[11392,11392],"mapped",[11393]],[[11393,11393],"valid"],[[11394,11394],"mapped",[11395]],[[11395,11395],"valid"],[[11396,11396],"mapped",[11397]],[[11397,11397],"valid"],[[11398,11398],"mapped",[11399]],[[11399,11399],"valid"],[[11400,11400],"mapped",[11401]],[[11401,11401],"valid"],[[11402,11402],"mapped",[11403]],[[11403,11403],"valid"],[[11404,11404],"mapped",[11405]],[[11405,11405],"valid"],[[11406,11406],"mapped",[11407]],[[11407,11407],"valid"],[[11408,11408],"mapped",[11409]],[[11409,11409],"valid"],[[11410,11410],"mapped",[11411]],[[11411,11411],"valid"],[[11412,11412],"mapped",[11413]],[[11413,11413],"valid"],[[11414,11414],"mapped",[11415]],[[11415,11415],"valid"],[[11416,11416],"mapped",[11417]],[[11417,11417],"valid"],[[11418,11418],"mapped",[11419]],[[11419,11419],"valid"],[[11420,11420],"mapped",[11421]],[[11421,11421],"valid"],[[11422,11422],"mapped",[11423]],[[11423,11423],"valid"],[[11424,11424],"mapped",[11425]],[[11425,11425],"valid"],[[11426,11426],"mapped",[11427]],[[11427,11427],"valid"],[[11428,11428],"mapped",[11429]],[[11429,11429],"valid"],[[11430,11430],"mapped",[11431]],[[11431,11431],"valid"],[[11432,11432],"mapped",[11433]],[[11433,11433],"valid"],[[11434,11434],"mapped",[11435]],[[11435,11435],"valid"],[[11436,11436],"mapped",[11437]],[[11437,11437],"valid"],[[11438,11438],"mapped",[11439]],[[11439,11439],"valid"],[[11440,11440],"mapped",[11441]],[[11441,11441],"valid"],[[11442,11442],"mapped",[11443]],[[11443,11443],"valid"],[[11444,11444],"mapped",[11445]],[[11445,11445],"valid"],[[11446,11446],"mapped",[11447]],[[11447,11447],"valid"],[[11448,11448],"mapped",[11449]],[[11449,11449],"valid"],[[11450,11450],"mapped",[11451]],[[11451,11451],"valid"],[[11452,11452],"mapped",[11453]],[[11453,11453],"valid"],[[11454,11454],"mapped",[11455]],[[11455,11455],"valid"],[[11456,11456],"mapped",[11457]],[[11457,11457],"valid"],[[11458,11458],"mapped",[11459]],[[11459,11459],"valid"],[[11460,11460],"mapped",[11461]],[[11461,11461],"valid"],[[11462,11462],"mapped",[11463]],[[11463,11463],"valid"],[[11464,11464],"mapped",[11465]],[[11465,11465],"valid"],[[11466,11466],"mapped",[11467]],[[11467,11467],"valid"],[[11468,11468],"mapped",[11469]],[[11469,11469],"valid"],[[11470,11470],"mapped",[11471]],[[11471,11471],"valid"],[[11472,11472],"mapped",[11473]],[[11473,11473],"valid"],[[11474,11474],"mapped",[11475]],[[11475,11475],"valid"],[[11476,11476],"mapped",[11477]],[[11477,11477],"valid"],[[11478,11478],"mapped",[11479]],[[11479,11479],"valid"],[[11480,11480],"mapped",[11481]],[[11481,11481],"valid"],[[11482,11482],"mapped",[11483]],[[11483,11483],"valid"],[[11484,11484],"mapped",[11485]],[[11485,11485],"valid"],[[11486,11486],"mapped",[11487]],[[11487,11487],"valid"],[[11488,11488],"mapped",[11489]],[[11489,11489],"valid"],[[11490,11490],"mapped",[11491]],[[11491,11492],"valid"],[[11493,11498],"valid",[],"NV8"],[[11499,11499],"mapped",[11500]],[[11500,11500],"valid"],[[11501,11501],"mapped",[11502]],[[11502,11505],"valid"],[[11506,11506],"mapped",[11507]],[[11507,11507],"valid"],[[11508,11512],"disallowed"],[[11513,11519],"valid",[],"NV8"],[[11520,11557],"valid"],[[11558,11558],"disallowed"],[[11559,11559],"valid"],[[11560,11564],"disallowed"],[[11565,11565],"valid"],[[11566,11567],"disallowed"],[[11568,11621],"valid"],[[11622,11623],"valid"],[[11624,11630],"disallowed"],[[11631,11631],"mapped",[11617]],[[11632,11632],"valid",[],"NV8"],[[11633,11646],"disallowed"],[[11647,11647],"valid"],[[11648,11670],"valid"],[[11671,11679],"disallowed"],[[11680,11686],"valid"],[[11687,11687],"disallowed"],[[11688,11694],"valid"],[[11695,11695],"disallowed"],[[11696,11702],"valid"],[[11703,11703],"disallowed"],[[11704,11710],"valid"],[[11711,11711],"disallowed"],[[11712,11718],"valid"],[[11719,11719],"disallowed"],[[11720,11726],"valid"],[[11727,11727],"disallowed"],[[11728,11734],"valid"],[[11735,11735],"disallowed"],[[11736,11742],"valid"],[[11743,11743],"disallowed"],[[11744,11775],"valid"],[[11776,11799],"valid",[],"NV8"],[[11800,11803],"valid",[],"NV8"],[[11804,11805],"valid",[],"NV8"],[[11806,11822],"valid",[],"NV8"],[[11823,11823],"valid"],[[11824,11824],"valid",[],"NV8"],[[11825,11825],"valid",[],"NV8"],[[11826,11835],"valid",[],"NV8"],[[11836,11842],"valid",[],"NV8"],[[11843,11903],"disallowed"],[[11904,11929],"valid",[],"NV8"],[[11930,11930],"disallowed"],[[11931,11934],"valid",[],"NV8"],[[11935,11935],"mapped",[27597]],[[11936,12018],"valid",[],"NV8"],[[12019,12019],"mapped",[40863]],[[12020,12031],"disallowed"],[[12032,12032],"mapped",[19968]],[[12033,12033],"mapped",[20008]],[[12034,12034],"mapped",[20022]],[[12035,12035],"mapped",[20031]],[[12036,12036],"mapped",[20057]],[[12037,12037],"mapped",[20101]],[[12038,12038],"mapped",[20108]],[[12039,12039],"mapped",[20128]],[[12040,12040],"mapped",[20154]],[[12041,12041],"mapped",[20799]],[[12042,12042],"mapped",[20837]],[[12043,12043],"mapped",[20843]],[[12044,12044],"mapped",[20866]],[[12045,12045],"mapped",[20886]],[[12046,12046],"mapped",[20907]],[[12047,12047],"mapped",[20960]],[[12048,12048],"mapped",[20981]],[[12049,12049],"mapped",[20992]],[[12050,12050],"mapped",[21147]],[[12051,12051],"mapped",[21241]],[[12052,12052],"mapped",[21269]],[[12053,12053],"mapped",[21274]],[[12054,12054],"mapped",[21304]],[[12055,12055],"mapped",[21313]],[[12056,12056],"mapped",[21340]],[[12057,12057],"mapped",[21353]],[[12058,12058],"mapped",[21378]],[[12059,12059],"mapped",[21430]],[[12060,12060],"mapped",[21448]],[[12061,12061],"mapped",[21475]],[[12062,12062],"mapped",[22231]],[[12063,12063],"mapped",[22303]],[[12064,12064],"mapped",[22763]],[[12065,12065],"mapped",[22786]],[[12066,12066],"mapped",[22794]],[[12067,12067],"mapped",[22805]],[[12068,12068],"mapped",[22823]],[[12069,12069],"mapped",[22899]],[[12070,12070],"mapped",[23376]],[[12071,12071],"mapped",[23424]],[[12072,12072],"mapped",[23544]],[[12073,12073],"mapped",[23567]],[[12074,12074],"mapped",[23586]],[[12075,12075],"mapped",[23608]],[[12076,12076],"mapped",[23662]],[[12077,12077],"mapped",[23665]],[[12078,12078],"mapped",[24027]],[[12079,12079],"mapped",[24037]],[[12080,12080],"mapped",[24049]],[[12081,12081],"mapped",[24062]],[[12082,12082],"mapped",[24178]],[[12083,12083],"mapped",[24186]],[[12084,12084],"mapped",[24191]],[[12085,12085],"mapped",[24308]],[[12086,12086],"mapped",[24318]],[[12087,12087],"mapped",[24331]],[[12088,12088],"mapped",[24339]],[[12089,12089],"mapped",[24400]],[[12090,12090],"mapped",[24417]],[[12091,12091],"mapped",[24435]],[[12092,12092],"mapped",[24515]],[[12093,12093],"mapped",[25096]],[[12094,12094],"mapped",[25142]],[[12095,12095],"mapped",[25163]],[[12096,12096],"mapped",[25903]],[[12097,12097],"mapped",[25908]],[[12098,12098],"mapped",[25991]],[[12099,12099],"mapped",[26007]],[[12100,12100],"mapped",[26020]],[[12101,12101],"mapped",[26041]],[[12102,12102],"mapped",[26080]],[[12103,12103],"mapped",[26085]],[[12104,12104],"mapped",[26352]],[[12105,12105],"mapped",[26376]],[[12106,12106],"mapped",[26408]],[[12107,12107],"mapped",[27424]],[[12108,12108],"mapped",[27490]],[[12109,12109],"mapped",[27513]],[[12110,12110],"mapped",[27571]],[[12111,12111],"mapped",[27595]],[[12112,12112],"mapped",[27604]],[[12113,12113],"mapped",[27611]],[[12114,12114],"mapped",[27663]],[[12115,12115],"mapped",[27668]],[[12116,12116],"mapped",[27700]],[[12117,12117],"mapped",[28779]],[[12118,12118],"mapped",[29226]],[[12119,12119],"mapped",[29238]],[[12120,12120],"mapped",[29243]],[[12121,12121],"mapped",[29247]],[[12122,12122],"mapped",[29255]],[[12123,12123],"mapped",[29273]],[[12124,12124],"mapped",[29275]],[[12125,12125],"mapped",[29356]],[[12126,12126],"mapped",[29572]],[[12127,12127],"mapped",[29577]],[[12128,12128],"mapped",[29916]],[[12129,12129],"mapped",[29926]],[[12130,12130],"mapped",[29976]],[[12131,12131],"mapped",[29983]],[[12132,12132],"mapped",[29992]],[[12133,12133],"mapped",[30000]],[[12134,12134],"mapped",[30091]],[[12135,12135],"mapped",[30098]],[[12136,12136],"mapped",[30326]],[[12137,12137],"mapped",[30333]],[[12138,12138],"mapped",[30382]],[[12139,12139],"mapped",[30399]],[[12140,12140],"mapped",[30446]],[[12141,12141],"mapped",[30683]],[[12142,12142],"mapped",[30690]],[[12143,12143],"mapped",[30707]],[[12144,12144],"mapped",[31034]],[[12145,12145],"mapped",[31160]],[[12146,12146],"mapped",[31166]],[[12147,12147],"mapped",[31348]],[[12148,12148],"mapped",[31435]],[[12149,12149],"mapped",[31481]],[[12150,12150],"mapped",[31859]],[[12151,12151],"mapped",[31992]],[[12152,12152],"mapped",[32566]],[[12153,12153],"mapped",[32593]],[[12154,12154],"mapped",[32650]],[[12155,12155],"mapped",[32701]],[[12156,12156],"mapped",[32769]],[[12157,12157],"mapped",[32780]],[[12158,12158],"mapped",[32786]],[[12159,12159],"mapped",[32819]],[[12160,12160],"mapped",[32895]],[[12161,12161],"mapped",[32905]],[[12162,12162],"mapped",[33251]],[[12163,12163],"mapped",[33258]],[[12164,12164],"mapped",[33267]],[[12165,12165],"mapped",[33276]],[[12166,12166],"mapped",[33292]],[[12167,12167],"mapped",[33307]],[[12168,12168],"mapped",[33311]],[[12169,12169],"mapped",[33390]],[[12170,12170],"mapped",[33394]],[[12171,12171],"mapped",[33400]],[[12172,12172],"mapped",[34381]],[[12173,12173],"mapped",[34411]],[[12174,12174],"mapped",[34880]],[[12175,12175],"mapped",[34892]],[[12176,12176],"mapped",[34915]],[[12177,12177],"mapped",[35198]],[[12178,12178],"mapped",[35211]],[[12179,12179],"mapped",[35282]],[[12180,12180],"mapped",[35328]],[[12181,12181],"mapped",[35895]],[[12182,12182],"mapped",[35910]],[[12183,12183],"mapped",[35925]],[[12184,12184],"mapped",[35960]],[[12185,12185],"mapped",[35997]],[[12186,12186],"mapped",[36196]],[[12187,12187],"mapped",[36208]],[[12188,12188],"mapped",[36275]],[[12189,12189],"mapped",[36523]],[[12190,12190],"mapped",[36554]],[[12191,12191],"mapped",[36763]],[[12192,12192],"mapped",[36784]],[[12193,12193],"mapped",[36789]],[[12194,12194],"mapped",[37009]],[[12195,12195],"mapped",[37193]],[[12196,12196],"mapped",[37318]],[[12197,12197],"mapped",[37324]],[[12198,12198],"mapped",[37329]],[[12199,12199],"mapped",[38263]],[[12200,12200],"mapped",[38272]],[[12201,12201],"mapped",[38428]],[[12202,12202],"mapped",[38582]],[[12203,12203],"mapped",[38585]],[[12204,12204],"mapped",[38632]],[[12205,12205],"mapped",[38737]],[[12206,12206],"mapped",[38750]],[[12207,12207],"mapped",[38754]],[[12208,12208],"mapped",[38761]],[[12209,12209],"mapped",[38859]],[[12210,12210],"mapped",[38893]],[[12211,12211],"mapped",[38899]],[[12212,12212],"mapped",[38913]],[[12213,12213],"mapped",[39080]],[[12214,12214],"mapped",[39131]],[[12215,12215],"mapped",[39135]],[[12216,12216],"mapped",[39318]],[[12217,12217],"mapped",[39321]],[[12218,12218],"mapped",[39340]],[[12219,12219],"mapped",[39592]],[[12220,12220],"mapped",[39640]],[[12221,12221],"mapped",[39647]],[[12222,12222],"mapped",[39717]],[[12223,12223],"mapped",[39727]],[[12224,12224],"mapped",[39730]],[[12225,12225],"mapped",[39740]],[[12226,12226],"mapped",[39770]],[[12227,12227],"mapped",[40165]],[[12228,12228],"mapped",[40565]],[[12229,12229],"mapped",[40575]],[[12230,12230],"mapped",[40613]],[[12231,12231],"mapped",[40635]],[[12232,12232],"mapped",[40643]],[[12233,12233],"mapped",[40653]],[[12234,12234],"mapped",[40657]],[[12235,12235],"mapped",[40697]],[[12236,12236],"mapped",[40701]],[[12237,12237],"mapped",[40718]],[[12238,12238],"mapped",[40723]],[[12239,12239],"mapped",[40736]],[[12240,12240],"mapped",[40763]],[[12241,12241],"mapped",[40778]],[[12242,12242],"mapped",[40786]],[[12243,12243],"mapped",[40845]],[[12244,12244],"mapped",[40860]],[[12245,12245],"mapped",[40864]],[[12246,12271],"disallowed"],[[12272,12283],"disallowed"],[[12284,12287],"disallowed"],[[12288,12288],"disallowed_STD3_mapped",[32]],[[12289,12289],"valid",[],"NV8"],[[12290,12290],"mapped",[46]],[[12291,12292],"valid",[],"NV8"],[[12293,12295],"valid"],[[12296,12329],"valid",[],"NV8"],[[12330,12333],"valid"],[[12334,12341],"valid",[],"NV8"],[[12342,12342],"mapped",[12306]],[[12343,12343],"valid",[],"NV8"],[[12344,12344],"mapped",[21313]],[[12345,12345],"mapped",[21316]],[[12346,12346],"mapped",[21317]],[[12347,12347],"valid",[],"NV8"],[[12348,12348],"valid"],[[12349,12349],"valid",[],"NV8"],[[12350,12350],"valid",[],"NV8"],[[12351,12351],"valid",[],"NV8"],[[12352,12352],"disallowed"],[[12353,12436],"valid"],[[12437,12438],"valid"],[[12439,12440],"disallowed"],[[12441,12442],"valid"],[[12443,12443],"disallowed_STD3_mapped",[32,12441]],[[12444,12444],"disallowed_STD3_mapped",[32,12442]],[[12445,12446],"valid"],[[12447,12447],"mapped",[12424,12426]],[[12448,12448],"valid",[],"NV8"],[[12449,12542],"valid"],[[12543,12543],"mapped",[12467,12488]],[[12544,12548],"disallowed"],[[12549,12588],"valid"],[[12589,12589],"valid"],[[12590,12592],"disallowed"],[[12593,12593],"mapped",[4352]],[[12594,12594],"mapped",[4353]],[[12595,12595],"mapped",[4522]],[[12596,12596],"mapped",[4354]],[[12597,12597],"mapped",[4524]],[[12598,12598],"mapped",[4525]],[[12599,12599],"mapped",[4355]],[[12600,12600],"mapped",[4356]],[[12601,12601],"mapped",[4357]],[[12602,12602],"mapped",[4528]],[[12603,12603],"mapped",[4529]],[[12604,12604],"mapped",[4530]],[[12605,12605],"mapped",[4531]],[[12606,12606],"mapped",[4532]],[[12607,12607],"mapped",[4533]],[[12608,12608],"mapped",[4378]],[[12609,12609],"mapped",[4358]],[[12610,12610],"mapped",[4359]],[[12611,12611],"mapped",[4360]],[[12612,12612],"mapped",[4385]],[[12613,12613],"mapped",[4361]],[[12614,12614],"mapped",[4362]],[[12615,12615],"mapped",[4363]],[[12616,12616],"mapped",[4364]],[[12617,12617],"mapped",[4365]],[[12618,12618],"mapped",[4366]],[[12619,12619],"mapped",[4367]],[[12620,12620],"mapped",[4368]],[[12621,12621],"mapped",[4369]],[[12622,12622],"mapped",[4370]],[[12623,12623],"mapped",[4449]],[[12624,12624],"mapped",[4450]],[[12625,12625],"mapped",[4451]],[[12626,12626],"mapped",[4452]],[[12627,12627],"mapped",[4453]],[[12628,12628],"mapped",[4454]],[[12629,12629],"mapped",[4455]],[[12630,12630],"mapped",[4456]],[[12631,12631],"mapped",[4457]],[[12632,12632],"mapped",[4458]],[[12633,12633],"mapped",[4459]],[[12634,12634],"mapped",[4460]],[[12635,12635],"mapped",[4461]],[[12636,12636],"mapped",[4462]],[[12637,12637],"mapped",[4463]],[[12638,12638],"mapped",[4464]],[[12639,12639],"mapped",[4465]],[[12640,12640],"mapped",[4466]],[[12641,12641],"mapped",[4467]],[[12642,12642],"mapped",[4468]],[[12643,12643],"mapped",[4469]],[[12644,12644],"disallowed"],[[12645,12645],"mapped",[4372]],[[12646,12646],"mapped",[4373]],[[12647,12647],"mapped",[4551]],[[12648,12648],"mapped",[4552]],[[12649,12649],"mapped",[4556]],[[12650,12650],"mapped",[4558]],[[12651,12651],"mapped",[4563]],[[12652,12652],"mapped",[4567]],[[12653,12653],"mapped",[4569]],[[12654,12654],"mapped",[4380]],[[12655,12655],"mapped",[4573]],[[12656,12656],"mapped",[4575]],[[12657,12657],"mapped",[4381]],[[12658,12658],"mapped",[4382]],[[12659,12659],"mapped",[4384]],[[12660,12660],"mapped",[4386]],[[12661,12661],"mapped",[4387]],[[12662,12662],"mapped",[4391]],[[12663,12663],"mapped",[4393]],[[12664,12664],"mapped",[4395]],[[12665,12665],"mapped",[4396]],[[12666,12666],"mapped",[4397]],[[12667,12667],"mapped",[4398]],[[12668,12668],"mapped",[4399]],[[12669,12669],"mapped",[4402]],[[12670,12670],"mapped",[4406]],[[12671,12671],"mapped",[4416]],[[12672,12672],"mapped",[4423]],[[12673,12673],"mapped",[4428]],[[12674,12674],"mapped",[4593]],[[12675,12675],"mapped",[4594]],[[12676,12676],"mapped",[4439]],[[12677,12677],"mapped",[4440]],[[12678,12678],"mapped",[4441]],[[12679,12679],"mapped",[4484]],[[12680,12680],"mapped",[4485]],[[12681,12681],"mapped",[4488]],[[12682,12682],"mapped",[4497]],[[12683,12683],"mapped",[4498]],[[12684,12684],"mapped",[4500]],[[12685,12685],"mapped",[4510]],[[12686,12686],"mapped",[4513]],[[12687,12687],"disallowed"],[[12688,12689],"valid",[],"NV8"],[[12690,12690],"mapped",[19968]],[[12691,12691],"mapped",[20108]],[[12692,12692],"mapped",[19977]],[[12693,12693],"mapped",[22235]],[[12694,12694],"mapped",[19978]],[[12695,12695],"mapped",[20013]],[[12696,12696],"mapped",[19979]],[[12697,12697],"mapped",[30002]],[[12698,12698],"mapped",[20057]],[[12699,12699],"mapped",[19993]],[[12700,12700],"mapped",[19969]],[[12701,12701],"mapped",[22825]],[[12702,12702],"mapped",[22320]],[[12703,12703],"mapped",[20154]],[[12704,12727],"valid"],[[12728,12730],"valid"],[[12731,12735],"disallowed"],[[12736,12751],"valid",[],"NV8"],[[12752,12771],"valid",[],"NV8"],[[12772,12783],"disallowed"],[[12784,12799],"valid"],[[12800,12800],"disallowed_STD3_mapped",[40,4352,41]],[[12801,12801],"disallowed_STD3_mapped",[40,4354,41]],[[12802,12802],"disallowed_STD3_mapped",[40,4355,41]],[[12803,12803],"disallowed_STD3_mapped",[40,4357,41]],[[12804,12804],"disallowed_STD3_mapped",[40,4358,41]],[[12805,12805],"disallowed_STD3_mapped",[40,4359,41]],[[12806,12806],"disallowed_STD3_mapped",[40,4361,41]],[[12807,12807],"disallowed_STD3_mapped",[40,4363,41]],[[12808,12808],"disallowed_STD3_mapped",[40,4364,41]],[[12809,12809],"disallowed_STD3_mapped",[40,4366,41]],[[12810,12810],"disallowed_STD3_mapped",[40,4367,41]],[[12811,12811],"disallowed_STD3_mapped",[40,4368,41]],[[12812,12812],"disallowed_STD3_mapped",[40,4369,41]],[[12813,12813],"disallowed_STD3_mapped",[40,4370,41]],[[12814,12814],"disallowed_STD3_mapped",[40,44032,41]],[[12815,12815],"disallowed_STD3_mapped",[40,45208,41]],[[12816,12816],"disallowed_STD3_mapped",[40,45796,41]],[[12817,12817],"disallowed_STD3_mapped",[40,46972,41]],[[12818,12818],"disallowed_STD3_mapped",[40,47560,41]],[[12819,12819],"disallowed_STD3_mapped",[40,48148,41]],[[12820,12820],"disallowed_STD3_mapped",[40,49324,41]],[[12821,12821],"disallowed_STD3_mapped",[40,50500,41]],[[12822,12822],"disallowed_STD3_mapped",[40,51088,41]],[[12823,12823],"disallowed_STD3_mapped",[40,52264,41]],[[12824,12824],"disallowed_STD3_mapped",[40,52852,41]],[[12825,12825],"disallowed_STD3_mapped",[40,53440,41]],[[12826,12826],"disallowed_STD3_mapped",[40,54028,41]],[[12827,12827],"disallowed_STD3_mapped",[40,54616,41]],[[12828,12828],"disallowed_STD3_mapped",[40,51452,41]],[[12829,12829],"disallowed_STD3_mapped",[40,50724,51204,41]],[[12830,12830],"disallowed_STD3_mapped",[40,50724,54980,41]],[[12831,12831],"disallowed"],[[12832,12832],"disallowed_STD3_mapped",[40,19968,41]],[[12833,12833],"disallowed_STD3_mapped",[40,20108,41]],[[12834,12834],"disallowed_STD3_mapped",[40,19977,41]],[[12835,12835],"disallowed_STD3_mapped",[40,22235,41]],[[12836,12836],"disallowed_STD3_mapped",[40,20116,41]],[[12837,12837],"disallowed_STD3_mapped",[40,20845,41]],[[12838,12838],"disallowed_STD3_mapped",[40,19971,41]],[[12839,12839],"disallowed_STD3_mapped",[40,20843,41]],[[12840,12840],"disallowed_STD3_mapped",[40,20061,41]],[[12841,12841],"disallowed_STD3_mapped",[40,21313,41]],[[12842,12842],"disallowed_STD3_mapped",[40,26376,41]],[[12843,12843],"disallowed_STD3_mapped",[40,28779,41]],[[12844,12844],"disallowed_STD3_mapped",[40,27700,41]],[[12845,12845],"disallowed_STD3_mapped",[40,26408,41]],[[12846,12846],"disallowed_STD3_mapped",[40,37329,41]],[[12847,12847],"disallowed_STD3_mapped",[40,22303,41]],[[12848,12848],"disallowed_STD3_mapped",[40,26085,41]],[[12849,12849],"disallowed_STD3_mapped",[40,26666,41]],[[12850,12850],"disallowed_STD3_mapped",[40,26377,41]],[[12851,12851],"disallowed_STD3_mapped",[40,31038,41]],[[12852,12852],"disallowed_STD3_mapped",[40,21517,41]],[[12853,12853],"disallowed_STD3_mapped",[40,29305,41]],[[12854,12854],"disallowed_STD3_mapped",[40,36001,41]],[[12855,12855],"disallowed_STD3_mapped",[40,31069,41]],[[12856,12856],"disallowed_STD3_mapped",[40,21172,41]],[[12857,12857],"disallowed_STD3_mapped",[40,20195,41]],[[12858,12858],"disallowed_STD3_mapped",[40,21628,41]],[[12859,12859],"disallowed_STD3_mapped",[40,23398,41]],[[12860,12860],"disallowed_STD3_mapped",[40,30435,41]],[[12861,12861],"disallowed_STD3_mapped",[40,20225,41]],[[12862,12862],"disallowed_STD3_mapped",[40,36039,41]],[[12863,12863],"disallowed_STD3_mapped",[40,21332,41]],[[12864,12864],"disallowed_STD3_mapped",[40,31085,41]],[[12865,12865],"disallowed_STD3_mapped",[40,20241,41]],[[12866,12866],"disallowed_STD3_mapped",[40,33258,41]],[[12867,12867],"disallowed_STD3_mapped",[40,33267,41]],[[12868,12868],"mapped",[21839]],[[12869,12869],"mapped",[24188]],[[12870,12870],"mapped",[25991]],[[12871,12871],"mapped",[31631]],[[12872,12879],"valid",[],"NV8"],[[12880,12880],"mapped",[112,116,101]],[[12881,12881],"mapped",[50,49]],[[12882,12882],"mapped",[50,50]],[[12883,12883],"mapped",[50,51]],[[12884,12884],"mapped",[50,52]],[[12885,12885],"mapped",[50,53]],[[12886,12886],"mapped",[50,54]],[[12887,12887],"mapped",[50,55]],[[12888,12888],"mapped",[50,56]],[[12889,12889],"mapped",[50,57]],[[12890,12890],"mapped",[51,48]],[[12891,12891],"mapped",[51,49]],[[12892,12892],"mapped",[51,50]],[[12893,12893],"mapped",[51,51]],[[12894,12894],"mapped",[51,52]],[[12895,12895],"mapped",[51,53]],[[12896,12896],"mapped",[4352]],[[12897,12897],"mapped",[4354]],[[12898,12898],"mapped",[4355]],[[12899,12899],"mapped",[4357]],[[12900,12900],"mapped",[4358]],[[12901,12901],"mapped",[4359]],[[12902,12902],"mapped",[4361]],[[12903,12903],"mapped",[4363]],[[12904,12904],"mapped",[4364]],[[12905,12905],"mapped",[4366]],[[12906,12906],"mapped",[4367]],[[12907,12907],"mapped",[4368]],[[12908,12908],"mapped",[4369]],[[12909,12909],"mapped",[4370]],[[12910,12910],"mapped",[44032]],[[12911,12911],"mapped",[45208]],[[12912,12912],"mapped",[45796]],[[12913,12913],"mapped",[46972]],[[12914,12914],"mapped",[47560]],[[12915,12915],"mapped",[48148]],[[12916,12916],"mapped",[49324]],[[12917,12917],"mapped",[50500]],[[12918,12918],"mapped",[51088]],[[12919,12919],"mapped",[52264]],[[12920,12920],"mapped",[52852]],[[12921,12921],"mapped",[53440]],[[12922,12922],"mapped",[54028]],[[12923,12923],"mapped",[54616]],[[12924,12924],"mapped",[52280,44256]],[[12925,12925],"mapped",[51452,51032]],[[12926,12926],"mapped",[50864]],[[12927,12927],"valid",[],"NV8"],[[12928,12928],"mapped",[19968]],[[12929,12929],"mapped",[20108]],[[12930,12930],"mapped",[19977]],[[12931,12931],"mapped",[22235]],[[12932,12932],"mapped",[20116]],[[12933,12933],"mapped",[20845]],[[12934,12934],"mapped",[19971]],[[12935,12935],"mapped",[20843]],[[12936,12936],"mapped",[20061]],[[12937,12937],"mapped",[21313]],[[12938,12938],"mapped",[26376]],[[12939,12939],"mapped",[28779]],[[12940,12940],"mapped",[27700]],[[12941,12941],"mapped",[26408]],[[12942,12942],"mapped",[37329]],[[12943,12943],"mapped",[22303]],[[12944,12944],"mapped",[26085]],[[12945,12945],"mapped",[26666]],[[12946,12946],"mapped",[26377]],[[12947,12947],"mapped",[31038]],[[12948,12948],"mapped",[21517]],[[12949,12949],"mapped",[29305]],[[12950,12950],"mapped",[36001]],[[12951,12951],"mapped",[31069]],[[12952,12952],"mapped",[21172]],[[12953,12953],"mapped",[31192]],[[12954,12954],"mapped",[30007]],[[12955,12955],"mapped",[22899]],[[12956,12956],"mapped",[36969]],[[12957,12957],"mapped",[20778]],[[12958,12958],"mapped",[21360]],[[12959,12959],"mapped",[27880]],[[12960,12960],"mapped",[38917]],[[12961,12961],"mapped",[20241]],[[12962,12962],"mapped",[20889]],[[12963,12963],"mapped",[27491]],[[12964,12964],"mapped",[19978]],[[12965,12965],"mapped",[20013]],[[12966,12966],"mapped",[19979]],[[12967,12967],"mapped",[24038]],[[12968,12968],"mapped",[21491]],[[12969,12969],"mapped",[21307]],[[12970,12970],"mapped",[23447]],[[12971,12971],"mapped",[23398]],[[12972,12972],"mapped",[30435]],[[12973,12973],"mapped",[20225]],[[12974,12974],"mapped",[36039]],[[12975,12975],"mapped",[21332]],[[12976,12976],"mapped",[22812]],[[12977,12977],"mapped",[51,54]],[[12978,12978],"mapped",[51,55]],[[12979,12979],"mapped",[51,56]],[[12980,12980],"mapped",[51,57]],[[12981,12981],"mapped",[52,48]],[[12982,12982],"mapped",[52,49]],[[12983,12983],"mapped",[52,50]],[[12984,12984],"mapped",[52,51]],[[12985,12985],"mapped",[52,52]],[[12986,12986],"mapped",[52,53]],[[12987,12987],"mapped",[52,54]],[[12988,12988],"mapped",[52,55]],[[12989,12989],"mapped",[52,56]],[[12990,12990],"mapped",[52,57]],[[12991,12991],"mapped",[53,48]],[[12992,12992],"mapped",[49,26376]],[[12993,12993],"mapped",[50,26376]],[[12994,12994],"mapped",[51,26376]],[[12995,12995],"mapped",[52,26376]],[[12996,12996],"mapped",[53,26376]],[[12997,12997],"mapped",[54,26376]],[[12998,12998],"mapped",[55,26376]],[[12999,12999],"mapped",[56,26376]],[[13000,13000],"mapped",[57,26376]],[[13001,13001],"mapped",[49,48,26376]],[[13002,13002],"mapped",[49,49,26376]],[[13003,13003],"mapped",[49,50,26376]],[[13004,13004],"mapped",[104,103]],[[13005,13005],"mapped",[101,114,103]],[[13006,13006],"mapped",[101,118]],[[13007,13007],"mapped",[108,116,100]],[[13008,13008],"mapped",[12450]],[[13009,13009],"mapped",[12452]],[[13010,13010],"mapped",[12454]],[[13011,13011],"mapped",[12456]],[[13012,13012],"mapped",[12458]],[[13013,13013],"mapped",[12459]],[[13014,13014],"mapped",[12461]],[[13015,13015],"mapped",[12463]],[[13016,13016],"mapped",[12465]],[[13017,13017],"mapped",[12467]],[[13018,13018],"mapped",[12469]],[[13019,13019],"mapped",[12471]],[[13020,13020],"mapped",[12473]],[[13021,13021],"mapped",[12475]],[[13022,13022],"mapped",[12477]],[[13023,13023],"mapped",[12479]],[[13024,13024],"mapped",[12481]],[[13025,13025],"mapped",[12484]],[[13026,13026],"mapped",[12486]],[[13027,13027],"mapped",[12488]],[[13028,13028],"mapped",[12490]],[[13029,13029],"mapped",[12491]],[[13030,13030],"mapped",[12492]],[[13031,13031],"mapped",[12493]],[[13032,13032],"mapped",[12494]],[[13033,13033],"mapped",[12495]],[[13034,13034],"mapped",[12498]],[[13035,13035],"mapped",[12501]],[[13036,13036],"mapped",[12504]],[[13037,13037],"mapped",[12507]],[[13038,13038],"mapped",[12510]],[[13039,13039],"mapped",[12511]],[[13040,13040],"mapped",[12512]],[[13041,13041],"mapped",[12513]],[[13042,13042],"mapped",[12514]],[[13043,13043],"mapped",[12516]],[[13044,13044],"mapped",[12518]],[[13045,13045],"mapped",[12520]],[[13046,13046],"mapped",[12521]],[[13047,13047],"mapped",[12522]],[[13048,13048],"mapped",[12523]],[[13049,13049],"mapped",[12524]],[[13050,13050],"mapped",[12525]],[[13051,13051],"mapped",[12527]],[[13052,13052],"mapped",[12528]],[[13053,13053],"mapped",[12529]],[[13054,13054],"mapped",[12530]],[[13055,13055],"disallowed"],[[13056,13056],"mapped",[12450,12497,12540,12488]],[[13057,13057],"mapped",[12450,12523,12501,12449]],[[13058,13058],"mapped",[12450,12531,12506,12450]],[[13059,13059],"mapped",[12450,12540,12523]],[[13060,13060],"mapped",[12452,12491,12531,12464]],[[13061,13061],"mapped",[12452,12531,12481]],[[13062,13062],"mapped",[12454,12457,12531]],[[13063,13063],"mapped",[12456,12473,12463,12540,12489]],[[13064,13064],"mapped",[12456,12540,12459,12540]],[[13065,13065],"mapped",[12458,12531,12473]],[[13066,13066],"mapped",[12458,12540,12512]],[[13067,13067],"mapped",[12459,12452,12522]],[[13068,13068],"mapped",[12459,12521,12483,12488]],[[13069,13069],"mapped",[12459,12525,12522,12540]],[[13070,13070],"mapped",[12460,12525,12531]],[[13071,13071],"mapped",[12460,12531,12510]],[[13072,13072],"mapped",[12462,12460]],[[13073,13073],"mapped",[12462,12491,12540]],[[13074,13074],"mapped",[12461,12517,12522,12540]],[[13075,13075],"mapped",[12462,12523,12480,12540]],[[13076,13076],"mapped",[12461,12525]],[[13077,13077],"mapped",[12461,12525,12464,12521,12512]],[[13078,13078],"mapped",[12461,12525,12513,12540,12488,12523]],[[13079,13079],"mapped",[12461,12525,12527,12483,12488]],[[13080,13080],"mapped",[12464,12521,12512]],[[13081,13081],"mapped",[12464,12521,12512,12488,12531]],[[13082,13082],"mapped",[12463,12523,12476,12452,12525]],[[13083,13083],"mapped",[12463,12525,12540,12493]],[[13084,13084],"mapped",[12465,12540,12473]],[[13085,13085],"mapped",[12467,12523,12490]],[[13086,13086],"mapped",[12467,12540,12509]],[[13087,13087],"mapped",[12469,12452,12463,12523]],[[13088,13088],"mapped",[12469,12531,12481,12540,12512]],[[13089,13089],"mapped",[12471,12522,12531,12464]],[[13090,13090],"mapped",[12475,12531,12481]],[[13091,13091],"mapped",[12475,12531,12488]],[[13092,13092],"mapped",[12480,12540,12473]],[[13093,13093],"mapped",[12487,12471]],[[13094,13094],"mapped",[12489,12523]],[[13095,13095],"mapped",[12488,12531]],[[13096,13096],"mapped",[12490,12494]],[[13097,13097],"mapped",[12494,12483,12488]],[[13098,13098],"mapped",[12495,12452,12484]],[[13099,13099],"mapped",[12497,12540,12475,12531,12488]],[[13100,13100],"mapped",[12497,12540,12484]],[[13101,13101],"mapped",[12496,12540,12524,12523]],[[13102,13102],"mapped",[12500,12450,12473,12488,12523]],[[13103,13103],"mapped",[12500,12463,12523]],[[13104,13104],"mapped",[12500,12467]],[[13105,13105],"mapped",[12499,12523]],[[13106,13106],"mapped",[12501,12449,12521,12483,12489]],[[13107,13107],"mapped",[12501,12451,12540,12488]],[[13108,13108],"mapped",[12502,12483,12471,12455,12523]],[[13109,13109],"mapped",[12501,12521,12531]],[[13110,13110],"mapped",[12504,12463,12479,12540,12523]],[[13111,13111],"mapped",[12506,12477]],[[13112,13112],"mapped",[12506,12491,12498]],[[13113,13113],"mapped",[12504,12523,12484]],[[13114,13114],"mapped",[12506,12531,12473]],[[13115,13115],"mapped",[12506,12540,12472]],[[13116,13116],"mapped",[12505,12540,12479]],[[13117,13117],"mapped",[12509,12452,12531,12488]],[[13118,13118],"mapped",[12508,12523,12488]],[[13119,13119],"mapped",[12507,12531]],[[13120,13120],"mapped",[12509,12531,12489]],[[13121,13121],"mapped",[12507,12540,12523]],[[13122,13122],"mapped",[12507,12540,12531]],[[13123,13123],"mapped",[12510,12452,12463,12525]],[[13124,13124],"mapped",[12510,12452,12523]],[[13125,13125],"mapped",[12510,12483,12495]],[[13126,13126],"mapped",[12510,12523,12463]],[[13127,13127],"mapped",[12510,12531,12471,12519,12531]],[[13128,13128],"mapped",[12511,12463,12525,12531]],[[13129,13129],"mapped",[12511,12522]],[[13130,13130],"mapped",[12511,12522,12496,12540,12523]],[[13131,13131],"mapped",[12513,12460]],[[13132,13132],"mapped",[12513,12460,12488,12531]],[[13133,13133],"mapped",[12513,12540,12488,12523]],[[13134,13134],"mapped",[12516,12540,12489]],[[13135,13135],"mapped",[12516,12540,12523]],[[13136,13136],"mapped",[12518,12450,12531]],[[13137,13137],"mapped",[12522,12483,12488,12523]],[[13138,13138],"mapped",[12522,12521]],[[13139,13139],"mapped",[12523,12500,12540]],[[13140,13140],"mapped",[12523,12540,12502,12523]],[[13141,13141],"mapped",[12524,12512]],[[13142,13142],"mapped",[12524,12531,12488,12466,12531]],[[13143,13143],"mapped",[12527,12483,12488]],[[13144,13144],"mapped",[48,28857]],[[13145,13145],"mapped",[49,28857]],[[13146,13146],"mapped",[50,28857]],[[13147,13147],"mapped",[51,28857]],[[13148,13148],"mapped",[52,28857]],[[13149,13149],"mapped",[53,28857]],[[13150,13150],"mapped",[54,28857]],[[13151,13151],"mapped",[55,28857]],[[13152,13152],"mapped",[56,28857]],[[13153,13153],"mapped",[57,28857]],[[13154,13154],"mapped",[49,48,28857]],[[13155,13155],"mapped",[49,49,28857]],[[13156,13156],"mapped",[49,50,28857]],[[13157,13157],"mapped",[49,51,28857]],[[13158,13158],"mapped",[49,52,28857]],[[13159,13159],"mapped",[49,53,28857]],[[13160,13160],"mapped",[49,54,28857]],[[13161,13161],"mapped",[49,55,28857]],[[13162,13162],"mapped",[49,56,28857]],[[13163,13163],"mapped",[49,57,28857]],[[13164,13164],"mapped",[50,48,28857]],[[13165,13165],"mapped",[50,49,28857]],[[13166,13166],"mapped",[50,50,28857]],[[13167,13167],"mapped",[50,51,28857]],[[13168,13168],"mapped",[50,52,28857]],[[13169,13169],"mapped",[104,112,97]],[[13170,13170],"mapped",[100,97]],[[13171,13171],"mapped",[97,117]],[[13172,13172],"mapped",[98,97,114]],[[13173,13173],"mapped",[111,118]],[[13174,13174],"mapped",[112,99]],[[13175,13175],"mapped",[100,109]],[[13176,13176],"mapped",[100,109,50]],[[13177,13177],"mapped",[100,109,51]],[[13178,13178],"mapped",[105,117]],[[13179,13179],"mapped",[24179,25104]],[[13180,13180],"mapped",[26157,21644]],[[13181,13181],"mapped",[22823,27491]],[[13182,13182],"mapped",[26126,27835]],[[13183,13183],"mapped",[26666,24335,20250,31038]],[[13184,13184],"mapped",[112,97]],[[13185,13185],"mapped",[110,97]],[[13186,13186],"mapped",[956,97]],[[13187,13187],"mapped",[109,97]],[[13188,13188],"mapped",[107,97]],[[13189,13189],"mapped",[107,98]],[[13190,13190],"mapped",[109,98]],[[13191,13191],"mapped",[103,98]],[[13192,13192],"mapped",[99,97,108]],[[13193,13193],"mapped",[107,99,97,108]],[[13194,13194],"mapped",[112,102]],[[13195,13195],"mapped",[110,102]],[[13196,13196],"mapped",[956,102]],[[13197,13197],"mapped",[956,103]],[[13198,13198],"mapped",[109,103]],[[13199,13199],"mapped",[107,103]],[[13200,13200],"mapped",[104,122]],[[13201,13201],"mapped",[107,104,122]],[[13202,13202],"mapped",[109,104,122]],[[13203,13203],"mapped",[103,104,122]],[[13204,13204],"mapped",[116,104,122]],[[13205,13205],"mapped",[956,108]],[[13206,13206],"mapped",[109,108]],[[13207,13207],"mapped",[100,108]],[[13208,13208],"mapped",[107,108]],[[13209,13209],"mapped",[102,109]],[[13210,13210],"mapped",[110,109]],[[13211,13211],"mapped",[956,109]],[[13212,13212],"mapped",[109,109]],[[13213,13213],"mapped",[99,109]],[[13214,13214],"mapped",[107,109]],[[13215,13215],"mapped",[109,109,50]],[[13216,13216],"mapped",[99,109,50]],[[13217,13217],"mapped",[109,50]],[[13218,13218],"mapped",[107,109,50]],[[13219,13219],"mapped",[109,109,51]],[[13220,13220],"mapped",[99,109,51]],[[13221,13221],"mapped",[109,51]],[[13222,13222],"mapped",[107,109,51]],[[13223,13223],"mapped",[109,8725,115]],[[13224,13224],"mapped",[109,8725,115,50]],[[13225,13225],"mapped",[112,97]],[[13226,13226],"mapped",[107,112,97]],[[13227,13227],"mapped",[109,112,97]],[[13228,13228],"mapped",[103,112,97]],[[13229,13229],"mapped",[114,97,100]],[[13230,13230],"mapped",[114,97,100,8725,115]],[[13231,13231],"mapped",[114,97,100,8725,115,50]],[[13232,13232],"mapped",[112,115]],[[13233,13233],"mapped",[110,115]],[[13234,13234],"mapped",[956,115]],[[13235,13235],"mapped",[109,115]],[[13236,13236],"mapped",[112,118]],[[13237,13237],"mapped",[110,118]],[[13238,13238],"mapped",[956,118]],[[13239,13239],"mapped",[109,118]],[[13240,13240],"mapped",[107,118]],[[13241,13241],"mapped",[109,118]],[[13242,13242],"mapped",[112,119]],[[13243,13243],"mapped",[110,119]],[[13244,13244],"mapped",[956,119]],[[13245,13245],"mapped",[109,119]],[[13246,13246],"mapped",[107,119]],[[13247,13247],"mapped",[109,119]],[[13248,13248],"mapped",[107,969]],[[13249,13249],"mapped",[109,969]],[[13250,13250],"disallowed"],[[13251,13251],"mapped",[98,113]],[[13252,13252],"mapped",[99,99]],[[13253,13253],"mapped",[99,100]],[[13254,13254],"mapped",[99,8725,107,103]],[[13255,13255],"disallowed"],[[13256,13256],"mapped",[100,98]],[[13257,13257],"mapped",[103,121]],[[13258,13258],"mapped",[104,97]],[[13259,13259],"mapped",[104,112]],[[13260,13260],"mapped",[105,110]],[[13261,13261],"mapped",[107,107]],[[13262,13262],"mapped",[107,109]],[[13263,13263],"mapped",[107,116]],[[13264,13264],"mapped",[108,109]],[[13265,13265],"mapped",[108,110]],[[13266,13266],"mapped",[108,111,103]],[[13267,13267],"mapped",[108,120]],[[13268,13268],"mapped",[109,98]],[[13269,13269],"mapped",[109,105,108]],[[13270,13270],"mapped",[109,111,108]],[[13271,13271],"mapped",[112,104]],[[13272,13272],"disallowed"],[[13273,13273],"mapped",[112,112,109]],[[13274,13274],"mapped",[112,114]],[[13275,13275],"mapped",[115,114]],[[13276,13276],"mapped",[115,118]],[[13277,13277],"mapped",[119,98]],[[13278,13278],"mapped",[118,8725,109]],[[13279,13279],"mapped",[97,8725,109]],[[13280,13280],"mapped",[49,26085]],[[13281,13281],"mapped",[50,26085]],[[13282,13282],"mapped",[51,26085]],[[13283,13283],"mapped",[52,26085]],[[13284,13284],"mapped",[53,26085]],[[13285,13285],"mapped",[54,26085]],[[13286,13286],"mapped",[55,26085]],[[13287,13287],"mapped",[56,26085]],[[13288,13288],"mapped",[57,26085]],[[13289,13289],"mapped",[49,48,26085]],[[13290,13290],"mapped",[49,49,26085]],[[13291,13291],"mapped",[49,50,26085]],[[13292,13292],"mapped",[49,51,26085]],[[13293,13293],"mapped",[49,52,26085]],[[13294,13294],"mapped",[49,53,26085]],[[13295,13295],"mapped",[49,54,26085]],[[13296,13296],"mapped",[49,55,26085]],[[13297,13297],"mapped",[49,56,26085]],[[13298,13298],"mapped",[49,57,26085]],[[13299,13299],"mapped",[50,48,26085]],[[13300,13300],"mapped",[50,49,26085]],[[13301,13301],"mapped",[50,50,26085]],[[13302,13302],"mapped",[50,51,26085]],[[13303,13303],"mapped",[50,52,26085]],[[13304,13304],"mapped",[50,53,26085]],[[13305,13305],"mapped",[50,54,26085]],[[13306,13306],"mapped",[50,55,26085]],[[13307,13307],"mapped",[50,56,26085]],[[13308,13308],"mapped",[50,57,26085]],[[13309,13309],"mapped",[51,48,26085]],[[13310,13310],"mapped",[51,49,26085]],[[13311,13311],"mapped",[103,97,108]],[[13312,19893],"valid"],[[19894,19903],"disallowed"],[[19904,19967],"valid",[],"NV8"],[[19968,40869],"valid"],[[40870,40891],"valid"],[[40892,40899],"valid"],[[40900,40907],"valid"],[[40908,40908],"valid"],[[40909,40917],"valid"],[[40918,40959],"disallowed"],[[40960,42124],"valid"],[[42125,42127],"disallowed"],[[42128,42145],"valid",[],"NV8"],[[42146,42147],"valid",[],"NV8"],[[42148,42163],"valid",[],"NV8"],[[42164,42164],"valid",[],"NV8"],[[42165,42176],"valid",[],"NV8"],[[42177,42177],"valid",[],"NV8"],[[42178,42180],"valid",[],"NV8"],[[42181,42181],"valid",[],"NV8"],[[42182,42182],"valid",[],"NV8"],[[42183,42191],"disallowed"],[[42192,42237],"valid"],[[42238,42239],"valid",[],"NV8"],[[42240,42508],"valid"],[[42509,42511],"valid",[],"NV8"],[[42512,42539],"valid"],[[42540,42559],"disallowed"],[[42560,42560],"mapped",[42561]],[[42561,42561],"valid"],[[42562,42562],"mapped",[42563]],[[42563,42563],"valid"],[[42564,42564],"mapped",[42565]],[[42565,42565],"valid"],[[42566,42566],"mapped",[42567]],[[42567,42567],"valid"],[[42568,42568],"mapped",[42569]],[[42569,42569],"valid"],[[42570,42570],"mapped",[42571]],[[42571,42571],"valid"],[[42572,42572],"mapped",[42573]],[[42573,42573],"valid"],[[42574,42574],"mapped",[42575]],[[42575,42575],"valid"],[[42576,42576],"mapped",[42577]],[[42577,42577],"valid"],[[42578,42578],"mapped",[42579]],[[42579,42579],"valid"],[[42580,42580],"mapped",[42581]],[[42581,42581],"valid"],[[42582,42582],"mapped",[42583]],[[42583,42583],"valid"],[[42584,42584],"mapped",[42585]],[[42585,42585],"valid"],[[42586,42586],"mapped",[42587]],[[42587,42587],"valid"],[[42588,42588],"mapped",[42589]],[[42589,42589],"valid"],[[42590,42590],"mapped",[42591]],[[42591,42591],"valid"],[[42592,42592],"mapped",[42593]],[[42593,42593],"valid"],[[42594,42594],"mapped",[42595]],[[42595,42595],"valid"],[[42596,42596],"mapped",[42597]],[[42597,42597],"valid"],[[42598,42598],"mapped",[42599]],[[42599,42599],"valid"],[[42600,42600],"mapped",[42601]],[[42601,42601],"valid"],[[42602,42602],"mapped",[42603]],[[42603,42603],"valid"],[[42604,42604],"mapped",[42605]],[[42605,42607],"valid"],[[42608,42611],"valid",[],"NV8"],[[42612,42619],"valid"],[[42620,42621],"valid"],[[42622,42622],"valid",[],"NV8"],[[42623,42623],"valid"],[[42624,42624],"mapped",[42625]],[[42625,42625],"valid"],[[42626,42626],"mapped",[42627]],[[42627,42627],"valid"],[[42628,42628],"mapped",[42629]],[[42629,42629],"valid"],[[42630,42630],"mapped",[42631]],[[42631,42631],"valid"],[[42632,42632],"mapped",[42633]],[[42633,42633],"valid"],[[42634,42634],"mapped",[42635]],[[42635,42635],"valid"],[[42636,42636],"mapped",[42637]],[[42637,42637],"valid"],[[42638,42638],"mapped",[42639]],[[42639,42639],"valid"],[[42640,42640],"mapped",[42641]],[[42641,42641],"valid"],[[42642,42642],"mapped",[42643]],[[42643,42643],"valid"],[[42644,42644],"mapped",[42645]],[[42645,42645],"valid"],[[42646,42646],"mapped",[42647]],[[42647,42647],"valid"],[[42648,42648],"mapped",[42649]],[[42649,42649],"valid"],[[42650,42650],"mapped",[42651]],[[42651,42651],"valid"],[[42652,42652],"mapped",[1098]],[[42653,42653],"mapped",[1100]],[[42654,42654],"valid"],[[42655,42655],"valid"],[[42656,42725],"valid"],[[42726,42735],"valid",[],"NV8"],[[42736,42737],"valid"],[[42738,42743],"valid",[],"NV8"],[[42744,42751],"disallowed"],[[42752,42774],"valid",[],"NV8"],[[42775,42778],"valid"],[[42779,42783],"valid"],[[42784,42785],"valid",[],"NV8"],[[42786,42786],"mapped",[42787]],[[42787,42787],"valid"],[[42788,42788],"mapped",[42789]],[[42789,42789],"valid"],[[42790,42790],"mapped",[42791]],[[42791,42791],"valid"],[[42792,42792],"mapped",[42793]],[[42793,42793],"valid"],[[42794,42794],"mapped",[42795]],[[42795,42795],"valid"],[[42796,42796],"mapped",[42797]],[[42797,42797],"valid"],[[42798,42798],"mapped",[42799]],[[42799,42801],"valid"],[[42802,42802],"mapped",[42803]],[[42803,42803],"valid"],[[42804,42804],"mapped",[42805]],[[42805,42805],"valid"],[[42806,42806],"mapped",[42807]],[[42807,42807],"valid"],[[42808,42808],"mapped",[42809]],[[42809,42809],"valid"],[[42810,42810],"mapped",[42811]],[[42811,42811],"valid"],[[42812,42812],"mapped",[42813]],[[42813,42813],"valid"],[[42814,42814],"mapped",[42815]],[[42815,42815],"valid"],[[42816,42816],"mapped",[42817]],[[42817,42817],"valid"],[[42818,42818],"mapped",[42819]],[[42819,42819],"valid"],[[42820,42820],"mapped",[42821]],[[42821,42821],"valid"],[[42822,42822],"mapped",[42823]],[[42823,42823],"valid"],[[42824,42824],"mapped",[42825]],[[42825,42825],"valid"],[[42826,42826],"mapped",[42827]],[[42827,42827],"valid"],[[42828,42828],"mapped",[42829]],[[42829,42829],"valid"],[[42830,42830],"mapped",[42831]],[[42831,42831],"valid"],[[42832,42832],"mapped",[42833]],[[42833,42833],"valid"],[[42834,42834],"mapped",[42835]],[[42835,42835],"valid"],[[42836,42836],"mapped",[42837]],[[42837,42837],"valid"],[[42838,42838],"mapped",[42839]],[[42839,42839],"valid"],[[42840,42840],"mapped",[42841]],[[42841,42841],"valid"],[[42842,42842],"mapped",[42843]],[[42843,42843],"valid"],[[42844,42844],"mapped",[42845]],[[42845,42845],"valid"],[[42846,42846],"mapped",[42847]],[[42847,42847],"valid"],[[42848,42848],"mapped",[42849]],[[42849,42849],"valid"],[[42850,42850],"mapped",[42851]],[[42851,42851],"valid"],[[42852,42852],"mapped",[42853]],[[42853,42853],"valid"],[[42854,42854],"mapped",[42855]],[[42855,42855],"valid"],[[42856,42856],"mapped",[42857]],[[42857,42857],"valid"],[[42858,42858],"mapped",[42859]],[[42859,42859],"valid"],[[42860,42860],"mapped",[42861]],[[42861,42861],"valid"],[[42862,42862],"mapped",[42863]],[[42863,42863],"valid"],[[42864,42864],"mapped",[42863]],[[42865,42872],"valid"],[[42873,42873],"mapped",[42874]],[[42874,42874],"valid"],[[42875,42875],"mapped",[42876]],[[42876,42876],"valid"],[[42877,42877],"mapped",[7545]],[[42878,42878],"mapped",[42879]],[[42879,42879],"valid"],[[42880,42880],"mapped",[42881]],[[42881,42881],"valid"],[[42882,42882],"mapped",[42883]],[[42883,42883],"valid"],[[42884,42884],"mapped",[42885]],[[42885,42885],"valid"],[[42886,42886],"mapped",[42887]],[[42887,42888],"valid"],[[42889,42890],"valid",[],"NV8"],[[42891,42891],"mapped",[42892]],[[42892,42892],"valid"],[[42893,42893],"mapped",[613]],[[42894,42894],"valid"],[[42895,42895],"valid"],[[42896,42896],"mapped",[42897]],[[42897,42897],"valid"],[[42898,42898],"mapped",[42899]],[[42899,42899],"valid"],[[42900,42901],"valid"],[[42902,42902],"mapped",[42903]],[[42903,42903],"valid"],[[42904,42904],"mapped",[42905]],[[42905,42905],"valid"],[[42906,42906],"mapped",[42907]],[[42907,42907],"valid"],[[42908,42908],"mapped",[42909]],[[42909,42909],"valid"],[[42910,42910],"mapped",[42911]],[[42911,42911],"valid"],[[42912,42912],"mapped",[42913]],[[42913,42913],"valid"],[[42914,42914],"mapped",[42915]],[[42915,42915],"valid"],[[42916,42916],"mapped",[42917]],[[42917,42917],"valid"],[[42918,42918],"mapped",[42919]],[[42919,42919],"valid"],[[42920,42920],"mapped",[42921]],[[42921,42921],"valid"],[[42922,42922],"mapped",[614]],[[42923,42923],"mapped",[604]],[[42924,42924],"mapped",[609]],[[42925,42925],"mapped",[620]],[[42926,42927],"disallowed"],[[42928,42928],"mapped",[670]],[[42929,42929],"mapped",[647]],[[42930,42930],"mapped",[669]],[[42931,42931],"mapped",[43859]],[[42932,42932],"mapped",[42933]],[[42933,42933],"valid"],[[42934,42934],"mapped",[42935]],[[42935,42935],"valid"],[[42936,42998],"disallowed"],[[42999,42999],"valid"],[[43000,43000],"mapped",[295]],[[43001,43001],"mapped",[339]],[[43002,43002],"valid"],[[43003,43007],"valid"],[[43008,43047],"valid"],[[43048,43051],"valid",[],"NV8"],[[43052,43055],"disallowed"],[[43056,43065],"valid",[],"NV8"],[[43066,43071],"disallowed"],[[43072,43123],"valid"],[[43124,43127],"valid",[],"NV8"],[[43128,43135],"disallowed"],[[43136,43204],"valid"],[[43205,43213],"disallowed"],[[43214,43215],"valid",[],"NV8"],[[43216,43225],"valid"],[[43226,43231],"disallowed"],[[43232,43255],"valid"],[[43256,43258],"valid",[],"NV8"],[[43259,43259],"valid"],[[43260,43260],"valid",[],"NV8"],[[43261,43261],"valid"],[[43262,43263],"disallowed"],[[43264,43309],"valid"],[[43310,43311],"valid",[],"NV8"],[[43312,43347],"valid"],[[43348,43358],"disallowed"],[[43359,43359],"valid",[],"NV8"],[[43360,43388],"valid",[],"NV8"],[[43389,43391],"disallowed"],[[43392,43456],"valid"],[[43457,43469],"valid",[],"NV8"],[[43470,43470],"disallowed"],[[43471,43481],"valid"],[[43482,43485],"disallowed"],[[43486,43487],"valid",[],"NV8"],[[43488,43518],"valid"],[[43519,43519],"disallowed"],[[43520,43574],"valid"],[[43575,43583],"disallowed"],[[43584,43597],"valid"],[[43598,43599],"disallowed"],[[43600,43609],"valid"],[[43610,43611],"disallowed"],[[43612,43615],"valid",[],"NV8"],[[43616,43638],"valid"],[[43639,43641],"valid",[],"NV8"],[[43642,43643],"valid"],[[43644,43647],"valid"],[[43648,43714],"valid"],[[43715,43738],"disallowed"],[[43739,43741],"valid"],[[43742,43743],"valid",[],"NV8"],[[43744,43759],"valid"],[[43760,43761],"valid",[],"NV8"],[[43762,43766],"valid"],[[43767,43776],"disallowed"],[[43777,43782],"valid"],[[43783,43784],"disallowed"],[[43785,43790],"valid"],[[43791,43792],"disallowed"],[[43793,43798],"valid"],[[43799,43807],"disallowed"],[[43808,43814],"valid"],[[43815,43815],"disallowed"],[[43816,43822],"valid"],[[43823,43823],"disallowed"],[[43824,43866],"valid"],[[43867,43867],"valid",[],"NV8"],[[43868,43868],"mapped",[42791]],[[43869,43869],"mapped",[43831]],[[43870,43870],"mapped",[619]],[[43871,43871],"mapped",[43858]],[[43872,43875],"valid"],[[43876,43877],"valid"],[[43878,43887],"disallowed"],[[43888,43888],"mapped",[5024]],[[43889,43889],"mapped",[5025]],[[43890,43890],"mapped",[5026]],[[43891,43891],"mapped",[5027]],[[43892,43892],"mapped",[5028]],[[43893,43893],"mapped",[5029]],[[43894,43894],"mapped",[5030]],[[43895,43895],"mapped",[5031]],[[43896,43896],"mapped",[5032]],[[43897,43897],"mapped",[5033]],[[43898,43898],"mapped",[5034]],[[43899,43899],"mapped",[5035]],[[43900,43900],"mapped",[5036]],[[43901,43901],"mapped",[5037]],[[43902,43902],"mapped",[5038]],[[43903,43903],"mapped",[5039]],[[43904,43904],"mapped",[5040]],[[43905,43905],"mapped",[5041]],[[43906,43906],"mapped",[5042]],[[43907,43907],"mapped",[5043]],[[43908,43908],"mapped",[5044]],[[43909,43909],"mapped",[5045]],[[43910,43910],"mapped",[5046]],[[43911,43911],"mapped",[5047]],[[43912,43912],"mapped",[5048]],[[43913,43913],"mapped",[5049]],[[43914,43914],"mapped",[5050]],[[43915,43915],"mapped",[5051]],[[43916,43916],"mapped",[5052]],[[43917,43917],"mapped",[5053]],[[43918,43918],"mapped",[5054]],[[43919,43919],"mapped",[5055]],[[43920,43920],"mapped",[5056]],[[43921,43921],"mapped",[5057]],[[43922,43922],"mapped",[5058]],[[43923,43923],"mapped",[5059]],[[43924,43924],"mapped",[5060]],[[43925,43925],"mapped",[5061]],[[43926,43926],"mapped",[5062]],[[43927,43927],"mapped",[5063]],[[43928,43928],"mapped",[5064]],[[43929,43929],"mapped",[5065]],[[43930,43930],"mapped",[5066]],[[43931,43931],"mapped",[5067]],[[43932,43932],"mapped",[5068]],[[43933,43933],"mapped",[5069]],[[43934,43934],"mapped",[5070]],[[43935,43935],"mapped",[5071]],[[43936,43936],"mapped",[5072]],[[43937,43937],"mapped",[5073]],[[43938,43938],"mapped",[5074]],[[43939,43939],"mapped",[5075]],[[43940,43940],"mapped",[5076]],[[43941,43941],"mapped",[5077]],[[43942,43942],"mapped",[5078]],[[43943,43943],"mapped",[5079]],[[43944,43944],"mapped",[5080]],[[43945,43945],"mapped",[5081]],[[43946,43946],"mapped",[5082]],[[43947,43947],"mapped",[5083]],[[43948,43948],"mapped",[5084]],[[43949,43949],"mapped",[5085]],[[43950,43950],"mapped",[5086]],[[43951,43951],"mapped",[5087]],[[43952,43952],"mapped",[5088]],[[43953,43953],"mapped",[5089]],[[43954,43954],"mapped",[5090]],[[43955,43955],"mapped",[5091]],[[43956,43956],"mapped",[5092]],[[43957,43957],"mapped",[5093]],[[43958,43958],"mapped",[5094]],[[43959,43959],"mapped",[5095]],[[43960,43960],"mapped",[5096]],[[43961,43961],"mapped",[5097]],[[43962,43962],"mapped",[5098]],[[43963,43963],"mapped",[5099]],[[43964,43964],"mapped",[5100]],[[43965,43965],"mapped",[5101]],[[43966,43966],"mapped",[5102]],[[43967,43967],"mapped",[5103]],[[43968,44010],"valid"],[[44011,44011],"valid",[],"NV8"],[[44012,44013],"valid"],[[44014,44015],"disallowed"],[[44016,44025],"valid"],[[44026,44031],"disallowed"],[[44032,55203],"valid"],[[55204,55215],"disallowed"],[[55216,55238],"valid",[],"NV8"],[[55239,55242],"disallowed"],[[55243,55291],"valid",[],"NV8"],[[55292,55295],"disallowed"],[[55296,57343],"disallowed"],[[57344,63743],"disallowed"],[[63744,63744],"mapped",[35912]],[[63745,63745],"mapped",[26356]],[[63746,63746],"mapped",[36554]],[[63747,63747],"mapped",[36040]],[[63748,63748],"mapped",[28369]],[[63749,63749],"mapped",[20018]],[[63750,63750],"mapped",[21477]],[[63751,63752],"mapped",[40860]],[[63753,63753],"mapped",[22865]],[[63754,63754],"mapped",[37329]],[[63755,63755],"mapped",[21895]],[[63756,63756],"mapped",[22856]],[[63757,63757],"mapped",[25078]],[[63758,63758],"mapped",[30313]],[[63759,63759],"mapped",[32645]],[[63760,63760],"mapped",[34367]],[[63761,63761],"mapped",[34746]],[[63762,63762],"mapped",[35064]],[[63763,63763],"mapped",[37007]],[[63764,63764],"mapped",[27138]],[[63765,63765],"mapped",[27931]],[[63766,63766],"mapped",[28889]],[[63767,63767],"mapped",[29662]],[[63768,63768],"mapped",[33853]],[[63769,63769],"mapped",[37226]],[[63770,63770],"mapped",[39409]],[[63771,63771],"mapped",[20098]],[[63772,63772],"mapped",[21365]],[[63773,63773],"mapped",[27396]],[[63774,63774],"mapped",[29211]],[[63775,63775],"mapped",[34349]],[[63776,63776],"mapped",[40478]],[[63777,63777],"mapped",[23888]],[[63778,63778],"mapped",[28651]],[[63779,63779],"mapped",[34253]],[[63780,63780],"mapped",[35172]],[[63781,63781],"mapped",[25289]],[[63782,63782],"mapped",[33240]],[[63783,63783],"mapped",[34847]],[[63784,63784],"mapped",[24266]],[[63785,63785],"mapped",[26391]],[[63786,63786],"mapped",[28010]],[[63787,63787],"mapped",[29436]],[[63788,63788],"mapped",[37070]],[[63789,63789],"mapped",[20358]],[[63790,63790],"mapped",[20919]],[[63791,63791],"mapped",[21214]],[[63792,63792],"mapped",[25796]],[[63793,63793],"mapped",[27347]],[[63794,63794],"mapped",[29200]],[[63795,63795],"mapped",[30439]],[[63796,63796],"mapped",[32769]],[[63797,63797],"mapped",[34310]],[[63798,63798],"mapped",[34396]],[[63799,63799],"mapped",[36335]],[[63800,63800],"mapped",[38706]],[[63801,63801],"mapped",[39791]],[[63802,63802],"mapped",[40442]],[[63803,63803],"mapped",[30860]],[[63804,63804],"mapped",[31103]],[[63805,63805],"mapped",[32160]],[[63806,63806],"mapped",[33737]],[[63807,63807],"mapped",[37636]],[[63808,63808],"mapped",[40575]],[[63809,63809],"mapped",[35542]],[[63810,63810],"mapped",[22751]],[[63811,63811],"mapped",[24324]],[[63812,63812],"mapped",[31840]],[[63813,63813],"mapped",[32894]],[[63814,63814],"mapped",[29282]],[[63815,63815],"mapped",[30922]],[[63816,63816],"mapped",[36034]],[[63817,63817],"mapped",[38647]],[[63818,63818],"mapped",[22744]],[[63819,63819],"mapped",[23650]],[[63820,63820],"mapped",[27155]],[[63821,63821],"mapped",[28122]],[[63822,63822],"mapped",[28431]],[[63823,63823],"mapped",[32047]],[[63824,63824],"mapped",[32311]],[[63825,63825],"mapped",[38475]],[[63826,63826],"mapped",[21202]],[[63827,63827],"mapped",[32907]],[[63828,63828],"mapped",[20956]],[[63829,63829],"mapped",[20940]],[[63830,63830],"mapped",[31260]],[[63831,63831],"mapped",[32190]],[[63832,63832],"mapped",[33777]],[[63833,63833],"mapped",[38517]],[[63834,63834],"mapped",[35712]],[[63835,63835],"mapped",[25295]],[[63836,63836],"mapped",[27138]],[[63837,63837],"mapped",[35582]],[[63838,63838],"mapped",[20025]],[[63839,63839],"mapped",[23527]],[[63840,63840],"mapped",[24594]],[[63841,63841],"mapped",[29575]],[[63842,63842],"mapped",[30064]],[[63843,63843],"mapped",[21271]],[[63844,63844],"mapped",[30971]],[[63845,63845],"mapped",[20415]],[[63846,63846],"mapped",[24489]],[[63847,63847],"mapped",[19981]],[[63848,63848],"mapped",[27852]],[[63849,63849],"mapped",[25976]],[[63850,63850],"mapped",[32034]],[[63851,63851],"mapped",[21443]],[[63852,63852],"mapped",[22622]],[[63853,63853],"mapped",[30465]],[[63854,63854],"mapped",[33865]],[[63855,63855],"mapped",[35498]],[[63856,63856],"mapped",[27578]],[[63857,63857],"mapped",[36784]],[[63858,63858],"mapped",[27784]],[[63859,63859],"mapped",[25342]],[[63860,63860],"mapped",[33509]],[[63861,63861],"mapped",[25504]],[[63862,63862],"mapped",[30053]],[[63863,63863],"mapped",[20142]],[[63864,63864],"mapped",[20841]],[[63865,63865],"mapped",[20937]],[[63866,63866],"mapped",[26753]],[[63867,63867],"mapped",[31975]],[[63868,63868],"mapped",[33391]],[[63869,63869],"mapped",[35538]],[[63870,63870],"mapped",[37327]],[[63871,63871],"mapped",[21237]],[[63872,63872],"mapped",[21570]],[[63873,63873],"mapped",[22899]],[[63874,63874],"mapped",[24300]],[[63875,63875],"mapped",[26053]],[[63876,63876],"mapped",[28670]],[[63877,63877],"mapped",[31018]],[[63878,63878],"mapped",[38317]],[[63879,63879],"mapped",[39530]],[[63880,63880],"mapped",[40599]],[[63881,63881],"mapped",[40654]],[[63882,63882],"mapped",[21147]],[[63883,63883],"mapped",[26310]],[[63884,63884],"mapped",[27511]],[[63885,63885],"mapped",[36706]],[[63886,63886],"mapped",[24180]],[[63887,63887],"mapped",[24976]],[[63888,63888],"mapped",[25088]],[[63889,63889],"mapped",[25754]],[[63890,63890],"mapped",[28451]],[[63891,63891],"mapped",[29001]],[[63892,63892],"mapped",[29833]],[[63893,63893],"mapped",[31178]],[[63894,63894],"mapped",[32244]],[[63895,63895],"mapped",[32879]],[[63896,63896],"mapped",[36646]],[[63897,63897],"mapped",[34030]],[[63898,63898],"mapped",[36899]],[[63899,63899],"mapped",[37706]],[[63900,63900],"mapped",[21015]],[[63901,63901],"mapped",[21155]],[[63902,63902],"mapped",[21693]],[[63903,63903],"mapped",[28872]],[[63904,63904],"mapped",[35010]],[[63905,63905],"mapped",[35498]],[[63906,63906],"mapped",[24265]],[[63907,63907],"mapped",[24565]],[[63908,63908],"mapped",[25467]],[[63909,63909],"mapped",[27566]],[[63910,63910],"mapped",[31806]],[[63911,63911],"mapped",[29557]],[[63912,63912],"mapped",[20196]],[[63913,63913],"mapped",[22265]],[[63914,63914],"mapped",[23527]],[[63915,63915],"mapped",[23994]],[[63916,63916],"mapped",[24604]],[[63917,63917],"mapped",[29618]],[[63918,63918],"mapped",[29801]],[[63919,63919],"mapped",[32666]],[[63920,63920],"mapped",[32838]],[[63921,63921],"mapped",[37428]],[[63922,63922],"mapped",[38646]],[[63923,63923],"mapped",[38728]],[[63924,63924],"mapped",[38936]],[[63925,63925],"mapped",[20363]],[[63926,63926],"mapped",[31150]],[[63927,63927],"mapped",[37300]],[[63928,63928],"mapped",[38584]],[[63929,63929],"mapped",[24801]],[[63930,63930],"mapped",[20102]],[[63931,63931],"mapped",[20698]],[[63932,63932],"mapped",[23534]],[[63933,63933],"mapped",[23615]],[[63934,63934],"mapped",[26009]],[[63935,63935],"mapped",[27138]],[[63936,63936],"mapped",[29134]],[[63937,63937],"mapped",[30274]],[[63938,63938],"mapped",[34044]],[[63939,63939],"mapped",[36988]],[[63940,63940],"mapped",[40845]],[[63941,63941],"mapped",[26248]],[[63942,63942],"mapped",[38446]],[[63943,63943],"mapped",[21129]],[[63944,63944],"mapped",[26491]],[[63945,63945],"mapped",[26611]],[[63946,63946],"mapped",[27969]],[[63947,63947],"mapped",[28316]],[[63948,63948],"mapped",[29705]],[[63949,63949],"mapped",[30041]],[[63950,63950],"mapped",[30827]],[[63951,63951],"mapped",[32016]],[[63952,63952],"mapped",[39006]],[[63953,63953],"mapped",[20845]],[[63954,63954],"mapped",[25134]],[[63955,63955],"mapped",[38520]],[[63956,63956],"mapped",[20523]],[[63957,63957],"mapped",[23833]],[[63958,63958],"mapped",[28138]],[[63959,63959],"mapped",[36650]],[[63960,63960],"mapped",[24459]],[[63961,63961],"mapped",[24900]],[[63962,63962],"mapped",[26647]],[[63963,63963],"mapped",[29575]],[[63964,63964],"mapped",[38534]],[[63965,63965],"mapped",[21033]],[[63966,63966],"mapped",[21519]],[[63967,63967],"mapped",[23653]],[[63968,63968],"mapped",[26131]],[[63969,63969],"mapped",[26446]],[[63970,63970],"mapped",[26792]],[[63971,63971],"mapped",[27877]],[[63972,63972],"mapped",[29702]],[[63973,63973],"mapped",[30178]],[[63974,63974],"mapped",[32633]],[[63975,63975],"mapped",[35023]],[[63976,63976],"mapped",[35041]],[[63977,63977],"mapped",[37324]],[[63978,63978],"mapped",[38626]],[[63979,63979],"mapped",[21311]],[[63980,63980],"mapped",[28346]],[[63981,63981],"mapped",[21533]],[[63982,63982],"mapped",[29136]],[[63983,63983],"mapped",[29848]],[[63984,63984],"mapped",[34298]],[[63985,63985],"mapped",[38563]],[[63986,63986],"mapped",[40023]],[[63987,63987],"mapped",[40607]],[[63988,63988],"mapped",[26519]],[[63989,63989],"mapped",[28107]],[[63990,63990],"mapped",[33256]],[[63991,63991],"mapped",[31435]],[[63992,63992],"mapped",[31520]],[[63993,63993],"mapped",[31890]],[[63994,63994],"mapped",[29376]],[[63995,63995],"mapped",[28825]],[[63996,63996],"mapped",[35672]],[[63997,63997],"mapped",[20160]],[[63998,63998],"mapped",[33590]],[[63999,63999],"mapped",[21050]],[[64000,64000],"mapped",[20999]],[[64001,64001],"mapped",[24230]],[[64002,64002],"mapped",[25299]],[[64003,64003],"mapped",[31958]],[[64004,64004],"mapped",[23429]],[[64005,64005],"mapped",[27934]],[[64006,64006],"mapped",[26292]],[[64007,64007],"mapped",[36667]],[[64008,64008],"mapped",[34892]],[[64009,64009],"mapped",[38477]],[[64010,64010],"mapped",[35211]],[[64011,64011],"mapped",[24275]],[[64012,64012],"mapped",[20800]],[[64013,64013],"mapped",[21952]],[[64014,64015],"valid"],[[64016,64016],"mapped",[22618]],[[64017,64017],"valid"],[[64018,64018],"mapped",[26228]],[[64019,64020],"valid"],[[64021,64021],"mapped",[20958]],[[64022,64022],"mapped",[29482]],[[64023,64023],"mapped",[30410]],[[64024,64024],"mapped",[31036]],[[64025,64025],"mapped",[31070]],[[64026,64026],"mapped",[31077]],[[64027,64027],"mapped",[31119]],[[64028,64028],"mapped",[38742]],[[64029,64029],"mapped",[31934]],[[64030,64030],"mapped",[32701]],[[64031,64031],"valid"],[[64032,64032],"mapped",[34322]],[[64033,64033],"valid"],[[64034,64034],"mapped",[35576]],[[64035,64036],"valid"],[[64037,64037],"mapped",[36920]],[[64038,64038],"mapped",[37117]],[[64039,64041],"valid"],[[64042,64042],"mapped",[39151]],[[64043,64043],"mapped",[39164]],[[64044,64044],"mapped",[39208]],[[64045,64045],"mapped",[40372]],[[64046,64046],"mapped",[37086]],[[64047,64047],"mapped",[38583]],[[64048,64048],"mapped",[20398]],[[64049,64049],"mapped",[20711]],[[64050,64050],"mapped",[20813]],[[64051,64051],"mapped",[21193]],[[64052,64052],"mapped",[21220]],[[64053,64053],"mapped",[21329]],[[64054,64054],"mapped",[21917]],[[64055,64055],"mapped",[22022]],[[64056,64056],"mapped",[22120]],[[64057,64057],"mapped",[22592]],[[64058,64058],"mapped",[22696]],[[64059,64059],"mapped",[23652]],[[64060,64060],"mapped",[23662]],[[64061,64061],"mapped",[24724]],[[64062,64062],"mapped",[24936]],[[64063,64063],"mapped",[24974]],[[64064,64064],"mapped",[25074]],[[64065,64065],"mapped",[25935]],[[64066,64066],"mapped",[26082]],[[64067,64067],"mapped",[26257]],[[64068,64068],"mapped",[26757]],[[64069,64069],"mapped",[28023]],[[64070,64070],"mapped",[28186]],[[64071,64071],"mapped",[28450]],[[64072,64072],"mapped",[29038]],[[64073,64073],"mapped",[29227]],[[64074,64074],"mapped",[29730]],[[64075,64075],"mapped",[30865]],[[64076,64076],"mapped",[31038]],[[64077,64077],"mapped",[31049]],[[64078,64078],"mapped",[31048]],[[64079,64079],"mapped",[31056]],[[64080,64080],"mapped",[31062]],[[64081,64081],"mapped",[31069]],[[64082,64082],"mapped",[31117]],[[64083,64083],"mapped",[31118]],[[64084,64084],"mapped",[31296]],[[64085,64085],"mapped",[31361]],[[64086,64086],"mapped",[31680]],[[64087,64087],"mapped",[32244]],[[64088,64088],"mapped",[32265]],[[64089,64089],"mapped",[32321]],[[64090,64090],"mapped",[32626]],[[64091,64091],"mapped",[32773]],[[64092,64092],"mapped",[33261]],[[64093,64094],"mapped",[33401]],[[64095,64095],"mapped",[33879]],[[64096,64096],"mapped",[35088]],[[64097,64097],"mapped",[35222]],[[64098,64098],"mapped",[35585]],[[64099,64099],"mapped",[35641]],[[64100,64100],"mapped",[36051]],[[64101,64101],"mapped",[36104]],[[64102,64102],"mapped",[36790]],[[64103,64103],"mapped",[36920]],[[64104,64104],"mapped",[38627]],[[64105,64105],"mapped",[38911]],[[64106,64106],"mapped",[38971]],[[64107,64107],"mapped",[24693]],[[64108,64108],"mapped",[148206]],[[64109,64109],"mapped",[33304]],[[64110,64111],"disallowed"],[[64112,64112],"mapped",[20006]],[[64113,64113],"mapped",[20917]],[[64114,64114],"mapped",[20840]],[[64115,64115],"mapped",[20352]],[[64116,64116],"mapped",[20805]],[[64117,64117],"mapped",[20864]],[[64118,64118],"mapped",[21191]],[[64119,64119],"mapped",[21242]],[[64120,64120],"mapped",[21917]],[[64121,64121],"mapped",[21845]],[[64122,64122],"mapped",[21913]],[[64123,64123],"mapped",[21986]],[[64124,64124],"mapped",[22618]],[[64125,64125],"mapped",[22707]],[[64126,64126],"mapped",[22852]],[[64127,64127],"mapped",[22868]],[[64128,64128],"mapped",[23138]],[[64129,64129],"mapped",[23336]],[[64130,64130],"mapped",[24274]],[[64131,64131],"mapped",[24281]],[[64132,64132],"mapped",[24425]],[[64133,64133],"mapped",[24493]],[[64134,64134],"mapped",[24792]],[[64135,64135],"mapped",[24910]],[[64136,64136],"mapped",[24840]],[[64137,64137],"mapped",[24974]],[[64138,64138],"mapped",[24928]],[[64139,64139],"mapped",[25074]],[[64140,64140],"mapped",[25140]],[[64141,64141],"mapped",[25540]],[[64142,64142],"mapped",[25628]],[[64143,64143],"mapped",[25682]],[[64144,64144],"mapped",[25942]],[[64145,64145],"mapped",[26228]],[[64146,64146],"mapped",[26391]],[[64147,64147],"mapped",[26395]],[[64148,64148],"mapped",[26454]],[[64149,64149],"mapped",[27513]],[[64150,64150],"mapped",[27578]],[[64151,64151],"mapped",[27969]],[[64152,64152],"mapped",[28379]],[[64153,64153],"mapped",[28363]],[[64154,64154],"mapped",[28450]],[[64155,64155],"mapped",[28702]],[[64156,64156],"mapped",[29038]],[[64157,64157],"mapped",[30631]],[[64158,64158],"mapped",[29237]],[[64159,64159],"mapped",[29359]],[[64160,64160],"mapped",[29482]],[[64161,64161],"mapped",[29809]],[[64162,64162],"mapped",[29958]],[[64163,64163],"mapped",[30011]],[[64164,64164],"mapped",[30237]],[[64165,64165],"mapped",[30239]],[[64166,64166],"mapped",[30410]],[[64167,64167],"mapped",[30427]],[[64168,64168],"mapped",[30452]],[[64169,64169],"mapped",[30538]],[[64170,64170],"mapped",[30528]],[[64171,64171],"mapped",[30924]],[[64172,64172],"mapped",[31409]],[[64173,64173],"mapped",[31680]],[[64174,64174],"mapped",[31867]],[[64175,64175],"mapped",[32091]],[[64176,64176],"mapped",[32244]],[[64177,64177],"mapped",[32574]],[[64178,64178],"mapped",[32773]],[[64179,64179],"mapped",[33618]],[[64180,64180],"mapped",[33775]],[[64181,64181],"mapped",[34681]],[[64182,64182],"mapped",[35137]],[[64183,64183],"mapped",[35206]],[[64184,64184],"mapped",[35222]],[[64185,64185],"mapped",[35519]],[[64186,64186],"mapped",[35576]],[[64187,64187],"mapped",[35531]],[[64188,64188],"mapped",[35585]],[[64189,64189],"mapped",[35582]],[[64190,64190],"mapped",[35565]],[[64191,64191],"mapped",[35641]],[[64192,64192],"mapped",[35722]],[[64193,64193],"mapped",[36104]],[[64194,64194],"mapped",[36664]],[[64195,64195],"mapped",[36978]],[[64196,64196],"mapped",[37273]],[[64197,64197],"mapped",[37494]],[[64198,64198],"mapped",[38524]],[[64199,64199],"mapped",[38627]],[[64200,64200],"mapped",[38742]],[[64201,64201],"mapped",[38875]],[[64202,64202],"mapped",[38911]],[[64203,64203],"mapped",[38923]],[[64204,64204],"mapped",[38971]],[[64205,64205],"mapped",[39698]],[[64206,64206],"mapped",[40860]],[[64207,64207],"mapped",[141386]],[[64208,64208],"mapped",[141380]],[[64209,64209],"mapped",[144341]],[[64210,64210],"mapped",[15261]],[[64211,64211],"mapped",[16408]],[[64212,64212],"mapped",[16441]],[[64213,64213],"mapped",[152137]],[[64214,64214],"mapped",[154832]],[[64215,64215],"mapped",[163539]],[[64216,64216],"mapped",[40771]],[[64217,64217],"mapped",[40846]],[[64218,64255],"disallowed"],[[64256,64256],"mapped",[102,102]],[[64257,64257],"mapped",[102,105]],[[64258,64258],"mapped",[102,108]],[[64259,64259],"mapped",[102,102,105]],[[64260,64260],"mapped",[102,102,108]],[[64261,64262],"mapped",[115,116]],[[64263,64274],"disallowed"],[[64275,64275],"mapped",[1396,1398]],[[64276,64276],"mapped",[1396,1381]],[[64277,64277],"mapped",[1396,1387]],[[64278,64278],"mapped",[1406,1398]],[[64279,64279],"mapped",[1396,1389]],[[64280,64284],"disallowed"],[[64285,64285],"mapped",[1497,1460]],[[64286,64286],"valid"],[[64287,64287],"mapped",[1522,1463]],[[64288,64288],"mapped",[1506]],[[64289,64289],"mapped",[1488]],[[64290,64290],"mapped",[1491]],[[64291,64291],"mapped",[1492]],[[64292,64292],"mapped",[1499]],[[64293,64293],"mapped",[1500]],[[64294,64294],"mapped",[1501]],[[64295,64295],"mapped",[1512]],[[64296,64296],"mapped",[1514]],[[64297,64297],"disallowed_STD3_mapped",[43]],[[64298,64298],"mapped",[1513,1473]],[[64299,64299],"mapped",[1513,1474]],[[64300,64300],"mapped",[1513,1468,1473]],[[64301,64301],"mapped",[1513,1468,1474]],[[64302,64302],"mapped",[1488,1463]],[[64303,64303],"mapped",[1488,1464]],[[64304,64304],"mapped",[1488,1468]],[[64305,64305],"mapped",[1489,1468]],[[64306,64306],"mapped",[1490,1468]],[[64307,64307],"mapped",[1491,1468]],[[64308,64308],"mapped",[1492,1468]],[[64309,64309],"mapped",[1493,1468]],[[64310,64310],"mapped",[1494,1468]],[[64311,64311],"disallowed"],[[64312,64312],"mapped",[1496,1468]],[[64313,64313],"mapped",[1497,1468]],[[64314,64314],"mapped",[1498,1468]],[[64315,64315],"mapped",[1499,1468]],[[64316,64316],"mapped",[1500,1468]],[[64317,64317],"disallowed"],[[64318,64318],"mapped",[1502,1468]],[[64319,64319],"disallowed"],[[64320,64320],"mapped",[1504,1468]],[[64321,64321],"mapped",[1505,1468]],[[64322,64322],"disallowed"],[[64323,64323],"mapped",[1507,1468]],[[64324,64324],"mapped",[1508,1468]],[[64325,64325],"disallowed"],[[64326,64326],"mapped",[1510,1468]],[[64327,64327],"mapped",[1511,1468]],[[64328,64328],"mapped",[1512,1468]],[[64329,64329],"mapped",[1513,1468]],[[64330,64330],"mapped",[1514,1468]],[[64331,64331],"mapped",[1493,1465]],[[64332,64332],"mapped",[1489,1471]],[[64333,64333],"mapped",[1499,1471]],[[64334,64334],"mapped",[1508,1471]],[[64335,64335],"mapped",[1488,1500]],[[64336,64337],"mapped",[1649]],[[64338,64341],"mapped",[1659]],[[64342,64345],"mapped",[1662]],[[64346,64349],"mapped",[1664]],[[64350,64353],"mapped",[1658]],[[64354,64357],"mapped",[1663]],[[64358,64361],"mapped",[1657]],[[64362,64365],"mapped",[1700]],[[64366,64369],"mapped",[1702]],[[64370,64373],"mapped",[1668]],[[64374,64377],"mapped",[1667]],[[64378,64381],"mapped",[1670]],[[64382,64385],"mapped",[1671]],[[64386,64387],"mapped",[1677]],[[64388,64389],"mapped",[1676]],[[64390,64391],"mapped",[1678]],[[64392,64393],"mapped",[1672]],[[64394,64395],"mapped",[1688]],[[64396,64397],"mapped",[1681]],[[64398,64401],"mapped",[1705]],[[64402,64405],"mapped",[1711]],[[64406,64409],"mapped",[1715]],[[64410,64413],"mapped",[1713]],[[64414,64415],"mapped",[1722]],[[64416,64419],"mapped",[1723]],[[64420,64421],"mapped",[1728]],[[64422,64425],"mapped",[1729]],[[64426,64429],"mapped",[1726]],[[64430,64431],"mapped",[1746]],[[64432,64433],"mapped",[1747]],[[64434,64449],"valid",[],"NV8"],[[64450,64466],"disallowed"],[[64467,64470],"mapped",[1709]],[[64471,64472],"mapped",[1735]],[[64473,64474],"mapped",[1734]],[[64475,64476],"mapped",[1736]],[[64477,64477],"mapped",[1735,1652]],[[64478,64479],"mapped",[1739]],[[64480,64481],"mapped",[1733]],[[64482,64483],"mapped",[1737]],[[64484,64487],"mapped",[1744]],[[64488,64489],"mapped",[1609]],[[64490,64491],"mapped",[1574,1575]],[[64492,64493],"mapped",[1574,1749]],[[64494,64495],"mapped",[1574,1608]],[[64496,64497],"mapped",[1574,1735]],[[64498,64499],"mapped",[1574,1734]],[[64500,64501],"mapped",[1574,1736]],[[64502,64504],"mapped",[1574,1744]],[[64505,64507],"mapped",[1574,1609]],[[64508,64511],"mapped",[1740]],[[64512,64512],"mapped",[1574,1580]],[[64513,64513],"mapped",[1574,1581]],[[64514,64514],"mapped",[1574,1605]],[[64515,64515],"mapped",[1574,1609]],[[64516,64516],"mapped",[1574,1610]],[[64517,64517],"mapped",[1576,1580]],[[64518,64518],"mapped",[1576,1581]],[[64519,64519],"mapped",[1576,1582]],[[64520,64520],"mapped",[1576,1605]],[[64521,64521],"mapped",[1576,1609]],[[64522,64522],"mapped",[1576,1610]],[[64523,64523],"mapped",[1578,1580]],[[64524,64524],"mapped",[1578,1581]],[[64525,64525],"mapped",[1578,1582]],[[64526,64526],"mapped",[1578,1605]],[[64527,64527],"mapped",[1578,1609]],[[64528,64528],"mapped",[1578,1610]],[[64529,64529],"mapped",[1579,1580]],[[64530,64530],"mapped",[1579,1605]],[[64531,64531],"mapped",[1579,1609]],[[64532,64532],"mapped",[1579,1610]],[[64533,64533],"mapped",[1580,1581]],[[64534,64534],"mapped",[1580,1605]],[[64535,64535],"mapped",[1581,1580]],[[64536,64536],"mapped",[1581,1605]],[[64537,64537],"mapped",[1582,1580]],[[64538,64538],"mapped",[1582,1581]],[[64539,64539],"mapped",[1582,1605]],[[64540,64540],"mapped",[1587,1580]],[[64541,64541],"mapped",[1587,1581]],[[64542,64542],"mapped",[1587,1582]],[[64543,64543],"mapped",[1587,1605]],[[64544,64544],"mapped",[1589,1581]],[[64545,64545],"mapped",[1589,1605]],[[64546,64546],"mapped",[1590,1580]],[[64547,64547],"mapped",[1590,1581]],[[64548,64548],"mapped",[1590,1582]],[[64549,64549],"mapped",[1590,1605]],[[64550,64550],"mapped",[1591,1581]],[[64551,64551],"mapped",[1591,1605]],[[64552,64552],"mapped",[1592,1605]],[[64553,64553],"mapped",[1593,1580]],[[64554,64554],"mapped",[1593,1605]],[[64555,64555],"mapped",[1594,1580]],[[64556,64556],"mapped",[1594,1605]],[[64557,64557],"mapped",[1601,1580]],[[64558,64558],"mapped",[1601,1581]],[[64559,64559],"mapped",[1601,1582]],[[64560,64560],"mapped",[1601,1605]],[[64561,64561],"mapped",[1601,1609]],[[64562,64562],"mapped",[1601,1610]],[[64563,64563],"mapped",[1602,1581]],[[64564,64564],"mapped",[1602,1605]],[[64565,64565],"mapped",[1602,1609]],[[64566,64566],"mapped",[1602,1610]],[[64567,64567],"mapped",[1603,1575]],[[64568,64568],"mapped",[1603,1580]],[[64569,64569],"mapped",[1603,1581]],[[64570,64570],"mapped",[1603,1582]],[[64571,64571],"mapped",[1603,1604]],[[64572,64572],"mapped",[1603,1605]],[[64573,64573],"mapped",[1603,1609]],[[64574,64574],"mapped",[1603,1610]],[[64575,64575],"mapped",[1604,1580]],[[64576,64576],"mapped",[1604,1581]],[[64577,64577],"mapped",[1604,1582]],[[64578,64578],"mapped",[1604,1605]],[[64579,64579],"mapped",[1604,1609]],[[64580,64580],"mapped",[1604,1610]],[[64581,64581],"mapped",[1605,1580]],[[64582,64582],"mapped",[1605,1581]],[[64583,64583],"mapped",[1605,1582]],[[64584,64584],"mapped",[1605,1605]],[[64585,64585],"mapped",[1605,1609]],[[64586,64586],"mapped",[1605,1610]],[[64587,64587],"mapped",[1606,1580]],[[64588,64588],"mapped",[1606,1581]],[[64589,64589],"mapped",[1606,1582]],[[64590,64590],"mapped",[1606,1605]],[[64591,64591],"mapped",[1606,1609]],[[64592,64592],"mapped",[1606,1610]],[[64593,64593],"mapped",[1607,1580]],[[64594,64594],"mapped",[1607,1605]],[[64595,64595],"mapped",[1607,1609]],[[64596,64596],"mapped",[1607,1610]],[[64597,64597],"mapped",[1610,1580]],[[64598,64598],"mapped",[1610,1581]],[[64599,64599],"mapped",[1610,1582]],[[64600,64600],"mapped",[1610,1605]],[[64601,64601],"mapped",[1610,1609]],[[64602,64602],"mapped",[1610,1610]],[[64603,64603],"mapped",[1584,1648]],[[64604,64604],"mapped",[1585,1648]],[[64605,64605],"mapped",[1609,1648]],[[64606,64606],"disallowed_STD3_mapped",[32,1612,1617]],[[64607,64607],"disallowed_STD3_mapped",[32,1613,1617]],[[64608,64608],"disallowed_STD3_mapped",[32,1614,1617]],[[64609,64609],"disallowed_STD3_mapped",[32,1615,1617]],[[64610,64610],"disallowed_STD3_mapped",[32,1616,1617]],[[64611,64611],"disallowed_STD3_mapped",[32,1617,1648]],[[64612,64612],"mapped",[1574,1585]],[[64613,64613],"mapped",[1574,1586]],[[64614,64614],"mapped",[1574,1605]],[[64615,64615],"mapped",[1574,1606]],[[64616,64616],"mapped",[1574,1609]],[[64617,64617],"mapped",[1574,1610]],[[64618,64618],"mapped",[1576,1585]],[[64619,64619],"mapped",[1576,1586]],[[64620,64620],"mapped",[1576,1605]],[[64621,64621],"mapped",[1576,1606]],[[64622,64622],"mapped",[1576,1609]],[[64623,64623],"mapped",[1576,1610]],[[64624,64624],"mapped",[1578,1585]],[[64625,64625],"mapped",[1578,1586]],[[64626,64626],"mapped",[1578,1605]],[[64627,64627],"mapped",[1578,1606]],[[64628,64628],"mapped",[1578,1609]],[[64629,64629],"mapped",[1578,1610]],[[64630,64630],"mapped",[1579,1585]],[[64631,64631],"mapped",[1579,1586]],[[64632,64632],"mapped",[1579,1605]],[[64633,64633],"mapped",[1579,1606]],[[64634,64634],"mapped",[1579,1609]],[[64635,64635],"mapped",[1579,1610]],[[64636,64636],"mapped",[1601,1609]],[[64637,64637],"mapped",[1601,1610]],[[64638,64638],"mapped",[1602,1609]],[[64639,64639],"mapped",[1602,1610]],[[64640,64640],"mapped",[1603,1575]],[[64641,64641],"mapped",[1603,1604]],[[64642,64642],"mapped",[1603,1605]],[[64643,64643],"mapped",[1603,1609]],[[64644,64644],"mapped",[1603,1610]],[[64645,64645],"mapped",[1604,1605]],[[64646,64646],"mapped",[1604,1609]],[[64647,64647],"mapped",[1604,1610]],[[64648,64648],"mapped",[1605,1575]],[[64649,64649],"mapped",[1605,1605]],[[64650,64650],"mapped",[1606,1585]],[[64651,64651],"mapped",[1606,1586]],[[64652,64652],"mapped",[1606,1605]],[[64653,64653],"mapped",[1606,1606]],[[64654,64654],"mapped",[1606,1609]],[[64655,64655],"mapped",[1606,1610]],[[64656,64656],"mapped",[1609,1648]],[[64657,64657],"mapped",[1610,1585]],[[64658,64658],"mapped",[1610,1586]],[[64659,64659],"mapped",[1610,1605]],[[64660,64660],"mapped",[1610,1606]],[[64661,64661],"mapped",[1610,1609]],[[64662,64662],"mapped",[1610,1610]],[[64663,64663],"mapped",[1574,1580]],[[64664,64664],"mapped",[1574,1581]],[[64665,64665],"mapped",[1574,1582]],[[64666,64666],"mapped",[1574,1605]],[[64667,64667],"mapped",[1574,1607]],[[64668,64668],"mapped",[1576,1580]],[[64669,64669],"mapped",[1576,1581]],[[64670,64670],"mapped",[1576,1582]],[[64671,64671],"mapped",[1576,1605]],[[64672,64672],"mapped",[1576,1607]],[[64673,64673],"mapped",[1578,1580]],[[64674,64674],"mapped",[1578,1581]],[[64675,64675],"mapped",[1578,1582]],[[64676,64676],"mapped",[1578,1605]],[[64677,64677],"mapped",[1578,1607]],[[64678,64678],"mapped",[1579,1605]],[[64679,64679],"mapped",[1580,1581]],[[64680,64680],"mapped",[1580,1605]],[[64681,64681],"mapped",[1581,1580]],[[64682,64682],"mapped",[1581,1605]],[[64683,64683],"mapped",[1582,1580]],[[64684,64684],"mapped",[1582,1605]],[[64685,64685],"mapped",[1587,1580]],[[64686,64686],"mapped",[1587,1581]],[[64687,64687],"mapped",[1587,1582]],[[64688,64688],"mapped",[1587,1605]],[[64689,64689],"mapped",[1589,1581]],[[64690,64690],"mapped",[1589,1582]],[[64691,64691],"mapped",[1589,1605]],[[64692,64692],"mapped",[1590,1580]],[[64693,64693],"mapped",[1590,1581]],[[64694,64694],"mapped",[1590,1582]],[[64695,64695],"mapped",[1590,1605]],[[64696,64696],"mapped",[1591,1581]],[[64697,64697],"mapped",[1592,1605]],[[64698,64698],"mapped",[1593,1580]],[[64699,64699],"mapped",[1593,1605]],[[64700,64700],"mapped",[1594,1580]],[[64701,64701],"mapped",[1594,1605]],[[64702,64702],"mapped",[1601,1580]],[[64703,64703],"mapped",[1601,1581]],[[64704,64704],"mapped",[1601,1582]],[[64705,64705],"mapped",[1601,1605]],[[64706,64706],"mapped",[1602,1581]],[[64707,64707],"mapped",[1602,1605]],[[64708,64708],"mapped",[1603,1580]],[[64709,64709],"mapped",[1603,1581]],[[64710,64710],"mapped",[1603,1582]],[[64711,64711],"mapped",[1603,1604]],[[64712,64712],"mapped",[1603,1605]],[[64713,64713],"mapped",[1604,1580]],[[64714,64714],"mapped",[1604,1581]],[[64715,64715],"mapped",[1604,1582]],[[64716,64716],"mapped",[1604,1605]],[[64717,64717],"mapped",[1604,1607]],[[64718,64718],"mapped",[1605,1580]],[[64719,64719],"mapped",[1605,1581]],[[64720,64720],"mapped",[1605,1582]],[[64721,64721],"mapped",[1605,1605]],[[64722,64722],"mapped",[1606,1580]],[[64723,64723],"mapped",[1606,1581]],[[64724,64724],"mapped",[1606,1582]],[[64725,64725],"mapped",[1606,1605]],[[64726,64726],"mapped",[1606,1607]],[[64727,64727],"mapped",[1607,1580]],[[64728,64728],"mapped",[1607,1605]],[[64729,64729],"mapped",[1607,1648]],[[64730,64730],"mapped",[1610,1580]],[[64731,64731],"mapped",[1610,1581]],[[64732,64732],"mapped",[1610,1582]],[[64733,64733],"mapped",[1610,1605]],[[64734,64734],"mapped",[1610,1607]],[[64735,64735],"mapped",[1574,1605]],[[64736,64736],"mapped",[1574,1607]],[[64737,64737],"mapped",[1576,1605]],[[64738,64738],"mapped",[1576,1607]],[[64739,64739],"mapped",[1578,1605]],[[64740,64740],"mapped",[1578,1607]],[[64741,64741],"mapped",[1579,1605]],[[64742,64742],"mapped",[1579,1607]],[[64743,64743],"mapped",[1587,1605]],[[64744,64744],"mapped",[1587,1607]],[[64745,64745],"mapped",[1588,1605]],[[64746,64746],"mapped",[1588,1607]],[[64747,64747],"mapped",[1603,1604]],[[64748,64748],"mapped",[1603,1605]],[[64749,64749],"mapped",[1604,1605]],[[64750,64750],"mapped",[1606,1605]],[[64751,64751],"mapped",[1606,1607]],[[64752,64752],"mapped",[1610,1605]],[[64753,64753],"mapped",[1610,1607]],[[64754,64754],"mapped",[1600,1614,1617]],[[64755,64755],"mapped",[1600,1615,1617]],[[64756,64756],"mapped",[1600,1616,1617]],[[64757,64757],"mapped",[1591,1609]],[[64758,64758],"mapped",[1591,1610]],[[64759,64759],"mapped",[1593,1609]],[[64760,64760],"mapped",[1593,1610]],[[64761,64761],"mapped",[1594,1609]],[[64762,64762],"mapped",[1594,1610]],[[64763,64763],"mapped",[1587,1609]],[[64764,64764],"mapped",[1587,1610]],[[64765,64765],"mapped",[1588,1609]],[[64766,64766],"mapped",[1588,1610]],[[64767,64767],"mapped",[1581,1609]],[[64768,64768],"mapped",[1581,1610]],[[64769,64769],"mapped",[1580,1609]],[[64770,64770],"mapped",[1580,1610]],[[64771,64771],"mapped",[1582,1609]],[[64772,64772],"mapped",[1582,1610]],[[64773,64773],"mapped",[1589,1609]],[[64774,64774],"mapped",[1589,1610]],[[64775,64775],"mapped",[1590,1609]],[[64776,64776],"mapped",[1590,1610]],[[64777,64777],"mapped",[1588,1580]],[[64778,64778],"mapped",[1588,1581]],[[64779,64779],"mapped",[1588,1582]],[[64780,64780],"mapped",[1588,1605]],[[64781,64781],"mapped",[1588,1585]],[[64782,64782],"mapped",[1587,1585]],[[64783,64783],"mapped",[1589,1585]],[[64784,64784],"mapped",[1590,1585]],[[64785,64785],"mapped",[1591,1609]],[[64786,64786],"mapped",[1591,1610]],[[64787,64787],"mapped",[1593,1609]],[[64788,64788],"mapped",[1593,1610]],[[64789,64789],"mapped",[1594,1609]],[[64790,64790],"mapped",[1594,1610]],[[64791,64791],"mapped",[1587,1609]],[[64792,64792],"mapped",[1587,1610]],[[64793,64793],"mapped",[1588,1609]],[[64794,64794],"mapped",[1588,1610]],[[64795,64795],"mapped",[1581,1609]],[[64796,64796],"mapped",[1581,1610]],[[64797,64797],"mapped",[1580,1609]],[[64798,64798],"mapped",[1580,1610]],[[64799,64799],"mapped",[1582,1609]],[[64800,64800],"mapped",[1582,1610]],[[64801,64801],"mapped",[1589,1609]],[[64802,64802],"mapped",[1589,1610]],[[64803,64803],"mapped",[1590,1609]],[[64804,64804],"mapped",[1590,1610]],[[64805,64805],"mapped",[1588,1580]],[[64806,64806],"mapped",[1588,1581]],[[64807,64807],"mapped",[1588,1582]],[[64808,64808],"mapped",[1588,1605]],[[64809,64809],"mapped",[1588,1585]],[[64810,64810],"mapped",[1587,1585]],[[64811,64811],"mapped",[1589,1585]],[[64812,64812],"mapped",[1590,1585]],[[64813,64813],"mapped",[1588,1580]],[[64814,64814],"mapped",[1588,1581]],[[64815,64815],"mapped",[1588,1582]],[[64816,64816],"mapped",[1588,1605]],[[64817,64817],"mapped",[1587,1607]],[[64818,64818],"mapped",[1588,1607]],[[64819,64819],"mapped",[1591,1605]],[[64820,64820],"mapped",[1587,1580]],[[64821,64821],"mapped",[1587,1581]],[[64822,64822],"mapped",[1587,1582]],[[64823,64823],"mapped",[1588,1580]],[[64824,64824],"mapped",[1588,1581]],[[64825,64825],"mapped",[1588,1582]],[[64826,64826],"mapped",[1591,1605]],[[64827,64827],"mapped",[1592,1605]],[[64828,64829],"mapped",[1575,1611]],[[64830,64831],"valid",[],"NV8"],[[64832,64847],"disallowed"],[[64848,64848],"mapped",[1578,1580,1605]],[[64849,64850],"mapped",[1578,1581,1580]],[[64851,64851],"mapped",[1578,1581,1605]],[[64852,64852],"mapped",[1578,1582,1605]],[[64853,64853],"mapped",[1578,1605,1580]],[[64854,64854],"mapped",[1578,1605,1581]],[[64855,64855],"mapped",[1578,1605,1582]],[[64856,64857],"mapped",[1580,1605,1581]],[[64858,64858],"mapped",[1581,1605,1610]],[[64859,64859],"mapped",[1581,1605,1609]],[[64860,64860],"mapped",[1587,1581,1580]],[[64861,64861],"mapped",[1587,1580,1581]],[[64862,64862],"mapped",[1587,1580,1609]],[[64863,64864],"mapped",[1587,1605,1581]],[[64865,64865],"mapped",[1587,1605,1580]],[[64866,64867],"mapped",[1587,1605,1605]],[[64868,64869],"mapped",[1589,1581,1581]],[[64870,64870],"mapped",[1589,1605,1605]],[[64871,64872],"mapped",[1588,1581,1605]],[[64873,64873],"mapped",[1588,1580,1610]],[[64874,64875],"mapped",[1588,1605,1582]],[[64876,64877],"mapped",[1588,1605,1605]],[[64878,64878],"mapped",[1590,1581,1609]],[[64879,64880],"mapped",[1590,1582,1605]],[[64881,64882],"mapped",[1591,1605,1581]],[[64883,64883],"mapped",[1591,1605,1605]],[[64884,64884],"mapped",[1591,1605,1610]],[[64885,64885],"mapped",[1593,1580,1605]],[[64886,64887],"mapped",[1593,1605,1605]],[[64888,64888],"mapped",[1593,1605,1609]],[[64889,64889],"mapped",[1594,1605,1605]],[[64890,64890],"mapped",[1594,1605,1610]],[[64891,64891],"mapped",[1594,1605,1609]],[[64892,64893],"mapped",[1601,1582,1605]],[[64894,64894],"mapped",[1602,1605,1581]],[[64895,64895],"mapped",[1602,1605,1605]],[[64896,64896],"mapped",[1604,1581,1605]],[[64897,64897],"mapped",[1604,1581,1610]],[[64898,64898],"mapped",[1604,1581,1609]],[[64899,64900],"mapped",[1604,1580,1580]],[[64901,64902],"mapped",[1604,1582,1605]],[[64903,64904],"mapped",[1604,1605,1581]],[[64905,64905],"mapped",[1605,1581,1580]],[[64906,64906],"mapped",[1605,1581,1605]],[[64907,64907],"mapped",[1605,1581,1610]],[[64908,64908],"mapped",[1605,1580,1581]],[[64909,64909],"mapped",[1605,1580,1605]],[[64910,64910],"mapped",[1605,1582,1580]],[[64911,64911],"mapped",[1605,1582,1605]],[[64912,64913],"disallowed"],[[64914,64914],"mapped",[1605,1580,1582]],[[64915,64915],"mapped",[1607,1605,1580]],[[64916,64916],"mapped",[1607,1605,1605]],[[64917,64917],"mapped",[1606,1581,1605]],[[64918,64918],"mapped",[1606,1581,1609]],[[64919,64920],"mapped",[1606,1580,1605]],[[64921,64921],"mapped",[1606,1580,1609]],[[64922,64922],"mapped",[1606,1605,1610]],[[64923,64923],"mapped",[1606,1605,1609]],[[64924,64925],"mapped",[1610,1605,1605]],[[64926,64926],"mapped",[1576,1582,1610]],[[64927,64927],"mapped",[1578,1580,1610]],[[64928,64928],"mapped",[1578,1580,1609]],[[64929,64929],"mapped",[1578,1582,1610]],[[64930,64930],"mapped",[1578,1582,1609]],[[64931,64931],"mapped",[1578,1605,1610]],[[64932,64932],"mapped",[1578,1605,1609]],[[64933,64933],"mapped",[1580,1605,1610]],[[64934,64934],"mapped",[1580,1581,1609]],[[64935,64935],"mapped",[1580,1605,1609]],[[64936,64936],"mapped",[1587,1582,1609]],[[64937,64937],"mapped",[1589,1581,1610]],[[64938,64938],"mapped",[1588,1581,1610]],[[64939,64939],"mapped",[1590,1581,1610]],[[64940,64940],"mapped",[1604,1580,1610]],[[64941,64941],"mapped",[1604,1605,1610]],[[64942,64942],"mapped",[1610,1581,1610]],[[64943,64943],"mapped",[1610,1580,1610]],[[64944,64944],"mapped",[1610,1605,1610]],[[64945,64945],"mapped",[1605,1605,1610]],[[64946,64946],"mapped",[1602,1605,1610]],[[64947,64947],"mapped",[1606,1581,1610]],[[64948,64948],"mapped",[1602,1605,1581]],[[64949,64949],"mapped",[1604,1581,1605]],[[64950,64950],"mapped",[1593,1605,1610]],[[64951,64951],"mapped",[1603,1605,1610]],[[64952,64952],"mapped",[1606,1580,1581]],[[64953,64953],"mapped",[1605,1582,1610]],[[64954,64954],"mapped",[1604,1580,1605]],[[64955,64955],"mapped",[1603,1605,1605]],[[64956,64956],"mapped",[1604,1580,1605]],[[64957,64957],"mapped",[1606,1580,1581]],[[64958,64958],"mapped",[1580,1581,1610]],[[64959,64959],"mapped",[1581,1580,1610]],[[64960,64960],"mapped",[1605,1580,1610]],[[64961,64961],"mapped",[1601,1605,1610]],[[64962,64962],"mapped",[1576,1581,1610]],[[64963,64963],"mapped",[1603,1605,1605]],[[64964,64964],"mapped",[1593,1580,1605]],[[64965,64965],"mapped",[1589,1605,1605]],[[64966,64966],"mapped",[1587,1582,1610]],[[64967,64967],"mapped",[1606,1580,1610]],[[64968,64975],"disallowed"],[[64976,65007],"disallowed"],[[65008,65008],"mapped",[1589,1604,1746]],[[65009,65009],"mapped",[1602,1604,1746]],[[65010,65010],"mapped",[1575,1604,1604,1607]],[[65011,65011],"mapped",[1575,1603,1576,1585]],[[65012,65012],"mapped",[1605,1581,1605,1583]],[[65013,65013],"mapped",[1589,1604,1593,1605]],[[65014,65014],"mapped",[1585,1587,1608,1604]],[[65015,65015],"mapped",[1593,1604,1610,1607]],[[65016,65016],"mapped",[1608,1587,1604,1605]],[[65017,65017],"mapped",[1589,1604,1609]],[[65018,65018],"disallowed_STD3_mapped",[1589,1604,1609,32,1575,1604,1604,1607,32,1593,1604,1610,1607,32,1608,1587,1604,1605]],[[65019,65019],"disallowed_STD3_mapped",[1580,1604,32,1580,1604,1575,1604,1607]],[[65020,65020],"mapped",[1585,1740,1575,1604]],[[65021,65021],"valid",[],"NV8"],[[65022,65023],"disallowed"],[[65024,65039],"ignored"],[[65040,65040],"disallowed_STD3_mapped",[44]],[[65041,65041],"mapped",[12289]],[[65042,65042],"disallowed"],[[65043,65043],"disallowed_STD3_mapped",[58]],[[65044,65044],"disallowed_STD3_mapped",[59]],[[65045,65045],"disallowed_STD3_mapped",[33]],[[65046,65046],"disallowed_STD3_mapped",[63]],[[65047,65047],"mapped",[12310]],[[65048,65048],"mapped",[12311]],[[65049,65049],"disallowed"],[[65050,65055],"disallowed"],[[65056,65059],"valid"],[[65060,65062],"valid"],[[65063,65069],"valid"],[[65070,65071],"valid"],[[65072,65072],"disallowed"],[[65073,65073],"mapped",[8212]],[[65074,65074],"mapped",[8211]],[[65075,65076],"disallowed_STD3_mapped",[95]],[[65077,65077],"disallowed_STD3_mapped",[40]],[[65078,65078],"disallowed_STD3_mapped",[41]],[[65079,65079],"disallowed_STD3_mapped",[123]],[[65080,65080],"disallowed_STD3_mapped",[125]],[[65081,65081],"mapped",[12308]],[[65082,65082],"mapped",[12309]],[[65083,65083],"mapped",[12304]],[[65084,65084],"mapped",[12305]],[[65085,65085],"mapped",[12298]],[[65086,65086],"mapped",[12299]],[[65087,65087],"mapped",[12296]],[[65088,65088],"mapped",[12297]],[[65089,65089],"mapped",[12300]],[[65090,65090],"mapped",[12301]],[[65091,65091],"mapped",[12302]],[[65092,65092],"mapped",[12303]],[[65093,65094],"valid",[],"NV8"],[[65095,65095],"disallowed_STD3_mapped",[91]],[[65096,65096],"disallowed_STD3_mapped",[93]],[[65097,65100],"disallowed_STD3_mapped",[32,773]],[[65101,65103],"disallowed_STD3_mapped",[95]],[[65104,65104],"disallowed_STD3_mapped",[44]],[[65105,65105],"mapped",[12289]],[[65106,65106],"disallowed"],[[65107,65107],"disallowed"],[[65108,65108],"disallowed_STD3_mapped",[59]],[[65109,65109],"disallowed_STD3_mapped",[58]],[[65110,65110],"disallowed_STD3_mapped",[63]],[[65111,65111],"disallowed_STD3_mapped",[33]],[[65112,65112],"mapped",[8212]],[[65113,65113],"disallowed_STD3_mapped",[40]],[[65114,65114],"disallowed_STD3_mapped",[41]],[[65115,65115],"disallowed_STD3_mapped",[123]],[[65116,65116],"disallowed_STD3_mapped",[125]],[[65117,65117],"mapped",[12308]],[[65118,65118],"mapped",[12309]],[[65119,65119],"disallowed_STD3_mapped",[35]],[[65120,65120],"disallowed_STD3_mapped",[38]],[[65121,65121],"disallowed_STD3_mapped",[42]],[[65122,65122],"disallowed_STD3_mapped",[43]],[[65123,65123],"mapped",[45]],[[65124,65124],"disallowed_STD3_mapped",[60]],[[65125,65125],"disallowed_STD3_mapped",[62]],[[65126,65126],"disallowed_STD3_mapped",[61]],[[65127,65127],"disallowed"],[[65128,65128],"disallowed_STD3_mapped",[92]],[[65129,65129],"disallowed_STD3_mapped",[36]],[[65130,65130],"disallowed_STD3_mapped",[37]],[[65131,65131],"disallowed_STD3_mapped",[64]],[[65132,65135],"disallowed"],[[65136,65136],"disallowed_STD3_mapped",[32,1611]],[[65137,65137],"mapped",[1600,1611]],[[65138,65138],"disallowed_STD3_mapped",[32,1612]],[[65139,65139],"valid"],[[65140,65140],"disallowed_STD3_mapped",[32,1613]],[[65141,65141],"disallowed"],[[65142,65142],"disallowed_STD3_mapped",[32,1614]],[[65143,65143],"mapped",[1600,1614]],[[65144,65144],"disallowed_STD3_mapped",[32,1615]],[[65145,65145],"mapped",[1600,1615]],[[65146,65146],"disallowed_STD3_mapped",[32,1616]],[[65147,65147],"mapped",[1600,1616]],[[65148,65148],"disallowed_STD3_mapped",[32,1617]],[[65149,65149],"mapped",[1600,1617]],[[65150,65150],"disallowed_STD3_mapped",[32,1618]],[[65151,65151],"mapped",[1600,1618]],[[65152,65152],"mapped",[1569]],[[65153,65154],"mapped",[1570]],[[65155,65156],"mapped",[1571]],[[65157,65158],"mapped",[1572]],[[65159,65160],"mapped",[1573]],[[65161,65164],"mapped",[1574]],[[65165,65166],"mapped",[1575]],[[65167,65170],"mapped",[1576]],[[65171,65172],"mapped",[1577]],[[65173,65176],"mapped",[1578]],[[65177,65180],"mapped",[1579]],[[65181,65184],"mapped",[1580]],[[65185,65188],"mapped",[1581]],[[65189,65192],"mapped",[1582]],[[65193,65194],"mapped",[1583]],[[65195,65196],"mapped",[1584]],[[65197,65198],"mapped",[1585]],[[65199,65200],"mapped",[1586]],[[65201,65204],"mapped",[1587]],[[65205,65208],"mapped",[1588]],[[65209,65212],"mapped",[1589]],[[65213,65216],"mapped",[1590]],[[65217,65220],"mapped",[1591]],[[65221,65224],"mapped",[1592]],[[65225,65228],"mapped",[1593]],[[65229,65232],"mapped",[1594]],[[65233,65236],"mapped",[1601]],[[65237,65240],"mapped",[1602]],[[65241,65244],"mapped",[1603]],[[65245,65248],"mapped",[1604]],[[65249,65252],"mapped",[1605]],[[65253,65256],"mapped",[1606]],[[65257,65260],"mapped",[1607]],[[65261,65262],"mapped",[1608]],[[65263,65264],"mapped",[1609]],[[65265,65268],"mapped",[1610]],[[65269,65270],"mapped",[1604,1570]],[[65271,65272],"mapped",[1604,1571]],[[65273,65274],"mapped",[1604,1573]],[[65275,65276],"mapped",[1604,1575]],[[65277,65278],"disallowed"],[[65279,65279],"ignored"],[[65280,65280],"disallowed"],[[65281,65281],"disallowed_STD3_mapped",[33]],[[65282,65282],"disallowed_STD3_mapped",[34]],[[65283,65283],"disallowed_STD3_mapped",[35]],[[65284,65284],"disallowed_STD3_mapped",[36]],[[65285,65285],"disallowed_STD3_mapped",[37]],[[65286,65286],"disallowed_STD3_mapped",[38]],[[65287,65287],"disallowed_STD3_mapped",[39]],[[65288,65288],"disallowed_STD3_mapped",[40]],[[65289,65289],"disallowed_STD3_mapped",[41]],[[65290,65290],"disallowed_STD3_mapped",[42]],[[65291,65291],"disallowed_STD3_mapped",[43]],[[65292,65292],"disallowed_STD3_mapped",[44]],[[65293,65293],"mapped",[45]],[[65294,65294],"mapped",[46]],[[65295,65295],"disallowed_STD3_mapped",[47]],[[65296,65296],"mapped",[48]],[[65297,65297],"mapped",[49]],[[65298,65298],"mapped",[50]],[[65299,65299],"mapped",[51]],[[65300,65300],"mapped",[52]],[[65301,65301],"mapped",[53]],[[65302,65302],"mapped",[54]],[[65303,65303],"mapped",[55]],[[65304,65304],"mapped",[56]],[[65305,65305],"mapped",[57]],[[65306,65306],"disallowed_STD3_mapped",[58]],[[65307,65307],"disallowed_STD3_mapped",[59]],[[65308,65308],"disallowed_STD3_mapped",[60]],[[65309,65309],"disallowed_STD3_mapped",[61]],[[65310,65310],"disallowed_STD3_mapped",[62]],[[65311,65311],"disallowed_STD3_mapped",[63]],[[65312,65312],"disallowed_STD3_mapped",[64]],[[65313,65313],"mapped",[97]],[[65314,65314],"mapped",[98]],[[65315,65315],"mapped",[99]],[[65316,65316],"mapped",[100]],[[65317,65317],"mapped",[101]],[[65318,65318],"mapped",[102]],[[65319,65319],"mapped",[103]],[[65320,65320],"mapped",[104]],[[65321,65321],"mapped",[105]],[[65322,65322],"mapped",[106]],[[65323,65323],"mapped",[107]],[[65324,65324],"mapped",[108]],[[65325,65325],"mapped",[109]],[[65326,65326],"mapped",[110]],[[65327,65327],"mapped",[111]],[[65328,65328],"mapped",[112]],[[65329,65329],"mapped",[113]],[[65330,65330],"mapped",[114]],[[65331,65331],"mapped",[115]],[[65332,65332],"mapped",[116]],[[65333,65333],"mapped",[117]],[[65334,65334],"mapped",[118]],[[65335,65335],"mapped",[119]],[[65336,65336],"mapped",[120]],[[65337,65337],"mapped",[121]],[[65338,65338],"mapped",[122]],[[65339,65339],"disallowed_STD3_mapped",[91]],[[65340,65340],"disallowed_STD3_mapped",[92]],[[65341,65341],"disallowed_STD3_mapped",[93]],[[65342,65342],"disallowed_STD3_mapped",[94]],[[65343,65343],"disallowed_STD3_mapped",[95]],[[65344,65344],"disallowed_STD3_mapped",[96]],[[65345,65345],"mapped",[97]],[[65346,65346],"mapped",[98]],[[65347,65347],"mapped",[99]],[[65348,65348],"mapped",[100]],[[65349,65349],"mapped",[101]],[[65350,65350],"mapped",[102]],[[65351,65351],"mapped",[103]],[[65352,65352],"mapped",[104]],[[65353,65353],"mapped",[105]],[[65354,65354],"mapped",[106]],[[65355,65355],"mapped",[107]],[[65356,65356],"mapped",[108]],[[65357,65357],"mapped",[109]],[[65358,65358],"mapped",[110]],[[65359,65359],"mapped",[111]],[[65360,65360],"mapped",[112]],[[65361,65361],"mapped",[113]],[[65362,65362],"mapped",[114]],[[65363,65363],"mapped",[115]],[[65364,65364],"mapped",[116]],[[65365,65365],"mapped",[117]],[[65366,65366],"mapped",[118]],[[65367,65367],"mapped",[119]],[[65368,65368],"mapped",[120]],[[65369,65369],"mapped",[121]],[[65370,65370],"mapped",[122]],[[65371,65371],"disallowed_STD3_mapped",[123]],[[65372,65372],"disallowed_STD3_mapped",[124]],[[65373,65373],"disallowed_STD3_mapped",[125]],[[65374,65374],"disallowed_STD3_mapped",[126]],[[65375,65375],"mapped",[10629]],[[65376,65376],"mapped",[10630]],[[65377,65377],"mapped",[46]],[[65378,65378],"mapped",[12300]],[[65379,65379],"mapped",[12301]],[[65380,65380],"mapped",[12289]],[[65381,65381],"mapped",[12539]],[[65382,65382],"mapped",[12530]],[[65383,65383],"mapped",[12449]],[[65384,65384],"mapped",[12451]],[[65385,65385],"mapped",[12453]],[[65386,65386],"mapped",[12455]],[[65387,65387],"mapped",[12457]],[[65388,65388],"mapped",[12515]],[[65389,65389],"mapped",[12517]],[[65390,65390],"mapped",[12519]],[[65391,65391],"mapped",[12483]],[[65392,65392],"mapped",[12540]],[[65393,65393],"mapped",[12450]],[[65394,65394],"mapped",[12452]],[[65395,65395],"mapped",[12454]],[[65396,65396],"mapped",[12456]],[[65397,65397],"mapped",[12458]],[[65398,65398],"mapped",[12459]],[[65399,65399],"mapped",[12461]],[[65400,65400],"mapped",[12463]],[[65401,65401],"mapped",[12465]],[[65402,65402],"mapped",[12467]],[[65403,65403],"mapped",[12469]],[[65404,65404],"mapped",[12471]],[[65405,65405],"mapped",[12473]],[[65406,65406],"mapped",[12475]],[[65407,65407],"mapped",[12477]],[[65408,65408],"mapped",[12479]],[[65409,65409],"mapped",[12481]],[[65410,65410],"mapped",[12484]],[[65411,65411],"mapped",[12486]],[[65412,65412],"mapped",[12488]],[[65413,65413],"mapped",[12490]],[[65414,65414],"mapped",[12491]],[[65415,65415],"mapped",[12492]],[[65416,65416],"mapped",[12493]],[[65417,65417],"mapped",[12494]],[[65418,65418],"mapped",[12495]],[[65419,65419],"mapped",[12498]],[[65420,65420],"mapped",[12501]],[[65421,65421],"mapped",[12504]],[[65422,65422],"mapped",[12507]],[[65423,65423],"mapped",[12510]],[[65424,65424],"mapped",[12511]],[[65425,65425],"mapped",[12512]],[[65426,65426],"mapped",[12513]],[[65427,65427],"mapped",[12514]],[[65428,65428],"mapped",[12516]],[[65429,65429],"mapped",[12518]],[[65430,65430],"mapped",[12520]],[[65431,65431],"mapped",[12521]],[[65432,65432],"mapped",[12522]],[[65433,65433],"mapped",[12523]],[[65434,65434],"mapped",[12524]],[[65435,65435],"mapped",[12525]],[[65436,65436],"mapped",[12527]],[[65437,65437],"mapped",[12531]],[[65438,65438],"mapped",[12441]],[[65439,65439],"mapped",[12442]],[[65440,65440],"disallowed"],[[65441,65441],"mapped",[4352]],[[65442,65442],"mapped",[4353]],[[65443,65443],"mapped",[4522]],[[65444,65444],"mapped",[4354]],[[65445,65445],"mapped",[4524]],[[65446,65446],"mapped",[4525]],[[65447,65447],"mapped",[4355]],[[65448,65448],"mapped",[4356]],[[65449,65449],"mapped",[4357]],[[65450,65450],"mapped",[4528]],[[65451,65451],"mapped",[4529]],[[65452,65452],"mapped",[4530]],[[65453,65453],"mapped",[4531]],[[65454,65454],"mapped",[4532]],[[65455,65455],"mapped",[4533]],[[65456,65456],"mapped",[4378]],[[65457,65457],"mapped",[4358]],[[65458,65458],"mapped",[4359]],[[65459,65459],"mapped",[4360]],[[65460,65460],"mapped",[4385]],[[65461,65461],"mapped",[4361]],[[65462,65462],"mapped",[4362]],[[65463,65463],"mapped",[4363]],[[65464,65464],"mapped",[4364]],[[65465,65465],"mapped",[4365]],[[65466,65466],"mapped",[4366]],[[65467,65467],"mapped",[4367]],[[65468,65468],"mapped",[4368]],[[65469,65469],"mapped",[4369]],[[65470,65470],"mapped",[4370]],[[65471,65473],"disallowed"],[[65474,65474],"mapped",[4449]],[[65475,65475],"mapped",[4450]],[[65476,65476],"mapped",[4451]],[[65477,65477],"mapped",[4452]],[[65478,65478],"mapped",[4453]],[[65479,65479],"mapped",[4454]],[[65480,65481],"disallowed"],[[65482,65482],"mapped",[4455]],[[65483,65483],"mapped",[4456]],[[65484,65484],"mapped",[4457]],[[65485,65485],"mapped",[4458]],[[65486,65486],"mapped",[4459]],[[65487,65487],"mapped",[4460]],[[65488,65489],"disallowed"],[[65490,65490],"mapped",[4461]],[[65491,65491],"mapped",[4462]],[[65492,65492],"mapped",[4463]],[[65493,65493],"mapped",[4464]],[[65494,65494],"mapped",[4465]],[[65495,65495],"mapped",[4466]],[[65496,65497],"disallowed"],[[65498,65498],"mapped",[4467]],[[65499,65499],"mapped",[4468]],[[65500,65500],"mapped",[4469]],[[65501,65503],"disallowed"],[[65504,65504],"mapped",[162]],[[65505,65505],"mapped",[163]],[[65506,65506],"mapped",[172]],[[65507,65507],"disallowed_STD3_mapped",[32,772]],[[65508,65508],"mapped",[166]],[[65509,65509],"mapped",[165]],[[65510,65510],"mapped",[8361]],[[65511,65511],"disallowed"],[[65512,65512],"mapped",[9474]],[[65513,65513],"mapped",[8592]],[[65514,65514],"mapped",[8593]],[[65515,65515],"mapped",[8594]],[[65516,65516],"mapped",[8595]],[[65517,65517],"mapped",[9632]],[[65518,65518],"mapped",[9675]],[[65519,65528],"disallowed"],[[65529,65531],"disallowed"],[[65532,65532],"disallowed"],[[65533,65533],"disallowed"],[[65534,65535],"disallowed"],[[65536,65547],"valid"],[[65548,65548],"disallowed"],[[65549,65574],"valid"],[[65575,65575],"disallowed"],[[65576,65594],"valid"],[[65595,65595],"disallowed"],[[65596,65597],"valid"],[[65598,65598],"disallowed"],[[65599,65613],"valid"],[[65614,65615],"disallowed"],[[65616,65629],"valid"],[[65630,65663],"disallowed"],[[65664,65786],"valid"],[[65787,65791],"disallowed"],[[65792,65794],"valid",[],"NV8"],[[65795,65798],"disallowed"],[[65799,65843],"valid",[],"NV8"],[[65844,65846],"disallowed"],[[65847,65855],"valid",[],"NV8"],[[65856,65930],"valid",[],"NV8"],[[65931,65932],"valid",[],"NV8"],[[65933,65935],"disallowed"],[[65936,65947],"valid",[],"NV8"],[[65948,65951],"disallowed"],[[65952,65952],"valid",[],"NV8"],[[65953,65999],"disallowed"],[[66000,66044],"valid",[],"NV8"],[[66045,66045],"valid"],[[66046,66175],"disallowed"],[[66176,66204],"valid"],[[66205,66207],"disallowed"],[[66208,66256],"valid"],[[66257,66271],"disallowed"],[[66272,66272],"valid"],[[66273,66299],"valid",[],"NV8"],[[66300,66303],"disallowed"],[[66304,66334],"valid"],[[66335,66335],"valid"],[[66336,66339],"valid",[],"NV8"],[[66340,66351],"disallowed"],[[66352,66368],"valid"],[[66369,66369],"valid",[],"NV8"],[[66370,66377],"valid"],[[66378,66378],"valid",[],"NV8"],[[66379,66383],"disallowed"],[[66384,66426],"valid"],[[66427,66431],"disallowed"],[[66432,66461],"valid"],[[66462,66462],"disallowed"],[[66463,66463],"valid",[],"NV8"],[[66464,66499],"valid"],[[66500,66503],"disallowed"],[[66504,66511],"valid"],[[66512,66517],"valid",[],"NV8"],[[66518,66559],"disallowed"],[[66560,66560],"mapped",[66600]],[[66561,66561],"mapped",[66601]],[[66562,66562],"mapped",[66602]],[[66563,66563],"mapped",[66603]],[[66564,66564],"mapped",[66604]],[[66565,66565],"mapped",[66605]],[[66566,66566],"mapped",[66606]],[[66567,66567],"mapped",[66607]],[[66568,66568],"mapped",[66608]],[[66569,66569],"mapped",[66609]],[[66570,66570],"mapped",[66610]],[[66571,66571],"mapped",[66611]],[[66572,66572],"mapped",[66612]],[[66573,66573],"mapped",[66613]],[[66574,66574],"mapped",[66614]],[[66575,66575],"mapped",[66615]],[[66576,66576],"mapped",[66616]],[[66577,66577],"mapped",[66617]],[[66578,66578],"mapped",[66618]],[[66579,66579],"mapped",[66619]],[[66580,66580],"mapped",[66620]],[[66581,66581],"mapped",[66621]],[[66582,66582],"mapped",[66622]],[[66583,66583],"mapped",[66623]],[[66584,66584],"mapped",[66624]],[[66585,66585],"mapped",[66625]],[[66586,66586],"mapped",[66626]],[[66587,66587],"mapped",[66627]],[[66588,66588],"mapped",[66628]],[[66589,66589],"mapped",[66629]],[[66590,66590],"mapped",[66630]],[[66591,66591],"mapped",[66631]],[[66592,66592],"mapped",[66632]],[[66593,66593],"mapped",[66633]],[[66594,66594],"mapped",[66634]],[[66595,66595],"mapped",[66635]],[[66596,66596],"mapped",[66636]],[[66597,66597],"mapped",[66637]],[[66598,66598],"mapped",[66638]],[[66599,66599],"mapped",[66639]],[[66600,66637],"valid"],[[66638,66717],"valid"],[[66718,66719],"disallowed"],[[66720,66729],"valid"],[[66730,66815],"disallowed"],[[66816,66855],"valid"],[[66856,66863],"disallowed"],[[66864,66915],"valid"],[[66916,66926],"disallowed"],[[66927,66927],"valid",[],"NV8"],[[66928,67071],"disallowed"],[[67072,67382],"valid"],[[67383,67391],"disallowed"],[[67392,67413],"valid"],[[67414,67423],"disallowed"],[[67424,67431],"valid"],[[67432,67583],"disallowed"],[[67584,67589],"valid"],[[67590,67591],"disallowed"],[[67592,67592],"valid"],[[67593,67593],"disallowed"],[[67594,67637],"valid"],[[67638,67638],"disallowed"],[[67639,67640],"valid"],[[67641,67643],"disallowed"],[[67644,67644],"valid"],[[67645,67646],"disallowed"],[[67647,67647],"valid"],[[67648,67669],"valid"],[[67670,67670],"disallowed"],[[67671,67679],"valid",[],"NV8"],[[67680,67702],"valid"],[[67703,67711],"valid",[],"NV8"],[[67712,67742],"valid"],[[67743,67750],"disallowed"],[[67751,67759],"valid",[],"NV8"],[[67760,67807],"disallowed"],[[67808,67826],"valid"],[[67827,67827],"disallowed"],[[67828,67829],"valid"],[[67830,67834],"disallowed"],[[67835,67839],"valid",[],"NV8"],[[67840,67861],"valid"],[[67862,67865],"valid",[],"NV8"],[[67866,67867],"valid",[],"NV8"],[[67868,67870],"disallowed"],[[67871,67871],"valid",[],"NV8"],[[67872,67897],"valid"],[[67898,67902],"disallowed"],[[67903,67903],"valid",[],"NV8"],[[67904,67967],"disallowed"],[[67968,68023],"valid"],[[68024,68027],"disallowed"],[[68028,68029],"valid",[],"NV8"],[[68030,68031],"valid"],[[68032,68047],"valid",[],"NV8"],[[68048,68049],"disallowed"],[[68050,68095],"valid",[],"NV8"],[[68096,68099],"valid"],[[68100,68100],"disallowed"],[[68101,68102],"valid"],[[68103,68107],"disallowed"],[[68108,68115],"valid"],[[68116,68116],"disallowed"],[[68117,68119],"valid"],[[68120,68120],"disallowed"],[[68121,68147],"valid"],[[68148,68151],"disallowed"],[[68152,68154],"valid"],[[68155,68158],"disallowed"],[[68159,68159],"valid"],[[68160,68167],"valid",[],"NV8"],[[68168,68175],"disallowed"],[[68176,68184],"valid",[],"NV8"],[[68185,68191],"disallowed"],[[68192,68220],"valid"],[[68221,68223],"valid",[],"NV8"],[[68224,68252],"valid"],[[68253,68255],"valid",[],"NV8"],[[68256,68287],"disallowed"],[[68288,68295],"valid"],[[68296,68296],"valid",[],"NV8"],[[68297,68326],"valid"],[[68327,68330],"disallowed"],[[68331,68342],"valid",[],"NV8"],[[68343,68351],"disallowed"],[[68352,68405],"valid"],[[68406,68408],"disallowed"],[[68409,68415],"valid",[],"NV8"],[[68416,68437],"valid"],[[68438,68439],"disallowed"],[[68440,68447],"valid",[],"NV8"],[[68448,68466],"valid"],[[68467,68471],"disallowed"],[[68472,68479],"valid",[],"NV8"],[[68480,68497],"valid"],[[68498,68504],"disallowed"],[[68505,68508],"valid",[],"NV8"],[[68509,68520],"disallowed"],[[68521,68527],"valid",[],"NV8"],[[68528,68607],"disallowed"],[[68608,68680],"valid"],[[68681,68735],"disallowed"],[[68736,68736],"mapped",[68800]],[[68737,68737],"mapped",[68801]],[[68738,68738],"mapped",[68802]],[[68739,68739],"mapped",[68803]],[[68740,68740],"mapped",[68804]],[[68741,68741],"mapped",[68805]],[[68742,68742],"mapped",[68806]],[[68743,68743],"mapped",[68807]],[[68744,68744],"mapped",[68808]],[[68745,68745],"mapped",[68809]],[[68746,68746],"mapped",[68810]],[[68747,68747],"mapped",[68811]],[[68748,68748],"mapped",[68812]],[[68749,68749],"mapped",[68813]],[[68750,68750],"mapped",[68814]],[[68751,68751],"mapped",[68815]],[[68752,68752],"mapped",[68816]],[[68753,68753],"mapped",[68817]],[[68754,68754],"mapped",[68818]],[[68755,68755],"mapped",[68819]],[[68756,68756],"mapped",[68820]],[[68757,68757],"mapped",[68821]],[[68758,68758],"mapped",[68822]],[[68759,68759],"mapped",[68823]],[[68760,68760],"mapped",[68824]],[[68761,68761],"mapped",[68825]],[[68762,68762],"mapped",[68826]],[[68763,68763],"mapped",[68827]],[[68764,68764],"mapped",[68828]],[[68765,68765],"mapped",[68829]],[[68766,68766],"mapped",[68830]],[[68767,68767],"mapped",[68831]],[[68768,68768],"mapped",[68832]],[[68769,68769],"mapped",[68833]],[[68770,68770],"mapped",[68834]],[[68771,68771],"mapped",[68835]],[[68772,68772],"mapped",[68836]],[[68773,68773],"mapped",[68837]],[[68774,68774],"mapped",[68838]],[[68775,68775],"mapped",[68839]],[[68776,68776],"mapped",[68840]],[[68777,68777],"mapped",[68841]],[[68778,68778],"mapped",[68842]],[[68779,68779],"mapped",[68843]],[[68780,68780],"mapped",[68844]],[[68781,68781],"mapped",[68845]],[[68782,68782],"mapped",[68846]],[[68783,68783],"mapped",[68847]],[[68784,68784],"mapped",[68848]],[[68785,68785],"mapped",[68849]],[[68786,68786],"mapped",[68850]],[[68787,68799],"disallowed"],[[68800,68850],"valid"],[[68851,68857],"disallowed"],[[68858,68863],"valid",[],"NV8"],[[68864,69215],"disallowed"],[[69216,69246],"valid",[],"NV8"],[[69247,69631],"disallowed"],[[69632,69702],"valid"],[[69703,69709],"valid",[],"NV8"],[[69710,69713],"disallowed"],[[69714,69733],"valid",[],"NV8"],[[69734,69743],"valid"],[[69744,69758],"disallowed"],[[69759,69759],"valid"],[[69760,69818],"valid"],[[69819,69820],"valid",[],"NV8"],[[69821,69821],"disallowed"],[[69822,69825],"valid",[],"NV8"],[[69826,69839],"disallowed"],[[69840,69864],"valid"],[[69865,69871],"disallowed"],[[69872,69881],"valid"],[[69882,69887],"disallowed"],[[69888,69940],"valid"],[[69941,69941],"disallowed"],[[69942,69951],"valid"],[[69952,69955],"valid",[],"NV8"],[[69956,69967],"disallowed"],[[69968,70003],"valid"],[[70004,70005],"valid",[],"NV8"],[[70006,70006],"valid"],[[70007,70015],"disallowed"],[[70016,70084],"valid"],[[70085,70088],"valid",[],"NV8"],[[70089,70089],"valid",[],"NV8"],[[70090,70092],"valid"],[[70093,70093],"valid",[],"NV8"],[[70094,70095],"disallowed"],[[70096,70105],"valid"],[[70106,70106],"valid"],[[70107,70107],"valid",[],"NV8"],[[70108,70108],"valid"],[[70109,70111],"valid",[],"NV8"],[[70112,70112],"disallowed"],[[70113,70132],"valid",[],"NV8"],[[70133,70143],"disallowed"],[[70144,70161],"valid"],[[70162,70162],"disallowed"],[[70163,70199],"valid"],[[70200,70205],"valid",[],"NV8"],[[70206,70271],"disallowed"],[[70272,70278],"valid"],[[70279,70279],"disallowed"],[[70280,70280],"valid"],[[70281,70281],"disallowed"],[[70282,70285],"valid"],[[70286,70286],"disallowed"],[[70287,70301],"valid"],[[70302,70302],"disallowed"],[[70303,70312],"valid"],[[70313,70313],"valid",[],"NV8"],[[70314,70319],"disallowed"],[[70320,70378],"valid"],[[70379,70383],"disallowed"],[[70384,70393],"valid"],[[70394,70399],"disallowed"],[[70400,70400],"valid"],[[70401,70403],"valid"],[[70404,70404],"disallowed"],[[70405,70412],"valid"],[[70413,70414],"disallowed"],[[70415,70416],"valid"],[[70417,70418],"disallowed"],[[70419,70440],"valid"],[[70441,70441],"disallowed"],[[70442,70448],"valid"],[[70449,70449],"disallowed"],[[70450,70451],"valid"],[[70452,70452],"disallowed"],[[70453,70457],"valid"],[[70458,70459],"disallowed"],[[70460,70468],"valid"],[[70469,70470],"disallowed"],[[70471,70472],"valid"],[[70473,70474],"disallowed"],[[70475,70477],"valid"],[[70478,70479],"disallowed"],[[70480,70480],"valid"],[[70481,70486],"disallowed"],[[70487,70487],"valid"],[[70488,70492],"disallowed"],[[70493,70499],"valid"],[[70500,70501],"disallowed"],[[70502,70508],"valid"],[[70509,70511],"disallowed"],[[70512,70516],"valid"],[[70517,70783],"disallowed"],[[70784,70853],"valid"],[[70854,70854],"valid",[],"NV8"],[[70855,70855],"valid"],[[70856,70863],"disallowed"],[[70864,70873],"valid"],[[70874,71039],"disallowed"],[[71040,71093],"valid"],[[71094,71095],"disallowed"],[[71096,71104],"valid"],[[71105,71113],"valid",[],"NV8"],[[71114,71127],"valid",[],"NV8"],[[71128,71133],"valid"],[[71134,71167],"disallowed"],[[71168,71232],"valid"],[[71233,71235],"valid",[],"NV8"],[[71236,71236],"valid"],[[71237,71247],"disallowed"],[[71248,71257],"valid"],[[71258,71295],"disallowed"],[[71296,71351],"valid"],[[71352,71359],"disallowed"],[[71360,71369],"valid"],[[71370,71423],"disallowed"],[[71424,71449],"valid"],[[71450,71452],"disallowed"],[[71453,71467],"valid"],[[71468,71471],"disallowed"],[[71472,71481],"valid"],[[71482,71487],"valid",[],"NV8"],[[71488,71839],"disallowed"],[[71840,71840],"mapped",[71872]],[[71841,71841],"mapped",[71873]],[[71842,71842],"mapped",[71874]],[[71843,71843],"mapped",[71875]],[[71844,71844],"mapped",[71876]],[[71845,71845],"mapped",[71877]],[[71846,71846],"mapped",[71878]],[[71847,71847],"mapped",[71879]],[[71848,71848],"mapped",[71880]],[[71849,71849],"mapped",[71881]],[[71850,71850],"mapped",[71882]],[[71851,71851],"mapped",[71883]],[[71852,71852],"mapped",[71884]],[[71853,71853],"mapped",[71885]],[[71854,71854],"mapped",[71886]],[[71855,71855],"mapped",[71887]],[[71856,71856],"mapped",[71888]],[[71857,71857],"mapped",[71889]],[[71858,71858],"mapped",[71890]],[[71859,71859],"mapped",[71891]],[[71860,71860],"mapped",[71892]],[[71861,71861],"mapped",[71893]],[[71862,71862],"mapped",[71894]],[[71863,71863],"mapped",[71895]],[[71864,71864],"mapped",[71896]],[[71865,71865],"mapped",[71897]],[[71866,71866],"mapped",[71898]],[[71867,71867],"mapped",[71899]],[[71868,71868],"mapped",[71900]],[[71869,71869],"mapped",[71901]],[[71870,71870],"mapped",[71902]],[[71871,71871],"mapped",[71903]],[[71872,71913],"valid"],[[71914,71922],"valid",[],"NV8"],[[71923,71934],"disallowed"],[[71935,71935],"valid"],[[71936,72383],"disallowed"],[[72384,72440],"valid"],[[72441,73727],"disallowed"],[[73728,74606],"valid"],[[74607,74648],"valid"],[[74649,74649],"valid"],[[74650,74751],"disallowed"],[[74752,74850],"valid",[],"NV8"],[[74851,74862],"valid",[],"NV8"],[[74863,74863],"disallowed"],[[74864,74867],"valid",[],"NV8"],[[74868,74868],"valid",[],"NV8"],[[74869,74879],"disallowed"],[[74880,75075],"valid"],[[75076,77823],"disallowed"],[[77824,78894],"valid"],[[78895,82943],"disallowed"],[[82944,83526],"valid"],[[83527,92159],"disallowed"],[[92160,92728],"valid"],[[92729,92735],"disallowed"],[[92736,92766],"valid"],[[92767,92767],"disallowed"],[[92768,92777],"valid"],[[92778,92781],"disallowed"],[[92782,92783],"valid",[],"NV8"],[[92784,92879],"disallowed"],[[92880,92909],"valid"],[[92910,92911],"disallowed"],[[92912,92916],"valid"],[[92917,92917],"valid",[],"NV8"],[[92918,92927],"disallowed"],[[92928,92982],"valid"],[[92983,92991],"valid",[],"NV8"],[[92992,92995],"valid"],[[92996,92997],"valid",[],"NV8"],[[92998,93007],"disallowed"],[[93008,93017],"valid"],[[93018,93018],"disallowed"],[[93019,93025],"valid",[],"NV8"],[[93026,93026],"disallowed"],[[93027,93047],"valid"],[[93048,93052],"disallowed"],[[93053,93071],"valid"],[[93072,93951],"disallowed"],[[93952,94020],"valid"],[[94021,94031],"disallowed"],[[94032,94078],"valid"],[[94079,94094],"disallowed"],[[94095,94111],"valid"],[[94112,110591],"disallowed"],[[110592,110593],"valid"],[[110594,113663],"disallowed"],[[113664,113770],"valid"],[[113771,113775],"disallowed"],[[113776,113788],"valid"],[[113789,113791],"disallowed"],[[113792,113800],"valid"],[[113801,113807],"disallowed"],[[113808,113817],"valid"],[[113818,113819],"disallowed"],[[113820,113820],"valid",[],"NV8"],[[113821,113822],"valid"],[[113823,113823],"valid",[],"NV8"],[[113824,113827],"ignored"],[[113828,118783],"disallowed"],[[118784,119029],"valid",[],"NV8"],[[119030,119039],"disallowed"],[[119040,119078],"valid",[],"NV8"],[[119079,119080],"disallowed"],[[119081,119081],"valid",[],"NV8"],[[119082,119133],"valid",[],"NV8"],[[119134,119134],"mapped",[119127,119141]],[[119135,119135],"mapped",[119128,119141]],[[119136,119136],"mapped",[119128,119141,119150]],[[119137,119137],"mapped",[119128,119141,119151]],[[119138,119138],"mapped",[119128,119141,119152]],[[119139,119139],"mapped",[119128,119141,119153]],[[119140,119140],"mapped",[119128,119141,119154]],[[119141,119154],"valid",[],"NV8"],[[119155,119162],"disallowed"],[[119163,119226],"valid",[],"NV8"],[[119227,119227],"mapped",[119225,119141]],[[119228,119228],"mapped",[119226,119141]],[[119229,119229],"mapped",[119225,119141,119150]],[[119230,119230],"mapped",[119226,119141,119150]],[[119231,119231],"mapped",[119225,119141,119151]],[[119232,119232],"mapped",[119226,119141,119151]],[[119233,119261],"valid",[],"NV8"],[[119262,119272],"valid",[],"NV8"],[[119273,119295],"disallowed"],[[119296,119365],"valid",[],"NV8"],[[119366,119551],"disallowed"],[[119552,119638],"valid",[],"NV8"],[[119639,119647],"disallowed"],[[119648,119665],"valid",[],"NV8"],[[119666,119807],"disallowed"],[[119808,119808],"mapped",[97]],[[119809,119809],"mapped",[98]],[[119810,119810],"mapped",[99]],[[119811,119811],"mapped",[100]],[[119812,119812],"mapped",[101]],[[119813,119813],"mapped",[102]],[[119814,119814],"mapped",[103]],[[119815,119815],"mapped",[104]],[[119816,119816],"mapped",[105]],[[119817,119817],"mapped",[106]],[[119818,119818],"mapped",[107]],[[119819,119819],"mapped",[108]],[[119820,119820],"mapped",[109]],[[119821,119821],"mapped",[110]],[[119822,119822],"mapped",[111]],[[119823,119823],"mapped",[112]],[[119824,119824],"mapped",[113]],[[119825,119825],"mapped",[114]],[[119826,119826],"mapped",[115]],[[119827,119827],"mapped",[116]],[[119828,119828],"mapped",[117]],[[119829,119829],"mapped",[118]],[[119830,119830],"mapped",[119]],[[119831,119831],"mapped",[120]],[[119832,119832],"mapped",[121]],[[119833,119833],"mapped",[122]],[[119834,119834],"mapped",[97]],[[119835,119835],"mapped",[98]],[[119836,119836],"mapped",[99]],[[119837,119837],"mapped",[100]],[[119838,119838],"mapped",[101]],[[119839,119839],"mapped",[102]],[[119840,119840],"mapped",[103]],[[119841,119841],"mapped",[104]],[[119842,119842],"mapped",[105]],[[119843,119843],"mapped",[106]],[[119844,119844],"mapped",[107]],[[119845,119845],"mapped",[108]],[[119846,119846],"mapped",[109]],[[119847,119847],"mapped",[110]],[[119848,119848],"mapped",[111]],[[119849,119849],"mapped",[112]],[[119850,119850],"mapped",[113]],[[119851,119851],"mapped",[114]],[[119852,119852],"mapped",[115]],[[119853,119853],"mapped",[116]],[[119854,119854],"mapped",[117]],[[119855,119855],"mapped",[118]],[[119856,119856],"mapped",[119]],[[119857,119857],"mapped",[120]],[[119858,119858],"mapped",[121]],[[119859,119859],"mapped",[122]],[[119860,119860],"mapped",[97]],[[119861,119861],"mapped",[98]],[[119862,119862],"mapped",[99]],[[119863,119863],"mapped",[100]],[[119864,119864],"mapped",[101]],[[119865,119865],"mapped",[102]],[[119866,119866],"mapped",[103]],[[119867,119867],"mapped",[104]],[[119868,119868],"mapped",[105]],[[119869,119869],"mapped",[106]],[[119870,119870],"mapped",[107]],[[119871,119871],"mapped",[108]],[[119872,119872],"mapped",[109]],[[119873,119873],"mapped",[110]],[[119874,119874],"mapped",[111]],[[119875,119875],"mapped",[112]],[[119876,119876],"mapped",[113]],[[119877,119877],"mapped",[114]],[[119878,119878],"mapped",[115]],[[119879,119879],"mapped",[116]],[[119880,119880],"mapped",[117]],[[119881,119881],"mapped",[118]],[[119882,119882],"mapped",[119]],[[119883,119883],"mapped",[120]],[[119884,119884],"mapped",[121]],[[119885,119885],"mapped",[122]],[[119886,119886],"mapped",[97]],[[119887,119887],"mapped",[98]],[[119888,119888],"mapped",[99]],[[119889,119889],"mapped",[100]],[[119890,119890],"mapped",[101]],[[119891,119891],"mapped",[102]],[[119892,119892],"mapped",[103]],[[119893,119893],"disallowed"],[[119894,119894],"mapped",[105]],[[119895,119895],"mapped",[106]],[[119896,119896],"mapped",[107]],[[119897,119897],"mapped",[108]],[[119898,119898],"mapped",[109]],[[119899,119899],"mapped",[110]],[[119900,119900],"mapped",[111]],[[119901,119901],"mapped",[112]],[[119902,119902],"mapped",[113]],[[119903,119903],"mapped",[114]],[[119904,119904],"mapped",[115]],[[119905,119905],"mapped",[116]],[[119906,119906],"mapped",[117]],[[119907,119907],"mapped",[118]],[[119908,119908],"mapped",[119]],[[119909,119909],"mapped",[120]],[[119910,119910],"mapped",[121]],[[119911,119911],"mapped",[122]],[[119912,119912],"mapped",[97]],[[119913,119913],"mapped",[98]],[[119914,119914],"mapped",[99]],[[119915,119915],"mapped",[100]],[[119916,119916],"mapped",[101]],[[119917,119917],"mapped",[102]],[[119918,119918],"mapped",[103]],[[119919,119919],"mapped",[104]],[[119920,119920],"mapped",[105]],[[119921,119921],"mapped",[106]],[[119922,119922],"mapped",[107]],[[119923,119923],"mapped",[108]],[[119924,119924],"mapped",[109]],[[119925,119925],"mapped",[110]],[[119926,119926],"mapped",[111]],[[119927,119927],"mapped",[112]],[[119928,119928],"mapped",[113]],[[119929,119929],"mapped",[114]],[[119930,119930],"mapped",[115]],[[119931,119931],"mapped",[116]],[[119932,119932],"mapped",[117]],[[119933,119933],"mapped",[118]],[[119934,119934],"mapped",[119]],[[119935,119935],"mapped",[120]],[[119936,119936],"mapped",[121]],[[119937,119937],"mapped",[122]],[[119938,119938],"mapped",[97]],[[119939,119939],"mapped",[98]],[[119940,119940],"mapped",[99]],[[119941,119941],"mapped",[100]],[[119942,119942],"mapped",[101]],[[119943,119943],"mapped",[102]],[[119944,119944],"mapped",[103]],[[119945,119945],"mapped",[104]],[[119946,119946],"mapped",[105]],[[119947,119947],"mapped",[106]],[[119948,119948],"mapped",[107]],[[119949,119949],"mapped",[108]],[[119950,119950],"mapped",[109]],[[119951,119951],"mapped",[110]],[[119952,119952],"mapped",[111]],[[119953,119953],"mapped",[112]],[[119954,119954],"mapped",[113]],[[119955,119955],"mapped",[114]],[[119956,119956],"mapped",[115]],[[119957,119957],"mapped",[116]],[[119958,119958],"mapped",[117]],[[119959,119959],"mapped",[118]],[[119960,119960],"mapped",[119]],[[119961,119961],"mapped",[120]],[[119962,119962],"mapped",[121]],[[119963,119963],"mapped",[122]],[[119964,119964],"mapped",[97]],[[119965,119965],"disallowed"],[[119966,119966],"mapped",[99]],[[119967,119967],"mapped",[100]],[[119968,119969],"disallowed"],[[119970,119970],"mapped",[103]],[[119971,119972],"disallowed"],[[119973,119973],"mapped",[106]],[[119974,119974],"mapped",[107]],[[119975,119976],"disallowed"],[[119977,119977],"mapped",[110]],[[119978,119978],"mapped",[111]],[[119979,119979],"mapped",[112]],[[119980,119980],"mapped",[113]],[[119981,119981],"disallowed"],[[119982,119982],"mapped",[115]],[[119983,119983],"mapped",[116]],[[119984,119984],"mapped",[117]],[[119985,119985],"mapped",[118]],[[119986,119986],"mapped",[119]],[[119987,119987],"mapped",[120]],[[119988,119988],"mapped",[121]],[[119989,119989],"mapped",[122]],[[119990,119990],"mapped",[97]],[[119991,119991],"mapped",[98]],[[119992,119992],"mapped",[99]],[[119993,119993],"mapped",[100]],[[119994,119994],"disallowed"],[[119995,119995],"mapped",[102]],[[119996,119996],"disallowed"],[[119997,119997],"mapped",[104]],[[119998,119998],"mapped",[105]],[[119999,119999],"mapped",[106]],[[120000,120000],"mapped",[107]],[[120001,120001],"mapped",[108]],[[120002,120002],"mapped",[109]],[[120003,120003],"mapped",[110]],[[120004,120004],"disallowed"],[[120005,120005],"mapped",[112]],[[120006,120006],"mapped",[113]],[[120007,120007],"mapped",[114]],[[120008,120008],"mapped",[115]],[[120009,120009],"mapped",[116]],[[120010,120010],"mapped",[117]],[[120011,120011],"mapped",[118]],[[120012,120012],"mapped",[119]],[[120013,120013],"mapped",[120]],[[120014,120014],"mapped",[121]],[[120015,120015],"mapped",[122]],[[120016,120016],"mapped",[97]],[[120017,120017],"mapped",[98]],[[120018,120018],"mapped",[99]],[[120019,120019],"mapped",[100]],[[120020,120020],"mapped",[101]],[[120021,120021],"mapped",[102]],[[120022,120022],"mapped",[103]],[[120023,120023],"mapped",[104]],[[120024,120024],"mapped",[105]],[[120025,120025],"mapped",[106]],[[120026,120026],"mapped",[107]],[[120027,120027],"mapped",[108]],[[120028,120028],"mapped",[109]],[[120029,120029],"mapped",[110]],[[120030,120030],"mapped",[111]],[[120031,120031],"mapped",[112]],[[120032,120032],"mapped",[113]],[[120033,120033],"mapped",[114]],[[120034,120034],"mapped",[115]],[[120035,120035],"mapped",[116]],[[120036,120036],"mapped",[117]],[[120037,120037],"mapped",[118]],[[120038,120038],"mapped",[119]],[[120039,120039],"mapped",[120]],[[120040,120040],"mapped",[121]],[[120041,120041],"mapped",[122]],[[120042,120042],"mapped",[97]],[[120043,120043],"mapped",[98]],[[120044,120044],"mapped",[99]],[[120045,120045],"mapped",[100]],[[120046,120046],"mapped",[101]],[[120047,120047],"mapped",[102]],[[120048,120048],"mapped",[103]],[[120049,120049],"mapped",[104]],[[120050,120050],"mapped",[105]],[[120051,120051],"mapped",[106]],[[120052,120052],"mapped",[107]],[[120053,120053],"mapped",[108]],[[120054,120054],"mapped",[109]],[[120055,120055],"mapped",[110]],[[120056,120056],"mapped",[111]],[[120057,120057],"mapped",[112]],[[120058,120058],"mapped",[113]],[[120059,120059],"mapped",[114]],[[120060,120060],"mapped",[115]],[[120061,120061],"mapped",[116]],[[120062,120062],"mapped",[117]],[[120063,120063],"mapped",[118]],[[120064,120064],"mapped",[119]],[[120065,120065],"mapped",[120]],[[120066,120066],"mapped",[121]],[[120067,120067],"mapped",[122]],[[120068,120068],"mapped",[97]],[[120069,120069],"mapped",[98]],[[120070,120070],"disallowed"],[[120071,120071],"mapped",[100]],[[120072,120072],"mapped",[101]],[[120073,120073],"mapped",[102]],[[120074,120074],"mapped",[103]],[[120075,120076],"disallowed"],[[120077,120077],"mapped",[106]],[[120078,120078],"mapped",[107]],[[120079,120079],"mapped",[108]],[[120080,120080],"mapped",[109]],[[120081,120081],"mapped",[110]],[[120082,120082],"mapped",[111]],[[120083,120083],"mapped",[112]],[[120084,120084],"mapped",[113]],[[120085,120085],"disallowed"],[[120086,120086],"mapped",[115]],[[120087,120087],"mapped",[116]],[[120088,120088],"mapped",[117]],[[120089,120089],"mapped",[118]],[[120090,120090],"mapped",[119]],[[120091,120091],"mapped",[120]],[[120092,120092],"mapped",[121]],[[120093,120093],"disallowed"],[[120094,120094],"mapped",[97]],[[120095,120095],"mapped",[98]],[[120096,120096],"mapped",[99]],[[120097,120097],"mapped",[100]],[[120098,120098],"mapped",[101]],[[120099,120099],"mapped",[102]],[[120100,120100],"mapped",[103]],[[120101,120101],"mapped",[104]],[[120102,120102],"mapped",[105]],[[120103,120103],"mapped",[106]],[[120104,120104],"mapped",[107]],[[120105,120105],"mapped",[108]],[[120106,120106],"mapped",[109]],[[120107,120107],"mapped",[110]],[[120108,120108],"mapped",[111]],[[120109,120109],"mapped",[112]],[[120110,120110],"mapped",[113]],[[120111,120111],"mapped",[114]],[[120112,120112],"mapped",[115]],[[120113,120113],"mapped",[116]],[[120114,120114],"mapped",[117]],[[120115,120115],"mapped",[118]],[[120116,120116],"mapped",[119]],[[120117,120117],"mapped",[120]],[[120118,120118],"mapped",[121]],[[120119,120119],"mapped",[122]],[[120120,120120],"mapped",[97]],[[120121,120121],"mapped",[98]],[[120122,120122],"disallowed"],[[120123,120123],"mapped",[100]],[[120124,120124],"mapped",[101]],[[120125,120125],"mapped",[102]],[[120126,120126],"mapped",[103]],[[120127,120127],"disallowed"],[[120128,120128],"mapped",[105]],[[120129,120129],"mapped",[106]],[[120130,120130],"mapped",[107]],[[120131,120131],"mapped",[108]],[[120132,120132],"mapped",[109]],[[120133,120133],"disallowed"],[[120134,120134],"mapped",[111]],[[120135,120137],"disallowed"],[[120138,120138],"mapped",[115]],[[120139,120139],"mapped",[116]],[[120140,120140],"mapped",[117]],[[120141,120141],"mapped",[118]],[[120142,120142],"mapped",[119]],[[120143,120143],"mapped",[120]],[[120144,120144],"mapped",[121]],[[120145,120145],"disallowed"],[[120146,120146],"mapped",[97]],[[120147,120147],"mapped",[98]],[[120148,120148],"mapped",[99]],[[120149,120149],"mapped",[100]],[[120150,120150],"mapped",[101]],[[120151,120151],"mapped",[102]],[[120152,120152],"mapped",[103]],[[120153,120153],"mapped",[104]],[[120154,120154],"mapped",[105]],[[120155,120155],"mapped",[106]],[[120156,120156],"mapped",[107]],[[120157,120157],"mapped",[108]],[[120158,120158],"mapped",[109]],[[120159,120159],"mapped",[110]],[[120160,120160],"mapped",[111]],[[120161,120161],"mapped",[112]],[[120162,120162],"mapped",[113]],[[120163,120163],"mapped",[114]],[[120164,120164],"mapped",[115]],[[120165,120165],"mapped",[116]],[[120166,120166],"mapped",[117]],[[120167,120167],"mapped",[118]],[[120168,120168],"mapped",[119]],[[120169,120169],"mapped",[120]],[[120170,120170],"mapped",[121]],[[120171,120171],"mapped",[122]],[[120172,120172],"mapped",[97]],[[120173,120173],"mapped",[98]],[[120174,120174],"mapped",[99]],[[120175,120175],"mapped",[100]],[[120176,120176],"mapped",[101]],[[120177,120177],"mapped",[102]],[[120178,120178],"mapped",[103]],[[120179,120179],"mapped",[104]],[[120180,120180],"mapped",[105]],[[120181,120181],"mapped",[106]],[[120182,120182],"mapped",[107]],[[120183,120183],"mapped",[108]],[[120184,120184],"mapped",[109]],[[120185,120185],"mapped",[110]],[[120186,120186],"mapped",[111]],[[120187,120187],"mapped",[112]],[[120188,120188],"mapped",[113]],[[120189,120189],"mapped",[114]],[[120190,120190],"mapped",[115]],[[120191,120191],"mapped",[116]],[[120192,120192],"mapped",[117]],[[120193,120193],"mapped",[118]],[[120194,120194],"mapped",[119]],[[120195,120195],"mapped",[120]],[[120196,120196],"mapped",[121]],[[120197,120197],"mapped",[122]],[[120198,120198],"mapped",[97]],[[120199,120199],"mapped",[98]],[[120200,120200],"mapped",[99]],[[120201,120201],"mapped",[100]],[[120202,120202],"mapped",[101]],[[120203,120203],"mapped",[102]],[[120204,120204],"mapped",[103]],[[120205,120205],"mapped",[104]],[[120206,120206],"mapped",[105]],[[120207,120207],"mapped",[106]],[[120208,120208],"mapped",[107]],[[120209,120209],"mapped",[108]],[[120210,120210],"mapped",[109]],[[120211,120211],"mapped",[110]],[[120212,120212],"mapped",[111]],[[120213,120213],"mapped",[112]],[[120214,120214],"mapped",[113]],[[120215,120215],"mapped",[114]],[[120216,120216],"mapped",[115]],[[120217,120217],"mapped",[116]],[[120218,120218],"mapped",[117]],[[120219,120219],"mapped",[118]],[[120220,120220],"mapped",[119]],[[120221,120221],"mapped",[120]],[[120222,120222],"mapped",[121]],[[120223,120223],"mapped",[122]],[[120224,120224],"mapped",[97]],[[120225,120225],"mapped",[98]],[[120226,120226],"mapped",[99]],[[120227,120227],"mapped",[100]],[[120228,120228],"mapped",[101]],[[120229,120229],"mapped",[102]],[[120230,120230],"mapped",[103]],[[120231,120231],"mapped",[104]],[[120232,120232],"mapped",[105]],[[120233,120233],"mapped",[106]],[[120234,120234],"mapped",[107]],[[120235,120235],"mapped",[108]],[[120236,120236],"mapped",[109]],[[120237,120237],"mapped",[110]],[[120238,120238],"mapped",[111]],[[120239,120239],"mapped",[112]],[[120240,120240],"mapped",[113]],[[120241,120241],"mapped",[114]],[[120242,120242],"mapped",[115]],[[120243,120243],"mapped",[116]],[[120244,120244],"mapped",[117]],[[120245,120245],"mapped",[118]],[[120246,120246],"mapped",[119]],[[120247,120247],"mapped",[120]],[[120248,120248],"mapped",[121]],[[120249,120249],"mapped",[122]],[[120250,120250],"mapped",[97]],[[120251,120251],"mapped",[98]],[[120252,120252],"mapped",[99]],[[120253,120253],"mapped",[100]],[[120254,120254],"mapped",[101]],[[120255,120255],"mapped",[102]],[[120256,120256],"mapped",[103]],[[120257,120257],"mapped",[104]],[[120258,120258],"mapped",[105]],[[120259,120259],"mapped",[106]],[[120260,120260],"mapped",[107]],[[120261,120261],"mapped",[108]],[[120262,120262],"mapped",[109]],[[120263,120263],"mapped",[110]],[[120264,120264],"mapped",[111]],[[120265,120265],"mapped",[112]],[[120266,120266],"mapped",[113]],[[120267,120267],"mapped",[114]],[[120268,120268],"mapped",[115]],[[120269,120269],"mapped",[116]],[[120270,120270],"mapped",[117]],[[120271,120271],"mapped",[118]],[[120272,120272],"mapped",[119]],[[120273,120273],"mapped",[120]],[[120274,120274],"mapped",[121]],[[120275,120275],"mapped",[122]],[[120276,120276],"mapped",[97]],[[120277,120277],"mapped",[98]],[[120278,120278],"mapped",[99]],[[120279,120279],"mapped",[100]],[[120280,120280],"mapped",[101]],[[120281,120281],"mapped",[102]],[[120282,120282],"mapped",[103]],[[120283,120283],"mapped",[104]],[[120284,120284],"mapped",[105]],[[120285,120285],"mapped",[106]],[[120286,120286],"mapped",[107]],[[120287,120287],"mapped",[108]],[[120288,120288],"mapped",[109]],[[120289,120289],"mapped",[110]],[[120290,120290],"mapped",[111]],[[120291,120291],"mapped",[112]],[[120292,120292],"mapped",[113]],[[120293,120293],"mapped",[114]],[[120294,120294],"mapped",[115]],[[120295,120295],"mapped",[116]],[[120296,120296],"mapped",[117]],[[120297,120297],"mapped",[118]],[[120298,120298],"mapped",[119]],[[120299,120299],"mapped",[120]],[[120300,120300],"mapped",[121]],[[120301,120301],"mapped",[122]],[[120302,120302],"mapped",[97]],[[120303,120303],"mapped",[98]],[[120304,120304],"mapped",[99]],[[120305,120305],"mapped",[100]],[[120306,120306],"mapped",[101]],[[120307,120307],"mapped",[102]],[[120308,120308],"mapped",[103]],[[120309,120309],"mapped",[104]],[[120310,120310],"mapped",[105]],[[120311,120311],"mapped",[106]],[[120312,120312],"mapped",[107]],[[120313,120313],"mapped",[108]],[[120314,120314],"mapped",[109]],[[120315,120315],"mapped",[110]],[[120316,120316],"mapped",[111]],[[120317,120317],"mapped",[112]],[[120318,120318],"mapped",[113]],[[120319,120319],"mapped",[114]],[[120320,120320],"mapped",[115]],[[120321,120321],"mapped",[116]],[[120322,120322],"mapped",[117]],[[120323,120323],"mapped",[118]],[[120324,120324],"mapped",[119]],[[120325,120325],"mapped",[120]],[[120326,120326],"mapped",[121]],[[120327,120327],"mapped",[122]],[[120328,120328],"mapped",[97]],[[120329,120329],"mapped",[98]],[[120330,120330],"mapped",[99]],[[120331,120331],"mapped",[100]],[[120332,120332],"mapped",[101]],[[120333,120333],"mapped",[102]],[[120334,120334],"mapped",[103]],[[120335,120335],"mapped",[104]],[[120336,120336],"mapped",[105]],[[120337,120337],"mapped",[106]],[[120338,120338],"mapped",[107]],[[120339,120339],"mapped",[108]],[[120340,120340],"mapped",[109]],[[120341,120341],"mapped",[110]],[[120342,120342],"mapped",[111]],[[120343,120343],"mapped",[112]],[[120344,120344],"mapped",[113]],[[120345,120345],"mapped",[114]],[[120346,120346],"mapped",[115]],[[120347,120347],"mapped",[116]],[[120348,120348],"mapped",[117]],[[120349,120349],"mapped",[118]],[[120350,120350],"mapped",[119]],[[120351,120351],"mapped",[120]],[[120352,120352],"mapped",[121]],[[120353,120353],"mapped",[122]],[[120354,120354],"mapped",[97]],[[120355,120355],"mapped",[98]],[[120356,120356],"mapped",[99]],[[120357,120357],"mapped",[100]],[[120358,120358],"mapped",[101]],[[120359,120359],"mapped",[102]],[[120360,120360],"mapped",[103]],[[120361,120361],"mapped",[104]],[[120362,120362],"mapped",[105]],[[120363,120363],"mapped",[106]],[[120364,120364],"mapped",[107]],[[120365,120365],"mapped",[108]],[[120366,120366],"mapped",[109]],[[120367,120367],"mapped",[110]],[[120368,120368],"mapped",[111]],[[120369,120369],"mapped",[112]],[[120370,120370],"mapped",[113]],[[120371,120371],"mapped",[114]],[[120372,120372],"mapped",[115]],[[120373,120373],"mapped",[116]],[[120374,120374],"mapped",[117]],[[120375,120375],"mapped",[118]],[[120376,120376],"mapped",[119]],[[120377,120377],"mapped",[120]],[[120378,120378],"mapped",[121]],[[120379,120379],"mapped",[122]],[[120380,120380],"mapped",[97]],[[120381,120381],"mapped",[98]],[[120382,120382],"mapped",[99]],[[120383,120383],"mapped",[100]],[[120384,120384],"mapped",[101]],[[120385,120385],"mapped",[102]],[[120386,120386],"mapped",[103]],[[120387,120387],"mapped",[104]],[[120388,120388],"mapped",[105]],[[120389,120389],"mapped",[106]],[[120390,120390],"mapped",[107]],[[120391,120391],"mapped",[108]],[[120392,120392],"mapped",[109]],[[120393,120393],"mapped",[110]],[[120394,120394],"mapped",[111]],[[120395,120395],"mapped",[112]],[[120396,120396],"mapped",[113]],[[120397,120397],"mapped",[114]],[[120398,120398],"mapped",[115]],[[120399,120399],"mapped",[116]],[[120400,120400],"mapped",[117]],[[120401,120401],"mapped",[118]],[[120402,120402],"mapped",[119]],[[120403,120403],"mapped",[120]],[[120404,120404],"mapped",[121]],[[120405,120405],"mapped",[122]],[[120406,120406],"mapped",[97]],[[120407,120407],"mapped",[98]],[[120408,120408],"mapped",[99]],[[120409,120409],"mapped",[100]],[[120410,120410],"mapped",[101]],[[120411,120411],"mapped",[102]],[[120412,120412],"mapped",[103]],[[120413,120413],"mapped",[104]],[[120414,120414],"mapped",[105]],[[120415,120415],"mapped",[106]],[[120416,120416],"mapped",[107]],[[120417,120417],"mapped",[108]],[[120418,120418],"mapped",[109]],[[120419,120419],"mapped",[110]],[[120420,120420],"mapped",[111]],[[120421,120421],"mapped",[112]],[[120422,120422],"mapped",[113]],[[120423,120423],"mapped",[114]],[[120424,120424],"mapped",[115]],[[120425,120425],"mapped",[116]],[[120426,120426],"mapped",[117]],[[120427,120427],"mapped",[118]],[[120428,120428],"mapped",[119]],[[120429,120429],"mapped",[120]],[[120430,120430],"mapped",[121]],[[120431,120431],"mapped",[122]],[[120432,120432],"mapped",[97]],[[120433,120433],"mapped",[98]],[[120434,120434],"mapped",[99]],[[120435,120435],"mapped",[100]],[[120436,120436],"mapped",[101]],[[120437,120437],"mapped",[102]],[[120438,120438],"mapped",[103]],[[120439,120439],"mapped",[104]],[[120440,120440],"mapped",[105]],[[120441,120441],"mapped",[106]],[[120442,120442],"mapped",[107]],[[120443,120443],"mapped",[108]],[[120444,120444],"mapped",[109]],[[120445,120445],"mapped",[110]],[[120446,120446],"mapped",[111]],[[120447,120447],"mapped",[112]],[[120448,120448],"mapped",[113]],[[120449,120449],"mapped",[114]],[[120450,120450],"mapped",[115]],[[120451,120451],"mapped",[116]],[[120452,120452],"mapped",[117]],[[120453,120453],"mapped",[118]],[[120454,120454],"mapped",[119]],[[120455,120455],"mapped",[120]],[[120456,120456],"mapped",[121]],[[120457,120457],"mapped",[122]],[[120458,120458],"mapped",[97]],[[120459,120459],"mapped",[98]],[[120460,120460],"mapped",[99]],[[120461,120461],"mapped",[100]],[[120462,120462],"mapped",[101]],[[120463,120463],"mapped",[102]],[[120464,120464],"mapped",[103]],[[120465,120465],"mapped",[104]],[[120466,120466],"mapped",[105]],[[120467,120467],"mapped",[106]],[[120468,120468],"mapped",[107]],[[120469,120469],"mapped",[108]],[[120470,120470],"mapped",[109]],[[120471,120471],"mapped",[110]],[[120472,120472],"mapped",[111]],[[120473,120473],"mapped",[112]],[[120474,120474],"mapped",[113]],[[120475,120475],"mapped",[114]],[[120476,120476],"mapped",[115]],[[120477,120477],"mapped",[116]],[[120478,120478],"mapped",[117]],[[120479,120479],"mapped",[118]],[[120480,120480],"mapped",[119]],[[120481,120481],"mapped",[120]],[[120482,120482],"mapped",[121]],[[120483,120483],"mapped",[122]],[[120484,120484],"mapped",[305]],[[120485,120485],"mapped",[567]],[[120486,120487],"disallowed"],[[120488,120488],"mapped",[945]],[[120489,120489],"mapped",[946]],[[120490,120490],"mapped",[947]],[[120491,120491],"mapped",[948]],[[120492,120492],"mapped",[949]],[[120493,120493],"mapped",[950]],[[120494,120494],"mapped",[951]],[[120495,120495],"mapped",[952]],[[120496,120496],"mapped",[953]],[[120497,120497],"mapped",[954]],[[120498,120498],"mapped",[955]],[[120499,120499],"mapped",[956]],[[120500,120500],"mapped",[957]],[[120501,120501],"mapped",[958]],[[120502,120502],"mapped",[959]],[[120503,120503],"mapped",[960]],[[120504,120504],"mapped",[961]],[[120505,120505],"mapped",[952]],[[120506,120506],"mapped",[963]],[[120507,120507],"mapped",[964]],[[120508,120508],"mapped",[965]],[[120509,120509],"mapped",[966]],[[120510,120510],"mapped",[967]],[[120511,120511],"mapped",[968]],[[120512,120512],"mapped",[969]],[[120513,120513],"mapped",[8711]],[[120514,120514],"mapped",[945]],[[120515,120515],"mapped",[946]],[[120516,120516],"mapped",[947]],[[120517,120517],"mapped",[948]],[[120518,120518],"mapped",[949]],[[120519,120519],"mapped",[950]],[[120520,120520],"mapped",[951]],[[120521,120521],"mapped",[952]],[[120522,120522],"mapped",[953]],[[120523,120523],"mapped",[954]],[[120524,120524],"mapped",[955]],[[120525,120525],"mapped",[956]],[[120526,120526],"mapped",[957]],[[120527,120527],"mapped",[958]],[[120528,120528],"mapped",[959]],[[120529,120529],"mapped",[960]],[[120530,120530],"mapped",[961]],[[120531,120532],"mapped",[963]],[[120533,120533],"mapped",[964]],[[120534,120534],"mapped",[965]],[[120535,120535],"mapped",[966]],[[120536,120536],"mapped",[967]],[[120537,120537],"mapped",[968]],[[120538,120538],"mapped",[969]],[[120539,120539],"mapped",[8706]],[[120540,120540],"mapped",[949]],[[120541,120541],"mapped",[952]],[[120542,120542],"mapped",[954]],[[120543,120543],"mapped",[966]],[[120544,120544],"mapped",[961]],[[120545,120545],"mapped",[960]],[[120546,120546],"mapped",[945]],[[120547,120547],"mapped",[946]],[[120548,120548],"mapped",[947]],[[120549,120549],"mapped",[948]],[[120550,120550],"mapped",[949]],[[120551,120551],"mapped",[950]],[[120552,120552],"mapped",[951]],[[120553,120553],"mapped",[952]],[[120554,120554],"mapped",[953]],[[120555,120555],"mapped",[954]],[[120556,120556],"mapped",[955]],[[120557,120557],"mapped",[956]],[[120558,120558],"mapped",[957]],[[120559,120559],"mapped",[958]],[[120560,120560],"mapped",[959]],[[120561,120561],"mapped",[960]],[[120562,120562],"mapped",[961]],[[120563,120563],"mapped",[952]],[[120564,120564],"mapped",[963]],[[120565,120565],"mapped",[964]],[[120566,120566],"mapped",[965]],[[120567,120567],"mapped",[966]],[[120568,120568],"mapped",[967]],[[120569,120569],"mapped",[968]],[[120570,120570],"mapped",[969]],[[120571,120571],"mapped",[8711]],[[120572,120572],"mapped",[945]],[[120573,120573],"mapped",[946]],[[120574,120574],"mapped",[947]],[[120575,120575],"mapped",[948]],[[120576,120576],"mapped",[949]],[[120577,120577],"mapped",[950]],[[120578,120578],"mapped",[951]],[[120579,120579],"mapped",[952]],[[120580,120580],"mapped",[953]],[[120581,120581],"mapped",[954]],[[120582,120582],"mapped",[955]],[[120583,120583],"mapped",[956]],[[120584,120584],"mapped",[957]],[[120585,120585],"mapped",[958]],[[120586,120586],"mapped",[959]],[[120587,120587],"mapped",[960]],[[120588,120588],"mapped",[961]],[[120589,120590],"mapped",[963]],[[120591,120591],"mapped",[964]],[[120592,120592],"mapped",[965]],[[120593,120593],"mapped",[966]],[[120594,120594],"mapped",[967]],[[120595,120595],"mapped",[968]],[[120596,120596],"mapped",[969]],[[120597,120597],"mapped",[8706]],[[120598,120598],"mapped",[949]],[[120599,120599],"mapped",[952]],[[120600,120600],"mapped",[954]],[[120601,120601],"mapped",[966]],[[120602,120602],"mapped",[961]],[[120603,120603],"mapped",[960]],[[120604,120604],"mapped",[945]],[[120605,120605],"mapped",[946]],[[120606,120606],"mapped",[947]],[[120607,120607],"mapped",[948]],[[120608,120608],"mapped",[949]],[[120609,120609],"mapped",[950]],[[120610,120610],"mapped",[951]],[[120611,120611],"mapped",[952]],[[120612,120612],"mapped",[953]],[[120613,120613],"mapped",[954]],[[120614,120614],"mapped",[955]],[[120615,120615],"mapped",[956]],[[120616,120616],"mapped",[957]],[[120617,120617],"mapped",[958]],[[120618,120618],"mapped",[959]],[[120619,120619],"mapped",[960]],[[120620,120620],"mapped",[961]],[[120621,120621],"mapped",[952]],[[120622,120622],"mapped",[963]],[[120623,120623],"mapped",[964]],[[120624,120624],"mapped",[965]],[[120625,120625],"mapped",[966]],[[120626,120626],"mapped",[967]],[[120627,120627],"mapped",[968]],[[120628,120628],"mapped",[969]],[[120629,120629],"mapped",[8711]],[[120630,120630],"mapped",[945]],[[120631,120631],"mapped",[946]],[[120632,120632],"mapped",[947]],[[120633,120633],"mapped",[948]],[[120634,120634],"mapped",[949]],[[120635,120635],"mapped",[950]],[[120636,120636],"mapped",[951]],[[120637,120637],"mapped",[952]],[[120638,120638],"mapped",[953]],[[120639,120639],"mapped",[954]],[[120640,120640],"mapped",[955]],[[120641,120641],"mapped",[956]],[[120642,120642],"mapped",[957]],[[120643,120643],"mapped",[958]],[[120644,120644],"mapped",[959]],[[120645,120645],"mapped",[960]],[[120646,120646],"mapped",[961]],[[120647,120648],"mapped",[963]],[[120649,120649],"mapped",[964]],[[120650,120650],"mapped",[965]],[[120651,120651],"mapped",[966]],[[120652,120652],"mapped",[967]],[[120653,120653],"mapped",[968]],[[120654,120654],"mapped",[969]],[[120655,120655],"mapped",[8706]],[[120656,120656],"mapped",[949]],[[120657,120657],"mapped",[952]],[[120658,120658],"mapped",[954]],[[120659,120659],"mapped",[966]],[[120660,120660],"mapped",[961]],[[120661,120661],"mapped",[960]],[[120662,120662],"mapped",[945]],[[120663,120663],"mapped",[946]],[[120664,120664],"mapped",[947]],[[120665,120665],"mapped",[948]],[[120666,120666],"mapped",[949]],[[120667,120667],"mapped",[950]],[[120668,120668],"mapped",[951]],[[120669,120669],"mapped",[952]],[[120670,120670],"mapped",[953]],[[120671,120671],"mapped",[954]],[[120672,120672],"mapped",[955]],[[120673,120673],"mapped",[956]],[[120674,120674],"mapped",[957]],[[120675,120675],"mapped",[958]],[[120676,120676],"mapped",[959]],[[120677,120677],"mapped",[960]],[[120678,120678],"mapped",[961]],[[120679,120679],"mapped",[952]],[[120680,120680],"mapped",[963]],[[120681,120681],"mapped",[964]],[[120682,120682],"mapped",[965]],[[120683,120683],"mapped",[966]],[[120684,120684],"mapped",[967]],[[120685,120685],"mapped",[968]],[[120686,120686],"mapped",[969]],[[120687,120687],"mapped",[8711]],[[120688,120688],"mapped",[945]],[[120689,120689],"mapped",[946]],[[120690,120690],"mapped",[947]],[[120691,120691],"mapped",[948]],[[120692,120692],"mapped",[949]],[[120693,120693],"mapped",[950]],[[120694,120694],"mapped",[951]],[[120695,120695],"mapped",[952]],[[120696,120696],"mapped",[953]],[[120697,120697],"mapped",[954]],[[120698,120698],"mapped",[955]],[[120699,120699],"mapped",[956]],[[120700,120700],"mapped",[957]],[[120701,120701],"mapped",[958]],[[120702,120702],"mapped",[959]],[[120703,120703],"mapped",[960]],[[120704,120704],"mapped",[961]],[[120705,120706],"mapped",[963]],[[120707,120707],"mapped",[964]],[[120708,120708],"mapped",[965]],[[120709,120709],"mapped",[966]],[[120710,120710],"mapped",[967]],[[120711,120711],"mapped",[968]],[[120712,120712],"mapped",[969]],[[120713,120713],"mapped",[8706]],[[120714,120714],"mapped",[949]],[[120715,120715],"mapped",[952]],[[120716,120716],"mapped",[954]],[[120717,120717],"mapped",[966]],[[120718,120718],"mapped",[961]],[[120719,120719],"mapped",[960]],[[120720,120720],"mapped",[945]],[[120721,120721],"mapped",[946]],[[120722,120722],"mapped",[947]],[[120723,120723],"mapped",[948]],[[120724,120724],"mapped",[949]],[[120725,120725],"mapped",[950]],[[120726,120726],"mapped",[951]],[[120727,120727],"mapped",[952]],[[120728,120728],"mapped",[953]],[[120729,120729],"mapped",[954]],[[120730,120730],"mapped",[955]],[[120731,120731],"mapped",[956]],[[120732,120732],"mapped",[957]],[[120733,120733],"mapped",[958]],[[120734,120734],"mapped",[959]],[[120735,120735],"mapped",[960]],[[120736,120736],"mapped",[961]],[[120737,120737],"mapped",[952]],[[120738,120738],"mapped",[963]],[[120739,120739],"mapped",[964]],[[120740,120740],"mapped",[965]],[[120741,120741],"mapped",[966]],[[120742,120742],"mapped",[967]],[[120743,120743],"mapped",[968]],[[120744,120744],"mapped",[969]],[[120745,120745],"mapped",[8711]],[[120746,120746],"mapped",[945]],[[120747,120747],"mapped",[946]],[[120748,120748],"mapped",[947]],[[120749,120749],"mapped",[948]],[[120750,120750],"mapped",[949]],[[120751,120751],"mapped",[950]],[[120752,120752],"mapped",[951]],[[120753,120753],"mapped",[952]],[[120754,120754],"mapped",[953]],[[120755,120755],"mapped",[954]],[[120756,120756],"mapped",[955]],[[120757,120757],"mapped",[956]],[[120758,120758],"mapped",[957]],[[120759,120759],"mapped",[958]],[[120760,120760],"mapped",[959]],[[120761,120761],"mapped",[960]],[[120762,120762],"mapped",[961]],[[120763,120764],"mapped",[963]],[[120765,120765],"mapped",[964]],[[120766,120766],"mapped",[965]],[[120767,120767],"mapped",[966]],[[120768,120768],"mapped",[967]],[[120769,120769],"mapped",[968]],[[120770,120770],"mapped",[969]],[[120771,120771],"mapped",[8706]],[[120772,120772],"mapped",[949]],[[120773,120773],"mapped",[952]],[[120774,120774],"mapped",[954]],[[120775,120775],"mapped",[966]],[[120776,120776],"mapped",[961]],[[120777,120777],"mapped",[960]],[[120778,120779],"mapped",[989]],[[120780,120781],"disallowed"],[[120782,120782],"mapped",[48]],[[120783,120783],"mapped",[49]],[[120784,120784],"mapped",[50]],[[120785,120785],"mapped",[51]],[[120786,120786],"mapped",[52]],[[120787,120787],"mapped",[53]],[[120788,120788],"mapped",[54]],[[120789,120789],"mapped",[55]],[[120790,120790],"mapped",[56]],[[120791,120791],"mapped",[57]],[[120792,120792],"mapped",[48]],[[120793,120793],"mapped",[49]],[[120794,120794],"mapped",[50]],[[120795,120795],"mapped",[51]],[[120796,120796],"mapped",[52]],[[120797,120797],"mapped",[53]],[[120798,120798],"mapped",[54]],[[120799,120799],"mapped",[55]],[[120800,120800],"mapped",[56]],[[120801,120801],"mapped",[57]],[[120802,120802],"mapped",[48]],[[120803,120803],"mapped",[49]],[[120804,120804],"mapped",[50]],[[120805,120805],"mapped",[51]],[[120806,120806],"mapped",[52]],[[120807,120807],"mapped",[53]],[[120808,120808],"mapped",[54]],[[120809,120809],"mapped",[55]],[[120810,120810],"mapped",[56]],[[120811,120811],"mapped",[57]],[[120812,120812],"mapped",[48]],[[120813,120813],"mapped",[49]],[[120814,120814],"mapped",[50]],[[120815,120815],"mapped",[51]],[[120816,120816],"mapped",[52]],[[120817,120817],"mapped",[53]],[[120818,120818],"mapped",[54]],[[120819,120819],"mapped",[55]],[[120820,120820],"mapped",[56]],[[120821,120821],"mapped",[57]],[[120822,120822],"mapped",[48]],[[120823,120823],"mapped",[49]],[[120824,120824],"mapped",[50]],[[120825,120825],"mapped",[51]],[[120826,120826],"mapped",[52]],[[120827,120827],"mapped",[53]],[[120828,120828],"mapped",[54]],[[120829,120829],"mapped",[55]],[[120830,120830],"mapped",[56]],[[120831,120831],"mapped",[57]],[[120832,121343],"valid",[],"NV8"],[[121344,121398],"valid"],[[121399,121402],"valid",[],"NV8"],[[121403,121452],"valid"],[[121453,121460],"valid",[],"NV8"],[[121461,121461],"valid"],[[121462,121475],"valid",[],"NV8"],[[121476,121476],"valid"],[[121477,121483],"valid",[],"NV8"],[[121484,121498],"disallowed"],[[121499,121503],"valid"],[[121504,121504],"disallowed"],[[121505,121519],"valid"],[[121520,124927],"disallowed"],[[124928,125124],"valid"],[[125125,125126],"disallowed"],[[125127,125135],"valid",[],"NV8"],[[125136,125142],"valid"],[[125143,126463],"disallowed"],[[126464,126464],"mapped",[1575]],[[126465,126465],"mapped",[1576]],[[126466,126466],"mapped",[1580]],[[126467,126467],"mapped",[1583]],[[126468,126468],"disallowed"],[[126469,126469],"mapped",[1608]],[[126470,126470],"mapped",[1586]],[[126471,126471],"mapped",[1581]],[[126472,126472],"mapped",[1591]],[[126473,126473],"mapped",[1610]],[[126474,126474],"mapped",[1603]],[[126475,126475],"mapped",[1604]],[[126476,126476],"mapped",[1605]],[[126477,126477],"mapped",[1606]],[[126478,126478],"mapped",[1587]],[[126479,126479],"mapped",[1593]],[[126480,126480],"mapped",[1601]],[[126481,126481],"mapped",[1589]],[[126482,126482],"mapped",[1602]],[[126483,126483],"mapped",[1585]],[[126484,126484],"mapped",[1588]],[[126485,126485],"mapped",[1578]],[[126486,126486],"mapped",[1579]],[[126487,126487],"mapped",[1582]],[[126488,126488],"mapped",[1584]],[[126489,126489],"mapped",[1590]],[[126490,126490],"mapped",[1592]],[[126491,126491],"mapped",[1594]],[[126492,126492],"mapped",[1646]],[[126493,126493],"mapped",[1722]],[[126494,126494],"mapped",[1697]],[[126495,126495],"mapped",[1647]],[[126496,126496],"disallowed"],[[126497,126497],"mapped",[1576]],[[126498,126498],"mapped",[1580]],[[126499,126499],"disallowed"],[[126500,126500],"mapped",[1607]],[[126501,126502],"disallowed"],[[126503,126503],"mapped",[1581]],[[126504,126504],"disallowed"],[[126505,126505],"mapped",[1610]],[[126506,126506],"mapped",[1603]],[[126507,126507],"mapped",[1604]],[[126508,126508],"mapped",[1605]],[[126509,126509],"mapped",[1606]],[[126510,126510],"mapped",[1587]],[[126511,126511],"mapped",[1593]],[[126512,126512],"mapped",[1601]],[[126513,126513],"mapped",[1589]],[[126514,126514],"mapped",[1602]],[[126515,126515],"disallowed"],[[126516,126516],"mapped",[1588]],[[126517,126517],"mapped",[1578]],[[126518,126518],"mapped",[1579]],[[126519,126519],"mapped",[1582]],[[126520,126520],"disallowed"],[[126521,126521],"mapped",[1590]],[[126522,126522],"disallowed"],[[126523,126523],"mapped",[1594]],[[126524,126529],"disallowed"],[[126530,126530],"mapped",[1580]],[[126531,126534],"disallowed"],[[126535,126535],"mapped",[1581]],[[126536,126536],"disallowed"],[[126537,126537],"mapped",[1610]],[[126538,126538],"disallowed"],[[126539,126539],"mapped",[1604]],[[126540,126540],"disallowed"],[[126541,126541],"mapped",[1606]],[[126542,126542],"mapped",[1587]],[[126543,126543],"mapped",[1593]],[[126544,126544],"disallowed"],[[126545,126545],"mapped",[1589]],[[126546,126546],"mapped",[1602]],[[126547,126547],"disallowed"],[[126548,126548],"mapped",[1588]],[[126549,126550],"disallowed"],[[126551,126551],"mapped",[1582]],[[126552,126552],"disallowed"],[[126553,126553],"mapped",[1590]],[[126554,126554],"disallowed"],[[126555,126555],"mapped",[1594]],[[126556,126556],"disallowed"],[[126557,126557],"mapped",[1722]],[[126558,126558],"disallowed"],[[126559,126559],"mapped",[1647]],[[126560,126560],"disallowed"],[[126561,126561],"mapped",[1576]],[[126562,126562],"mapped",[1580]],[[126563,126563],"disallowed"],[[126564,126564],"mapped",[1607]],[[126565,126566],"disallowed"],[[126567,126567],"mapped",[1581]],[[126568,126568],"mapped",[1591]],[[126569,126569],"mapped",[1610]],[[126570,126570],"mapped",[1603]],[[126571,126571],"disallowed"],[[126572,126572],"mapped",[1605]],[[126573,126573],"mapped",[1606]],[[126574,126574],"mapped",[1587]],[[126575,126575],"mapped",[1593]],[[126576,126576],"mapped",[1601]],[[126577,126577],"mapped",[1589]],[[126578,126578],"mapped",[1602]],[[126579,126579],"disallowed"],[[126580,126580],"mapped",[1588]],[[126581,126581],"mapped",[1578]],[[126582,126582],"mapped",[1579]],[[126583,126583],"mapped",[1582]],[[126584,126584],"disallowed"],[[126585,126585],"mapped",[1590]],[[126586,126586],"mapped",[1592]],[[126587,126587],"mapped",[1594]],[[126588,126588],"mapped",[1646]],[[126589,126589],"disallowed"],[[126590,126590],"mapped",[1697]],[[126591,126591],"disallowed"],[[126592,126592],"mapped",[1575]],[[126593,126593],"mapped",[1576]],[[126594,126594],"mapped",[1580]],[[126595,126595],"mapped",[1583]],[[126596,126596],"mapped",[1607]],[[126597,126597],"mapped",[1608]],[[126598,126598],"mapped",[1586]],[[126599,126599],"mapped",[1581]],[[126600,126600],"mapped",[1591]],[[126601,126601],"mapped",[1610]],[[126602,126602],"disallowed"],[[126603,126603],"mapped",[1604]],[[126604,126604],"mapped",[1605]],[[126605,126605],"mapped",[1606]],[[126606,126606],"mapped",[1587]],[[126607,126607],"mapped",[1593]],[[126608,126608],"mapped",[1601]],[[126609,126609],"mapped",[1589]],[[126610,126610],"mapped",[1602]],[[126611,126611],"mapped",[1585]],[[126612,126612],"mapped",[1588]],[[126613,126613],"mapped",[1578]],[[126614,126614],"mapped",[1579]],[[126615,126615],"mapped",[1582]],[[126616,126616],"mapped",[1584]],[[126617,126617],"mapped",[1590]],[[126618,126618],"mapped",[1592]],[[126619,126619],"mapped",[1594]],[[126620,126624],"disallowed"],[[126625,126625],"mapped",[1576]],[[126626,126626],"mapped",[1580]],[[126627,126627],"mapped",[1583]],[[126628,126628],"disallowed"],[[126629,126629],"mapped",[1608]],[[126630,126630],"mapped",[1586]],[[126631,126631],"mapped",[1581]],[[126632,126632],"mapped",[1591]],[[126633,126633],"mapped",[1610]],[[126634,126634],"disallowed"],[[126635,126635],"mapped",[1604]],[[126636,126636],"mapped",[1605]],[[126637,126637],"mapped",[1606]],[[126638,126638],"mapped",[1587]],[[126639,126639],"mapped",[1593]],[[126640,126640],"mapped",[1601]],[[126641,126641],"mapped",[1589]],[[126642,126642],"mapped",[1602]],[[126643,126643],"mapped",[1585]],[[126644,126644],"mapped",[1588]],[[126645,126645],"mapped",[1578]],[[126646,126646],"mapped",[1579]],[[126647,126647],"mapped",[1582]],[[126648,126648],"mapped",[1584]],[[126649,126649],"mapped",[1590]],[[126650,126650],"mapped",[1592]],[[126651,126651],"mapped",[1594]],[[126652,126703],"disallowed"],[[126704,126705],"valid",[],"NV8"],[[126706,126975],"disallowed"],[[126976,127019],"valid",[],"NV8"],[[127020,127023],"disallowed"],[[127024,127123],"valid",[],"NV8"],[[127124,127135],"disallowed"],[[127136,127150],"valid",[],"NV8"],[[127151,127152],"disallowed"],[[127153,127166],"valid",[],"NV8"],[[127167,127167],"valid",[],"NV8"],[[127168,127168],"disallowed"],[[127169,127183],"valid",[],"NV8"],[[127184,127184],"disallowed"],[[127185,127199],"valid",[],"NV8"],[[127200,127221],"valid",[],"NV8"],[[127222,127231],"disallowed"],[[127232,127232],"disallowed"],[[127233,127233],"disallowed_STD3_mapped",[48,44]],[[127234,127234],"disallowed_STD3_mapped",[49,44]],[[127235,127235],"disallowed_STD3_mapped",[50,44]],[[127236,127236],"disallowed_STD3_mapped",[51,44]],[[127237,127237],"disallowed_STD3_mapped",[52,44]],[[127238,127238],"disallowed_STD3_mapped",[53,44]],[[127239,127239],"disallowed_STD3_mapped",[54,44]],[[127240,127240],"disallowed_STD3_mapped",[55,44]],[[127241,127241],"disallowed_STD3_mapped",[56,44]],[[127242,127242],"disallowed_STD3_mapped",[57,44]],[[127243,127244],"valid",[],"NV8"],[[127245,127247],"disallowed"],[[127248,127248],"disallowed_STD3_mapped",[40,97,41]],[[127249,127249],"disallowed_STD3_mapped",[40,98,41]],[[127250,127250],"disallowed_STD3_mapped",[40,99,41]],[[127251,127251],"disallowed_STD3_mapped",[40,100,41]],[[127252,127252],"disallowed_STD3_mapped",[40,101,41]],[[127253,127253],"disallowed_STD3_mapped",[40,102,41]],[[127254,127254],"disallowed_STD3_mapped",[40,103,41]],[[127255,127255],"disallowed_STD3_mapped",[40,104,41]],[[127256,127256],"disallowed_STD3_mapped",[40,105,41]],[[127257,127257],"disallowed_STD3_mapped",[40,106,41]],[[127258,127258],"disallowed_STD3_mapped",[40,107,41]],[[127259,127259],"disallowed_STD3_mapped",[40,108,41]],[[127260,127260],"disallowed_STD3_mapped",[40,109,41]],[[127261,127261],"disallowed_STD3_mapped",[40,110,41]],[[127262,127262],"disallowed_STD3_mapped",[40,111,41]],[[127263,127263],"disallowed_STD3_mapped",[40,112,41]],[[127264,127264],"disallowed_STD3_mapped",[40,113,41]],[[127265,127265],"disallowed_STD3_mapped",[40,114,41]],[[127266,127266],"disallowed_STD3_mapped",[40,115,41]],[[127267,127267],"disallowed_STD3_mapped",[40,116,41]],[[127268,127268],"disallowed_STD3_mapped",[40,117,41]],[[127269,127269],"disallowed_STD3_mapped",[40,118,41]],[[127270,127270],"disallowed_STD3_mapped",[40,119,41]],[[127271,127271],"disallowed_STD3_mapped",[40,120,41]],[[127272,127272],"disallowed_STD3_mapped",[40,121,41]],[[127273,127273],"disallowed_STD3_mapped",[40,122,41]],[[127274,127274],"mapped",[12308,115,12309]],[[127275,127275],"mapped",[99]],[[127276,127276],"mapped",[114]],[[127277,127277],"mapped",[99,100]],[[127278,127278],"mapped",[119,122]],[[127279,127279],"disallowed"],[[127280,127280],"mapped",[97]],[[127281,127281],"mapped",[98]],[[127282,127282],"mapped",[99]],[[127283,127283],"mapped",[100]],[[127284,127284],"mapped",[101]],[[127285,127285],"mapped",[102]],[[127286,127286],"mapped",[103]],[[127287,127287],"mapped",[104]],[[127288,127288],"mapped",[105]],[[127289,127289],"mapped",[106]],[[127290,127290],"mapped",[107]],[[127291,127291],"mapped",[108]],[[127292,127292],"mapped",[109]],[[127293,127293],"mapped",[110]],[[127294,127294],"mapped",[111]],[[127295,127295],"mapped",[112]],[[127296,127296],"mapped",[113]],[[127297,127297],"mapped",[114]],[[127298,127298],"mapped",[115]],[[127299,127299],"mapped",[116]],[[127300,127300],"mapped",[117]],[[127301,127301],"mapped",[118]],[[127302,127302],"mapped",[119]],[[127303,127303],"mapped",[120]],[[127304,127304],"mapped",[121]],[[127305,127305],"mapped",[122]],[[127306,127306],"mapped",[104,118]],[[127307,127307],"mapped",[109,118]],[[127308,127308],"mapped",[115,100]],[[127309,127309],"mapped",[115,115]],[[127310,127310],"mapped",[112,112,118]],[[127311,127311],"mapped",[119,99]],[[127312,127318],"valid",[],"NV8"],[[127319,127319],"valid",[],"NV8"],[[127320,127326],"valid",[],"NV8"],[[127327,127327],"valid",[],"NV8"],[[127328,127337],"valid",[],"NV8"],[[127338,127338],"mapped",[109,99]],[[127339,127339],"mapped",[109,100]],[[127340,127343],"disallowed"],[[127344,127352],"valid",[],"NV8"],[[127353,127353],"valid",[],"NV8"],[[127354,127354],"valid",[],"NV8"],[[127355,127356],"valid",[],"NV8"],[[127357,127358],"valid",[],"NV8"],[[127359,127359],"valid",[],"NV8"],[[127360,127369],"valid",[],"NV8"],[[127370,127373],"valid",[],"NV8"],[[127374,127375],"valid",[],"NV8"],[[127376,127376],"mapped",[100,106]],[[127377,127386],"valid",[],"NV8"],[[127387,127461],"disallowed"],[[127462,127487],"valid",[],"NV8"],[[127488,127488],"mapped",[12411,12363]],[[127489,127489],"mapped",[12467,12467]],[[127490,127490],"mapped",[12469]],[[127491,127503],"disallowed"],[[127504,127504],"mapped",[25163]],[[127505,127505],"mapped",[23383]],[[127506,127506],"mapped",[21452]],[[127507,127507],"mapped",[12487]],[[127508,127508],"mapped",[20108]],[[127509,127509],"mapped",[22810]],[[127510,127510],"mapped",[35299]],[[127511,127511],"mapped",[22825]],[[127512,127512],"mapped",[20132]],[[127513,127513],"mapped",[26144]],[[127514,127514],"mapped",[28961]],[[127515,127515],"mapped",[26009]],[[127516,127516],"mapped",[21069]],[[127517,127517],"mapped",[24460]],[[127518,127518],"mapped",[20877]],[[127519,127519],"mapped",[26032]],[[127520,127520],"mapped",[21021]],[[127521,127521],"mapped",[32066]],[[127522,127522],"mapped",[29983]],[[127523,127523],"mapped",[36009]],[[127524,127524],"mapped",[22768]],[[127525,127525],"mapped",[21561]],[[127526,127526],"mapped",[28436]],[[127527,127527],"mapped",[25237]],[[127528,127528],"mapped",[25429]],[[127529,127529],"mapped",[19968]],[[127530,127530],"mapped",[19977]],[[127531,127531],"mapped",[36938]],[[127532,127532],"mapped",[24038]],[[127533,127533],"mapped",[20013]],[[127534,127534],"mapped",[21491]],[[127535,127535],"mapped",[25351]],[[127536,127536],"mapped",[36208]],[[127537,127537],"mapped",[25171]],[[127538,127538],"mapped",[31105]],[[127539,127539],"mapped",[31354]],[[127540,127540],"mapped",[21512]],[[127541,127541],"mapped",[28288]],[[127542,127542],"mapped",[26377]],[[127543,127543],"mapped",[26376]],[[127544,127544],"mapped",[30003]],[[127545,127545],"mapped",[21106]],[[127546,127546],"mapped",[21942]],[[127547,127551],"disallowed"],[[127552,127552],"mapped",[12308,26412,12309]],[[127553,127553],"mapped",[12308,19977,12309]],[[127554,127554],"mapped",[12308,20108,12309]],[[127555,127555],"mapped",[12308,23433,12309]],[[127556,127556],"mapped",[12308,28857,12309]],[[127557,127557],"mapped",[12308,25171,12309]],[[127558,127558],"mapped",[12308,30423,12309]],[[127559,127559],"mapped",[12308,21213,12309]],[[127560,127560],"mapped",[12308,25943,12309]],[[127561,127567],"disallowed"],[[127568,127568],"mapped",[24471]],[[127569,127569],"mapped",[21487]],[[127570,127743],"disallowed"],[[127744,127776],"valid",[],"NV8"],[[127777,127788],"valid",[],"NV8"],[[127789,127791],"valid",[],"NV8"],[[127792,127797],"valid",[],"NV8"],[[127798,127798],"valid",[],"NV8"],[[127799,127868],"valid",[],"NV8"],[[127869,127869],"valid",[],"NV8"],[[127870,127871],"valid",[],"NV8"],[[127872,127891],"valid",[],"NV8"],[[127892,127903],"valid",[],"NV8"],[[127904,127940],"valid",[],"NV8"],[[127941,127941],"valid",[],"NV8"],[[127942,127946],"valid",[],"NV8"],[[127947,127950],"valid",[],"NV8"],[[127951,127955],"valid",[],"NV8"],[[127956,127967],"valid",[],"NV8"],[[127968,127984],"valid",[],"NV8"],[[127985,127991],"valid",[],"NV8"],[[127992,127999],"valid",[],"NV8"],[[128000,128062],"valid",[],"NV8"],[[128063,128063],"valid",[],"NV8"],[[128064,128064],"valid",[],"NV8"],[[128065,128065],"valid",[],"NV8"],[[128066,128247],"valid",[],"NV8"],[[128248,128248],"valid",[],"NV8"],[[128249,128252],"valid",[],"NV8"],[[128253,128254],"valid",[],"NV8"],[[128255,128255],"valid",[],"NV8"],[[128256,128317],"valid",[],"NV8"],[[128318,128319],"valid",[],"NV8"],[[128320,128323],"valid",[],"NV8"],[[128324,128330],"valid",[],"NV8"],[[128331,128335],"valid",[],"NV8"],[[128336,128359],"valid",[],"NV8"],[[128360,128377],"valid",[],"NV8"],[[128378,128378],"disallowed"],[[128379,128419],"valid",[],"NV8"],[[128420,128420],"disallowed"],[[128421,128506],"valid",[],"NV8"],[[128507,128511],"valid",[],"NV8"],[[128512,128512],"valid",[],"NV8"],[[128513,128528],"valid",[],"NV8"],[[128529,128529],"valid",[],"NV8"],[[128530,128532],"valid",[],"NV8"],[[128533,128533],"valid",[],"NV8"],[[128534,128534],"valid",[],"NV8"],[[128535,128535],"valid",[],"NV8"],[[128536,128536],"valid",[],"NV8"],[[128537,128537],"valid",[],"NV8"],[[128538,128538],"valid",[],"NV8"],[[128539,128539],"valid",[],"NV8"],[[128540,128542],"valid",[],"NV8"],[[128543,128543],"valid",[],"NV8"],[[128544,128549],"valid",[],"NV8"],[[128550,128551],"valid",[],"NV8"],[[128552,128555],"valid",[],"NV8"],[[128556,128556],"valid",[],"NV8"],[[128557,128557],"valid",[],"NV8"],[[128558,128559],"valid",[],"NV8"],[[128560,128563],"valid",[],"NV8"],[[128564,128564],"valid",[],"NV8"],[[128565,128576],"valid",[],"NV8"],[[128577,128578],"valid",[],"NV8"],[[128579,128580],"valid",[],"NV8"],[[128581,128591],"valid",[],"NV8"],[[128592,128639],"valid",[],"NV8"],[[128640,128709],"valid",[],"NV8"],[[128710,128719],"valid",[],"NV8"],[[128720,128720],"valid",[],"NV8"],[[128721,128735],"disallowed"],[[128736,128748],"valid",[],"NV8"],[[128749,128751],"disallowed"],[[128752,128755],"valid",[],"NV8"],[[128756,128767],"disallowed"],[[128768,128883],"valid",[],"NV8"],[[128884,128895],"disallowed"],[[128896,128980],"valid",[],"NV8"],[[128981,129023],"disallowed"],[[129024,129035],"valid",[],"NV8"],[[129036,129039],"disallowed"],[[129040,129095],"valid",[],"NV8"],[[129096,129103],"disallowed"],[[129104,129113],"valid",[],"NV8"],[[129114,129119],"disallowed"],[[129120,129159],"valid",[],"NV8"],[[129160,129167],"disallowed"],[[129168,129197],"valid",[],"NV8"],[[129198,129295],"disallowed"],[[129296,129304],"valid",[],"NV8"],[[129305,129407],"disallowed"],[[129408,129412],"valid",[],"NV8"],[[129413,129471],"disallowed"],[[129472,129472],"valid",[],"NV8"],[[129473,131069],"disallowed"],[[131070,131071],"disallowed"],[[131072,173782],"valid"],[[173783,173823],"disallowed"],[[173824,177972],"valid"],[[177973,177983],"disallowed"],[[177984,178205],"valid"],[[178206,178207],"disallowed"],[[178208,183969],"valid"],[[183970,194559],"disallowed"],[[194560,194560],"mapped",[20029]],[[194561,194561],"mapped",[20024]],[[194562,194562],"mapped",[20033]],[[194563,194563],"mapped",[131362]],[[194564,194564],"mapped",[20320]],[[194565,194565],"mapped",[20398]],[[194566,194566],"mapped",[20411]],[[194567,194567],"mapped",[20482]],[[194568,194568],"mapped",[20602]],[[194569,194569],"mapped",[20633]],[[194570,194570],"mapped",[20711]],[[194571,194571],"mapped",[20687]],[[194572,194572],"mapped",[13470]],[[194573,194573],"mapped",[132666]],[[194574,194574],"mapped",[20813]],[[194575,194575],"mapped",[20820]],[[194576,194576],"mapped",[20836]],[[194577,194577],"mapped",[20855]],[[194578,194578],"mapped",[132380]],[[194579,194579],"mapped",[13497]],[[194580,194580],"mapped",[20839]],[[194581,194581],"mapped",[20877]],[[194582,194582],"mapped",[132427]],[[194583,194583],"mapped",[20887]],[[194584,194584],"mapped",[20900]],[[194585,194585],"mapped",[20172]],[[194586,194586],"mapped",[20908]],[[194587,194587],"mapped",[20917]],[[194588,194588],"mapped",[168415]],[[194589,194589],"mapped",[20981]],[[194590,194590],"mapped",[20995]],[[194591,194591],"mapped",[13535]],[[194592,194592],"mapped",[21051]],[[194593,194593],"mapped",[21062]],[[194594,194594],"mapped",[21106]],[[194595,194595],"mapped",[21111]],[[194596,194596],"mapped",[13589]],[[194597,194597],"mapped",[21191]],[[194598,194598],"mapped",[21193]],[[194599,194599],"mapped",[21220]],[[194600,194600],"mapped",[21242]],[[194601,194601],"mapped",[21253]],[[194602,194602],"mapped",[21254]],[[194603,194603],"mapped",[21271]],[[194604,194604],"mapped",[21321]],[[194605,194605],"mapped",[21329]],[[194606,194606],"mapped",[21338]],[[194607,194607],"mapped",[21363]],[[194608,194608],"mapped",[21373]],[[194609,194611],"mapped",[21375]],[[194612,194612],"mapped",[133676]],[[194613,194613],"mapped",[28784]],[[194614,194614],"mapped",[21450]],[[194615,194615],"mapped",[21471]],[[194616,194616],"mapped",[133987]],[[194617,194617],"mapped",[21483]],[[194618,194618],"mapped",[21489]],[[194619,194619],"mapped",[21510]],[[194620,194620],"mapped",[21662]],[[194621,194621],"mapped",[21560]],[[194622,194622],"mapped",[21576]],[[194623,194623],"mapped",[21608]],[[194624,194624],"mapped",[21666]],[[194625,194625],"mapped",[21750]],[[194626,194626],"mapped",[21776]],[[194627,194627],"mapped",[21843]],[[194628,194628],"mapped",[21859]],[[194629,194630],"mapped",[21892]],[[194631,194631],"mapped",[21913]],[[194632,194632],"mapped",[21931]],[[194633,194633],"mapped",[21939]],[[194634,194634],"mapped",[21954]],[[194635,194635],"mapped",[22294]],[[194636,194636],"mapped",[22022]],[[194637,194637],"mapped",[22295]],[[194638,194638],"mapped",[22097]],[[194639,194639],"mapped",[22132]],[[194640,194640],"mapped",[20999]],[[194641,194641],"mapped",[22766]],[[194642,194642],"mapped",[22478]],[[194643,194643],"mapped",[22516]],[[194644,194644],"mapped",[22541]],[[194645,194645],"mapped",[22411]],[[194646,194646],"mapped",[22578]],[[194647,194647],"mapped",[22577]],[[194648,194648],"mapped",[22700]],[[194649,194649],"mapped",[136420]],[[194650,194650],"mapped",[22770]],[[194651,194651],"mapped",[22775]],[[194652,194652],"mapped",[22790]],[[194653,194653],"mapped",[22810]],[[194654,194654],"mapped",[22818]],[[194655,194655],"mapped",[22882]],[[194656,194656],"mapped",[136872]],[[194657,194657],"mapped",[136938]],[[194658,194658],"mapped",[23020]],[[194659,194659],"mapped",[23067]],[[194660,194660],"mapped",[23079]],[[194661,194661],"mapped",[23000]],[[194662,194662],"mapped",[23142]],[[194663,194663],"mapped",[14062]],[[194664,194664],"disallowed"],[[194665,194665],"mapped",[23304]],[[194666,194667],"mapped",[23358]],[[194668,194668],"mapped",[137672]],[[194669,194669],"mapped",[23491]],[[194670,194670],"mapped",[23512]],[[194671,194671],"mapped",[23527]],[[194672,194672],"mapped",[23539]],[[194673,194673],"mapped",[138008]],[[194674,194674],"mapped",[23551]],[[194675,194675],"mapped",[23558]],[[194676,194676],"disallowed"],[[194677,194677],"mapped",[23586]],[[194678,194678],"mapped",[14209]],[[194679,194679],"mapped",[23648]],[[194680,194680],"mapped",[23662]],[[194681,194681],"mapped",[23744]],[[194682,194682],"mapped",[23693]],[[194683,194683],"mapped",[138724]],[[194684,194684],"mapped",[23875]],[[194685,194685],"mapped",[138726]],[[194686,194686],"mapped",[23918]],[[194687,194687],"mapped",[23915]],[[194688,194688],"mapped",[23932]],[[194689,194689],"mapped",[24033]],[[194690,194690],"mapped",[24034]],[[194691,194691],"mapped",[14383]],[[194692,194692],"mapped",[24061]],[[194693,194693],"mapped",[24104]],[[194694,194694],"mapped",[24125]],[[194695,194695],"mapped",[24169]],[[194696,194696],"mapped",[14434]],[[194697,194697],"mapped",[139651]],[[194698,194698],"mapped",[14460]],[[194699,194699],"mapped",[24240]],[[194700,194700],"mapped",[24243]],[[194701,194701],"mapped",[24246]],[[194702,194702],"mapped",[24266]],[[194703,194703],"mapped",[172946]],[[194704,194704],"mapped",[24318]],[[194705,194706],"mapped",[140081]],[[194707,194707],"mapped",[33281]],[[194708,194709],"mapped",[24354]],[[194710,194710],"mapped",[14535]],[[194711,194711],"mapped",[144056]],[[194712,194712],"mapped",[156122]],[[194713,194713],"mapped",[24418]],[[194714,194714],"mapped",[24427]],[[194715,194715],"mapped",[14563]],[[194716,194716],"mapped",[24474]],[[194717,194717],"mapped",[24525]],[[194718,194718],"mapped",[24535]],[[194719,194719],"mapped",[24569]],[[194720,194720],"mapped",[24705]],[[194721,194721],"mapped",[14650]],[[194722,194722],"mapped",[14620]],[[194723,194723],"mapped",[24724]],[[194724,194724],"mapped",[141012]],[[194725,194725],"mapped",[24775]],[[194726,194726],"mapped",[24904]],[[194727,194727],"mapped",[24908]],[[194728,194728],"mapped",[24910]],[[194729,194729],"mapped",[24908]],[[194730,194730],"mapped",[24954]],[[194731,194731],"mapped",[24974]],[[194732,194732],"mapped",[25010]],[[194733,194733],"mapped",[24996]],[[194734,194734],"mapped",[25007]],[[194735,194735],"mapped",[25054]],[[194736,194736],"mapped",[25074]],[[194737,194737],"mapped",[25078]],[[194738,194738],"mapped",[25104]],[[194739,194739],"mapped",[25115]],[[194740,194740],"mapped",[25181]],[[194741,194741],"mapped",[25265]],[[194742,194742],"mapped",[25300]],[[194743,194743],"mapped",[25424]],[[194744,194744],"mapped",[142092]],[[194745,194745],"mapped",[25405]],[[194746,194746],"mapped",[25340]],[[194747,194747],"mapped",[25448]],[[194748,194748],"mapped",[25475]],[[194749,194749],"mapped",[25572]],[[194750,194750],"mapped",[142321]],[[194751,194751],"mapped",[25634]],[[194752,194752],"mapped",[25541]],[[194753,194753],"mapped",[25513]],[[194754,194754],"mapped",[14894]],[[194755,194755],"mapped",[25705]],[[194756,194756],"mapped",[25726]],[[194757,194757],"mapped",[25757]],[[194758,194758],"mapped",[25719]],[[194759,194759],"mapped",[14956]],[[194760,194760],"mapped",[25935]],[[194761,194761],"mapped",[25964]],[[194762,194762],"mapped",[143370]],[[194763,194763],"mapped",[26083]],[[194764,194764],"mapped",[26360]],[[194765,194765],"mapped",[26185]],[[194766,194766],"mapped",[15129]],[[194767,194767],"mapped",[26257]],[[194768,194768],"mapped",[15112]],[[194769,194769],"mapped",[15076]],[[194770,194770],"mapped",[20882]],[[194771,194771],"mapped",[20885]],[[194772,194772],"mapped",[26368]],[[194773,194773],"mapped",[26268]],[[194774,194774],"mapped",[32941]],[[194775,194775],"mapped",[17369]],[[194776,194776],"mapped",[26391]],[[194777,194777],"mapped",[26395]],[[194778,194778],"mapped",[26401]],[[194779,194779],"mapped",[26462]],[[194780,194780],"mapped",[26451]],[[194781,194781],"mapped",[144323]],[[194782,194782],"mapped",[15177]],[[194783,194783],"mapped",[26618]],[[194784,194784],"mapped",[26501]],[[194785,194785],"mapped",[26706]],[[194786,194786],"mapped",[26757]],[[194787,194787],"mapped",[144493]],[[194788,194788],"mapped",[26766]],[[194789,194789],"mapped",[26655]],[[194790,194790],"mapped",[26900]],[[194791,194791],"mapped",[15261]],[[194792,194792],"mapped",[26946]],[[194793,194793],"mapped",[27043]],[[194794,194794],"mapped",[27114]],[[194795,194795],"mapped",[27304]],[[194796,194796],"mapped",[145059]],[[194797,194797],"mapped",[27355]],[[194798,194798],"mapped",[15384]],[[194799,194799],"mapped",[27425]],[[194800,194800],"mapped",[145575]],[[194801,194801],"mapped",[27476]],[[194802,194802],"mapped",[15438]],[[194803,194803],"mapped",[27506]],[[194804,194804],"mapped",[27551]],[[194805,194805],"mapped",[27578]],[[194806,194806],"mapped",[27579]],[[194807,194807],"mapped",[146061]],[[194808,194808],"mapped",[138507]],[[194809,194809],"mapped",[146170]],[[194810,194810],"mapped",[27726]],[[194811,194811],"mapped",[146620]],[[194812,194812],"mapped",[27839]],[[194813,194813],"mapped",[27853]],[[194814,194814],"mapped",[27751]],[[194815,194815],"mapped",[27926]],[[194816,194816],"mapped",[27966]],[[194817,194817],"mapped",[28023]],[[194818,194818],"mapped",[27969]],[[194819,194819],"mapped",[28009]],[[194820,194820],"mapped",[28024]],[[194821,194821],"mapped",[28037]],[[194822,194822],"mapped",[146718]],[[194823,194823],"mapped",[27956]],[[194824,194824],"mapped",[28207]],[[194825,194825],"mapped",[28270]],[[194826,194826],"mapped",[15667]],[[194827,194827],"mapped",[28363]],[[194828,194828],"mapped",[28359]],[[194829,194829],"mapped",[147153]],[[194830,194830],"mapped",[28153]],[[194831,194831],"mapped",[28526]],[[194832,194832],"mapped",[147294]],[[194833,194833],"mapped",[147342]],[[194834,194834],"mapped",[28614]],[[194835,194835],"mapped",[28729]],[[194836,194836],"mapped",[28702]],[[194837,194837],"mapped",[28699]],[[194838,194838],"mapped",[15766]],[[194839,194839],"mapped",[28746]],[[194840,194840],"mapped",[28797]],[[194841,194841],"mapped",[28791]],[[194842,194842],"mapped",[28845]],[[194843,194843],"mapped",[132389]],[[194844,194844],"mapped",[28997]],[[194845,194845],"mapped",[148067]],[[194846,194846],"mapped",[29084]],[[194847,194847],"disallowed"],[[194848,194848],"mapped",[29224]],[[194849,194849],"mapped",[29237]],[[194850,194850],"mapped",[29264]],[[194851,194851],"mapped",[149000]],[[194852,194852],"mapped",[29312]],[[194853,194853],"mapped",[29333]],[[194854,194854],"mapped",[149301]],[[194855,194855],"mapped",[149524]],[[194856,194856],"mapped",[29562]],[[194857,194857],"mapped",[29579]],[[194858,194858],"mapped",[16044]],[[194859,194859],"mapped",[29605]],[[194860,194861],"mapped",[16056]],[[194862,194862],"mapped",[29767]],[[194863,194863],"mapped",[29788]],[[194864,194864],"mapped",[29809]],[[194865,194865],"mapped",[29829]],[[194866,194866],"mapped",[29898]],[[194867,194867],"mapped",[16155]],[[194868,194868],"mapped",[29988]],[[194869,194869],"mapped",[150582]],[[194870,194870],"mapped",[30014]],[[194871,194871],"mapped",[150674]],[[194872,194872],"mapped",[30064]],[[194873,194873],"mapped",[139679]],[[194874,194874],"mapped",[30224]],[[194875,194875],"mapped",[151457]],[[194876,194876],"mapped",[151480]],[[194877,194877],"mapped",[151620]],[[194878,194878],"mapped",[16380]],[[194879,194879],"mapped",[16392]],[[194880,194880],"mapped",[30452]],[[194881,194881],"mapped",[151795]],[[194882,194882],"mapped",[151794]],[[194883,194883],"mapped",[151833]],[[194884,194884],"mapped",[151859]],[[194885,194885],"mapped",[30494]],[[194886,194887],"mapped",[30495]],[[194888,194888],"mapped",[30538]],[[194889,194889],"mapped",[16441]],[[194890,194890],"mapped",[30603]],[[194891,194891],"mapped",[16454]],[[194892,194892],"mapped",[16534]],[[194893,194893],"mapped",[152605]],[[194894,194894],"mapped",[30798]],[[194895,194895],"mapped",[30860]],[[194896,194896],"mapped",[30924]],[[194897,194897],"mapped",[16611]],[[194898,194898],"mapped",[153126]],[[194899,194899],"mapped",[31062]],[[194900,194900],"mapped",[153242]],[[194901,194901],"mapped",[153285]],[[194902,194902],"mapped",[31119]],[[194903,194903],"mapped",[31211]],[[194904,194904],"mapped",[16687]],[[194905,194905],"mapped",[31296]],[[194906,194906],"mapped",[31306]],[[194907,194907],"mapped",[31311]],[[194908,194908],"mapped",[153980]],[[194909,194910],"mapped",[154279]],[[194911,194911],"disallowed"],[[194912,194912],"mapped",[16898]],[[194913,194913],"mapped",[154539]],[[194914,194914],"mapped",[31686]],[[194915,194915],"mapped",[31689]],[[194916,194916],"mapped",[16935]],[[194917,194917],"mapped",[154752]],[[194918,194918],"mapped",[31954]],[[194919,194919],"mapped",[17056]],[[194920,194920],"mapped",[31976]],[[194921,194921],"mapped",[31971]],[[194922,194922],"mapped",[32000]],[[194923,194923],"mapped",[155526]],[[194924,194924],"mapped",[32099]],[[194925,194925],"mapped",[17153]],[[194926,194926],"mapped",[32199]],[[194927,194927],"mapped",[32258]],[[194928,194928],"mapped",[32325]],[[194929,194929],"mapped",[17204]],[[194930,194930],"mapped",[156200]],[[194931,194931],"mapped",[156231]],[[194932,194932],"mapped",[17241]],[[194933,194933],"mapped",[156377]],[[194934,194934],"mapped",[32634]],[[194935,194935],"mapped",[156478]],[[194936,194936],"mapped",[32661]],[[194937,194937],"mapped",[32762]],[[194938,194938],"mapped",[32773]],[[194939,194939],"mapped",[156890]],[[194940,194940],"mapped",[156963]],[[194941,194941],"mapped",[32864]],[[194942,194942],"mapped",[157096]],[[194943,194943],"mapped",[32880]],[[194944,194944],"mapped",[144223]],[[194945,194945],"mapped",[17365]],[[194946,194946],"mapped",[32946]],[[194947,194947],"mapped",[33027]],[[194948,194948],"mapped",[17419]],[[194949,194949],"mapped",[33086]],[[194950,194950],"mapped",[23221]],[[194951,194951],"mapped",[157607]],[[194952,194952],"mapped",[157621]],[[194953,194953],"mapped",[144275]],[[194954,194954],"mapped",[144284]],[[194955,194955],"mapped",[33281]],[[194956,194956],"mapped",[33284]],[[194957,194957],"mapped",[36766]],[[194958,194958],"mapped",[17515]],[[194959,194959],"mapped",[33425]],[[194960,194960],"mapped",[33419]],[[194961,194961],"mapped",[33437]],[[194962,194962],"mapped",[21171]],[[194963,194963],"mapped",[33457]],[[194964,194964],"mapped",[33459]],[[194965,194965],"mapped",[33469]],[[194966,194966],"mapped",[33510]],[[194967,194967],"mapped",[158524]],[[194968,194968],"mapped",[33509]],[[194969,194969],"mapped",[33565]],[[194970,194970],"mapped",[33635]],[[194971,194971],"mapped",[33709]],[[194972,194972],"mapped",[33571]],[[194973,194973],"mapped",[33725]],[[194974,194974],"mapped",[33767]],[[194975,194975],"mapped",[33879]],[[194976,194976],"mapped",[33619]],[[194977,194977],"mapped",[33738]],[[194978,194978],"mapped",[33740]],[[194979,194979],"mapped",[33756]],[[194980,194980],"mapped",[158774]],[[194981,194981],"mapped",[159083]],[[194982,194982],"mapped",[158933]],[[194983,194983],"mapped",[17707]],[[194984,194984],"mapped",[34033]],[[194985,194985],"mapped",[34035]],[[194986,194986],"mapped",[34070]],[[194987,194987],"mapped",[160714]],[[194988,194988],"mapped",[34148]],[[194989,194989],"mapped",[159532]],[[194990,194990],"mapped",[17757]],[[194991,194991],"mapped",[17761]],[[194992,194992],"mapped",[159665]],[[194993,194993],"mapped",[159954]],[[194994,194994],"mapped",[17771]],[[194995,194995],"mapped",[34384]],[[194996,194996],"mapped",[34396]],[[194997,194997],"mapped",[34407]],[[194998,194998],"mapped",[34409]],[[194999,194999],"mapped",[34473]],[[195000,195000],"mapped",[34440]],[[195001,195001],"mapped",[34574]],[[195002,195002],"mapped",[34530]],[[195003,195003],"mapped",[34681]],[[195004,195004],"mapped",[34600]],[[195005,195005],"mapped",[34667]],[[195006,195006],"mapped",[34694]],[[195007,195007],"disallowed"],[[195008,195008],"mapped",[34785]],[[195009,195009],"mapped",[34817]],[[195010,195010],"mapped",[17913]],[[195011,195011],"mapped",[34912]],[[195012,195012],"mapped",[34915]],[[195013,195013],"mapped",[161383]],[[195014,195014],"mapped",[35031]],[[195015,195015],"mapped",[35038]],[[195016,195016],"mapped",[17973]],[[195017,195017],"mapped",[35066]],[[195018,195018],"mapped",[13499]],[[195019,195019],"mapped",[161966]],[[195020,195020],"mapped",[162150]],[[195021,195021],"mapped",[18110]],[[195022,195022],"mapped",[18119]],[[195023,195023],"mapped",[35488]],[[195024,195024],"mapped",[35565]],[[195025,195025],"mapped",[35722]],[[195026,195026],"mapped",[35925]],[[195027,195027],"mapped",[162984]],[[195028,195028],"mapped",[36011]],[[195029,195029],"mapped",[36033]],[[195030,195030],"mapped",[36123]],[[195031,195031],"mapped",[36215]],[[195032,195032],"mapped",[163631]],[[195033,195033],"mapped",[133124]],[[195034,195034],"mapped",[36299]],[[195035,195035],"mapped",[36284]],[[195036,195036],"mapped",[36336]],[[195037,195037],"mapped",[133342]],[[195038,195038],"mapped",[36564]],[[195039,195039],"mapped",[36664]],[[195040,195040],"mapped",[165330]],[[195041,195041],"mapped",[165357]],[[195042,195042],"mapped",[37012]],[[195043,195043],"mapped",[37105]],[[195044,195044],"mapped",[37137]],[[195045,195045],"mapped",[165678]],[[195046,195046],"mapped",[37147]],[[195047,195047],"mapped",[37432]],[[195048,195048],"mapped",[37591]],[[195049,195049],"mapped",[37592]],[[195050,195050],"mapped",[37500]],[[195051,195051],"mapped",[37881]],[[195052,195052],"mapped",[37909]],[[195053,195053],"mapped",[166906]],[[195054,195054],"mapped",[38283]],[[195055,195055],"mapped",[18837]],[[195056,195056],"mapped",[38327]],[[195057,195057],"mapped",[167287]],[[195058,195058],"mapped",[18918]],[[195059,195059],"mapped",[38595]],[[195060,195060],"mapped",[23986]],[[195061,195061],"mapped",[38691]],[[195062,195062],"mapped",[168261]],[[195063,195063],"mapped",[168474]],[[195064,195064],"mapped",[19054]],[[195065,195065],"mapped",[19062]],[[195066,195066],"mapped",[38880]],[[195067,195067],"mapped",[168970]],[[195068,195068],"mapped",[19122]],[[195069,195069],"mapped",[169110]],[[195070,195071],"mapped",[38923]],[[195072,195072],"mapped",[38953]],[[195073,195073],"mapped",[169398]],[[195074,195074],"mapped",[39138]],[[195075,195075],"mapped",[19251]],[[195076,195076],"mapped",[39209]],[[195077,195077],"mapped",[39335]],[[195078,195078],"mapped",[39362]],[[195079,195079],"mapped",[39422]],[[195080,195080],"mapped",[19406]],[[195081,195081],"mapped",[170800]],[[195082,195082],"mapped",[39698]],[[195083,195083],"mapped",[40000]],[[195084,195084],"mapped",[40189]],[[195085,195085],"mapped",[19662]],[[195086,195086],"mapped",[19693]],[[195087,195087],"mapped",[40295]],[[195088,195088],"mapped",[172238]],[[195089,195089],"mapped",[19704]],[[195090,195090],"mapped",[172293]],[[195091,195091],"mapped",[172558]],[[195092,195092],"mapped",[172689]],[[195093,195093],"mapped",[40635]],[[195094,195094],"mapped",[19798]],[[195095,195095],"mapped",[40697]],[[195096,195096],"mapped",[40702]],[[195097,195097],"mapped",[40709]],[[195098,195098],"mapped",[40719]],[[195099,195099],"mapped",[40726]],[[195100,195100],"mapped",[40763]],[[195101,195101],"mapped",[173568]],[[195102,196605],"disallowed"],[[196606,196607],"disallowed"],[[196608,262141],"disallowed"],[[262142,262143],"disallowed"],[[262144,327677],"disallowed"],[[327678,327679],"disallowed"],[[327680,393213],"disallowed"],[[393214,393215],"disallowed"],[[393216,458749],"disallowed"],[[458750,458751],"disallowed"],[[458752,524285],"disallowed"],[[524286,524287],"disallowed"],[[524288,589821],"disallowed"],[[589822,589823],"disallowed"],[[589824,655357],"disallowed"],[[655358,655359],"disallowed"],[[655360,720893],"disallowed"],[[720894,720895],"disallowed"],[[720896,786429],"disallowed"],[[786430,786431],"disallowed"],[[786432,851965],"disallowed"],[[851966,851967],"disallowed"],[[851968,917501],"disallowed"],[[917502,917503],"disallowed"],[[917504,917504],"disallowed"],[[917505,917505],"disallowed"],[[917506,917535],"disallowed"],[[917536,917631],"disallowed"],[[917632,917759],"disallowed"],[[917760,917999],"ignored"],[[918000,983037],"disallowed"],[[983038,983039],"disallowed"],[[983040,1048573],"disallowed"],[[1048574,1048575],"disallowed"],[[1048576,1114109],"disallowed"],[[1114110,1114111],"disallowed"]]'))},66636,(a,b,c)=>{"use strict";var d=a.r(992097),e=a.r(545736),f={TRANSITIONAL:0,NONTRANSITIONAL:1};function g(a){return a.split("\0").map(function(a){return a.normalize("NFC")}).join("\0")}function h(a){for(var b=0,c=e.length-1;b<=c;){var d=Math.floor((b+c)/2),f=e[d];if(f[0][0]<=a&&f[0][1]>=a)return f;f[0][0]>a?c=d-1:b=d+1}return null}var i=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g;function j(a){return a.replace(i,"_").length}var k=/[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;function l(a,b,c){var e=function(a,b,c){for(var d=!1,e="",g=j(a),i=0;i<g;++i){var k=a.codePointAt(i),l=h(k);switch(l[1]){case"disallowed":d=!0,e+=String.fromCodePoint(k);break;case"ignored":break;case"mapped":e+=String.fromCodePoint.apply(String,l[2]);break;case"deviation":c===f.TRANSITIONAL?e+=String.fromCodePoint.apply(String,l[2]):e+=String.fromCodePoint(k);break;case"valid":e+=String.fromCodePoint(k);break;case"disallowed_STD3_mapped":b?(d=!0,e+=String.fromCodePoint(k)):e+=String.fromCodePoint.apply(String,l[2]);break;case"disallowed_STD3_valid":b&&(d=!0),e+=String.fromCodePoint(k)}}return{string:e,error:d}}(a,b,c);e.string=g(e.string);for(var i=e.string.split("."),m=0;m<i.length;++m)try{var n=function(a,b){"xn--"===a.substr(0,4)&&(a=d.toUnicode(a),f.NONTRANSITIONAL);var c=!1;(g(a)!==a||"-"===a[3]&&"-"===a[4]||"-"===a[0]||"-"===a[a.length-1]||-1!==a.indexOf(".")||0===a.search(k))&&(c=!0);for(var e=j(a),i=0;i<e;++i){var m=h(a.codePointAt(i));if(l===f.TRANSITIONAL&&"valid"!==m[1]||l===f.NONTRANSITIONAL&&"valid"!==m[1]&&"deviation"!==m[1]){c=!0;break}}return{label:a,error:c}}(i[m]);i[m]=n.label,e.error=e.error||n.error}catch(a){e.error=!0}return{string:i.join("."),error:e.error}}b.exports.toASCII=function(a,b,c,e){var f=l(a,b,c),g=f.string.split(".");if(g=g.map(function(a){try{return d.toASCII(a)}catch(b){return f.error=!0,a}}),e){var h=g.slice(0,g.length-1).join(".").length;(h.length>253||0===h.length)&&(f.error=!0);for(var i=0;i<g.length;++i)if(g.length>63||0===g.length){f.error=!0;break}}return f.error?null:g.join(".")},b.exports.toUnicode=function(a,b){var c=l(a,b,f.NONTRANSITIONAL);return{domain:c.string,error:c.error}},b.exports.PROCESSING_OPTIONS=f},381853,(a,b,c)=>{"use strict";let d=a.r(992097),e=a.r(66636),f={ftp:21,file:null,gopher:70,http:80,https:443,ws:80,wss:443},g=Symbol("failure");function h(a){return d.ucs2.decode(a).length}function i(a,b){let c=a[b];return isNaN(c)?void 0:String.fromCodePoint(c)}function j(a){return a>=48&&a<=57}function k(a){return a>=65&&a<=90||a>=97&&a<=122}function l(a){return j(a)||a>=65&&a<=70||a>=97&&a<=102}function m(a){return"."===a||"%2e"===a.toLowerCase()}function n(a){return 2===a.length&&k(a.codePointAt(0))&&(":"===a[1]||"|"===a[1])}function o(a){return void 0!==f[a]}function p(a){return o(a.scheme)}function q(a){let b=a.toString(16).toUpperCase();return 1===b.length&&(b="0"+b),"%"+b}function r(a){return a<=31||a>126}let s=new Set([32,34,35,60,62,63,96,123,125]);function t(a){return r(a)||s.has(a)}let u=new Set([47,58,59,61,64,91,92,93,94,124]);function v(a){return t(a)||u.has(a)}function w(a,b){let c=String.fromCodePoint(a);if(b(a)){let a=new Buffer(c),b="";for(let c=0;c<a.length;++c)b+=q(a[c]);return b}return c}function x(a,b){if("["===a[0])return"]"!==a[a.length-1]?g:function(a){let b=[0,0,0,0,0,0,0,0],c=0,e=null,f=0;if(58===(a=d.ucs2.decode(a))[f]){if(58!==a[f+1])return g;f+=2,e=++c}for(;f<a.length;){if(8===c)return g;if(58===a[f]){if(null!==e)return g;++f,e=++c;continue}let d=0,h=0;for(;h<4&&l(a[f]);)d=16*d+parseInt(i(a,f),16),++f,++h;if(46===a[f]){if(0===h||(f-=h,c>6))return g;let d=0;for(;void 0!==a[f];){let e=null;if(d>0)if(46!==a[f]||!(d<4))return g;else++f;if(!j(a[f]))return g;for(;j(a[f]);){let b=parseInt(i(a,f));if(null===e)e=b;else{if(0===e)return g;e=10*e+b}if(e>255)return g;++f}b[c]=256*b[c]+e,(2==++d||4===d)&&++c}if(4!==d)return g;break}if(58===a[f]){if(void 0===a[++f])return g}else if(void 0!==a[f])return g;b[c]=d,++c}if(null!==e){let a=c-e;for(c=7;0!==c&&a>0;){let d=b[e+a-1];b[e+a-1]=b[c],b[c]=d,--c,--a}}else if(null===e&&8!==c)return g;return b}(a.substring(1,a.length-1));if(!b){var c=a;if(-1!==c.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/))return g;let b="",e=d.ucs2.decode(c);for(let a=0;a<e.length;++a)b+=w(e[a],r);return b}let f=function(a){let b=new Buffer(a),c=[];for(let a=0;a<b.length;++a)37!==b[a]?c.push(b[a]):37===b[a]&&l(b[a+1])&&l(b[a+2])?(c.push(parseInt(b.slice(a+1,a+3).toString(),16)),a+=2):c.push(b[a]);return new Buffer(c).toString()}(a),h=e.toASCII(f,!1,e.PROCESSING_OPTIONS.NONTRANSITIONAL,!1);if(null===h||-1!==h.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/))return g;let k=function(a){let b=a.split(".");if(""===b[b.length-1]&&b.length>1&&b.pop(),b.length>4)return a;let c=[];for(let d of b){if(""===d)return a;let b=function(a){let b=10;return(a.length>=2&&"0"===a.charAt(0)&&"x"===a.charAt(1).toLowerCase()?(a=a.substring(2),b=16):a.length>=2&&"0"===a.charAt(0)&&(a=a.substring(1),b=8),""===a)?0:(10===b?/[^0-9]/:16===b?/[^0-9A-Fa-f]/:/[^0-7]/).test(a)?g:parseInt(a,b)}(d);if(b===g)return a;c.push(b)}for(let a=0;a<c.length-1;++a)if(c[a]>255)return g;if(c[c.length-1]>=Math.pow(256,5-c.length))return g;let d=c.pop(),e=0;for(let a of c)d+=a*Math.pow(256,3-e),++e;return d}(h);return"number"==typeof k||k===g?k:h}function y(a){if("number"==typeof a){let b="",c=a;for(let a=1;a<=4;++a)b=String(c%256)+b,4!==a&&(b="."+b),c=Math.floor(c/256);return b}return a instanceof Array?"["+function(a){let b="",c=function(a){let b=null,c=1,d=null,e=0;for(let f=0;f<a.length;++f)0!==a[f]?(e>c&&(b=d,c=e),d=null,e=0):(null===d&&(d=f),++e);return e>c&&(b=d,c=e),{idx:b,len:c}}(a).idx,d=!1;for(let e=0;e<=7;++e)if(!d||0!==a[e]){if(d&&(d=!1),c===e){b+=0===e?"::":":",d=!0;continue}b+=a[e].toString(16),7!==e&&(b+=":")}return b}(a)+"]":a}function z(a){var b;let c=a.path;0===c.length||"file"===a.scheme&&1===c.length&&(b=c[0],/^[A-Za-z]:$/.test(b))||c.pop()}function A(a){return""!==a.username||""!==a.password}function B(a,b,c,e,f){if(this.pointer=0,this.input=a,this.base=b||null,this.encodingOverride=c||"utf-8",this.stateOverride=f,this.url=e,this.failure=!1,this.parseError=!1,!this.url){this.url={scheme:"",username:"",password:"",host:null,port:null,path:[],query:null,fragment:null,cannotBeABaseURL:!1};let a=this.input.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g,"");a!==this.input&&(this.parseError=!0),this.input=a}let h=this.input.replace(/\u0009|\u000A|\u000D/g,"");for(h!==this.input&&(this.parseError=!0),this.input=h,this.state=f||"scheme start",this.buffer="",this.atFlag=!1,this.arrFlag=!1,this.passwordTokenSeenFlag=!1,this.input=d.ucs2.decode(this.input);this.pointer<=this.input.length;++this.pointer){let a=this.input[this.pointer],b=isNaN(a)?void 0:String.fromCodePoint(a),c=this["parse "+this.state](a,b);if(c){if(c===g){this.failure=!0;break}}else break}}B.prototype["parse scheme start"]=function(a,b){if(k(a))this.buffer+=b.toLowerCase(),this.state="scheme";else{if(this.stateOverride)return this.parseError=!0,g;this.state="no scheme",--this.pointer}return!0},B.prototype["parse scheme"]=function(a,b){if(k(a)||j(a)||43===a||45===a||46===a)this.buffer+=b.toLowerCase();else if(58===a){if(this.stateOverride&&(p(this.url)&&!o(this.buffer)||!p(this.url)&&o(this.buffer)||(A(this.url)||null!==this.url.port)&&"file"===this.buffer||"file"===this.url.scheme&&(""===this.url.host||null===this.url.host))||(this.url.scheme=this.buffer,this.buffer="",this.stateOverride))return!1;"file"===this.url.scheme?((47!==this.input[this.pointer+1]||47!==this.input[this.pointer+2])&&(this.parseError=!0),this.state="file"):p(this.url)&&null!==this.base&&this.base.scheme===this.url.scheme?this.state="special relative or authority":p(this.url)?this.state="special authority slashes":47===this.input[this.pointer+1]?(this.state="path or authority",++this.pointer):(this.url.cannotBeABaseURL=!0,this.url.path.push(""),this.state="cannot-be-a-base-URL path")}else{if(this.stateOverride)return this.parseError=!0,g;this.buffer="",this.state="no scheme",this.pointer=-1}return!0},B.prototype["parse no scheme"]=function(a){return null===this.base||this.base.cannotBeABaseURL&&35!==a?g:(this.base.cannotBeABaseURL&&35===a?(this.url.scheme=this.base.scheme,this.url.path=this.base.path.slice(),this.url.query=this.base.query,this.url.fragment="",this.url.cannotBeABaseURL=!0,this.state="fragment"):("file"===this.base.scheme?this.state="file":this.state="relative",--this.pointer),!0)},B.prototype["parse special relative or authority"]=function(a){return 47===a&&47===this.input[this.pointer+1]?(this.state="special authority ignore slashes",++this.pointer):(this.parseError=!0,this.state="relative",--this.pointer),!0},B.prototype["parse path or authority"]=function(a){return 47===a?this.state="authority":(this.state="path",--this.pointer),!0},B.prototype["parse relative"]=function(a){return this.url.scheme=this.base.scheme,isNaN(a)?(this.url.username=this.base.username,this.url.password=this.base.password,this.url.host=this.base.host,this.url.port=this.base.port,this.url.path=this.base.path.slice(),this.url.query=this.base.query):47===a?this.state="relative slash":63===a?(this.url.username=this.base.username,this.url.password=this.base.password,this.url.host=this.base.host,this.url.port=this.base.port,this.url.path=this.base.path.slice(),this.url.query="",this.state="query"):35===a?(this.url.username=this.base.username,this.url.password=this.base.password,this.url.host=this.base.host,this.url.port=this.base.port,this.url.path=this.base.path.slice(),this.url.query=this.base.query,this.url.fragment="",this.state="fragment"):p(this.url)&&92===a?(this.parseError=!0,this.state="relative slash"):(this.url.username=this.base.username,this.url.password=this.base.password,this.url.host=this.base.host,this.url.port=this.base.port,this.url.path=this.base.path.slice(0,this.base.path.length-1),this.state="path",--this.pointer),!0},B.prototype["parse relative slash"]=function(a){return p(this.url)&&(47===a||92===a)?(92===a&&(this.parseError=!0),this.state="special authority ignore slashes"):47===a?this.state="authority":(this.url.username=this.base.username,this.url.password=this.base.password,this.url.host=this.base.host,this.url.port=this.base.port,this.state="path",--this.pointer),!0},B.prototype["parse special authority slashes"]=function(a){return 47===a&&47===this.input[this.pointer+1]?(this.state="special authority ignore slashes",++this.pointer):(this.parseError=!0,this.state="special authority ignore slashes",--this.pointer),!0},B.prototype["parse special authority ignore slashes"]=function(a){return 47!==a&&92!==a?(this.state="authority",--this.pointer):this.parseError=!0,!0},B.prototype["parse authority"]=function(a,b){if(64===a){this.parseError=!0,this.atFlag&&(this.buffer="%40"+this.buffer),this.atFlag=!0;let a=h(this.buffer);for(let b=0;b<a;++b){let a=this.buffer.codePointAt(b);if(58===a&&!this.passwordTokenSeenFlag){this.passwordTokenSeenFlag=!0;continue}let c=w(a,v);this.passwordTokenSeenFlag?this.url.password+=c:this.url.username+=c}this.buffer=""}else if(isNaN(a)||47===a||63===a||35===a||p(this.url)&&92===a){if(this.atFlag&&""===this.buffer)return this.parseError=!0,g;this.pointer-=h(this.buffer)+1,this.buffer="",this.state="host"}else this.buffer+=b;return!0},B.prototype["parse hostname"]=B.prototype["parse host"]=function(a,b){if(this.stateOverride&&"file"===this.url.scheme)--this.pointer,this.state="file host";else if(58!==a||this.arrFlag)if(isNaN(a)||47===a||63===a||35===a||p(this.url)&&92===a){if(--this.pointer,p(this.url)&&""===this.buffer)return this.parseError=!0,g;if(this.stateOverride&&""===this.buffer&&(A(this.url)||null!==this.url.port))return this.parseError=!0,!1;let a=x(this.buffer,p(this.url));if(a===g)return g;if(this.url.host=a,this.buffer="",this.state="path start",this.stateOverride)return!1}else 91===a?this.arrFlag=!0:93===a&&(this.arrFlag=!1),this.buffer+=b;else{if(""===this.buffer)return this.parseError=!0,g;let a=x(this.buffer,p(this.url));if(a===g)return g;if(this.url.host=a,this.buffer="",this.state="port","hostname"===this.stateOverride)return!1}return!0},B.prototype["parse port"]=function(a,b){if(j(a))this.buffer+=b;else{if(!(isNaN(a)||47===a||63===a||35===a||p(this.url)&&92===a)&&!this.stateOverride)return this.parseError=!0,g;if(""!==this.buffer){let a=parseInt(this.buffer);if(a>65535)return this.parseError=!0,g;this.url.port=a===f[this.url.scheme]?null:a,this.buffer=""}if(this.stateOverride)return!1;this.state="path start",--this.pointer}return!0};let C=new Set([47,92,63,35]);B.prototype["parse file"]=function(a){if(this.url.scheme="file",47===a||92===a)92===a&&(this.parseError=!0),this.state="file slash";else if(null!==this.base&&"file"===this.base.scheme)if(isNaN(a))this.url.host=this.base.host,this.url.path=this.base.path.slice(),this.url.query=this.base.query;else if(63===a)this.url.host=this.base.host,this.url.path=this.base.path.slice(),this.url.query="",this.state="query";else if(35===a)this.url.host=this.base.host,this.url.path=this.base.path.slice(),this.url.query=this.base.query,this.url.fragment="",this.state="fragment";else{var b;this.input.length-this.pointer-1!=0&&(b=this.input[this.pointer+1],k(a)&&(58===b||124===b))&&(!(this.input.length-this.pointer-1>=2)||C.has(this.input[this.pointer+2]))?this.parseError=!0:(this.url.host=this.base.host,this.url.path=this.base.path.slice(),z(this.url)),this.state="path",--this.pointer}else this.state="path",--this.pointer;return!0},B.prototype["parse file slash"]=function(a){if(47===a||92===a)92===a&&(this.parseError=!0),this.state="file host";else{if(null!==this.base&&"file"===this.base.scheme){var b;2===(b=this.base.path[0]).length&&k(b.codePointAt(0))&&":"===b[1]?this.url.path.push(this.base.path[0]):this.url.host=this.base.host}this.state="path",--this.pointer}return!0},B.prototype["parse file host"]=function(a,b){if(isNaN(a)||47===a||92===a||63===a||35===a)if(--this.pointer,!this.stateOverride&&n(this.buffer))this.parseError=!0,this.state="path";else if(""===this.buffer){if(this.url.host="",this.stateOverride)return!1;this.state="path start"}else{let a=x(this.buffer,p(this.url));if(a===g)return g;if("localhost"===a&&(a=""),this.url.host=a,this.stateOverride)return!1;this.buffer="",this.state="path start"}else this.buffer+=b;return!0},B.prototype["parse path start"]=function(a){return p(this.url)?(92===a&&(this.parseError=!0),this.state="path",47!==a&&92!==a&&--this.pointer):this.stateOverride||63!==a?this.stateOverride||35!==a?void 0!==a&&(this.state="path",47!==a&&--this.pointer):(this.url.fragment="",this.state="fragment"):(this.url.query="",this.state="query"),!0},B.prototype["parse path"]=function(a){if(isNaN(a)||47===a||p(this.url)&&92===a||!this.stateOverride&&(63===a||35===a)){var b;if((p(this.url)&&92===a&&(this.parseError=!0),".."===(b=(b=this.buffer).toLowerCase())||"%2e."===b||".%2e"===b||"%2e%2e"===b)?(z(this.url),47===a||p(this.url)&&92===a||this.url.path.push("")):m(this.buffer)&&47!==a&&!(p(this.url)&&92===a)?this.url.path.push(""):m(this.buffer)||("file"===this.url.scheme&&0===this.url.path.length&&n(this.buffer)&&(""!==this.url.host&&null!==this.url.host&&(this.parseError=!0,this.url.host=""),this.buffer=this.buffer[0]+":"),this.url.path.push(this.buffer)),this.buffer="","file"===this.url.scheme&&(void 0===a||63===a||35===a))for(;this.url.path.length>1&&""===this.url.path[0];)this.parseError=!0,this.url.path.shift();63===a&&(this.url.query="",this.state="query"),35===a&&(this.url.fragment="",this.state="fragment")}else 37!==a||l(this.input[this.pointer+1])&&l(this.input[this.pointer+2])||(this.parseError=!0),this.buffer+=w(a,t);return!0},B.prototype["parse cannot-be-a-base-URL path"]=function(a){return 63===a?(this.url.query="",this.state="query"):35===a?(this.url.fragment="",this.state="fragment"):(isNaN(a)||37===a||(this.parseError=!0),37!==a||l(this.input[this.pointer+1])&&l(this.input[this.pointer+2])||(this.parseError=!0),isNaN(a)||(this.url.path[0]=this.url.path[0]+w(a,r))),!0},B.prototype["parse query"]=function(a,b){if(isNaN(a)||!this.stateOverride&&35===a){p(this.url)&&"ws"!==this.url.scheme&&"wss"!==this.url.scheme||(this.encodingOverride="utf-8");let b=new Buffer(this.buffer);for(let a=0;a<b.length;++a)b[a]<33||b[a]>126||34===b[a]||35===b[a]||60===b[a]||62===b[a]?this.url.query+=q(b[a]):this.url.query+=String.fromCodePoint(b[a]);this.buffer="",35===a&&(this.url.fragment="",this.state="fragment")}else 37!==a||l(this.input[this.pointer+1])&&l(this.input[this.pointer+2])||(this.parseError=!0),this.buffer+=b;return!0},B.prototype["parse fragment"]=function(a){return isNaN(a)||(0===a?this.parseError=!0:(37!==a||l(this.input[this.pointer+1])&&l(this.input[this.pointer+2])||(this.parseError=!0),this.url.fragment+=w(a,r))),!0},b.exports.serializeURL=function(a,b){let c=a.scheme+":";if(null!==a.host?(c+="//",(""!==a.username||""!==a.password)&&(c+=a.username,""!==a.password&&(c+=":"+a.password),c+="@"),c+=y(a.host),null!==a.port&&(c+=":"+a.port)):null===a.host&&"file"===a.scheme&&(c+="//"),a.cannotBeABaseURL)c+=a.path[0];else for(let b of a.path)c+="/"+b;return null!==a.query&&(c+="?"+a.query),b||null===a.fragment||(c+="#"+a.fragment),c},b.exports.serializeURLOrigin=function(a){switch(a.scheme){case"blob":try{return b.exports.serializeURLOrigin(b.exports.parseURL(a.path[0]))}catch(a){return"null"}case"ftp":case"gopher":case"http":case"https":case"ws":case"wss":var c;let d;return d=(c={scheme:a.scheme,host:a.host,port:a.port}).scheme+"://"+y(c.host),null!==c.port&&(d+=":"+c.port),d;case"file":return"file://";default:return"null"}},b.exports.basicURLParse=function(a,b){void 0===b&&(b={});let c=new B(a,b.baseURL,b.encodingOverride,b.url,b.stateOverride);return c.failure?"failure":c.url},b.exports.setTheUsername=function(a,b){a.username="";let c=d.ucs2.decode(b);for(let b=0;b<c.length;++b)a.username+=w(c[b],v)},b.exports.setThePassword=function(a,b){a.password="";let c=d.ucs2.decode(b);for(let b=0;b<c.length;++b)a.password+=w(c[b],v)},b.exports.serializeHost=y,b.exports.cannotHaveAUsernamePasswordPort=function(a){return null===a.host||""===a.host||a.cannotBeABaseURL||"file"===a.scheme},b.exports.serializeInteger=function(a){return String(a)},b.exports.parseURL=function(a,c){return void 0===c&&(c={}),b.exports.basicURLParse(a,{baseURL:c.baseURL,encodingOverride:c.encodingOverride})}},181046,(a,b,c)=>{"use strict";let d=a.r(381853);c.implementation=class{constructor(a){const b=a[0],c=a[1];let e=null;if(void 0!==c&&"failure"===(e=d.basicURLParse(c)))throw TypeError("Invalid base URL");const f=d.basicURLParse(b,{baseURL:e});if("failure"===f)throw TypeError("Invalid URL");this._url=f}get href(){return d.serializeURL(this._url)}set href(a){let b=d.basicURLParse(a);if("failure"===b)throw TypeError("Invalid URL");this._url=b}get origin(){return d.serializeURLOrigin(this._url)}get protocol(){return this._url.scheme+":"}set protocol(a){d.basicURLParse(a+":",{url:this._url,stateOverride:"scheme start"})}get username(){return this._url.username}set username(a){d.cannotHaveAUsernamePasswordPort(this._url)||d.setTheUsername(this._url,a)}get password(){return this._url.password}set password(a){d.cannotHaveAUsernamePasswordPort(this._url)||d.setThePassword(this._url,a)}get host(){let a=this._url;return null===a.host?"":null===a.port?d.serializeHost(a.host):d.serializeHost(a.host)+":"+d.serializeInteger(a.port)}set host(a){this._url.cannotBeABaseURL||d.basicURLParse(a,{url:this._url,stateOverride:"host"})}get hostname(){return null===this._url.host?"":d.serializeHost(this._url.host)}set hostname(a){this._url.cannotBeABaseURL||d.basicURLParse(a,{url:this._url,stateOverride:"hostname"})}get port(){return null===this._url.port?"":d.serializeInteger(this._url.port)}set port(a){d.cannotHaveAUsernamePasswordPort(this._url)||(""===a?this._url.port=null:d.basicURLParse(a,{url:this._url,stateOverride:"port"}))}get pathname(){return this._url.cannotBeABaseURL?this._url.path[0]:0===this._url.path.length?"":"/"+this._url.path.join("/")}set pathname(a){this._url.cannotBeABaseURL||(this._url.path=[],d.basicURLParse(a,{url:this._url,stateOverride:"path start"}))}get search(){return null===this._url.query||""===this._url.query?"":"?"+this._url.query}set search(a){let b=this._url;if(""===a){b.query=null;return}let c="?"===a[0]?a.substring(1):a;b.query="",d.basicURLParse(c,{url:b,stateOverride:"query"})}get hash(){return null===this._url.fragment||""===this._url.fragment?"":"#"+this._url.fragment}set hash(a){if(""===a){this._url.fragment=null;return}let b="#"===a[0]?a.substring(1):a;this._url.fragment="",d.basicURLParse(b,{url:this._url,stateOverride:"fragment"})}toJSON(){return this.href}}},598394,(a,b,c)=>{"use strict";let d=a.r(55844),e=a.r(721905),f=a.r(181046),g=e.implSymbol;function h(a){if(!this||this[g]||!(this instanceof h))throw TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");if(arguments.length<1)throw TypeError("Failed to construct 'URL': 1 argument required, but only "+arguments.length+" present.");let c=[];for(let a=0;a<arguments.length&&a<2;++a)c[a]=arguments[a];c[0]=d.USVString(c[0]),void 0!==c[1]&&(c[1]=d.USVString(c[1])),b.exports.setup(this,c)}h.prototype.toJSON=function(){if(!this||!b.exports.is(this))throw TypeError("Illegal invocation");let a=[];for(let b=0;b<arguments.length&&b<0;++b)a[b]=arguments[b];return this[g].toJSON.apply(this[g],a)},Object.defineProperty(h.prototype,"href",{get(){return this[g].href},set(a){a=d.USVString(a),this[g].href=a},enumerable:!0,configurable:!0}),h.prototype.toString=function(){if(!this||!b.exports.is(this))throw TypeError("Illegal invocation");return this.href},Object.defineProperty(h.prototype,"origin",{get(){return this[g].origin},enumerable:!0,configurable:!0}),Object.defineProperty(h.prototype,"protocol",{get(){return this[g].protocol},set(a){a=d.USVString(a),this[g].protocol=a},enumerable:!0,configurable:!0}),Object.defineProperty(h.prototype,"username",{get(){return this[g].username},set(a){a=d.USVString(a),this[g].username=a},enumerable:!0,configurable:!0}),Object.defineProperty(h.prototype,"password",{get(){return this[g].password},set(a){a=d.USVString(a),this[g].password=a},enumerable:!0,configurable:!0}),Object.defineProperty(h.prototype,"host",{get(){return this[g].host},set(a){a=d.USVString(a),this[g].host=a},enumerable:!0,configurable:!0}),Object.defineProperty(h.prototype,"hostname",{get(){return this[g].hostname},set(a){a=d.USVString(a),this[g].hostname=a},enumerable:!0,configurable:!0}),Object.defineProperty(h.prototype,"port",{get(){return this[g].port},set(a){a=d.USVString(a),this[g].port=a},enumerable:!0,configurable:!0}),Object.defineProperty(h.prototype,"pathname",{get(){return this[g].pathname},set(a){a=d.USVString(a),this[g].pathname=a},enumerable:!0,configurable:!0}),Object.defineProperty(h.prototype,"search",{get(){return this[g].search},set(a){a=d.USVString(a),this[g].search=a},enumerable:!0,configurable:!0}),Object.defineProperty(h.prototype,"hash",{get(){return this[g].hash},set(a){a=d.USVString(a),this[g].hash=a},enumerable:!0,configurable:!0}),b.exports={is:a=>!!a&&a[g]instanceof f.implementation,create(a,b){let c=Object.create(h.prototype);return this.setup(c,a,b),c},setup(a,b,c){c||(c={}),c.wrapper=a,a[g]=new f.implementation(b,c),a[g][e.wrapperSymbol]=a},interface:h,expose:{Window:{URL:h},Worker:{URL:h}}}},470705,(a,b,c)=>{"use strict";c.URL=a.r(598394).interface,c.serializeURL=a.r(381853).serializeURL,c.serializeURLOrigin=a.r(381853).serializeURLOrigin,c.basicURLParse=a.r(381853).basicURLParse,c.setTheUsername=a.r(381853).setTheUsername,c.setThePassword=a.r(381853).setThePassword,c.serializeHost=a.r(381853).serializeHost,c.serializeInteger=a.r(381853).serializeInteger,c.parseURL=a.r(381853).parseURL},671277,a=>{"use strict";let b;var c=a.i(688947),d=a.i(921517),e=a.i(792509),f=a.i(470705),g=a.i(524836),h=a.i(406461);let i=c.default.Readable,j=Symbol("buffer"),k=Symbol("type");class l{constructor(){this[k]="";const a=arguments[0],b=arguments[1],c=[];if(a){const b=Number(a.length);for(let d=0;d<b;d++){let b;const e=a[d];(b=e instanceof Buffer?e:ArrayBuffer.isView(e)?Buffer.from(e.buffer,e.byteOffset,e.byteLength):e instanceof ArrayBuffer?Buffer.from(e):e instanceof l?e[j]:Buffer.from("string"==typeof e?e:String(e))).length,c.push(b)}}this[j]=Buffer.concat(c);let d=b&&void 0!==b.type&&String(b.type).toLowerCase();d&&!/[^\u0020-\u007E]/.test(d)&&(this[k]=d)}get size(){return this[j].length}get type(){return this[k]}text(){return Promise.resolve(this[j].toString())}arrayBuffer(){let a=this[j];return Promise.resolve(a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength))}stream(){let a=new i;return a._read=function(){},a.push(this[j]),a.push(null),a}toString(){return"[object Blob]"}slice(){let a,b=this.size,c=arguments[0],d=arguments[1];a=void 0===c?0:c<0?Math.max(b+c,0):Math.min(c,b);let e=Math.max((void 0===d?b:d<0?Math.max(b+d,0):Math.min(d,b))-a,0),f=this[j].slice(a,a+e),g=new l([],{type:arguments[2]});return g[j]=f,g}}function m(a,b,c){Error.call(this,a),this.message=a,this.type=b,c&&(this.code=this.errno=c.code),Error.captureStackTrace(this,this.constructor)}Object.defineProperties(l.prototype,{size:{enumerable:!0},type:{enumerable:!0},slice:{enumerable:!0}}),Object.defineProperty(l.prototype,Symbol.toStringTag,{value:"Blob",writable:!1,enumerable:!1,configurable:!0}),m.prototype=Object.create(Error.prototype),m.prototype.constructor=m,m.prototype.name="FetchError";try{b=(()=>{let a=Error("Cannot find module 'encoding'");throw a.code="MODULE_NOT_FOUND",a})().convert}catch(a){}let n=Symbol("Body internals"),o=c.default.PassThrough;function p(a){var b=this,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},e=d.size,f=d.timeout;null==a?a=null:r(a)?a=Buffer.from(a.toString()):s(a)||Buffer.isBuffer(a)||("[object ArrayBuffer]"===Object.prototype.toString.call(a)?a=Buffer.from(a):ArrayBuffer.isView(a)?a=Buffer.from(a.buffer,a.byteOffset,a.byteLength):a instanceof c.default||(a=Buffer.from(String(a)))),this[n]={body:a,disturbed:!1,error:null},this.size=void 0===e?0:e,this.timeout=void 0===f?0:f,a instanceof c.default&&a.on("error",function(a){let c="AbortError"===a.name?a:new m(`Invalid response body while trying to fetch ${b.url}: ${a.message}`,"system",a);b[n].error=c})}function q(){var a=this;if(this[n].disturbed)return p.Promise.reject(TypeError(`body used already for: ${this.url}`));if(this[n].disturbed=!0,this[n].error)return p.Promise.reject(this[n].error);let b=this.body;if(null===b)return p.Promise.resolve(Buffer.alloc(0));if(s(b)&&(b=b.stream()),Buffer.isBuffer(b))return p.Promise.resolve(b);if(!(b instanceof c.default))return p.Promise.resolve(Buffer.alloc(0));let d=[],e=0,f=!1;return new p.Promise(function(c,g){let h;a.timeout&&(h=setTimeout(function(){f=!0,g(new m(`Response timeout while trying to fetch ${a.url} (over ${a.timeout}ms)`,"body-timeout"))},a.timeout)),b.on("error",function(b){"AbortError"===b.name?(f=!0,g(b)):g(new m(`Invalid response body while trying to fetch ${a.url}: ${b.message}`,"system",b))}),b.on("data",function(b){if(!f&&null!==b){if(a.size&&e+b.length>a.size){f=!0,g(new m(`content size at ${a.url} over limit: ${a.size}`,"max-size"));return}e+=b.length,d.push(b)}}),b.on("end",function(){if(!f){clearTimeout(h);try{c(Buffer.concat(d,e))}catch(b){g(new m(`Could not create Buffer from response body for ${a.url}: ${b.message}`,"system",b))}}})})}function r(a){return"object"==typeof a&&"function"==typeof a.append&&"function"==typeof a.delete&&"function"==typeof a.get&&"function"==typeof a.getAll&&"function"==typeof a.has&&"function"==typeof a.set&&("URLSearchParams"===a.constructor.name||"[object URLSearchParams]"===Object.prototype.toString.call(a)||"function"==typeof a.sort)}function s(a){return"object"==typeof a&&"function"==typeof a.arrayBuffer&&"string"==typeof a.type&&"function"==typeof a.stream&&"function"==typeof a.constructor&&"string"==typeof a.constructor.name&&/^(Blob|File)$/.test(a.constructor.name)&&/^(Blob|File)$/.test(a[Symbol.toStringTag])}function t(a){let b,d,e=a.body;if(a.bodyUsed)throw Error("cannot clone body after it is used");return e instanceof c.default&&"function"!=typeof e.getBoundary&&(b=new o,d=new o,e.pipe(b),e.pipe(d),a[n].body=b,e=d),e}function u(a){if(null===a)return null;if("string"==typeof a)return"text/plain;charset=UTF-8";if(r(a))return"application/x-www-form-urlencoded;charset=UTF-8";if(s(a))return a.type||null;if(Buffer.isBuffer(a))return null;else if("[object ArrayBuffer]"===Object.prototype.toString.call(a))return null;else if(ArrayBuffer.isView(a))return null;else if("function"==typeof a.getBoundary)return`multipart/form-data;boundary=${a.getBoundary()}`;else if(a instanceof c.default)return null;else return"text/plain;charset=UTF-8"}function v(a){let b=a.body;return null===b?0:s(b)?b.size:Buffer.isBuffer(b)?b.length:b&&"function"==typeof b.getLengthSync?b._lengthRetrievers&&0==b._lengthRetrievers.length||b.hasKnownLength&&b.hasKnownLength()?b.getLengthSync():null:null}p.prototype={get body(){return this[n].body},get bodyUsed(){return this[n].disturbed},arrayBuffer(){return q.call(this).then(function(a){return a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength)})},blob(){let a=this.headers&&this.headers.get("content-type")||"";return q.call(this).then(function(b){return Object.assign(new l([],{type:a.toLowerCase()}),{[j]:b})})},json(){var a=this;return q.call(this).then(function(b){try{return JSON.parse(b.toString())}catch(b){return p.Promise.reject(new m(`invalid json response body at ${a.url} reason: ${b.message}`,"invalid-json"))}})},text(){return q.call(this).then(function(a){return a.toString()})},buffer(){return q.call(this)},textConverted(){var a=this;return q.call(this).then(function(c){return function(a,c){let d,e;if("function"!=typeof b)throw Error("The package `encoding` must be installed to use the textConverted() function");let f=c.get("content-type"),g="utf-8";return f&&(d=/charset=([^;]*)/i.exec(f)),e=a.slice(0,1024).toString(),!d&&e&&(d=/<meta.+?charset=(['"])(.+?)\1/i.exec(e)),!d&&e&&(!(d=/<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(e))&&(d=/<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(e))&&d.pop(),d&&(d=/charset=(.*)/i.exec(d.pop()))),!d&&e&&(d=/<\?xml.+?encoding=(['"])(.+?)\1/i.exec(e)),d&&("gb2312"===(g=d.pop())||"gbk"===g)&&(g="gb18030"),b(a,"UTF-8",g).toString()}(c,a.headers)})}},Object.defineProperties(p.prototype,{body:{enumerable:!0},bodyUsed:{enumerable:!0},arrayBuffer:{enumerable:!0},blob:{enumerable:!0},json:{enumerable:!0},text:{enumerable:!0}}),p.mixIn=function(a){for(let b of Object.getOwnPropertyNames(p.prototype))if(!(b in a)){let c=Object.getOwnPropertyDescriptor(p.prototype,b);Object.defineProperty(a,b,c)}},p.Promise=a.g.Promise;let w=/[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/,x=/[^\t\x20-\x7e\x80-\xff]/;function y(a){if(a=`${a}`,w.test(a)||""===a)throw TypeError(`${a} is not a legal HTTP header name`)}function z(a){if(a=`${a}`,x.test(a))throw TypeError(`${a} is not a legal HTTP header value`)}function A(a,b){for(let c in b=b.toLowerCase(),a)if(c.toLowerCase()===b)return c}let B=Symbol("map");class C{constructor(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0;if(this[B]=Object.create(null),a instanceof C){const b=a.raw();for(const a of Object.keys(b))for(const c of b[a])this.append(a,c);return}if(null==a);else if("object"==typeof a){const b=a[Symbol.iterator];if(null!=b){if("function"!=typeof b)throw TypeError("Header pairs must be iterable");const c=[];for(const b of a){if("object"!=typeof b||"function"!=typeof b[Symbol.iterator])throw TypeError("Each header pair must be iterable");c.push(Array.from(b))}for(const a of c){if(2!==a.length)throw TypeError("Each header pair must be a name/value tuple");this.append(a[0],a[1])}}else for(const b of Object.keys(a)){const c=a[b];this.append(b,c)}}else throw TypeError("Provided initializer must be an object")}get(a){y(a=`${a}`);let b=A(this[B],a);return void 0===b?null:this[B][b].join(", ")}forEach(a){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,c=D(this),d=0;for(;d<c.length;){var e=c[d];let f=e[0],g=e[1];a.call(b,g,f,this),c=D(this),d++}}set(a,b){a=`${a}`,b=`${b}`,y(a),z(b);let c=A(this[B],a);this[B][void 0!==c?c:a]=[b]}append(a,b){a=`${a}`,b=`${b}`,y(a),z(b);let c=A(this[B],a);void 0!==c?this[B][c].push(b):this[B][a]=[b]}has(a){return y(a=`${a}`),void 0!==A(this[B],a)}delete(a){y(a=`${a}`);let b=A(this[B],a);void 0!==b&&delete this[B][b]}raw(){return this[B]}keys(){return F(this,"key")}values(){return F(this,"value")}[Symbol.iterator](){return F(this,"key+value")}}function D(a){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"key+value";return Object.keys(a[B]).sort().map("key"===b?function(a){return a.toLowerCase()}:"value"===b?function(b){return a[B][b].join(", ")}:function(b){return[b.toLowerCase(),a[B][b].join(", ")]})}C.prototype.entries=C.prototype[Symbol.iterator],Object.defineProperty(C.prototype,Symbol.toStringTag,{value:"Headers",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(C.prototype,{get:{enumerable:!0},forEach:{enumerable:!0},set:{enumerable:!0},append:{enumerable:!0},has:{enumerable:!0},delete:{enumerable:!0},keys:{enumerable:!0},values:{enumerable:!0},entries:{enumerable:!0}});let E=Symbol("internal");function F(a,b){let c=Object.create(G);return c[E]={target:a,kind:b,index:0},c}let G=Object.setPrototypeOf({next(){if(!this||Object.getPrototypeOf(this)!==G)throw TypeError("Value of `this` is not a HeadersIterator");var a=this[E];let b=a.target,c=a.kind,d=a.index,e=D(b,c);return d>=e.length?{value:void 0,done:!0}:(this[E].index=d+1,{value:e[d],done:!1})}},Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));Object.defineProperty(G,Symbol.toStringTag,{value:"HeadersIterator",writable:!1,enumerable:!1,configurable:!0});let H=Symbol("Response internals"),I=d.default.STATUS_CODES;class J{constructor(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};p.call(this,a,b);const c=b.status||200,d=new C(b.headers);if(null!=a&&!d.has("Content-Type")){const b=u(a);b&&d.append("Content-Type",b)}this[H]={url:b.url,status:c,statusText:b.statusText||I[c],headers:d,counter:b.counter}}get url(){return this[H].url||""}get status(){return this[H].status}get ok(){return this[H].status>=200&&this[H].status<300}get redirected(){return this[H].counter>0}get statusText(){return this[H].statusText}get headers(){return this[H].headers}clone(){return new J(t(this),{url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok,redirected:this.redirected})}}p.mixIn(J.prototype),Object.defineProperties(J.prototype,{url:{enumerable:!0},status:{enumerable:!0},ok:{enumerable:!0},redirected:{enumerable:!0},statusText:{enumerable:!0},headers:{enumerable:!0},clone:{enumerable:!0}}),Object.defineProperty(J.prototype,Symbol.toStringTag,{value:"Response",writable:!1,enumerable:!1,configurable:!0});let K=Symbol("Request internals"),L=e.default.URL||f.default.URL,M=e.default.parse,N=e.default.format;function O(a){return/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(a)&&(a=new L(a).toString()),M(a)}let P="destroy"in c.default.Readable.prototype;function Q(a){return"object"==typeof a&&"object"==typeof a[K]}class R{constructor(a){let b,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Q(a)?b=O(a.url):(b=a&&a.href?O(a.href):O(`${a}`),a={});let d=c.method||a.method||"GET";if(d=d.toUpperCase(),(null!=c.body||Q(a)&&null!==a.body)&&("GET"===d||"HEAD"===d))throw TypeError("Request with GET/HEAD method cannot have body");let e=null!=c.body?c.body:Q(a)&&null!==a.body?t(a):null;p.call(this,e,{timeout:c.timeout||a.timeout||0,size:c.size||a.size||0});const f=new C(c.headers||a.headers||{});if(null!=e&&!f.has("Content-Type")){const a=u(e);a&&f.append("Content-Type",a)}let g=Q(a)?a.signal:null;if("signal"in c&&(g=c.signal),null!=g&&!function(a){let b=a&&"object"==typeof a&&Object.getPrototypeOf(a);return!!(b&&"AbortSignal"===b.constructor.name)}(g))throw TypeError("Expected signal to be an instanceof AbortSignal");this[K]={method:d,redirect:c.redirect||a.redirect||"follow",headers:f,parsedURL:b,signal:g},this.follow=void 0!==c.follow?c.follow:void 0!==a.follow?a.follow:20,this.compress=void 0!==c.compress?c.compress:void 0===a.compress||a.compress,this.counter=c.counter||a.counter||0,this.agent=c.agent||a.agent}get method(){return this[K].method}get url(){return N(this[K].parsedURL)}get headers(){return this[K].headers}get redirect(){return this[K].redirect}get signal(){return this[K].signal}clone(){return new R(this)}}function S(a){Error.call(this,a),this.type="aborted",this.message=a,Error.captureStackTrace(this,this.constructor)}p.mixIn(R.prototype),Object.defineProperty(R.prototype,Symbol.toStringTag,{value:"Request",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(R.prototype,{method:{enumerable:!0},url:{enumerable:!0},headers:{enumerable:!0},redirect:{enumerable:!0},clone:{enumerable:!0},signal:{enumerable:!0}}),S.prototype=Object.create(Error.prototype),S.prototype.constructor=S,S.prototype.name="AbortError";let T=e.default.URL||f.default.URL,U=c.default.PassThrough,V=function(a,b){let c=new T(b).hostname,d=new T(a).hostname;return c===d||"."===c[c.length-d.length-1]&&c.endsWith(d)};function W(a,b){if(!W.Promise)throw Error("native promise missing, set fetch.Promise to your favorite alternative");return p.Promise=W.Promise,new W.Promise(function(e,f){var i,j;let k,l,n,o=new R(a,b),p=function(a){let b,d,e=a[K].parsedURL,f=new C(a[K].headers);if(f.has("Accept")||f.set("Accept","*/*"),!e.protocol||!e.hostname)throw TypeError("Only absolute URLs are supported");if(!/^https?:$/.test(e.protocol))throw TypeError("Only HTTP(S) protocols are supported");if(a.signal&&a.body instanceof c.default.Readable&&!P)throw Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");let g=null;if(null==a.body&&/^(POST|PUT)$/i.test(a.method)&&(g="0"),null!=a.body){let b=v(a);"number"==typeof b&&(g=String(b))}g&&f.set("Content-Length",g),f.has("User-Agent")||f.set("User-Agent","node-fetch/1.0 (+https://github.com/bitinn/node-fetch)"),a.compress&&!f.has("Accept-Encoding")&&f.set("Accept-Encoding","gzip,deflate");let h=a.agent;return"function"==typeof h&&(h=h(e)),Object.assign({},e,{method:a.method,headers:(b=Object.assign({__proto__:null},f[B]),void 0!==(d=A(f[B],"Host"))&&(b[d]=b[d][0]),b),agent:h})}(o),q=("https:"===p.protocol?g.default:d.default).request,r=o.signal,t=null,u=function(){let a=new S("The user aborted a request.");f(a),o.body&&o.body instanceof c.default.Readable&&X(o.body,a),t&&t.body&&t.body.emit("error",a)};if(r&&r.aborted)return void u();let y=function(){u(),D()},z=q(p);function D(){z.abort(),r&&r.removeEventListener("abort",y),clearTimeout(l)}r&&r.addEventListener("abort",y),o.timeout&&z.once("socket",function(a){l=setTimeout(function(){f(new m(`network timeout at: ${o.url}`,"request-timeout")),D()},o.timeout)}),z.on("error",function(a){f(new m(`request to ${o.url} failed, reason: ${a.message}`,"system",a)),t&&t.body&&X(t.body,a),D()}),i=z,j=function(a){(!r||!r.aborted)&&t&&t.body&&X(t.body,a)},i.on("socket",function(a){k=a}),i.on("response",function(a){let b=a.headers;"chunked"!==b["transfer-encoding"]||b["content-length"]||a.once("close",function(a){if(k&&k.listenerCount("data")>0&&!a){let a=Error("Premature close");a.code="ERR_STREAM_PREMATURE_CLOSE",j(a)}})}),14>parseInt(process.version.substring(1))&&z.on("socket",function(a){a.addListener("close",function(b){let c=a.listenerCount("data")>0;if(t&&c&&!b&&!(r&&r.aborted)){let a=Error("Premature close");a.code="ERR_STREAM_PREMATURE_CLOSE",t.body.emit("error",a)}})}),z.on("response",function(a){clearTimeout(l);let b=function(a){let b=new C;for(let c of Object.keys(a))if(!w.test(c))if(Array.isArray(a[c]))for(let d of a[c])x.test(d)||(void 0===b[B][c]?b[B][c]=[d]:b[B][c].push(d));else x.test(a[c])||(b[B][c]=[a[c]]);return b}(a.headers);if(W.isRedirect(a.statusCode)){let d=b.get("Location"),g=null;try{g=null===d?null:new T(d,o.url).toString()}catch(a){if("manual"!==o.redirect){f(new m(`uri requested responds with an invalid redirect URL: ${d}`,"invalid-redirect")),D();return}}switch(o.redirect){case"error":f(new m(`uri requested responds with a redirect, redirect mode is set to error: ${o.url}`,"no-redirect")),D();return;case"manual":if(null!==g)try{b.set("Location",g)}catch(a){f(a)}break;case"follow":var c;if(null===g)break;if(o.counter>=o.follow){f(new m(`maximum redirect reached at: ${o.url}`,"max-redirect")),D();return}let h={headers:new C(o.headers),follow:o.follow,counter:o.counter+1,agent:o.agent,compress:o.compress,method:o.method,body:o.body,signal:o.signal,timeout:o.timeout,size:o.size};if(!V(o.url,g)||(c=o.url,new T(g).protocol!==new T(c).protocol))for(let a of["authorization","www-authenticate","cookie","cookie2"])h.headers.delete(a);if(303!==a.statusCode&&o.body&&null===v(o)){f(new m("Cannot follow redirect with body being a readable stream","unsupported-redirect")),D();return}(303===a.statusCode||(301===a.statusCode||302===a.statusCode)&&"POST"===o.method)&&(h.method="GET",h.body=void 0,h.headers.delete("content-length")),e(W(new R(g,h))),D();return}}a.once("end",function(){r&&r.removeEventListener("abort",y)});let d=a.pipe(new U),g={url:o.url,status:a.statusCode,statusText:a.statusMessage,headers:b,size:o.size,timeout:o.timeout,counter:o.counter},i=b.get("Content-Encoding");if(!o.compress||"HEAD"===o.method||null===i||204===a.statusCode||304===a.statusCode)return void e(t=new J(d,g));let j={flush:h.default.Z_SYNC_FLUSH,finishFlush:h.default.Z_SYNC_FLUSH};if("gzip"==i||"x-gzip"==i)return void e(t=new J(d=d.pipe(h.default.createGunzip(j)),g));if("deflate"==i||"x-deflate"==i){let b=a.pipe(new U);b.once("data",function(a){e(t=new J(d=(15&a[0])==8?d.pipe(h.default.createInflate()):d.pipe(h.default.createInflateRaw()),g))}),b.on("end",function(){t||e(t=new J(d,g))});return}"br"==i&&"function"==typeof h.default.createBrotliDecompress?e(t=new J(d=d.pipe(h.default.createBrotliDecompress()),g)):e(t=new J(d,g))}),null===(n=o.body)?z.end():s(n)?n.stream().pipe(z):Buffer.isBuffer(n)?(z.write(n),z.end()):n.pipe(z)})}function X(a,b){a.destroy?a.destroy(b):(a.emit("error",b),a.end())}W.isRedirect=function(a){return 301===a||302===a||303===a||307===a||308===a},W.Promise=a.g.Promise,a.s(["FetchError",()=>m,"Headers",()=>C,"Request",()=>R,"Response",()=>J,"default",0,W])},486301,(a,b,c)=>{b.exports=e;var d=null;try{d=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(a){}function e(a,b,c){this.low=0|a,this.high=0|b,this.unsigned=!!c}function f(a){return!0===(a&&a.__isLong__)}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0}),e.isLong=f;var g={},h={};function i(a,b){var c,d,e;if(b)return(a>>>=0,(e=0<=a&&a<256)&&(d=h[a]))?d:(c=k(a,(0|a)<0?-1:0,!0),e&&(h[a]=c),c);return(a|=0,(e=-128<=a&&a<128)&&(d=g[a]))?d:(c=k(a,a<0?-1:0,!1),e&&(g[a]=c),c)}function j(a,b){if(isNaN(a))return b?t:s;if(b){if(a<0)return t;if(a>=p)return y}else{if(a<=-q)return z;if(a+1>=q)return x}return a<0?j(-a,b).neg():k(a%o|0,a/o|0,b)}function k(a,b,c){return new e(a,b,c)}e.fromInt=i,e.fromNumber=j,e.fromBits=k;var l=Math.pow;function m(a,b,c){if(0===a.length)throw Error("empty string");if("NaN"===a||"Infinity"===a||"+Infinity"===a||"-Infinity"===a)return s;if("number"==typeof b?(c=b,b=!1):b=!!b,(c=c||10)<2||36<c)throw RangeError("radix");if((d=a.indexOf("-"))>0)throw Error("interior hyphen");if(0===d)return m(a.substring(1),b,c).neg();for(var d,e=j(l(c,8)),f=s,g=0;g<a.length;g+=8){var h=Math.min(8,a.length-g),i=parseInt(a.substring(g,g+h),c);if(h<8){var k=j(l(c,h));f=f.mul(k).add(j(i))}else f=(f=f.mul(e)).add(j(i))}return f.unsigned=b,f}function n(a,b){return"number"==typeof a?j(a,b):"string"==typeof a?m(a,b):k(a.low,a.high,"boolean"==typeof b?b:a.unsigned)}e.fromString=m,e.fromValue=n;var o=0x100000000,p=0xffffffffffffffff,q=0x8000000000000000,r=i(0x1000000),s=i(0);e.ZERO=s;var t=i(0,!0);e.UZERO=t;var u=i(1);e.ONE=u;var v=i(1,!0);e.UONE=v;var w=i(-1);e.NEG_ONE=w;var x=k(-1,0x7fffffff,!1);e.MAX_VALUE=x;var y=k(-1,-1,!0);e.MAX_UNSIGNED_VALUE=y;var z=k(0,-0x80000000,!1);e.MIN_VALUE=z;var A=e.prototype;A.toInt=function(){return this.unsigned?this.low>>>0:this.low},A.toNumber=function(){return this.unsigned?(this.high>>>0)*o+(this.low>>>0):this.high*o+(this.low>>>0)},A.toString=function(a){if((a=a||10)<2||36<a)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(!this.eq(z))return"-"+this.neg().toString(a);else{var b=j(a),c=this.div(b),d=c.mul(b).sub(this);return c.toString(a)+d.toInt().toString(a)}for(var e=j(l(a,6),this.unsigned),f=this,g="";;){var h=f.div(e),i=(f.sub(h.mul(e)).toInt()>>>0).toString(a);if((f=h).isZero())return i+g;for(;i.length<6;)i="0"+i;g=""+i+g}},A.getHighBits=function(){return this.high},A.getHighBitsUnsigned=function(){return this.high>>>0},A.getLowBits=function(){return this.low},A.getLowBitsUnsigned=function(){return this.low>>>0},A.getNumBitsAbs=function(){if(this.isNegative())return this.eq(z)?64:this.neg().getNumBitsAbs();for(var a=0!=this.high?this.high:this.low,b=31;b>0&&(a&1<<b)==0;b--);return 0!=this.high?b+33:b+1},A.isZero=function(){return 0===this.high&&0===this.low},A.eqz=A.isZero,A.isNegative=function(){return!this.unsigned&&this.high<0},A.isPositive=function(){return this.unsigned||this.high>=0},A.isOdd=function(){return(1&this.low)==1},A.isEven=function(){return(1&this.low)==0},A.equals=function(a){return f(a)||(a=n(a)),(this.unsigned===a.unsigned||this.high>>>31!=1||a.high>>>31!=1)&&this.high===a.high&&this.low===a.low},A.eq=A.equals,A.notEquals=function(a){return!this.eq(a)},A.neq=A.notEquals,A.ne=A.notEquals,A.lessThan=function(a){return 0>this.comp(a)},A.lt=A.lessThan,A.lessThanOrEqual=function(a){return 0>=this.comp(a)},A.lte=A.lessThanOrEqual,A.le=A.lessThanOrEqual,A.greaterThan=function(a){return this.comp(a)>0},A.gt=A.greaterThan,A.greaterThanOrEqual=function(a){return this.comp(a)>=0},A.gte=A.greaterThanOrEqual,A.ge=A.greaterThanOrEqual,A.compare=function(a){if(f(a)||(a=n(a)),this.eq(a))return 0;var b=this.isNegative(),c=a.isNegative();return b&&!c?-1:!b&&c?1:this.unsigned?a.high>>>0>this.high>>>0||a.high===this.high&&a.low>>>0>this.low>>>0?-1:1:this.sub(a).isNegative()?-1:1},A.comp=A.compare,A.negate=function(){return!this.unsigned&&this.eq(z)?z:this.not().add(u)},A.neg=A.negate,A.add=function(a){f(a)||(a=n(a));var b,c,d=this.high>>>16,e=65535&this.high,g=this.low>>>16,h=65535&this.low,i=a.high>>>16,j=65535&a.high,l=a.low>>>16,m=65535&a.low,o=0,p=0;return b=0+((c=0+(h+m))>>>16),c&=65535,b+=g+l,p+=b>>>16,b&=65535,p+=e+j,o+=p>>>16,p&=65535,o+=d+i,k(b<<16|c,(o&=65535)<<16|p,this.unsigned)},A.subtract=function(a){return f(a)||(a=n(a)),this.add(a.neg())},A.sub=A.subtract,A.multiply=function(a){if(this.isZero())return s;if(f(a)||(a=n(a)),d)return k(d.mul(this.low,this.high,a.low,a.high),d.get_high(),this.unsigned);if(a.isZero())return s;if(this.eq(z))return a.isOdd()?z:s;if(a.eq(z))return this.isOdd()?z:s;if(this.isNegative())if(a.isNegative())return this.neg().mul(a.neg());else return this.neg().mul(a).neg();if(a.isNegative())return this.mul(a.neg()).neg();if(this.lt(r)&&a.lt(r))return j(this.toNumber()*a.toNumber(),this.unsigned);var b,c,e=this.high>>>16,g=65535&this.high,h=this.low>>>16,i=65535&this.low,l=a.high>>>16,m=65535&a.high,o=a.low>>>16,p=65535&a.low,q=0,t=0;return b=0+((c=0+i*p)>>>16),c&=65535,b+=h*p,t+=b>>>16,b&=65535,b+=i*o,t+=b>>>16,b&=65535,t+=g*p,q+=t>>>16,t&=65535,t+=h*o,q+=t>>>16,t&=65535,t+=i*m,q+=t>>>16,t&=65535,q+=e*p+g*o+h*m+i*l,k(b<<16|c,(q&=65535)<<16|t,this.unsigned)},A.mul=A.multiply,A.divide=function(a){if(f(a)||(a=n(a)),a.isZero())throw Error("division by zero");if(d){var b,c,e;return this.unsigned||-0x80000000!==this.high||-1!==a.low||-1!==a.high?k((this.unsigned?d.div_u:d.div_s)(this.low,this.high,a.low,a.high),d.get_high(),this.unsigned):this}if(this.isZero())return this.unsigned?t:s;if(this.unsigned){if(a.unsigned||(a=a.toUnsigned()),a.gt(this))return t;if(a.gt(this.shru(1)))return v;e=t}else{if(this.eq(z))if(a.eq(u)||a.eq(w))return z;else return a.eq(z)?u:(b=this.shr(1).div(a).shl(1)).eq(s)?a.isNegative()?u:w:(c=this.sub(a.mul(b)),e=b.add(c.div(a)));if(a.eq(z))return this.unsigned?t:s;if(this.isNegative())return a.isNegative()?this.neg().div(a.neg()):this.neg().div(a).neg();if(a.isNegative())return this.div(a.neg()).neg();e=s}for(c=this;c.gte(a);){for(var g=Math.ceil(Math.log(b=Math.max(1,Math.floor(c.toNumber()/a.toNumber())))/Math.LN2),h=g<=48?1:l(2,g-48),i=j(b),m=i.mul(a);m.isNegative()||m.gt(c);)b-=h,m=(i=j(b,this.unsigned)).mul(a);i.isZero()&&(i=u),e=e.add(i),c=c.sub(m)}return e},A.div=A.divide,A.modulo=function(a){return(f(a)||(a=n(a)),d)?k((this.unsigned?d.rem_u:d.rem_s)(this.low,this.high,a.low,a.high),d.get_high(),this.unsigned):this.sub(this.div(a).mul(a))},A.mod=A.modulo,A.rem=A.modulo,A.not=function(){return k(~this.low,~this.high,this.unsigned)},A.and=function(a){return f(a)||(a=n(a)),k(this.low&a.low,this.high&a.high,this.unsigned)},A.or=function(a){return f(a)||(a=n(a)),k(this.low|a.low,this.high|a.high,this.unsigned)},A.xor=function(a){return f(a)||(a=n(a)),k(this.low^a.low,this.high^a.high,this.unsigned)},A.shiftLeft=function(a){return(f(a)&&(a=a.toInt()),0==(a&=63))?this:a<32?k(this.low<<a,this.high<<a|this.low>>>32-a,this.unsigned):k(0,this.low<<a-32,this.unsigned)},A.shl=A.shiftLeft,A.shiftRight=function(a){return(f(a)&&(a=a.toInt()),0==(a&=63))?this:a<32?k(this.low>>>a|this.high<<32-a,this.high>>a,this.unsigned):k(this.high>>a-32,this.high>=0?0:-1,this.unsigned)},A.shr=A.shiftRight,A.shiftRightUnsigned=function(a){if(f(a)&&(a=a.toInt()),0==(a&=63))return this;var b=this.high;return a<32?k(this.low>>>a|b<<32-a,b>>>a,this.unsigned):32===a?k(b,0,this.unsigned):k(b>>>a-32,0,this.unsigned)},A.shru=A.shiftRightUnsigned,A.shr_u=A.shiftRightUnsigned,A.toSigned=function(){return this.unsigned?k(this.low,this.high,!1):this},A.toUnsigned=function(){return this.unsigned?this:k(this.low,this.high,!0)},A.toBytes=function(a){return a?this.toBytesLE():this.toBytesBE()},A.toBytesLE=function(){var a=this.high,b=this.low;return[255&b,b>>>8&255,b>>>16&255,b>>>24,255&a,a>>>8&255,a>>>16&255,a>>>24]},A.toBytesBE=function(){var a=this.high,b=this.low;return[a>>>24,a>>>16&255,a>>>8&255,255&a,b>>>24,b>>>16&255,b>>>8&255,255&b]},e.fromBytes=function(a,b,c){return c?e.fromBytesLE(a,b):e.fromBytesBE(a,b)},e.fromBytesLE=function(a,b){return new e(a[0]|a[1]<<8|a[2]<<16|a[3]<<24,a[4]|a[5]<<8|a[6]<<16|a[7]<<24,b)},e.fromBytesBE=function(a,b){return new e(a[4]<<24|a[5]<<16|a[6]<<8|a[7],a[0]<<24|a[1]<<16|a[2]<<8|a[3],b)}},791919,(a,b,c)=>{!function(b,c,d){function e(a){var b,c=this,d=(b=0xefc8249d,function(a){a=String(a);for(var c=0;c<a.length;c++){var d=.02519603282416938*(b+=a.charCodeAt(c));b=d>>>0,d-=b,d*=b,b=d>>>0,d-=b,b+=0x100000000*d}return(b>>>0)*23283064365386963e-26});c.next=function(){var a=2091639*c.s0+23283064365386963e-26*c.c;return c.s0=c.s1,c.s1=c.s2,c.s2=a-(c.c=0|a)},c.c=1,c.s0=d(" "),c.s1=d(" "),c.s2=d(" "),c.s0-=d(a),c.s0<0&&(c.s0+=1),c.s1-=d(a),c.s1<0&&(c.s1+=1),c.s2-=d(a),c.s2<0&&(c.s2+=1)}function f(a,b){return b.c=a.c,b.s0=a.s0,b.s1=a.s1,b.s2=a.s2,b}function g(a,b){var c=new e(a),d=b&&b.state,g=c.next;return g.int32=function(){return 0x100000000*c.next()|0},g.double=function(){return g()+(2097152*g()|0)*11102230246251565e-32},g.quick=g,d&&("object"==typeof d&&f(d,c),g.state=function(){return f(c,{})}),g}if(c&&c.exports)c.exports=g;else if(d&&d.amd)a.r,void 0!==g&&a.v(g);else this.alea=g}(a.e,b,"function"==typeof define&&define)},700734,(a,b,c)=>{!function(b,c,d){function e(a){var b=this,c="";b.x=0,b.y=0,b.z=0,b.w=0,b.next=function(){var a=b.x^b.x<<11;return b.x=b.y,b.y=b.z,b.z=b.w,b.w^=b.w>>>19^a^a>>>8},a===(0|a)?b.x=a:c+=a;for(var d=0;d<c.length+64;d++)b.x^=c.charCodeAt(d),b.next()}function f(a,b){return b.x=a.x,b.y=a.y,b.z=a.z,b.w=a.w,b}function g(a,b){var c=new e(a),d=b&&b.state,g=function(){return(c.next()>>>0)/0x100000000};return g.double=function(){do var a=((c.next()>>>11)+(c.next()>>>0)/0x100000000)/2097152;while(0===a)return a},g.int32=c.next,g.quick=g,d&&("object"==typeof d&&f(d,c),g.state=function(){return f(c,{})}),g}if(c&&c.exports)c.exports=g;else if(d&&d.amd)a.r,void 0!==g&&a.v(g);else this.xor128=g}(a.e,b,"function"==typeof define&&define)},696209,(a,b,c)=>{!function(b,c,d){function e(a){var b=this,c="";b.next=function(){var a=b.x^b.x>>>2;return b.x=b.y,b.y=b.z,b.z=b.w,b.w=b.v,(b.d=b.d+362437|0)+(b.v=b.v^b.v<<4^(a^a<<1))|0},b.x=0,b.y=0,b.z=0,b.w=0,b.v=0,a===(0|a)?b.x=a:c+=a;for(var d=0;d<c.length+64;d++)b.x^=c.charCodeAt(d),d==c.length&&(b.d=b.x<<10^b.x>>>4),b.next()}function f(a,b){return b.x=a.x,b.y=a.y,b.z=a.z,b.w=a.w,b.v=a.v,b.d=a.d,b}function g(a,b){var c=new e(a),d=b&&b.state,g=function(){return(c.next()>>>0)/0x100000000};return g.double=function(){do var a=((c.next()>>>11)+(c.next()>>>0)/0x100000000)/2097152;while(0===a)return a},g.int32=c.next,g.quick=g,d&&("object"==typeof d&&f(d,c),g.state=function(){return f(c,{})}),g}if(c&&c.exports)c.exports=g;else if(d&&d.amd)a.r,void 0!==g&&a.v(g);else this.xorwow=g}(a.e,b,"function"==typeof define&&define)},933556,(a,b,c)=>{!function(b,c,d){function e(a){var b=this;b.next=function(){var a,c,d=b.x,e=b.i;return a=d[e],a^=a>>>7,c=a^a<<24^((a=d[e+1&7])^a>>>10)^((a=d[e+3&7])^a>>>3)^((a=d[e+4&7])^a<<7),a=d[e+7&7],a^=a<<13,c^=a^a<<9,d[e]=c,b.i=e+1&7,c};var c,d=a,e=[];if(d===(0|d))e[0]=d;else for(c=0,d=""+d;c<d.length;++c)e[7&c]=e[7&c]<<15^d.charCodeAt(c)+e[c+1&7]<<13;for(;e.length<8;)e.push(0);for(c=0;c<8&&0===e[c];++c);for(8==c?e[7]=-1:e[c],b.x=e,b.i=0,c=256;c>0;--c)b.next()}function f(a,b){return b.x=a.x.slice(),b.i=a.i,b}function g(a,b){null==a&&(a=+new Date);var c=new e(a),d=b&&b.state,g=function(){return(c.next()>>>0)/0x100000000};return g.double=function(){do var a=((c.next()>>>11)+(c.next()>>>0)/0x100000000)/2097152;while(0===a)return a},g.int32=c.next,g.quick=g,d&&(d.x&&f(d,c),g.state=function(){return f(c,{})}),g}if(c&&c.exports)c.exports=g;else if(d&&d.amd)a.r,void 0!==g&&a.v(g);else this.xorshift7=g}(a.e,b,"function"==typeof define&&define)},521073,(a,b,c)=>{!function(b,c,d){function e(a){var b=this;b.next=function(){var a,c,d=b.w,e=b.X,f=b.i;return b.w=d=d+0x61c88647|0,c=e[f+34&127],a=e[f=f+1&127],c^=c<<13,a^=a<<17,c^=c>>>15,a^=a>>>12,c=e[f]=c^a,b.i=f,c+(d^d>>>16)|0},!function(a,b){var c,d,e,f,g,h=[],i=128;for(b===(0|b)?(d=b,b=null):(b+="\0",d=0,i=Math.max(i,b.length)),e=0,f=-32;f<i;++f)b&&(d^=b.charCodeAt((f+32)%b.length)),0===f&&(g=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,f>=0&&(g=g+0x61c88647|0,e=0==(c=h[127&f]^=d+g)?e+1:0);for(e>=128&&(h[127&(b&&b.length||0)]=-1),e=127,f=512;f>0;--f)d=h[e+34&127],c=h[e=e+1&127],d^=d<<13,c^=c<<17,d^=d>>>15,c^=c>>>12,h[e]=d^c;a.w=g,a.X=h,a.i=e}(b,a)}function f(a,b){return b.i=a.i,b.w=a.w,b.X=a.X.slice(),b}function g(a,b){null==a&&(a=+new Date);var c=new e(a),d=b&&b.state,g=function(){return(c.next()>>>0)/0x100000000};return g.double=function(){do var a=((c.next()>>>11)+(c.next()>>>0)/0x100000000)/2097152;while(0===a)return a},g.int32=c.next,g.quick=g,d&&(d.X&&f(d,c),g.state=function(){return f(c,{})}),g}if(c&&c.exports)c.exports=g;else if(d&&d.amd)a.r,void 0!==g&&a.v(g);else this.xor4096=g}(a.e,b,"function"==typeof define&&define)},420251,(a,b,c)=>{!function(b,c,d){function e(a){var b=this,c="";b.next=function(){var a=b.b,c=b.c,d=b.d,e=b.a;return a=a<<25^a>>>7^c,c=c-d|0,d=d<<24^d>>>8^e,e=e-a|0,b.b=a=a<<20^a>>>12^c,b.c=c=c-d|0,b.d=d<<16^c>>>16^e,b.a=e-a|0},b.a=0,b.b=0,b.c=-0x61c88647,b.d=0x517cc1b7,a===Math.floor(a)?(b.a=a/0x100000000|0,b.b=0|a):c+=a;for(var d=0;d<c.length+20;d++)b.b^=c.charCodeAt(d),b.next()}function f(a,b){return b.a=a.a,b.b=a.b,b.c=a.c,b.d=a.d,b}function g(a,b){var c=new e(a),d=b&&b.state,g=function(){return(c.next()>>>0)/0x100000000};return g.double=function(){do var a=((c.next()>>>11)+(c.next()>>>0)/0x100000000)/2097152;while(0===a)return a},g.int32=c.next,g.quick=g,d&&("object"==typeof d&&f(d,c),g.state=function(){return f(c,{})}),g}if(c&&c.exports)c.exports=g;else if(d&&d.amd)a.r,void 0!==g&&a.v(g);else this.tychei=g}(a.e,b,"function"==typeof define&&define)},561965,(a,b,c)=>{!function(c,d,e){var f,g="random",h=e.pow(256,6),i=e.pow(2,52),j=2*i;function k(a,b,k){var p=[],q=n(function a(b,c){var d,e=[],f=typeof b;if(c&&"object"==f)for(d in b)try{e.push(a(b[d],c-1))}catch(a){}return e.length?e:"string"==f?b:b+"\0"}((b=!0==b?{entropy:!0}:b||{}).entropy?[a,o(d)]:null==a?function(){try{var a;return f&&(a=f.randomBytes)?a=a(256):(a=new Uint8Array(256),(c.crypto||c.msCrypto).getRandomValues(a)),o(a)}catch(a){var b=c.navigator,e=b&&b.plugins;return[+new Date,c,e,c.screen,o(d)]}}():a,3),p),r=new l(p),s=function(){for(var a=r.g(6),b=h,c=0;a<i;)a=(a+c)*256,b*=256,c=r.g(1);for(;a>=j;)a/=2,b/=2,c>>>=1;return(a+c)/b};return s.int32=function(){return 0|r.g(4)},s.quick=function(){return r.g(4)/0x100000000},s.double=s,n(o(r.S),d),(b.pass||k||function(a,b,c,d){return(d&&(d.S&&m(d,r),a.state=function(){return m(r,{})}),c)?(e[g]=a,b):a})(s,q,"global"in b?b.global:this==e,b.state)}function l(a){var b,c=a.length,d=this,e=0,f=d.i=d.j=0,g=d.S=[];for(c||(a=[c++]);e<256;)g[e]=e++;for(e=0;e<256;e++)g[e]=g[f=255&f+a[e%c]+(b=g[e])],g[f]=b;(d.g=function(a){for(var b,c=0,e=d.i,f=d.j,g=d.S;a--;)b=g[e=255&e+1],c=256*c+g[255&(g[e]=g[f=255&f+b])+(g[f]=b)];return d.i=e,d.j=f,c})(256)}function m(a,b){return b.i=a.i,b.j=a.j,b.S=a.S.slice(),b}function n(a,b){for(var c,d=a+"",e=0;e<d.length;)b[255&e]=255&(c^=19*b[255&e])+d.charCodeAt(e++);return o(b)}function o(a){return String.fromCharCode.apply(0,a)}if(n(e.random(),d),b.exports){b.exports=k;try{f=a.r(254799)}catch(a){}}else if("function"==typeof define&&define.amd)a.r,void 0!==k&&a.v(k);else e["seed"+g]=k}("undefined"!=typeof self?self:a.e,[],Math)},999416,(a,b,c)=>{var d=a.r(791919),e=a.r(700734),f=a.r(696209),g=a.r(933556),h=a.r(521073),i=a.r(420251),j=a.r(561965);j.alea=d,j.xor128=e,j.xorwow=f,j.xorshift7=g,j.xor4096=h,j.tychei=i,b.exports=j},99348,(a,b,c)=>{b.exports=a.x("string_decoder",()=>require("string_decoder"))},409e3,708720,a=>{"use strict";let b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w;class x{constructor(a,b){this.backend=a,this.dataMover=b,this.data=new WeakMap,this.dataIdsCount=0}get(a){return this.data.has(a)||this.dataMover.moveData(this.backend,a),this.data.get(a)}set(a,b){this.dataIdsCount++,this.data.set(a,b)}has(a){return this.data.has(a)}delete(a){return this.dataIdsCount--,this.data.delete(a)}numDataIds(){return this.dataIdsCount}}class y{refCount(a){return z("refCount")}incRef(a){return z("incRef")}timerAvailable(){return!0}time(a){return z("time")}read(a){return z("read")}readSync(a){return z("readSync")}readToGPU(a,b){return z("readToGPU")}numDataIds(){return z("numDataIds")}disposeData(a,b){return z("disposeData")}write(a,b,c){return z("write")}move(a,b,c,d,e){return z("move")}createTensorFromGPUData(a,b,c){return z("createTensorFromGPUData")}memory(){return z("memory")}floatPrecision(){return z("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return z("dispose")}}function z(a){throw Error(`'${a}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function A(a){let b=a.length,c=0;for(;b>0;)c=Math.random()*b|0,E(a,--b,c)}function B(a,b){if(a.length!==b.length)throw Error(`Array sizes must match to be shuffled together First array length was ${a.length}Second array length was ${b.length}`);let c=a.length,d=0;for(;c>0;)d=Math.random()*c|0,E(a,--c,d),E(b,c,d)}function C(a,b,c){return Math.max(a,Math.min(b,c))}function D(a){return a%2==0?a:a+1}function E(a,b,c){let d=a[b];a[b]=a[c],a[c]=d}function F(a){let b=0;for(let c=0;c<a.length;c++)b+=a[c];return b}function G(a,b){let c=Math.random();return b*c+(1-c)*a}function H(a,b){let c=0;for(let d=0;d<a.length;d++){let e=Number(a[d])-Number(b[d]);c+=e*e}return c}function I(a,b){if(!a)throw Error("string"==typeof b?b:b())}function J(a,b,c=""){I(O(a,b),()=>c+` Shapes ${a} and ${b} must match`)}function K(a){I(null!=a,()=>"The input to the tensor constructor must be a non-null value.")}function L(a){if(0===a.length)return 1;let b=a[0];for(let c=1;c<a.length;c++)b*=a[c];return b}function M(a){return 0===a.length}function N(a,b){if(a===b)return!0;if(null==a||null==b||a.length!==b.length)return!1;for(let c=0;c<a.length;c++)if(null!==a[c]&&null!==b[c]&&a[c]!==b[c])return!1;return!0}function O(a,b){if(a===b)return!0;if(null==a||null==b||a.length!==b.length)return!1;for(let c=0;c<a.length;c++)if(a[c]!==b[c])return!1;return!0}function P(a){return a%1==0}function Q(a){if(null!=Math.tanh)return Math.tanh(a);if(a===1/0)return 1;{if(a===-1/0)return -1;let b=Math.exp(2*a);return(b-1)/(b+1)}}function R(a){let b=Math.ceil(Math.sqrt(a));return[b,Math.ceil(a/b)]}function S(a){let b=new Uint32Array(a);for(let c=0;c<a;++c)b[c]=c;return A(b),b}function T(a,b){return b<=a.length?a:a+" ".repeat(b-a.length)}function U(a,b=a=>0,c,d){return new Promise((e,f)=>{let g=0,h=()=>{if(a())return void e();let i=b(++g);null!=c&&g>=c?f():null!=d?d(h,i):setTimeout(h,i)};h()})}function V(a,b){let c=1,d=-1;for(let b=0;b<a.length;++b)if(a[b]>=0)c*=a[b];else if(-1===a[b]){if(-1!==d)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${d} and dim ${b}`);d=b}else if(a[b]<0)throw Error(`Shapes can not be < 0. Found ${a[b]} at dim ${b}`);if(-1===d){if(b>0&&b!==c)throw Error(`Size(${b}) must match the product of shape ${a}`);return a}if(0===c)throw Error(`Cannot infer the missing size in [${a}] when there are 0 elements`);if(b%c!=0)throw Error(`The implicit shape can't be a fractional number. Got ${b} / ${c}`);let e=a.slice();return e[d]=b/c,e}function W(a,b){let c=b.length;return I((a=null==a?b.map((a,b)=>b):[].concat(a)).every(a=>a>=-c&&a<c),()=>`All values in axis param must be in range [-${c}, ${c}) but got axis ${a}`),I(a.every(a=>P(a)),()=>`All values in axis param must be integers but got axis ${a}`),a.map(a=>a<0?c+a:a)}function X(a,b){let c=[],d=[],e=null!=b&&Array.isArray(b)&&0===b.length,f=null==b||e?null:W(b,a).sort(),g=0;for(let b=0;b<a.length;++b){if(null!=f){if(f[g]===b&&1!==a[b])throw Error(`Can't squeeze axis ${b} since its dim '${a[b]}' is not 1`);(null==f[g]||f[g]>b)&&1===a[b]&&(c.push(a[b]),d.push(b)),f[g]<=b&&g++}1!==a[b]&&(c.push(a[b]),d.push(b))}return{newShape:c,keptDims:d}}function Y(a,b){return Z(a,b)}function Z(a,b){let c=null;if(null==a||"float32"===a)c=new Float32Array(b);else if("int32"===a)c=new Int32Array(b);else if("bool"===a)c=new Uint8Array(b);else if("string"===a)c=Array(b);else throw Error(`Unknown data type ${a}`);return c}function $(a,b){for(let c=0;c<a.length;c++){let d=a[c];if(isNaN(d)||!isFinite(d))throw Error(`A tensor of type ${b} being uploaded contains ${d}.`)}}function _(a){return"bool"===a||"complex64"===a||"float32"===a||"int32"===a||"string"===a}function aa(a,b){return"complex64"!==b&&("float32"!==b||"complex64"===a)&&("int32"!==b||"float32"===a||"complex64"===a)&&("bool"!==b||"bool"!==a)}function ab(a){if("float32"===a||"int32"===a)return 4;if("complex64"===a)return 8;if("bool"===a)return 1;throw Error(`Unknown dtype ${a}`)}function ac(a){if(null==a)return 0;let b=0;return a.forEach(a=>b+=a.length),b}function ad(a){return"string"==typeof a||a instanceof String}function ae(a){return"boolean"==typeof a}function af(a){return"number"==typeof a}function ag(a){if(Array.isArray(a))return ag(a[0]);if(a instanceof Float32Array);else if(a instanceof Int32Array||a instanceof Uint8Array||a instanceof Uint8ClampedArray)return"int32";else if(af(a));else if(ad(a))return"string";else if(ae(a))return"bool";return"float32"}function ah(a){return!!(a&&a.constructor&&a.call&&a.apply)}function ai(a,b){for(let c=b;c<a;++c)if(a%c==0)return c;return a}function aj(a){let b=a.length;if(b<2)return[];let c=Array(b-1);c[b-2]=a[b-1];for(let d=b-3;d>=0;--d)c[d]=c[d+1]*a[d+1];return c}function ak(a,b,c=!1){if(0===a.length)return b[0];let d=a.reduce((a,b)=>a*b)*(c?2:1);if(0===d)return[];if(d!==b.length)throw Error(`[${a}] does not match the input size ${b.length}${c?" for a complex tensor":""}.`);return function a(b,c,d,e=!1){let f=[];if(1===c.length){let a=c[0]*(e?2:1);for(let c=0;c<a;c++)f[c]=d[b+c]}else{let g=c[0],h=c.slice(1),i=h.reduce((a,b)=>a*b)*(e?2:1);for(let c=0;c<g;c++)f[c]=a(b+c*i,h,d,e)}return f}(0,a,b,c)}function al(a,b){if(Array.isArray(a))return a;if("float32"===b)return a instanceof Float32Array?a:new Float32Array(a);if("int32"===b)return a instanceof Int32Array?a:new Int32Array(a);if("bool"===b||"string"===b)return Uint8Array.from(new Int32Array(a));throw Error(`Unknown dtype ${b}`)}function am(a,b){let c=an(a,b);for(let a=0;a<c.length;a++)c[a]=1;return c}function an(a,b){if(null==b||"float32"===b||"complex64"===b)return new Float32Array(a);if("int32"===b)return new Int32Array(a);if("bool"===b)return new Uint8Array(a);throw Error(`Unknown data type ${b}`)}function ao(a,b){let c=a.reduce((a,b)=>a*b,1);if(null==b||"float32"===b)return ak(a,new Float32Array(c));if("int32"===b)return ak(a,new Int32Array(c));if("bool"===b)return ak(a,new Uint8Array(c));throw Error(`Unknown data type ${b}`)}function ap(a){a.forEach(b=>{I(Number.isInteger(b)&&b>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${a}].`)})}function aq(a,b,c){if(0===b)return 0;if(1===b)return a[0];let d=a[a.length-1];for(let b=0;b<a.length-1;++b)d+=c[b]*a[b];return d}function ar(a,b,c){if(0===b)return[];if(1===b)return[a];let d=Array(b);for(let b=0;b<d.length-1;++b)d[b]=Math.floor(a/c[b]),a-=d[b]*c[b];return d[d.length-1]=a,d}function as(a){return a&&a.then&&"function"==typeof a.then}a.s(["arraysEqual",()=>O,"arraysEqualWithNull",()=>N,"assert",()=>I,"assertNonNegativeIntegerDimensions",()=>ap,"assertNonNull",()=>K,"assertShapesMatch",()=>J,"bytesFromStringArray",()=>ac,"bytesPerElement",()=>ab,"checkConversionForErrors",()=>$,"clamp",()=>C,"computeStrides",()=>aj,"convertBackendValuesAndArrayBuffer",()=>al,"createShuffledIndices",()=>S,"distSquared",()=>H,"getArrayFromDType",()=>Z,"getTypedArrayFromDType",()=>Y,"hasEncodingLoss",()=>aa,"indexToLoc",()=>ar,"inferDtype",()=>ag,"inferFromImplicitShape",()=>V,"isBoolean",()=>ae,"isFunction",()=>ah,"isInt",()=>P,"isNumber",()=>af,"isPromise",()=>as,"isScalarShape",()=>M,"isString",()=>ad,"isValidDtype",()=>_,"locToIndex",()=>aq,"makeOnesTypedArray",()=>am,"makeZerosNestedTypedArray",()=>ao,"makeZerosTypedArray",()=>an,"nearestDivisor",()=>ai,"nearestLargerEven",()=>D,"parseAxisParam",()=>W,"randUniform",()=>G,"repeatedTry",()=>U,"rightPad",()=>T,"shuffle",()=>A,"shuffleCombo",()=>B,"sizeFromShape",()=>L,"sizeToSquarishShape",()=>R,"squeezeShape",()=>X,"sum",()=>F,"swap",()=>E,"tanh",()=>Q,"toNestedArray",()=>ak],134750);let at="tfjsflags";class au{constructor(a){this.global=a,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=av,this.populateURLFlags()}setPlatform(a,b){null==this.platform||aw.getBool("IS_TEST")||aw.getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${a}.`),this.platformName=a,this.platform=b}registerFlag(a,b,c){if(this.flagRegistry[a]={evaluationFn:b,setHook:c},null!=this.urlFlags[a]){let b=this.urlFlags[a];aw.getBool("IS_TEST")||aw.getBool("PROD")||console.warn(`Setting feature override from URL ${a}: ${b}.`),this.set(a,b)}}async getAsync(a){return a in this.flags||(this.flags[a]=await this.evaluateFlag(a)),this.flags[a]}get(a){if(a in this.flags)return this.flags[a];let b=this.evaluateFlag(a);if(as(b))throw Error(`Flag ${a} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[a]=b,this.flags[a]}getNumber(a){return this.get(a)}getBool(a){return this.get(a)}getString(a){return this.get(a)}getFlags(){return this.flags}get features(){return this.flags}set(a,b){if(null==this.flagRegistry[a])throw Error(`Cannot set flag ${a} as it has not been registered.`);this.flags[a]=b,null!=this.flagRegistry[a].setHook&&this.flagRegistry[a].setHook(b)}evaluateFlag(a){if(null==this.flagRegistry[a])throw Error(`Cannot evaluate flag '${a}': no evaluation function found.`);return this.flagRegistry[a].evaluationFn()}setFlags(a){this.flags=Object.assign({},a)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;let a=this.getQueryParams(this.global.location.search);at in a&&a[at].split(",").forEach(a=>{var b;let c,[d,e]=a.split(":");this.urlFlags[d]="true"===(c=(b=e).toLowerCase())||"false"===c?"true"===c:`${+c}`===c?+c:b})}}function av(a){let b={};return a.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(a,...c)=>{var d,e,f;return d=b,e=c[0],f=c[1],d[decodeURIComponent(e)]=decodeURIComponent(f||""),c.join("=")}),b}let aw=null;function ax(){null==b&&(b=a.g);return b}function ay(a,b){let c,d=(null==(c=ax())._tfGlobals&&(c._tfGlobals=new Map),c._tfGlobals);if(d.has(a))return d.get(a);{let c=b();return d.set(a,c),d.get(a)}}let az="Acos",aA="Acosh",aB="AddN",aC="ArgMax",aD="ArgMin",aE="Asin",aF="Asinh",aG="Atan",aH="Atanh",aI="Atan2",aJ="AvgPool",aK="AvgPoolGrad",aL="AvgPool3D",aM="AvgPool3DGrad",aN="BatchMatMul",aO="BatchToSpaceND",aP="Bincount",aQ="BitwiseAnd",aR="BroadcastArgs",aS="Cast",aT="Ceil",aU="ClipByValue",aV="Complex",aW="ComplexAbs",aX="Concat",aY="Conv2D",aZ="Conv2DBackpropFilter",a$="Conv2DBackpropInput",a_="Conv3D",a0="Conv3DBackpropFilterV2",a1="Conv3DBackpropInputV2",a2="Cosh",a3="Cumprod",a4="Cumsum",a5="CropAndResize",a6="DenseBincount",a7="DepthToSpace",a8="DepthwiseConv2dNative",a9="DepthwiseConv2dNativeBackpropFilter",ba="DepthwiseConv2dNativeBackpropInput",bb="Diag",bc="Dilation2D",bd="Dilation2DBackpropInput",be="Dilation2DBackpropFilter",bf="Draw",bg="RealDiv",bh="Einsum",bi="EluGrad",bj="Equal",bk="ExpandDims",bl="Expm1",bm="Fill",bn="FlipLeftRight",bo="Floor",bp="FloorDiv",bq="FusedBatchNorm",br="GatherV2",bs="GatherNd",bt="Greater",bu="GreaterEqual",bv="Identity",bw="IFFT",bx="Imag",by="IsFinite",bz="IsInf",bA="IsNan",bB="LeakyRelu",bC="Less",bD="LessEqual",bE="LinSpace",bF="Log1p",bG="LogicalAnd",bH="LogicalNot",bI="LogicalOr",bJ="LRNGrad",bK="Maximum",bL="MaxPool",bM="MaxPoolGrad",bN="MaxPool3D",bO="MaxPool3DGrad",bP="MaxPoolWithArgmax",bQ="Mean",bR="Minimum",bS="MirrorPad",bT="Multinomial",bU="Multiply",bV="NotEqual",bW="NonMaxSuppressionV3",bX="NonMaxSuppressionV4",bY="NonMaxSuppressionV5",bZ="OnesLike",b$="OneHot",b_="Pack",b0="PadV2",b1="Prelu",b2="Prod",b3="RaggedGather",b4="RaggedRange",b5="RaggedTensorToTensor",b6="Range",b7="Real",b8="Reciprocal",b9="Relu",ca="Reshape",cb="ResizeNearestNeighbor",cc="ResizeNearestNeighborGrad",cd="ResizeBilinear",ce="ResizeBilinearGrad",cf="Relu6",cg="Reverse",ch="Round",ci="Rsqrt",cj="ScatterNd",ck="TensorScatterUpdate",cl="SearchSorted",cm="Select",cn="Selu",co="Slice",cp="Sinh",cq="Sign",cr="Sigmoid",cs="Softplus",ct="Sqrt",cu="SpaceToBatchND",cv="SplitV",cw="Softmax",cx="SparseFillEmptyRows",cy="SparseReshape",cz="SparseSegmentMean",cA="SparseSegmentSum",cB="SparseToDense",cC="SquaredDifference",cD="Square",cE="StaticRegexReplace",cF="StridedSlice",cG="StringNGrams",cH="StringSplit",cI="StringToHashBucketFast",cJ="Tanh",cK="Tile",cL="TopK",cM="Transform",cN="Transpose",cO="Unique",cP="Unpack",cQ="UnsortedSegmentSum",cR="ZerosLike",cS="Step",cT="FromPixels",cU="RotateWithOffset",cV="_FusedMatMul",cW="FusedConv2D",cX="FusedDepthwiseConv2D";function cY(...a){aw.getBool("IS_TEST")||aw.getBool("PROD")||console.warn(...a)}function cZ(...a){aw.getBool("IS_TEST")||aw.getBool("PROD")||console.log(...a)}a.s(["log",()=>cZ,"warn",()=>cY],384572);let c$=ay("kernelRegistry",()=>new Map),c_=ay("gradRegistry",()=>new Map);function c0(a,b){var c,d;let e=(c=a,d=b,`${d}_${c}`);return c$.get(e)}function c1(a){let b=c$.entries(),c=[];for(;;){let{done:d,value:e}=b.next();if(d)break;let[f,g]=e,[h]=f.split("_");h===a&&c.push(g)}return c}function c2(a){var b,c;let{kernelName:d,backendName:e}=a,f=(b=d,c=e,`${c}_${b}`);c$.has(f)&&cY(`The kernel '${d}' for backend '${e}' is already registered`),c$.set(f,a)}function c3(a){return a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array||a instanceof Uint8ClampedArray}function c4(a,b){return"string"===b?c8(a):c5([a],b)}function c5(a,b){var c;if("string"===b)throw Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(a)&&(a=db(a)),aw.getBool("DEBUG")&&$(a,b),(c=a)instanceof Float32Array&&"float32"===b||c instanceof Int32Array&&"int32"===b||c instanceof Uint8Array&&"bool"===b)return a;if(null==b||"float32"===b||"complex64"===b)return new Float32Array(a);if("int32"===b)return new Int32Array(a);if("bool"===b){let b=new Uint8Array(a.length);for(let c=0;c<b.length;++c)0!==Math.round(a[c])&&(b[c]=1);return b}throw Error(`Unknown data type ${b}`)}function c6(){return aw.platform.now()}function c7(a,b){return aw.platform.fetch(a,b)}function c8(a,b="utf-8"){return b=b||"utf-8",aw.platform.encode(a,b)}function c9(a,b="utf-8"){return b=b||"utf-8",aw.platform.decode(a,b)}function da(a){return null!=aw.platform.isTypedArray?aw.platform.isTypedArray(a):c3(a)}function db(a,b=[],c=!1){if(null==b&&(b=[]),"boolean"==typeof a||"number"==typeof a||"string"==typeof a||as(a)||null==a||da(a)&&c)b.push(a);else if(Array.isArray(a)||da(a))for(let d=0;d<a.length;++d)db(a[d],b,c);else{let d=-1;for(let b of Object.keys(a))/^([1-9]+[0-9]*|0)$/.test(b)&&(d=Math.max(d,Number(b)));for(let e=0;e<=d;e++)db(a[e],b,c)}return b}a.s(["createScalarValue",()=>c4,"decodeString",()=>c9,"encodeString",()=>c8,"fetch",()=>c7,"flatten",()=>db,"isTypedArray",()=>da,"now",()=>c6,"toTypedArray",()=>c5],317594);class dc{constructor(a,b){this.backendTimer=a,this.logger=b,null==b&&(this.logger=new dd)}profileKernel(a,b,c){let d,e,f=()=>{d=c()},g=c6();if(this.backendTimer.timerAvailable())e=this.backendTimer.time(f);else{for(let a of(f(),d))a.dataSync();e=Promise.resolve({kernelMs:c6()-g})}if(aw.getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let b=0;b<d.length;b++){let c=d[b];c.data().then(b=>{!function(a,b,c){if("float32"===b)for(let b=0;b<a.length;b++){let d=a[b];if(isNaN(d)||!isFinite(d))return console.warn(`Found ${d} in the result of '${c}'`),!0}}(b,c.dtype,a)})}return{kernelName:a,outputs:d,inputs:b,timeMs:e.then(a=>a.kernelMs),extraInfo:e.then(a=>null!=a.getExtraProfileInfo?a.getExtraProfileInfo():"")}}logKernelProfile(a){let{kernelName:b,outputs:c,timeMs:d,inputs:e,extraInfo:f}=a;c.forEach(a=>{Promise.all([a.data(),d,f]).then(c=>{this.logger.logKernelProfile(b,a,c[0],c[1],e,c[2])})})}}class dd{logKernelProfile(a,b,c,d,e,f){let g="number"==typeof d?T(`${d}ms`,9):d.error,h=T(a,25),i=b.rank,j=b.size,k=T(b.shape.toString(),14),l="";for(let a in e){let c=e[a];if(null!=c){let d=c.shape||b.shape,e=d.length;l+=`${a}: ${e}D ${e>0?d:""} `}}console.log(`%c${h}	%c${g}	%c${i}D ${k}	%c${j}	%c${l}	%c${f}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function de(a,b,c){return T(Array.isArray(a)?`${parseFloat(a[0].toFixed(7))} + ${parseFloat(a[1].toFixed(7))}j`:ad(a)?`'${a}'`:"bool"===c?df(a):parseFloat(a.toFixed(7)).toString(),b)}function df(a){return 0===a?"false":"true"}function dg(a){let b=[];for(let c=0;c<a.length;c+=2)b.push([a[c],a[c+1]]);return b}class dh{constructor(a,b,c){if(this.dtype=b,this.shape=a.slice(),this.size=L(a),null!=c){const a=c.length;I(a===this.size,()=>`Length of values '${a}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===b)throw Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=c||Z(b,this.size),this.strides=aj(a)}set(a,...b){0===b.length&&(b=[0]),I(b.length===this.rank,()=>`The number of provided coordinates (${b.length}) must match the rank (${this.rank})`);let c=this.locToIndex(b);this.values[c]=a}get(...a){0===a.length&&(a=[0]);let b=0;for(let c of a){if(c<0||c>=this.shape[b])throw Error(`Requested out of range element at ${a}.   Buffer shape=${this.shape}`);b++}let c=a[a.length-1];for(let b=0;b<a.length-1;++b)c+=this.strides[b]*a[b];return this.values[c]}locToIndex(a){if(0===this.rank)return 0;if(1===this.rank)return a[0];let b=a[a.length-1];for(let c=0;c<a.length-1;++c)b+=this.strides[c]*a[c];return b}indexToLoc(a){if(0===this.rank)return[];if(1===this.rank)return[a];let b=Array(this.shape.length);for(let c=0;c<b.length-1;++c)b[c]=Math.floor(a/this.strides[c]),a-=b[c]*this.strides[c];return b[b.length-1]=a,b}get rank(){return this.shape.length}toTensor(){return di().makeTensor(this.values,this.shape,this.dtype)}}let di=null,dj=null;class dk{constructor(a,b,c,d){this.kept=!1,this.isDisposedInternal=!1,this.shape=a.slice(),this.dtype=b||"float32",this.size=L(a),this.strides=aj(a),this.dataId=c,this.id=d,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let a=await this.data();return dj.buffer(this.shape,this.dtype,a)}bufferSync(){return dj.buffer(this.shape,this.dtype,this.dataSync())}async array(){let a=await this.data();return ak(this.shape,a,"complex64"===this.dtype)}arraySync(){return ak(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let a=di().read(this.dataId);if("string"===this.dtype){let b=await a;try{return b.map(a=>c9(a))}catch(a){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return a}dataToGPU(a){return this.throwIfDisposed(),di().readToGPU(this.dataId,a)}dataSync(){this.throwIfDisposed();let a=di().readSync(this.dataId);if("string"===this.dtype)try{return a.map(a=>c9(a))}catch(a){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return a}async bytes(){this.throwIfDisposed();let a=await di().read(this.dataId);return"string"===this.dtype?a:new Uint8Array(a.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),di().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw Error("Tensor is disposed.")}print(a=!1){return dj.print(this,a)}clone(){return this.throwIfDisposed(),dj.clone(this)}toString(a=!1){var b,c,d;let e,f,g,h,i;return b=this.dataSync(),c=this.shape,d=this.dtype,e=aj(c),f=function(a,b,c,d){let e=L(b),f=d[d.length-1],g=Array(f).fill(0),h=b.length,i="complex64"===c?dg(a):a;if(h>1)for(let a=0;a<e/f;a++){let b=a*f;for(let a=0;a<f;a++)g[a]=Math.max(g[a],de(i[b+a],0,c).length)}return g}(b,c,d,e),g=c.length,h=function a(b,c,d,e,f,g=!0){let h="complex64"===d?2:1,i=c[0],j=c.length;if(0===j)return"complex64"===d?[de(dg(b)[0],0,d)]:"bool"===d?[df(b[0])]:[b[0].toString()];if(1===j){if(i>20){let a=Array.from(b.slice(0,3*h)),c=Array.from(b.slice((i-3)*h,i*h));return"complex64"===d&&(a=dg(a),c=dg(c)),["["+a.map((a,b)=>de(a,f[b],d)).join(", ")+", ..., "+c.map((a,b)=>de(a,f[i-3+b],d)).join(", ")+"]"]}return["["+("complex64"===d?dg(b):Array.from(b)).map((a,b)=>de(a,f[b],d)).join(", ")+"]"]}let k=c.slice(1),l=e.slice(1),m=e[0]*h,n=[];if(i>20){for(let c=0;c<3;c++){let e=c*m,g=e+m;n.push(...a(b.slice(e,g),k,d,l,f,!1))}n.push("...");for(let c=i-3;c<i;c++){let e=c*m,g=e+m;n.push(...a(b.slice(e,g),k,d,l,f,c===i-1))}}else for(let c=0;c<i;c++){let e=c*m,g=e+m;n.push(...a(b.slice(e,g),k,d,l,f,c===i-1))}let o=2===j?",":"";n[0]="["+(i>0?n[0]+o:"");for(let a=1;a<n.length-1;a++)n[a]=" "+n[a]+o;let p=",\n";for(let a=2;a<j;a++)p+="\n";return n[n.length-1]=" "+n[n.length-1]+"]"+(g?"":p),n}(b,c,d,e,f),i=["Tensor"],a&&(i.push(`  dtype: ${d}`),i.push(`  rank: ${g}`),i.push(`  shape: [${c}]`),i.push("  values:")),i.push(h.map(a=>"    "+a).join("\n")),i.join("\n")}cast(a){return this.throwIfDisposed(),dj.cast(this,a)}variable(a=!0,b,c){return this.throwIfDisposed(),di().makeVariable(this,a,b,c)}}function dl(){return ay("Tensor",()=>dk)}Object.defineProperty(dk,Symbol.hasInstance,{value:a=>!!a&&null!=a.data&&null!=a.dataSync&&null!=a.throwIfDisposed}),dl();class dm extends dk{constructor(a,b,c,d){super(a.shape,a.dtype,a.dataId,d),this.trainable=b,this.name=c}assign(a){if(a.dtype!==this.dtype)throw Error(`dtype of the new value (${a.dtype}) and previous value (${this.dtype}) must match`);if(!O(a.shape,this.shape))throw Error(`shape of the new value (${a.shape}) and previous value (${this.shape}) must match`);di().disposeTensor(this),this.dataId=a.dataId,di().incRef(this,null)}dispose(){di().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(dm,Symbol.hasInstance,{value:a=>a instanceof dk&&null!=a.assign&&a.assign instanceof Function}),(Br=BH||(BH={})).R0="R0",Br.R1="R1",Br.R2="R2",Br.R3="R3",Br.R4="R4",Br.R5="R5",Br.R6="R6",(Bs=BI||(BI={})).float32="float32",Bs.int32="int32",Bs.bool="int32",Bs.complex64="complex64",(Bt=BJ||(BJ={})).float32="float32",Bt.int32="int32",Bt.bool="bool",Bt.complex64="complex64",(Bu=BK||(BK={})).float32="float32",Bu.int32="float32",Bu.bool="float32",Bu.complex64="complex64",(Bv=BL||(BL={})).float32="complex64",Bv.int32="complex64",Bv.bool="complex64",Bv.complex64="complex64";let dn={float32:BK,int32:BI,bool:BJ,complex64:BL};function dp(a,b){if("string"===a||"string"===b){if("string"===a&&"string"===b)return"string";throw Error(`Can not upcast ${a} with ${b}`)}return dn[a][b]}function dq(a){return dp(a,"int32")}function dr(a){return null!=a&&"object"==typeof a&&"texture"in a&&a.texture instanceof WebGLTexture}function ds(a){return"undefined"!=typeof GPUBuffer&&null!=a&&"object"==typeof a&&"buffer"in a&&a.buffer instanceof GPUBuffer}function dt(a,b){if(a.dtype===b.dtype)return[a,b];let c=dp(a.dtype,b.dtype);return[a.cast(c),b.cast(c)]}function du(a,b){I(a.dtype===b.dtype,()=>`The dtypes of the first(${a.dtype}) and second(${b.dtype}) input must match`)}function dv(a,b){return b.some(b=>b.id===a.id)}function dw(a){let b=[];return function a(b,c,d){var e;if(null!=b){if(b instanceof dk)return void c.push(b);if(Array.isArray(e=b)||"object"==typeof e)for(let e in b){let f=b[e];d.has(f)||(d.add(f),a(f,c,d))}}}(a,b,new Set),b}function dx(a){return null!=a.kernelName}a.s(["assertTypesMatch",()=>du,"getTensorsInContainer",()=>dw,"isTensorInList",()=>dv,"makeTypesMatch",()=>dt],899899);class dy{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(a=>a.name)))}}}dispose(){for(let a in this.registeredVariables)this.registeredVariables[a].dispose()}}class dz{constructor(a){this.ENV=a,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new dy}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;let a=this.getSortedBackends();for(let b=0;b<a.length;b++){let c=a[b];if(await this.initializeBackend(c).success)return void await this.setBackend(c)}throw Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:a,asyncInit:b}=this.initializeBackendsAndReturnBest();if(b)throw Error(`The highest priority backend '${a}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(a)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(a){if(!(a in this.registry))if(!(a in this.registryFactory))return null;else{let{asyncInit:b}=this.initializeBackend(a);if(b)return null}return this.registry[a]}findBackendFactory(a){return a in this.registryFactory?this.registryFactory[a].factory:null}registerBackend(a,b,c=1){return a in this.registryFactory?(cY(`${a} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[a]={factory:b,priority:c},!0)}async setBackend(a){if(null==this.registryFactory[a])throw Error(`Backend name '${a}' not found in registry`);if(this.backendName=a,null==this.registry[a]){this.backendInstance=null;let{success:b,asyncInit:c}=this.initializeBackend(a);if(!(c?await b:b))return!1}return this.backendInstance=this.registry[a],this.setupRegisteredKernels(),this.profiler=new dc(this.backendInstance),!0}setupRegisteredKernels(){c1(this.backendName).forEach(a=>{null!=a.setupFunc&&a.setupFunc(this.backendInstance)})}disposeRegisteredKernels(a){c1(a).forEach(b=>{null!=b.disposeFunc&&b.disposeFunc(this.registry[a])})}initializeBackend(a){let b=this.registryFactory[a];if(null==b)throw Error(`Cannot initialize backend ${a}, no registration found.`);try{let c=b.factory();if(!c||c instanceof y||"function"!=typeof c.then)return this.registry[a]=c,{success:!0,asyncInit:!1};{let b=++this.pendingBackendInitId,d=c.then(c=>!(b<this.pendingBackendInitId)&&(this.registry[a]=c,this.pendingBackendInit=null,!0)).catch(c=>!(b<this.pendingBackendInitId)&&(this.pendingBackendInit=null,cY(`Initialization of backend ${a} failed`),cY(c.stack||c.message),!1));return this.pendingBackendInit=d,{success:d,asyncInit:!0}}}catch(b){return cY(`Initialization of backend ${a} failed`),cY(b.stack||b.message),{success:!1,asyncInit:!1}}}removeBackend(a){if(!(a in this.registryFactory))throw Error(`${a} backend not found in registry`);this.backendName===a&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,a in this.registry&&(this.disposeRegisteredKernels(a),this.registry[a].dispose(),delete this.registry[a]),delete this.registryFactory[a],this.backendName===a&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((a,b)=>this.registryFactory[b].priority-this.registryFactory[a].priority)}initializeBackendsAndReturnBest(){let a=this.getSortedBackends();for(let b=0;b<a.length;b++){let c=a[b],{success:d,asyncInit:e}=this.initializeBackend(c);if(e||d)return{name:c,asyncInit:e}}throw Error("Could not initialize any backends, all backend initializations failed.")}moveData(a,b){let c=this.state.tensorInfo.get(b),d=c.backend,e=this.readSync(b),f=d.refCount(b);d.disposeData(b,!0),c.backend=a,a.move(b,e,c.shape,c.dtype,f),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(a,b){let c,d=null;if(null==b){if("function"!=typeof a)throw Error("Please provide a function to tidy()");b=a}else{if("string"!=typeof a&&!(a instanceof String))throw Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof b)throw Error("When calling with two arguments, the 2nd argument to tidy() must be a function");d=a}return this.scopedRun(()=>this.startScope(d),()=>this.endScope(c),()=>((c=b())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),c))}scopedRun(a,b,c){a();try{let a=c();return b(),a}catch(a){throw b(),a}}nextTensorId(){return dz.nextTensorId++}nextVariableId(){return dz.nextVariableId++}clone(a){let b=dB.runKernel(bv,{x:a});return this.addTapeNode(this.state.activeScope.name,{x:a},[b],a=>({x:()=>dB.runKernel(aS,{x:a},{dtype:"float32"})}),[],{}),b}runKernel(a,b,c){if(null==this.backendName&&this.backend,null==c0(a,this.backendName))throw Error(`Kernel '${a}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:a,inputs:b,attrs:c})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(a,b,c){let d=this.backend.numDataIds(),e=0;c.forEach(a=>{e+="complex64"===a.dtype?3:1});let f=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],g=d-b-e-f;if(g>0)throw Error(`Backend '${this.backendName}' has an internal memory leak (${g} data ids) after running '${a}'`)}runKernelFunc(a){let b,c,d,e,f=[],g=this.isTapeOn(),h=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let j=dx(a)?a.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(dx(a)){let{kernelName:b,inputs:e,attrs:h}=a;null==this.backendName&&this.backend;let i=c0(b,this.backendName);I(null!=i,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),c=()=>{let a=this.backend.numDataIds(),c=Array.isArray(d=i.kernelFunc({inputs:e,attrs:h,backend:this.backend}))?d:[d];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,a,c);let j=c.map(a=>null!=a.rank?a:this.makeTensorFromTensorInfo(a));if(g){let a=this.getTensorsForGradient(b,e,j);f=this.saveTensorsForBackwardMode(a)}return j}}else{let{forwardFunc:b}=a,e=a=>{g&&(f=a.map(a=>this.keep(this.clone(a))))};c=()=>{let a=this.backend.numDataIds(),c=Array.isArray(d=this.tidy(()=>b(this.backend,e)))?d:[d];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(j,a,c),c}}let{inputs:k,attrs:l}=a,m=dx(a)?null:a.backwardsFunc;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(e=this.profiler.profileKernel(j,k,()=>c()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(e),b=e.outputs):b=c()}),g&&this.addTapeNode(j,k,b,m,f,l),this.state.profiling&&this.state.activeProfile.kernels.push({name:j,bytesAdded:this.state.numBytes-h,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(k).map(a=>null!=k[a]?k[a].shape:null),outputShapes:b.map(a=>a.shape),kernelTimeMs:e.timeMs,extraInfo:e.extraInfo}),Array.isArray(d)?b:b[0]}saveTensorsForBackwardMode(a){return a.map(a=>this.keep(this.clone(a)))}getTensorsForGradient(a,b,c){let d=c_.get(a);if(null!=d){let a,e=d.inputsToSave||[],f=d.outputsToSave||[];d.saveAllInputs?(I(Array.isArray(b),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(b).map(a=>b[a])):a=e.map(a=>b[a]);let g=c.filter((a,b)=>f[b]);return a.concat(g)}return[]}makeTensor(a,b,c,d){if(null==a)throw Error("Values passed to engine.makeTensor() are null");c=c||"float32",d=d||this.backend;let e=a;"string"===c&&ad(a[0])&&(e=a.map(a=>c8(a)));let f=d.write(e,b,c),g=new dk(b,c,f,this.nextTensorId());if(this.trackTensor(g,d),"string"===c){let a=this.state.tensorInfo.get(f),b=ac(e);this.state.numBytes+=b-a.bytes,a.bytes=b}return g}makeTensorFromDataId(a,b,c,d){let e={dataId:a,shape:b,dtype:c=c||"float32"};return this.makeTensorFromTensorInfo(e,d)}makeTensorFromTensorInfo(a,b){let{dataId:c,shape:d,dtype:e}=a,f=new dk(d,e,c,this.nextTensorId());return this.trackTensor(f,b),f}makeVariable(a,b=!0,c,d){c=c||this.nextVariableId().toString(),null!=d&&d!==a.dtype&&(a=a.cast(d));let e=new dm(a,b,c,this.nextTensorId());if(null!=this.state.registeredVariables[e.name])throw Error(`Variable with name ${e.name} was already registered`);return this.state.registeredVariables[e.name]=e,this.incRef(e,this.backend),e}trackTensor(a,b){this.state.numTensors++,"string"===a.dtype&&this.state.numStringTensors++;let c=0;"complex64"!==a.dtype&&"string"!==a.dtype&&(c=a.size*ab(a.dtype)),this.state.numBytes+=c,this.state.tensorInfo.has(a.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(a.dataId,{backend:b||this.backend,dtype:a.dtype,shape:a.shape,bytes:c})),a instanceof dm||this.track(a)}incRef(a,b){this.trackTensor(a,b),this.backend.incRef(a.dataId)}removeDataId(a,b){this.state.tensorInfo.has(a)&&this.state.tensorInfo.get(a).backend===b&&(this.state.tensorInfo.delete(a),this.state.numDataBuffers--)}disposeTensor(a){if(!this.state.tensorInfo.has(a.dataId))return;let b=this.state.tensorInfo.get(a.dataId);if(this.state.numTensors--,"string"===a.dtype&&(this.state.numStringTensors--,this.state.numBytes-=b.bytes),"complex64"!==a.dtype&&"string"!==a.dtype){let b=a.size*ab(a.dtype);this.state.numBytes-=b}b.backend.disposeData(a.dataId)&&this.removeDataId(a.dataId,b.backend)}disposeVariables(){for(let a in this.state.registeredVariables){let b=this.state.registeredVariables[a];this.disposeVariable(b)}}disposeVariable(a){this.disposeTensor(a),null!=this.state.registeredVariables[a.name]&&delete this.state.registeredVariables[a.name]}memory(){let a=this.backend.memory();return a.numTensors=this.state.numTensors,a.numDataBuffers=this.state.numDataBuffers,a.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(a.unreliable=!0,null==a.reasons&&(a.reasons=[]),a.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),a}async profile(a){this.state.profiling=!0;let b=this.state.numBytes,c=this.state.numTensors;for(let d of(this.state.activeProfile.kernels=[],this.state.activeProfile.result=await a(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(a=>a.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-b,this.state.activeProfile.newTensors=this.state.numTensors-c,this.state.activeProfile.kernels))d.kernelTimeMs=await d.kernelTimeMs,d.extraInfo=await d.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(a,b,c,d,e,f){let g={id:this.state.nextTapeNodeId++,kernelName:a,inputs:b,outputs:c,saved:e},h=c_.get(a);null!=h&&(d=h.gradFunc),null!=d&&(g.gradient=a=>(a=a.map((a,b)=>{if(null==a){let a=c[b],d=an(a.size,a.dtype);return this.makeTensor(d,a.shape,a.dtype)}return a}),d(a.length>1?a:a[0],e,f))),this.state.activeTape.push(g)}keep(a){return a.kept=!0,a}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(a){let b={track:[],name:"unnamed scope",id:this.state.nextScopeId++};a&&(b.name=a),this.state.scopeStack.push(b),this.state.activeScope=b}endScope(a){let b=dw(a),c=new Set(b.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){let b=this.state.activeScope.track[a];b.kept||c.has(b.id)||b.dispose()}let d=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],b.forEach(a=>{a.kept||a.scopeId!==d.id||this.track(a)})}gradients(a,b,c,d=!1){if(I(b.length>0,()=>"gradients() received an empty list of xs."),null!=c&&"float32"!==c.dtype)throw Error(`dy must have 'float32' dtype, but has '${c.dtype}'`);let e=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",a));I(e instanceof dk,()=>"The result y returned by f() must be a tensor.");let f=function(a,b,c){let d={},e={};for(let a=0;a<b.length;a++)d[b[a].id]=!0;for(let c=0;c<a.length;c++){let f=a[c],g=f.inputs;for(let a in g){let c=g[a],h=!1;for(let a=0;a<b.length;a++)if(d[c.id]){f.outputs.forEach(a=>d[a.id]=!0),h=!0,e[f.id]=!0;break}if(h)break}}let f={};f[c.id]=!0;let g={};for(let b=a.length-1;b>=0;b--){let c=a[b],d=c.inputs;for(let a=0;a<c.outputs.length;a++)if(f[c.outputs[a].id]){for(let a in d)f[d[a].id]=!0,g[c.id]=!0;break}}let h=[];for(let b=0;b<a.length;b++){let c=a[b];if(e[c.id]&&g[c.id]){let a={};for(let b in c.inputs){let e=c.inputs[b];d[e.id]&&(a[b]=e)}let b=Object.assign({},c);b.inputs=a,b.outputs=c.outputs,h.push(b)}}return h}(this.state.activeTape,b,e);if(!d&&0===f.length&&b.length>0)throw Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{var a;let d,g={};g[e.id]=null==c?(d=am(L(a=e.shape),"float32"),dB.makeTensor(d,a,"float32")):c,function(a,b,c,d){for(let e=b.length-1;e>=0;e--){let f=b[e],g=[];if(f.outputs.forEach(b=>{let c=a[b.id];null!=c?g.push(c):g.push(null)}),null==f.gradient)throw Error(`Cannot compute gradient: gradient function not found for ${f.kernelName}.`);let h=f.gradient(g);for(let b in f.inputs){if(!(b in h))throw Error(`Cannot backprop through input ${b}. Available gradients found: ${Object.keys(h)}.`);let e=c(()=>h[b]());if("float32"!==e.dtype)throw Error(`Error in gradient for op ${f.kernelName}. The gradient of input ${b} must have 'float32' dtype, but has '${e.dtype}'`);let g=f.inputs[b];if(!O(e.shape,g.shape))throw Error(`Error in gradient for op ${f.kernelName}. The gradient of input '${b}' has shape '${e.shape}', which does not match the shape of the input '${g.shape}'`);if(null==a[g.id])a[g.id]=e;else{let b=a[g.id];a[g.id]=d(b,e),b.dispose()}}}}(g,f,a=>this.tidy(a),dC);let h=b.map(a=>g[a.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(a=>{for(let b of a.saved)b.dispose()}),this.state.activeTape=null),{value:e,grads:h}})}customGrad(a){return I(ah(a),()=>"The f passed in customGrad(f) must be a function."),(...b)=>{let c;I(b.every(a=>a instanceof dk),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let d={};return b.forEach((a,b)=>{d[b]=a}),this.runKernelFunc({forwardFunc:(d,e)=>(I((c=a(...b,e)).value instanceof dk,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),I(ah(c.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),c.value),backwardsFunc:(a,d)=>{let e=c.gradFunc(a,d),f=Array.isArray(e)?e:[e];I(f.length===b.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),I(f.every(a=>a instanceof dk),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let g={};return f.forEach((a,b)=>{g[b]=()=>a}),g},inputs:d})}}readSync(a){return this.state.tensorInfo.get(a).backend.readSync(a)}read(a){return this.state.tensorInfo.get(a).backend.read(a)}readToGPU(a,b){return this.state.tensorInfo.get(a).backend.readToGPU(a,b)}async time(a){let b=c6(),c=await this.backend.time(a);return c.wallMs=c6()-b,c}track(a){return null!=this.state.activeScope&&(a.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(a)),a}get registeredVariables(){return this.state.registeredVariables}reset(){for(let a in this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new dy,this.registry)this.disposeRegisteredKernels(a),this.registry[a].dispose(),delete this.registry[a];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function dA(){let a=ax();if(null==a._tfengine){let b=new au(a);a._tfengine=new dz(b)}return aw=a._tfengine.ENV,di=()=>a._tfengine,a._tfengine}dz.nextTensorId=0,dz.nextVariableId=0;let dB=dA();function dC(a,b){return dB.runKernel("Add",{a,b})}function dD(a){c=a}function dE(a){if(void 0!==c)return c;if(a||"undefined"!=typeof navigator&&null!=navigator){if(a||(a=navigator),"ReactNative"===a.product)return!0;let b=a.userAgent||a.vendor||"";if(!b){let b=a;return b.userAgentData&&b.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(b)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(b.substr(0,4))}return!1}function dF(){return"undefined"!=typeof WorkerGlobalScope}a.s(["isBrowser",()=>dF,"isMobile",()=>dE,"mockIsMobile",()=>dD],550695);let dG=aw;function dH(a,b){let c=a;if(da(a))return"string"===b?[]:[a.length];if(dr(a)){let b=a.channels||"RGBA";return[a.height,a.width*b.length]}if(ds(a))return[a.buffer.size/(null==b?4:ab(b))];if(!Array.isArray(a))return[];let d=[];for(;Array.isArray(c)||da(c)&&"string"!==b;)d.push(c.length),c=c[0];return Array.isArray(a)&&aw.getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function a(b,c,d){if(d=d||[],!Array.isArray(b)&&!da(b))return void I(0===c.length,()=>`Element arr[${d.join("][")}] is a primitive, but should be an array/TypedArray of ${c[0]} elements`);I(c.length>0,()=>`Element arr[${d.join("][")}] should be a primitive, but is an array of ${b.length} elements`),I(b.length===c[0],()=>`Element arr[${d.join("][")}] should have ${c[0]} elements, but has ${b.length} elements`);let e=c.slice(1);for(let c=0;c<b.length;++c)a(b[c],e,d.concat(c))}(a,d,[]),d}function dI(a,b,c,d){if("string_or_numeric"!==a){if(null==a)throw Error("Expected dtype cannot be null.");if("numeric"!==a&&a!==b||"numeric"===a&&"string"===b)throw Error(`Argument '${c}' passed to '${d}' must be ${a} tensor, but got ${b} tensor`)}}function dJ(a,b,c,d="numeric"){if(a instanceof dl())return dI(d,a.dtype,b,c),a;let e=ag(a);if("string"!==e&&["bool","int32","float32"].indexOf(d)>=0&&(e=d),dI(d,e,b,c),null==a||!da(a)&&!Array.isArray(a)&&"number"!=typeof a&&"boolean"!=typeof a&&"string"!=typeof a){let d=null==a?"null":a.constructor.name;throw Error(`Argument '${b}' passed to '${c}' must be a Tensor or TensorLike, but got '${d}'`)}let f=dH(a,e);da(a)||Array.isArray(a)||(a=[a]);let g="string"!==e?c5(a,e):db(a,[],!0);return dB.makeTensor(g,f,e)}function dK(a,b,c,d="numeric"){if(!Array.isArray(a))throw Error(`Argument ${b} passed to ${c} must be a \`Tensor[]\` or \`TensorLike[]\``);return a.map((a,e)=>dJ(a,`${b}[${e}]`,c,d))}dG.registerFlag("DEBUG",()=>!1,a=>{a&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),dG.registerFlag("IS_BROWSER",()=>dF()),dG.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),dG.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),dG.registerFlag("IS_SAFARI",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),dG.registerFlag("PROD",()=>!1),dG.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>dG.getBool("DEBUG")),dG.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),dG.registerFlag("IS_TEST",()=>!1),dG.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>dG.getBool("DEBUG")),dG.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),dG.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),dG.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);let dL="__op";function dM(a){let b=Object.keys(a);if(1!==b.length)throw Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${b.length} keys.`);let c=b[0],d=a[c];c.endsWith("_")&&(c=c.substring(0,c.length-1));let e=(...a)=>{dB.startScope(c);try{let b=d(...a);return as(b)&&console.error("Cannot return a Promise inside of tidy."),dB.endScope(b),b}catch(a){throw dB.endScope(null),a}};return Object.defineProperty(e,"name",{value:c+=dL,configurable:!0}),e}let dN=dM({complex_:function(a,b){let c=dJ(a,"real","complex"),d=dJ(b,"imag","complex");return J(c.shape,d.shape,`real and imag shapes, ${c.shape} and ${d.shape}, must match in call to tf.complex().`),dB.runKernel(aV,{real:c,imag:d})}});function dO(a,b,c,d){if(null==d)d=ag(a);else if("complex64"===d)throw Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(ds(a)||dr(a)){if("float32"!==d&&"int32"!==d)throw Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${d}.`);return dB.backend.createTensorFromGPUData(a,b||c,d)}if(!da(a)&&!Array.isArray(a)&&"number"!=typeof a&&"boolean"!=typeof a&&"string"!=typeof a)throw Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=b){ap(b);let a=L(b),d=L(c);I(a===d,()=>`Based on the provided shape, [${b}], the tensor should have ${a} values but has ${d}`);for(let a=0;a<c.length;++a){let d=c[a],e=a!==c.length-1||d!==L(b.slice(a));I(c[a]===b[a]||!e,()=>`Error creating a new Tensor. Inferred shape (${c}) does not match the provided shape (${b}). `)}}return da(a)||Array.isArray(a)||(a=[a]),b=b||c,a="string"!==d?c5(a,d):db(a,[],!0),dB.makeTensor(a,b,d)}function dP(a,b,c){let d=dH(a,c);return dO(a,b,d,c)}let dQ={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class dR{static join(a){return new dR(a).slice()}constructor(a){if(this.shards=[],this.previousShardIndex=0,null==a||(a instanceof Array||(a=[a]),0===(a=a.map(a=>da(a)?a.buffer:a)).length))return;this.bufferUniformSize=a[0].byteLength;let b=0;for(let c=0;c<a.length;c++){const d=a[c];c!==a.length-1&&d.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const e=b+d.byteLength;this.shards.push({buffer:d,start:b,end:e}),b=e}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(a=0,b=this.byteLength){if(0===this.shards.length||(a=isNaN(Number(a))?0:a,b=isNaN(Number(b))?0:b,a=Math.max(0,a),(b=Math.min(this.byteLength,b))<=a))return new ArrayBuffer(0);let c=this.findShardForByte(a);if(-1===c)throw Error(`Could not find start shard for byte ${a}`);let d=new ArrayBuffer(b-a),e=new Uint8Array(d),f=0;for(let d=c;d<this.shards.length;d++){let c=this.shards[d],g=a+f-c.start,h=f,i=Math.min(b,c.end)-c.start,j=new Uint8Array(c.buffer,g,i-g);if(e.set(j,h),f+=j.length,b<c.end)break}return d}findShardForByte(a){if(0===this.shards.length||a<0||a>=this.byteLength)return -1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(a/this.bufferUniformSize),this.previousShardIndex;function b(b){return a<b.start?-1:+(a>=b.end)}if(0===b(this.shards[this.previousShardIndex]))return this.previousShardIndex;let c=function(a,b){let c=0,d=a.length;for(;c<=d;){let e=Math.floor((d-c)/2)+c,f=b(a[e]);if(0===f)return e;f<0?d=e:c=e+1}return -1}(this.shards,b);return -1===c?-1:(this.previousShardIndex=c,this.previousShardIndex)}}function dS(){return dB.memory()}function dT(a,b){return dB.tidy(a,b)}function dU(a){dw(a).forEach(a=>a.dispose())}function dV(a){return dB.keep(a)}function dW(a,b,c=1){return dB.registerBackend(a,b,c)}async function dX(a,b){let c=[],d=[],e=Array.isArray(a)?a.map(a=>a.name):Object.keys(a);for(let f=0;f<e.length;++f){let g=e[f],h=Array.isArray(a)?a[f].tensor:a[g];if("float32"!==h.dtype&&"int32"!==h.dtype&&"bool"!==h.dtype&&"string"!==h.dtype&&"complex64"!==h.dtype)throw Error(`Unsupported dtype in weight '${g}': ${h.dtype}`);let i={name:g,shape:h.shape,dtype:h.dtype};if("string"===h.dtype){let a=new Promise(async a=>{let b=await h.bytes(),c=new Uint8Array(b.reduce((a,b)=>a+b.length,0)+4*b.length),d=0;for(let a=0;a<b.length;a++){let e=b[a],f=new Uint8Array(new Uint32Array([e.length]).buffer);c.set(f,d),d+=4,c.set(e,d),d+=e.length}a(c)});d.push(a)}else d.push(h.data());null!=b&&(i.group=b),c.push(i)}return{data:function(a){if(null===a)throw Error(`Invalid input value: ${JSON.stringify(a)}`);let b=0,c=[];a.forEach(a=>{if(b+=a.byteLength,c.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});let d=new Uint8Array(b),e=0;return c.forEach(a=>{d.set(new Uint8Array(a.buffer),e),e+=a.byteLength}),d.buffer}(await Promise.all(d)),specs:c}}function dY(a,b){let c=new dR(a),d={},e=0;for(let a of b){let b=function(a,b){let c,d=L(a.shape);if("quantization"in a)c=dQ[a.quantization.dtype];else if("string"===a.dtype){let a=0;for(let c=0;c<d;c++)a+=4+new Uint32Array(b(a,a+4))[0];return a}else c=dQ[a.dtype];return d*c}(a,(a,b)=>c.slice(e+a,e+b));d[a.name]=d$(a,c.slice(e,e+b)),e+=b}return d}async function dZ(a,b){let c,d=L(a.shape);if("quantization"in a)c=dQ[a.quantization.dtype];else if("string"===a.dtype){let a=0;for(let c=0;c<d;c++)a+=4+new Uint32Array(await b(a,a+4))[0];return a}else c=dQ[a.dtype];return d*c}function d$(a,b){let c,d=a.name,e=a.dtype,f=a.shape,g=L(f),h=0;if("quantization"in a){let f=a.quantization;if("uint8"===f.dtype||"uint16"===f.dtype){if(!("min"in f&&"scale"in f))throw Error(`Weight ${a.name} with quantization ${f.dtype} doesn't have corresponding metadata min and scale.`)}else if("float16"===f.dtype){if("float32"!==e)throw Error(`Weight ${a.name} is quantized with ${f.dtype} which only supports weights of type float32 not ${e}.`)}else throw Error(`Weight ${a.name} has unknown quantization dtype ${f.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let i=dQ[f.dtype],j="uint8"===f.dtype?new Uint8Array(b):new Uint16Array(b);if("float32"===e)if("uint8"===f.dtype||"uint16"===f.dtype){c=new Float32Array(j.length);for(let a=0;a<j.length;a++){let b=j[a];c[a]=b*f.scale+f.min}}else if("float16"===f.dtype){let a,b,d;c=(a=function(){let a=a=>{let b=a<<13,c=0;for(;(8388608&b)==0;)c-=8388608,b<<=1;return(b&=-8388609)|(c+=0x38800000)},b=new Uint32Array(2048);b[0]=0;for(let c=1;c<1024;c++)b[c]=a(c);for(let a=1024;a<2048;a++)b[a]=0x38000000+(a-1024<<13);return b}(),b=function(){let a=new Uint32Array(64);a[0]=0,a[31]=0x47800000,a[32]=0x80000000,a[63]=0xc7800000;for(let b=1;b<31;b++)a[b]=b<<23;for(let b=33;b<63;b++)a[b]=0x80000000+(b-32<<23);return a}(),d=function(){let a=new Uint32Array(64);for(let b=0;b<64;b++)a[b]=1024;return a[0]=a[32]=0,a}(),c=>{let e=new ArrayBuffer(4*c.length),f=new Uint32Array(e);for(let e=0;e<c.length;e++){let g=c[e],h=a[d[g>>10]+(1023&g)]+b[g>>10];f[e]=h}return new Float32Array(e)})(j)}else throw Error(`Unsupported quantization type ${f.dtype} for weight type float32.`);else if("int32"===e){if("uint8"!==f.dtype&&"uint16"!==f.dtype)throw Error(`Unsupported quantization type ${f.dtype} for weight type int32.`);c=new Int32Array(j.length);for(let a=0;a<j.length;a++){let b=j[a];c[a]=Math.round(b*f.scale+f.min)}}else throw Error(`Unsupported dtype in weight '${d}': ${e}`);h+=g*i}else if("string"===e){let d=L(a.shape);c=[];for(let a=0;a<d;a++){let a=new Uint32Array(b.slice(h,h+4))[0];h+=4;let d=new Uint8Array(b.slice(h,h+a));c.push(d),h+=a}}else{let a=dQ[e];if("float32"===e)c=new Float32Array(b);else if("int32"===e)c=new Int32Array(b);else if("bool"===e)c=new Uint8Array(b);else if("complex64"===e){c=new Float32Array(b);let a=new Float32Array(c.length/2),d=new Float32Array(c.length/2);for(let b=0;b<a.length;b++)a[b]=c[2*b],d[b]=c[2*b+1];let e=dP(a,f,"float32"),g=dP(d,f,"float32"),h=dN(e,g);return e.dispose(),g.dispose(),h}else throw Error(`Unsupported dtype in weight '${d}': ${e}`);h+=g*a}return dP(c,f,e)}async function d_(a,b,c){let d=new Uint8Array(b);for(;d.byteLength<c;){let{done:b,value:e}=await a.read();if(b&&null==e){let a=c-d.byteLength;throw Error(`Reader is done but ${a} bytes are still expected`)}let f=new Uint8Array(d.length+e.byteLength);f.set(d,0),f.set(new Uint8Array(e),d.length),d=f}return d.buffer}async function d0(a,b){let c={},d=a.getReader(),e=new ArrayBuffer(0);for(let a of b){let b=await dZ(a,async(a,b)=>(e=await d_(d,e,b)).slice(a,b)),f=(e=await d_(d,e,b)).slice(0,b);e=e.slice(b);let g=d$(a,f);if(c[a.name]=g,"webgpu"===dB.backendName){let a=dB.backend;"uploadToGPU"in a&&L(g.shape)>=aw.get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&a.uploadToGPU(g.dataId)}}return c}let d1="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function d2(a){return d1?Buffer.byteLength(a,"utf8"):new Blob([a]).size}function d3(a){return dR.join(a)}function d4(a){for(a=a.trim();a.endsWith("/");)a=a.slice(0,a.length-1);let b=a.split("/");return b[b.length-1]}function d5(a,b){let c={modelTopology:a.modelTopology,format:a.format,generatedBy:a.generatedBy,convertedBy:a.convertedBy,weightsManifest:b};return null!=a.signature&&(c.signature=a.signature),null!=a.userDefinedMetadata&&(c.userDefinedMetadata=a.userDefinedMetadata),null!=a.modelInitializer&&(c.modelInitializer=a.modelInitializer),null!=a.initializerSignature&&(c.initializerSignature=a.initializerSignature),null!=a.trainingConfig&&(c.trainingConfig=a.trainingConfig),c}function d6(a,b,c){let d={modelTopology:a.modelTopology,format:a.format,generatedBy:a.generatedBy,convertedBy:a.convertedBy};if(null!=a.trainingConfig&&(d.trainingConfig=a.trainingConfig),null!=a.weightsManifest){if(!b)throw Error("modelJSON has weightsManifest but weightSpecs is null");if(!c)throw Error("modelJSON has weightsManifest but weightData is null");d.weightSpecs=b,d.weightData=c}return null!=a.signature&&(d.signature=a.signature),null!=a.userDefinedMetadata&&(d.userDefinedMetadata=a.userDefinedMetadata),null!=a.modelInitializer&&(d.modelInitializer=a.modelInitializer),null!=a.initializerSignature&&(d.initializerSignature=a.initializerSignature),d}async function d7(a,b){let c,d;return null!=a.weightsManifest&&([c,d]=await b(a.weightsManifest)),d6(a,c,d)}function d8(a){if(a.modelTopology instanceof ArrayBuffer)throw Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==a.modelTopology?0:d2(JSON.stringify(a.modelTopology)),weightSpecsBytes:null==a.weightSpecs?0:d2(JSON.stringify(a.weightSpecs)),weightDataBytes:null==a.weightData?0:new dR(a.weightData).byteLength}}function d9(a){let b=[];for(let c of a)b.push(...c.weights);return b}class ea{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==ea.instance&&(ea.instance=new ea),ea.instance}static registerSaveRouter(a){ea.getInstance().saveRouters.push(a)}static registerLoadRouter(a){ea.getInstance().loadRouters.push(a)}static getSaveHandlers(a){return ea.getHandlers(a,"save")}static getLoadHandlers(a,b){return ea.getHandlers(a,"load",b)}static getHandlers(a,b,c){let d=[];return("load"===b?ea.getInstance().loadRouters:ea.getInstance().saveRouters).forEach(b=>{let e=b(a,c);null!==e&&d.push(e)}),d}}let eb="tensorflowjs",ec="models_store",ed="model_info_store";function ee(){if(!aw.getBool("IS_BROWSER"))throw Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let a=self,b=a.indexedDB||a.mozIndexedDB||a.webkitIndexedDB||a.msIndexedDB||a.shimIndexedDB;if(null==b)throw Error("The current browser does not appear to support IndexedDB.");return b}function ef(a){let b=a.result;b.createObjectStore(ec,{keyPath:"modelPath"}),b.createObjectStore(ed,{keyPath:"modelPath"})}class eg{constructor(a){if(this.indexedDB=ee(),null==a||!a)throw Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=a}async save(a){if(a.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,a)}async load(){return this.databaseAction(this.modelPath)}databaseAction(a,b){return new Promise((a,c)=>{let d=this.indexedDB.open(eb,1);d.onupgradeneeded=()=>ef(d),d.onsuccess=()=>{let e=d.result;if(null==b){let b=e.transaction(ec,"readonly"),d=b.objectStore(ec).get(this.modelPath);d.onsuccess=()=>{if(null==d.result)return e.close(),c(Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));a(d.result.modelArtifacts)},d.onerror=a=>(e.close(),c(d.error)),b.oncomplete=()=>e.close()}else{let d,f;b.weightData=dR.join(b.weightData);let g=d8(b),h=e.transaction(ed,"readwrite"),i=h.objectStore(ed);try{d=i.put({modelPath:this.modelPath,modelArtifactsInfo:g})}catch(a){return c(a)}d.onsuccess=()=>{let d,j=(f=e.transaction(ec,"readwrite")).objectStore(ec);try{d=j.put({modelPath:this.modelPath,modelArtifacts:b,modelArtifactsInfo:g})}catch(a){return c(a)}d.onsuccess=()=>a({modelArtifactsInfo:g}),d.onerror=a=>{let b=(i=h.objectStore(ed)).delete(this.modelPath);b.onsuccess=()=>(e.close(),c(d.error)),b.onerror=a=>(e.close(),c(d.error))}},d.onerror=a=>(e.close(),c(d.error)),h.oncomplete=()=>{null==f?e.close():f.oncomplete=()=>e.close()}}},d.onerror=a=>c(d.error)})}}eg.URL_SCHEME="indexeddb://";let eh=a=>{var b;return aw.getBool("IS_BROWSER")&&!Array.isArray(a)&&a.startsWith(eg.URL_SCHEME)?(b=a.slice(eg.URL_SCHEME.length),new eg(b)):null};ea.registerSaveRouter(eh),ea.registerLoadRouter(eh);let ei="tensorflowjs_models",ej="info";function ek(a){for(let b of Object.values(a))window.localStorage.removeItem(b)}class el{constructor(a){throw aw.getBool("IS_BROWSER"),Error("The current environment does not support local storage.")}async save(a){if(a.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let b=JSON.stringify(a.modelTopology),c=JSON.stringify(a.weightSpecs),d=d8(a),e=dR.join(a.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(d)),this.LS.setItem(this.keys.topology,b),this.LS.setItem(this.keys.weightSpecs,c),this.LS.setItem(this.keys.weightData,function(a){if(d1)return Buffer.from(a).toString("base64");let b=new Uint8Array(a),c="";for(let a=0,d=b.length;a<d;a++)c+=String.fromCharCode(b[a]);return btoa(c)}(e));let f={format:a.format,generatedBy:a.generatedBy,convertedBy:a.convertedBy,signature:null!=a.signature?a.signature:void 0,userDefinedMetadata:null!=a.userDefinedMetadata?a.userDefinedMetadata:void 0,modelInitializer:null!=a.modelInitializer?a.modelInitializer:void 0,initializerSignature:null!=a.initializerSignature?a.initializerSignature:void 0,trainingConfig:null!=a.trainingConfig?a.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(f)),{modelArtifactsInfo:d}}catch(a){throw ek(this.keys),Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${d.modelTopologyBytes}, weightSpecsBytes=${d.weightSpecsBytes}, weightDataBytes=${d.weightDataBytes}.`)}}}async load(){let a=JSON.parse(this.LS.getItem(this.keys.info));if(null==a)throw Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==a.modelTopologyType)throw Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let b={},c=JSON.parse(this.LS.getItem(this.keys.topology));if(null==c)throw Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);b.modelTopology=c;let d=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==d)throw Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);b.weightSpecs=d;let e=this.LS.getItem(this.keys.modelMetadata);if(null!=e){let a=JSON.parse(e);b.format=a.format,b.generatedBy=a.generatedBy,b.convertedBy=a.convertedBy,null!=a.signature&&(b.signature=a.signature),null!=a.userDefinedMetadata&&(b.userDefinedMetadata=a.userDefinedMetadata),null!=a.modelInitializer&&(b.modelInitializer=a.modelInitializer),null!=a.initializerSignature&&(b.initializerSignature=a.initializerSignature),null!=a.trainingConfig&&(b.trainingConfig=a.trainingConfig)}let f=this.LS.getItem(this.keys.weightData);if(null==f)throw Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return b.weightData=function(a){if(d1){let b=Buffer.from(a,"base64");return b.buffer.slice(b.byteOffset,b.byteOffset+b.byteLength)}let b=atob(a),c=new Uint8Array(b.length);for(let a=0;a<b.length;++a)c.set([b.charCodeAt(a)],a);return c.buffer}(f),b}}el.URL_SCHEME="localstorage://";let em=a=>{var b;return aw.getBool("IS_BROWSER")&&!Array.isArray(a)&&a.startsWith(el.URL_SCHEME)?(b=a.slice(el.URL_SCHEME.length),new el(b)):null};ea.registerSaveRouter(em),ea.registerLoadRouter(em);class en{constructor(){this.managers={}}static getInstance(){return null==en.instance&&(en.instance=new en),en.instance}static registerManager(a,b){I(null!=a,()=>"scheme must not be undefined or null."),a.endsWith("://")&&(a=a.slice(0,a.indexOf("://"))),I(a.length>0,()=>"scheme must not be an empty string.");let c=en.getInstance();I(null==c.managers[a],()=>`A model store manager is already registered for scheme '${a}'.`),c.managers[a]=b}static getManager(a){let b=en.getInstance().managers[a];if(null==b)throw Error(`Cannot find model manager for scheme '${a}'`);return b}static getSchemes(){return Object.keys(en.getInstance().managers)}}function eo(a){if(-1===a.indexOf("://"))throw Error(`The url string provided does not contain a scheme. Supported schemes are: ${en.getSchemes().join(",")}`);return{scheme:a.split("://")[0],path:a.split("://")[1]}}async function ep(a,b,c=!1){I(a!==b,()=>`Old path and new path are the same: '${a}'`);let d=ea.getLoadHandlers(a);I(d.length>0,()=>`Copying failed because no load handler is found for source URL ${a}.`),I(d.length<2,()=>`Copying failed because more than one (${d.length}) load handlers for source URL ${a}.`);let e=d[0],f=ea.getSaveHandlers(b);I(f.length>0,()=>`Copying failed because no save handler is found for destination URL ${b}.`),I(f.length<2,()=>`Copying failed because more than one (${d.length}) save handlers for destination URL ${b}.`);let g=f[0],h=eo(a).scheme,i=eo(a).path,j=h===eo(a).scheme,k=await e.load();c&&j&&await en.getManager(h).removeModel(i);let l=await g.save(k);return c&&!j&&await en.getManager(h).removeModel(i),l.modelArtifactsInfo}async function eq(){let a=en.getSchemes(),b={};for(let c of a){let a=await en.getManager(c).listModels();for(let d in a)b[c+"://"+d]=a[d]}return b}async function er(a){let b=eo(a);return en.getManager(b.scheme).removeModel(b.path)}async function es(a,b){return ep(a,b,!1)}async function et(a,b){return ep(a,b,!0)}if(aw.get("IS_BROWSER")){aw.setPlatform("browser",new class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(a,b){return fetch(a,b)}now(){return performance.now()}encode(a,b){if("utf-8"!==b&&"utf8"!==b)throw Error(`Browser's encoder only supports utf-8, but got ${b}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(a)}decode(a,b){return new TextDecoder(b).decode(a)}setTimeoutCustom(a,b){setTimeout(a,b)}isTypedArray(a){return c3(a)}});try{en.registerManager(el.URL_SCHEME,new class{constructor(){I(aw.getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),I(!0,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let a={},b=ei+"/",c="/"+ej;for(let d=0;d<this.LS.length;++d){let e=this.LS.key(d);e.startsWith(b)&&e.endsWith(c)&&(a[function(a){let b=a.split("/");if(b.length<3)throw Error(`Invalid key format: ${a}`);return b.slice(1,b.length-1).join("/")}(e)]=JSON.parse(this.LS.getItem(e)))}return a}async removeModel(a){var b,c;let d={info:[ei,c=a=(b=a).startsWith(el.URL_SCHEME)?b.slice(el.URL_SCHEME.length):b,ej].join("/"),topology:[ei,c,"model_topology"].join("/"),weightSpecs:[ei,c,"weight_specs"].join("/"),weightData:[ei,c,"weight_data"].join("/"),modelMetadata:[ei,c,"model_metadata"].join("/")};if(null==this.LS.getItem(d.info))throw Error(`Cannot find model at path '${a}'`);let e=JSON.parse(this.LS.getItem(d.info));return ek(d),e}})}catch(a){}try{en.registerManager(eg.URL_SCHEME,new class{constructor(){this.indexedDB=ee()}async listModels(){return new Promise((a,b)=>{let c=this.indexedDB.open(eb,1);c.onupgradeneeded=()=>ef(c),c.onsuccess=()=>{let d=c.result,e=d.transaction(ed,"readonly"),f=e.objectStore(ed).getAll();f.onsuccess=()=>{let b={};for(let a of f.result)b[a.modelPath]=a.modelArtifactsInfo;a(b)},f.onerror=a=>(d.close(),b(f.error)),e.oncomplete=()=>d.close()},c.onerror=a=>b(c.error)})}async removeModel(a){var b;return a=(b=a).startsWith(eg.URL_SCHEME)?b.slice(eg.URL_SCHEME.length):b,new Promise((b,c)=>{let d=this.indexedDB.open(eb,1);d.onupgradeneeded=()=>ef(d),d.onsuccess=()=>{let e,f=d.result,g=f.transaction(ed,"readwrite"),h=g.objectStore(ed),i=h.get(a);i.onsuccess=()=>{if(null==i.result)return f.close(),c(Error(`Cannot find model with path '${a}' in IndexedDB.`));{let d=h.delete(a),g=()=>{let d=(e=f.transaction(ec,"readwrite")).objectStore(ec).delete(a);d.onsuccess=()=>b(i.result.modelArtifactsInfo),d.onerror=a=>c(i.error)};d.onsuccess=g,d.onerror=a=>(g(),f.close(),c(i.error))}},i.onerror=a=>(f.close(),c(i.error)),g.oncomplete=()=>{null==e?f.close():e.oncomplete=()=>f.close()}},d.onerror=a=>c(d.error)})}})}catch(a){}}function eu(a,b="float32",c){return b=b||"float32",ap(a),new dh(a,b,c)}aw.get("IS_NODE")&&!aw.get("IS_BROWSER")&&aw.setPlatform("node",new class{constructor(){this.util=a.r(224361),this.textEncoder=new this.util.TextEncoder}fetch(b,c){return null!=aw.global.fetch?aw.global.fetch(b,c):(null==d&&(d=a.r(671277)),d(b,c))}now(){let a=process.hrtime();return 1e3*a[0]+a[1]/1e6}encode(a,b){if("utf-8"!==b&&"utf8"!==b)throw Error(`Node built-in encoder only supports utf-8, but got ${b}`);return this.textEncoder.encode(a)}decode(a,b){return 0===a.length?"":new this.util.TextDecoder(b).decode(a)}isTypedArray(a){return this.util.types.isFloat32Array(a)||this.util.types.isInt32Array(a)||this.util.types.isUint8Array(a)||this.util.types.isUint8ClampedArray(a)}});let ev=dM({cast_:function(a,b){let c=dJ(a,"x","cast");if(!_(b))throw Error(`Failed to cast to unknown dtype ${b}`);if("string"===b&&"string"!==c.dtype||"string"!==b&&"string"===c.dtype)throw Error("Only strings can be casted to strings");return dB.runKernel(aS,{x:c},{dtype:b})}}),ew=dM({clone_:function(a){let b=dJ(a,"x","clone","string_or_numeric");return dB.runKernel(bv,{x:b})}});function ex(a,b=!1){console.log(a.toString(b))}dA(),dj={buffer:eu,cast:ev,clone:ew,print:ex};let ey=dM({add_:function(a,b){let c=dJ(a,"a","add"),d=dJ(b,"b","add");[c,d]=dt(c,d);let e={a:c,b:d};return dB.runKernel("Add",e)}}),ez=dM({floorDiv_:function(a,b){let c=dJ(a,"a","floorDiv"),d=dJ(b,"b","floorDiv");[c,d]=dt(c,d);let e={a:c,b:d};return dB.runKernel(bp,e)}}),eA=dM({div_:function(a,b){let c=dJ(a,"a","div"),d=dJ(b,"b","div");if([c,d]=dt(c,d),"int32"===c.dtype&&"int32"===d.dtype)return ez(c,d);let e={a:c,b:d};return dB.runKernel(bg,e,{})}}),eB=dM({mul_:function(a,b){let c=dJ(a,"a","mul"),d=dJ(b,"b","mul");[c,d]=dt(c,d);let e={a:c,b:d};return dB.runKernel(bU,e)}}),eC=dM({sqrt_:function(a){let b=dJ(a,"x","sqrt","float32");return dB.runKernel(ct,{x:b})}}),eD=dM({square_:function(a){let b=dJ(a,"x","square");return dB.runKernel("Square",{x:b},{})}}),eE=dM({zerosLike_:function(a){let b=dJ(a,"x","zerosLike");return dB.runKernel(cR,{x:b})}});function eF(a){return dB.customGrad(a)}function eG(a,b){if((da(a)&&"string"!==b||Array.isArray(a))&&"complex64"!==b)throw Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===b&&da(a)&&!(a instanceof Uint8Array))throw Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return dO(a,[],[],b)}let eH=new Map,eI=new Map;class eJ{getClassName(){return this.constructor.className}static fromConfig(a,b){return new a(b)}}class eK{constructor(){this.classNameMap={}}static getMap(){return null==eK.instance&&(eK.instance=new eK),eK.instance}static register(a){eK.getMap().classNameMap[a.className]=[a,a.fromConfig]}}function eL(a,b,c){I(null!=a.className,()=>"Class being registered does not have the static className property defined."),I("string"==typeof a.className,()=>"className is required to be a string, but got type "+typeof a.className),I(a.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),void 0===b&&(b="Custom"),void 0===c&&(c=a.className);let d=b+">"+c;return eK.register(a),eH.set(d,a),eI.set(a,d),a}function eM(a){return eI.has(a)?eI.get(a):a.className}a.s(["Serializable",()=>eJ,"SerializationMap",()=>eK,"getRegisteredName",()=>eM,"registerClass",()=>eL],953321);class eN extends eJ{minimize(a,b=!1,c){let{value:d,grads:e}=this.computeGradients(a,c);if(null!=c){let a=c.map(a=>({name:a.name,tensor:e[a.name]}));this.applyGradients(a)}else this.applyGradients(e);return(dU(e),b)?d:(d.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(a,b){return function(a,b){I(ah(a),()=>"The f passed in variableGrads(f) must be a function"),I(null==b||Array.isArray(b)&&b.every(a=>a instanceof dm),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let c=null!=b;if(!c)for(let a in b=[],dB.registeredVariables)b.push(dB.registeredVariables[a]);let d=c?b.filter(a=>!a.trainable):null,e=b.length;I((b=b.filter(a=>a.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${e} variables is trainable.`);let{value:f,grads:g}=dB.gradients(a,b,null,!0);I(g.some(a=>null!=a),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),I(0===f.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${f.rank} tensor`);let h={};return b.forEach((a,b)=>{null!=g[b]&&(h[a.name]=g[b])}),null!=d&&d.forEach(a=>h[a.name]=null),{value:f,grads:h}}(a,b)}dispose(){null!=this.iterations_&&dU(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:eG(this.iterations_,"int32")}}async getWeights(){throw Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(a){throw Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(a){return this.iterations_=(await a[0].tensor.data())[0],a.slice(1)}}Object.defineProperty(eN,Symbol.hasInstance,{value:a=>null!=a.minimize&&null!=a.computeGradients&&null!=a.applyGradients});class eO extends eN{static get className(){return"Adadelta"}constructor(a,b,c=null){super(),this.learningRate=a,this.rho=b,this.epsilon=c,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==c&&(this.epsilon=dB.backend.epsilon())}applyGradients(a){(Array.isArray(a)?a.map(a=>a.name):Object.keys(a)).forEach((b,c)=>{let d=dB.registeredVariables[b];null==this.accumulatedGrads[c]&&(this.accumulatedGrads[c]={originalName:`${b}/accum_grad`,variable:dT(()=>eE(d).variable(!1))}),null==this.accumulatedUpdates[c]&&(this.accumulatedUpdates[c]={originalName:`${b}/accum_var`,variable:dT(()=>eE(d).variable(!1))});let e=Array.isArray(a)?a[c].tensor:a[b];if(null==e)return;let f=this.accumulatedGrads[c].variable,g=this.accumulatedUpdates[c].variable;dT(()=>{let a=ey(eB(f,this.rho),eB(eD(e),1-this.rho)),b=eB(eA(eC(ey(g,this.epsilon)),eC(ey(f,this.epsilon))),e),c=ey(eB(g,this.rho),eB(eD(b),1-this.rho));f.assign(a),g.assign(c);let h=ey(eB(b,-this.learningRate),d);d.assign(h)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(dU(this.accumulatedGrads.map(a=>a.variable)),dU(this.accumulatedUpdates.map(a=>a.variable)))}async getWeights(){let a=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(a.map(a=>({name:a.originalName,tensor:a.variable})))}async setWeights(a){let b=(a=await this.extractIterations(a)).length/2;this.accumulatedGrads=a.slice(0,b).map(a=>({originalName:a.name,variable:a.tensor.variable(!1)})),this.accumulatedUpdates=a.slice(b,2*b).map(a=>({originalName:a.name,variable:a.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(a,b){return new a(b.learningRate,b.rho,b.epsilon)}}function eP(a,b,c){ap(a),c=c||ag(b);let d={shape:a,value:b,dtype:c};return dB.runKernel(bm,{},d)}class eQ extends eN{static get className(){return"Adagrad"}constructor(a,b=.1){super(),this.learningRate=a,this.initialAccumulatorValue=b,this.accumulatedGrads=[]}applyGradients(a){(Array.isArray(a)?a.map(a=>a.name):Object.keys(a)).forEach((b,c)=>{let d=dB.registeredVariables[b];null==this.accumulatedGrads[c]&&(this.accumulatedGrads[c]={originalName:`${b}/accumulator`,variable:dT(()=>eP(d.shape,this.initialAccumulatorValue).variable(!1))});let e=Array.isArray(a)?a[c].tensor:a[b];if(null==e)return;let f=this.accumulatedGrads[c].variable;dT(()=>{let a=ey(f,eD(e));f.assign(a);let b=ey(eB(eA(e,eC(ey(a,dB.backend.epsilon()))),-this.learningRate),d);d.assign(b)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&dU(this.accumulatedGrads.map(a=>a.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(a=>({name:a.originalName,tensor:a.variable})))}async setWeights(a){a=await this.extractIterations(a),this.accumulatedGrads=a.map(a=>({originalName:a.name,variable:a.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(a,b){return new a(b.learningRate,b.initialAccumulatorValue)}}let eR=dM({pow_:function(a,b){let c=dJ(a,"base","pow"),d=dJ(b,"exp","pow");[c,d]=dt(c,d);let e={a:c,b:d};return dB.runKernel("Pow",e)}}),eS=dM({sub_:function(a,b){let c=dJ(a,"a","sub"),d=dJ(b,"b","sub");[c,d]=dt(c,d);let e={a:c,b:d};return dB.runKernel("Sub",e)}});class eT extends eN{static get className(){return"Adam"}constructor(a,b,c,d=null){super(),this.learningRate=a,this.beta1=b,this.beta2=c,this.epsilon=d,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],dT(()=>{this.accBeta1=eG(b).variable(),this.accBeta2=eG(c).variable()}),null==d&&(this.epsilon=dB.backend.epsilon())}applyGradients(a){let b=Array.isArray(a)?a.map(a=>a.name):Object.keys(a);dT(()=>{let c=eS(1,this.accBeta1),d=eS(1,this.accBeta2);b.forEach((b,e)=>{let f=dB.registeredVariables[b];null==this.accumulatedFirstMoment[e]&&(this.accumulatedFirstMoment[e]={originalName:`${b}/m`,variable:dT(()=>eE(f).variable(!1))}),null==this.accumulatedSecondMoment[e]&&(this.accumulatedSecondMoment[e]={originalName:`${b}/v`,variable:dT(()=>eE(f).variable(!1))});let g=Array.isArray(a)?a[e].tensor:a[b];if(null==g)return;let h=this.accumulatedFirstMoment[e].variable,i=this.accumulatedSecondMoment[e].variable,j=ey(eB(h,this.beta1),eB(g,1-this.beta1)),k=ey(eB(i,this.beta2),eB(eD(g),1-this.beta2)),l=eA(j,c),m=eA(k,d);h.assign(j),i.assign(k);let n=ey(eB(eA(l,ey(eC(m),this.epsilon)),-this.learningRate),f);f.assign(n)}),this.accBeta1.assign(eB(this.accBeta1,this.beta1)),this.accBeta2.assign(eB(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&dU(this.accumulatedFirstMoment.map(a=>a.variable)),null!=this.accumulatedSecondMoment&&dU(this.accumulatedSecondMoment.map(a=>a.variable))}async getWeights(){let a=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(a.map(a=>({name:a.originalName,tensor:a.variable})))}async setWeights(a){a=await this.extractIterations(a),dT(()=>{this.accBeta1.assign(eR(this.beta1,this.iterations_+1)),this.accBeta2.assign(eR(this.beta2,this.iterations_+1))});let b=a.length/2;this.accumulatedFirstMoment=a.slice(0,b).map(a=>({originalName:a.name,variable:a.tensor.variable(!1)})),this.accumulatedSecondMoment=a.slice(b,2*b).map(a=>({originalName:a.name,variable:a.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(a,b){return new a(b.learningRate,b.beta1,b.beta2,b.epsilon)}}let eU=dM({abs_:function(a){let b=dJ(a,"x","abs");return"complex64"===b.dtype?dB.runKernel(aW,{x:b}):dB.runKernel("Abs",{x:b})}});function eV(a,b){let c=a.length,d=[];for(let e=0;e<c;e++){let f=c-1-e,g=a[f]||1;(b[b.length-1-e]||1)>1&&1===g&&d.unshift(f)}return d}function eW(a,b){let c=[];for(let d=0;d<b.length;d++){let e=a[a.length-d-1],f=b.length-d-1,g=b[f];(null==e||1===e&&g>1)&&c.unshift(f)}return c}function eX(a,b){let c=Math.max(a.length,b.length),d=Array(c);for(let e=0;e<c;e++){let f=a[a.length-e-1];null==f&&(f=1);let g=b[b.length-e-1];if(null==g&&(g=1),1===f)d[c-e-1]=g;else if(1===g)d[c-e-1]=f;else if(f!==g)throw Error(`Operands could not be broadcast together with shapes ${a} and ${b}.`);else d[c-e-1]=f}return d}a.s(["assertAndGetBroadcastShape",()=>eX,"getBroadcastDims",()=>eV,"getReductionAxes",()=>eW],528505);let eY=dM({maximum_:function(a,b){let c=dJ(a,"a","maximum"),d=dJ(b,"b","maximum");[c,d]=dt(c,d),"bool"===c.dtype&&(c=ev(c,"int32"),d=ev(d,"int32")),eX(c.shape,d.shape);let e={a:c,b:d};return dB.runKernel(bK,e)}});class eZ extends eN{static get className(){return"Adamax"}constructor(a,b,c,d=null,e=0){super(),this.learningRate=a,this.beta1=b,this.beta2=c,this.epsilon=d,this.decay=e,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],dT(()=>{this.iteration=eG(0).variable(),this.accBeta1=eG(b).variable()}),null==d&&(this.epsilon=dB.backend.epsilon())}applyGradients(a){let b=Array.isArray(a)?a.map(a=>a.name):Object.keys(a);dT(()=>{let c=eS(1,this.accBeta1),d=eA(-this.learningRate,ey(eB(this.iteration,this.decay),1));b.forEach((b,e)=>{let f=dB.registeredVariables[b];null==this.accumulatedFirstMoment[e]&&(this.accumulatedFirstMoment[e]={originalName:`${b}/m`,variable:eE(f).variable(!1)}),null==this.accumulatedWeightedInfNorm[e]&&(this.accumulatedWeightedInfNorm[e]={originalName:`${b}/v`,variable:eE(f).variable(!1)});let g=Array.isArray(a)?a[e].tensor:a[b];if(null==g)return;let h=this.accumulatedFirstMoment[e].variable,i=this.accumulatedWeightedInfNorm[e].variable,j=ey(eB(h,this.beta1),eB(g,1-this.beta1)),k=eY(eB(i,this.beta2),eU(g));h.assign(j),i.assign(k);let l=ey(eB(eA(d,c),eA(j,ey(k,this.epsilon))),f);f.assign(l)}),this.iteration.assign(ey(this.iteration,1)),this.accBeta1.assign(eB(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&dU(this.accumulatedFirstMoment.map(a=>a.variable)),null!=this.accumulatedWeightedInfNorm&&dU(this.accumulatedWeightedInfNorm.map(a=>a.variable))}async getWeights(){throw Error("getWeights() is not implemented for Adamax yet.")}async setWeights(a){throw Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(a,b){return new a(b.learningRate,b.beta1,b.beta2,b.epsilon,b.decay)}}class e$ extends eN{static get className(){return"SGD"}constructor(a){super(),this.learningRate=a,this.setLearningRate(a)}applyGradients(a){(Array.isArray(a)?a.map(a=>a.name):Object.keys(a)).forEach((b,c)=>{let d=Array.isArray(a)?a[c].tensor:a[b];if(null==d)return;let e=dB.registeredVariables[b];dT(()=>{let a=ey(eB(this.c,d),e);e.assign(a)})}),this.incrementIterations()}setLearningRate(a){this.learningRate=a,null!=this.c&&this.c.dispose(),this.c=dV(eG(-a))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(a){if(0!==(a=await this.extractIterations(a)).length)throw Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(a,b){return new a(b.learningRate)}}class e_ extends e${static get className(){return"Momentum"}constructor(a,b,c=!1){super(a),this.learningRate=a,this.momentum=b,this.useNesterov=c,this.accumulations=[],this.m=eG(this.momentum)}applyGradients(a){(Array.isArray(a)?a.map(a=>a.name):Object.keys(a)).forEach((b,c)=>{let d=dB.registeredVariables[b];null==this.accumulations[c]&&(this.accumulations[c]={originalName:`${b}/momentum`,variable:dT(()=>eE(d).variable(!1))});let e=this.accumulations[c].variable,f=Array.isArray(a)?a[c].tensor:a[b];null!=f&&dT(()=>{let a,b=ey(eB(this.m,e),f);a=this.useNesterov?ey(eB(this.c,ey(f,eB(b,this.m))),d):ey(eB(this.c,b),d),e.assign(b),d.assign(a)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&dU(this.accumulations.map(a=>a.variable))}setMomentum(a){this.momentum=a}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(a=>({name:a.originalName,tensor:a.variable})))}async setWeights(a){a=await this.extractIterations(a),this.accumulations=a.map(a=>({originalName:a.name,variable:a.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(a,b){return new a(b.learningRate,b.momentum,b.useNesterov)}}class e0 extends eN{static get className(){return"RMSProp"}constructor(a,b=.9,c=0,d=null,e=!1){if(super(),this.learningRate=a,this.decay=b,this.momentum=c,this.epsilon=d,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=e,null==d&&(this.epsilon=dB.backend.epsilon()),null==a)throw Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(a){(Array.isArray(a)?a.map(a=>a.name):Object.keys(a)).forEach((b,c)=>{let d=dB.registeredVariables[b];null==this.accumulatedMeanSquares[c]&&(this.accumulatedMeanSquares[c]={originalName:`${b}/rms`,variable:dT(()=>eE(d).variable(!1))}),null==this.accumulatedMoments[c]&&(this.accumulatedMoments[c]={originalName:`${b}/momentum`,variable:dT(()=>eE(d).variable(!1))}),null==this.accumulatedMeanGrads[c]&&this.centered&&(this.accumulatedMeanGrads[c]={originalName:`${b}/mg`,variable:dT(()=>eE(d).variable(!1))});let e=Array.isArray(a)?a[c].tensor:a[b];if(null==e)return;let f=this.accumulatedMeanSquares[c].variable,g=this.accumulatedMoments[c].variable;dT(()=>{let a=ey(eB(f,this.decay),eB(eD(e),1-this.decay));if(this.centered){let b=this.accumulatedMeanGrads[c].variable,h=ey(eB(b,this.decay),eB(e,1-this.decay)),i=eA(eB(e,this.learningRate),eC(eS(a,ey(eD(h),this.epsilon)))),j=ey(eB(g,this.momentum),i);f.assign(a),b.assign(h),g.assign(j);let k=eS(d,j);d.assign(k)}else{let a=ey(eB(f,this.decay),eB(eD(e),1-this.decay)),b=ey(eB(g,this.momentum),eA(eB(e,this.learningRate),eC(ey(a,this.epsilon))));f.assign(a),g.assign(b);let c=eS(d,b);d.assign(c)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&dU(this.accumulatedMeanSquares.map(a=>a.variable)),null!=this.accumulatedMeanGrads&&this.centered&&dU(this.accumulatedMeanGrads.map(a=>a.variable)),null!=this.accumulatedMoments&&dU(this.accumulatedMoments.map(a=>a.variable))}async getWeights(){let a=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&a.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(a.map(a=>({name:a.originalName,tensor:a.variable})))}async setWeights(a){a=await this.extractIterations(a);let b=this.centered?a.length/3:a.length/2;this.accumulatedMeanSquares=a.slice(0,b).map(a=>({originalName:a.name,variable:a.tensor.variable(!1)})),this.accumulatedMoments=a.slice(b,2*b).map(a=>({originalName:a.name,variable:a.tensor.variable(!1)})),this.centered&&(this.accumulatedMeanGrads=a.slice(2*b,3*b).map(a=>({originalName:a.name,variable:a.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(a,b){return new a(b.learningRate,b.decay,b.momentum,b.epsilon,b.centered)}}for(let a of[eO,eQ,eT,eZ,e_,e0,e$])eL(a);let e1=dM({step_:function(a,b=0){let c=dJ(a,"x","step");return dB.runKernel(cS,{x:c},{alpha:b})}}),e2={kernelName:"Abs",inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eB(a,e1(ev(c,"float32"),-1))}}},e3=dM({neg_:function(a){let b=dJ(a,"x","neg");return dB.runKernel("Neg",{x:b})}}),e4=dM({reshape_:function(a,b){let c=dJ(a,"x","reshape","string_or_numeric");return dB.runKernel(ca,{x:c},{shape:b})}}),e5=dM({sum_:function(a,b=null,c=!1){let d=dJ(a,"x","sum");"bool"===d.dtype&&(d=ev(d,"int32"));let e={x:d};return dB.runKernel("Sum",e,{axis:b,keepDims:c})}});function e6(a,b,c,d,e="NHWC",f){let g=[...b,a[3]];return e9(a,g,c,f,d,null,null,fj(e))}function e7(a,b,c,d,e,f,g="channelsLast"){let h,[i,j]=fc(b);if("channelsLast"===g)h=[i,j,a[3],a[3]];else if("channelsFirst"===g)h=[i,j,a[1],a[1]];else throw Error(`Unknown dataFormat ${g}`);return e9(a,h,c,d,e,f,!1,g)}function e8(a,b,c,d,e,f,g="NDHWC"){let h,i,[j,k,l]=fd(b);if("NDHWC"===g)i="channelsLast",h=[j,k,l,a[4],a[4]];else if("NCDHW"===g)i="channelsFirst",h=[j,k,l,a[1],a[1]];else throw Error(`Unknown dataFormat ${g}`);return fa(a,h,c,d,e,!1,i,f)}function e9(a,b,c,d,e,f,g=!1,h="channelsLast"){let i,[j,k,l,m]=[-1,-1,-1,-1];if("channelsLast"===h)[j,k,l,m]=a;else if("channelsFirst"===h)[j,m,k,l]=a;else throw Error(`Unknown dataFormat ${h}`);let[n,o,,p]=b,[q,r]=fc(c),[s,t]=fc(d),u=fe(n,s),v=fe(o,t),{padInfo:w,outHeight:x,outWidth:y}=function(a,b,c,d,e,f,g,h,i){let j,k,l;if("number"==typeof a){var m,n;let e,g,i=0===a?"VALID":"NUMBER";j={top:a,bottom:a,left:a,right:a,type:i};let o=(m=[b,c],null==(n=a)&&(n=fb(m,f,d)),e=m[0],g=m[1],[ff((e-f+2*n)/d+1,h),ff((g-f+2*n)/d+1,h)]);k=o[0],l=o[1]}else if("same"===a){let a=Math.max(0,((k=Math.ceil(b/d))-1)*d+f-b),h=Math.max(0,((l=Math.ceil(c/e))-1)*e+g-c),i=Math.floor(a/2),m=Math.floor(h/2);j={top:i,bottom:a-i,left:m,right:h-m,type:"SAME"}}else if("valid"===a)j={top:0,bottom:0,left:0,right:0,type:"VALID"},k=Math.ceil((b-f+1)/d),l=Math.ceil((c-g+1)/e);else if("object"==typeof a){let m="channelsLast"===i?a[1][0]:a[2][0],n="channelsLast"===i?a[1][1]:a[2][1],o="channelsLast"===i?a[2][0]:a[3][0],p="channelsLast"===i?a[2][1]:a[3][1];j={top:m,bottom:n,left:o,right:p,type:0===m&&0===n&&0===o&&0===p?"VALID":"EXPLICIT"},k=ff((b-f+m+n)/d+1,h),l=ff((c-g+o+p)/e+1,h)}else throw Error(`Unknown padding parameter: ${a}`);return{padInfo:j,outHeight:k,outWidth:l}}(e,k,l,q,r,u,v,f,h),z=g?p*m:p;return"channelsFirst"===h?i=[j,z,x,y]:"channelsLast"===h&&(i=[j,x,y,z]),{batchSize:j,dataFormat:h,inHeight:k,inWidth:l,inChannels:m,outHeight:x,outWidth:y,outChannels:z,padInfo:w,strideHeight:q,strideWidth:r,filterHeight:n,filterWidth:o,effectiveFilterHeight:u,effectiveFilterWidth:v,dilationHeight:s,dilationWidth:t,inShape:a,outShape:i,filterShape:b}}function fa(a,b,c,d,e,f=!1,g="channelsLast",h){let i,[j,k,l,m,n]=[-1,-1,-1,-1,-1];if("channelsLast"===g)[j,k,l,m,n]=a;else if("channelsFirst"===g)[j,n,k,l,m]=a;else throw Error(`Unknown dataFormat ${g}`);let[o,p,q,,r]=b,[s,t,u]=fd(c),[v,w,x]=fd(d),y=fe(o,v),z=fe(p,w),A=fe(q,x),{padInfo:B,outDepth:C,outHeight:D,outWidth:E}=function(a,b,c,d,e,f,g,h,i,j,k){let l,m,n,o;if("valid"===a&&(a=0),"number"==typeof a){let p=0===a?"VALID":"NUMBER";l={top:a,bottom:a,left:a,right:a,front:a,back:a,type:p};let q=function(a,b,c,d,e,f){null==e&&(e=fb(a,b[0],d[0]));let g=[0,0,0,1];for(let c=0;c<3;c++)a[c]+2*e>=b[c]&&(g[c]=ff((a[c]-b[c]+2*e)/d[c]+1,f));return g}([b,c,d,1],[h,i,j],0,[e,f,g],a,k);m=q[0],n=q[1],o=q[2]}else if("same"===a){let a=((m=Math.ceil(b/e))-1)*e+h-b,k=((n=Math.ceil(c/f))-1)*f+i-c,p=((o=Math.ceil(d/g))-1)*g+j-d,q=Math.floor(a/2),r=Math.floor(k/2),s=Math.floor(p/2);l={top:r,bottom:k-r,left:s,right:p-s,front:q,back:a-q,type:"SAME"}}else throw Error(`Unknown padding parameter: ${a}`);return{padInfo:l,outDepth:m,outHeight:n,outWidth:o}}(e,k,l,m,s,t,u,y,z,A,h),F=f?r*n:r;return"channelsFirst"===g?i=[j,F,C,D,E]:"channelsLast"===g&&(i=[j,C,D,E,F]),{batchSize:j,dataFormat:g,inDepth:k,inHeight:l,inWidth:m,inChannels:n,outDepth:C,outHeight:D,outWidth:E,outChannels:F,padInfo:B,strideDepth:s,strideHeight:t,strideWidth:u,filterDepth:o,filterHeight:p,filterWidth:q,effectiveFilterDepth:y,effectiveFilterHeight:z,effectiveFilterWidth:A,dilationDepth:v,dilationHeight:w,dilationWidth:x,inShape:a,outShape:i,filterShape:b}}function fb(a,b,c,d=1){let e=fe(b,d);return Math.floor((a[0]*(c-1)-c+e)/2)}function fc(a){return"number"==typeof a?[a,a,a]:2===a.length?[a[0],a[1],1]:a}function fd(a){return"number"==typeof a?[a,a,a]:a}function fe(a,b){return b<=1?a:a+(a-1)*(b-1)}function ff(a,b){if(!b)return Math.trunc(a);switch(b){case"round":return Math.round(a);case"ceil":return Math.ceil(a);case"floor":return Math.floor(a);default:throw Error(`Unknown roundingMode ${b}`)}}function fg(a){let[b,c,d]=fc(a);return 1===b&&1===c&&1===d}function fh(a,b){return fg(a)||fg(b)}function fi(a){return fc(a).every(a=>a>0)}function fj(a){if("NHWC"===a)return"channelsLast";if("NCHW"===a)return"channelsFirst";throw Error(`Unknown dataFormat ${a}`)}function fk(a,b,c){if(null!=c)if("string"==typeof b)throw Error(`Error in ${a}: pad must be an integer when using dimRoundingMode ${c} but got pad ${b}.`);else if("number"==typeof b)I(P(b),()=>`Error in ${a}: pad must be an integer when using dimRoundingMode ${c} but got pad ${b}.`);else if("object"==typeof b)b.forEach(b=>{b.forEach(b=>{I(P(b),()=>`Error in ${a}: pad must be an integer when using dimRoundingMode ${c} but got pad ${b}.`)})});else throw Error(`Error in ${a}: Unknown padding parameter: ${b}`)}a.s(["checkPadOnDimRoundingMode",()=>fk,"computeConv2DInfo",()=>e9,"computeConv3DInfo",()=>fa,"computeDefaultPad",()=>fb,"computeDilation2DInfo",()=>e6,"computePool2DInfo",()=>e7,"computePool3DInfo",()=>e8,"convertConv2DDataFormat",()=>fj,"eitherStridesOrDilationsAreOne",()=>fh,"stridesOrDilationsArePositive",()=>fi,"tupleValuesAreOne",()=>fg],436202);let fl=dM({avgPool3dGrad_:function(a,b,c,d,e,f){let g=dJ(a,"dy","avgPool3dGrad"),h=dJ(b,"input","avgPool3dGrad"),i=g,j=h,k=!1;4===h.rank&&(k=!0,i=e4(g,[1,g.shape[0],g.shape[1],g.shape[2],g.shape[3]]),j=e4(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),I(5===i.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${i.rank}.`),I(5===j.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${j.rank}.`),fk("avgPool3dGrad",e,f);let l={dy:i,input:j},m=dB.runKernel(aM,l,{filterSize:c,strides:d,pad:e,dimRoundingMode:f});return k?e4(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),fm=dM({avgPoolGrad_:function(a,b,c,d,e){let f=dJ(a,"dy","avgPoolGrad"),g=dJ(b,"input","avgPoolGrad");I(g.rank===f.rank,()=>`Rank of input (${g.rank}) does not match rank of dy (${f.rank})`);let h=g,i=f,j=!1;3===g.rank&&(j=!0,h=e4(g,[1,g.shape[0],g.shape[1],g.shape[2]]),i=e4(f,[1,f.shape[0],f.shape[1],f.shape[2]])),I(4===i.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),I(4===h.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${h.rank}.`);let k={dy:i,input:h},l=dB.runKernel(aK,k,{filterSize:c,strides:d,pad:e});return j?e4(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),fn=dM({matMul_:function(a,b,c=!1,d=!1){let e=dJ(a,"a","matMul"),f=dJ(b,"b","matMul");[e,f]=dt(e,f);let g={a:e,b:f};return dB.runKernel(aN,g,{transposeA:c,transposeB:d})}}),fo=dM({spaceToBatchND_:function(a,b,c){let d=dJ(a,"x","spaceToBatchND");return I(d.rank>=1+b.length,()=>`input rank ${d.rank} should be > than [blockShape] ${b.length}`),I(c.length===b.length,()=>`paddings.shape[0] ${c.length} must be equal to [blockShape] ${b.length}`),I(d.shape.reduce((a,d,e)=>e>0&&e<=b.length?a&&(d+c[e-1][0]+c[e-1][1])%b[e-1]==0:a,!0),()=>`input spatial dimensions ${d.shape.slice(1)} with paddings ${c.toString()} must be divisible by blockShapes ${b.toString()}`),dB.runKernel(cu,{x:d},{blockShape:b,paddings:c})}}),fp=dM({greaterEqual_:function(a,b){let c=dJ(a,"a","greaterEqual","string_or_numeric"),d=dJ(b,"b","greaterEqual","string_or_numeric");[c,d]=dt(c,d),eX(c.shape,d.shape);let e={a:c,b:d};return dB.runKernel(bu,e)}}),fq=dM({lessEqual_:function(a,b){let c=dJ(a,"a","lessEqual","string_or_numeric"),d=dJ(b,"b","lessEqual","string_or_numeric");[c,d]=dt(c,d),eX(c.shape,d.shape);let e={a:c,b:d};return dB.runKernel(bD,e)}}),fr=dM({logicalAnd_:function(a,b){let c=dJ(a,"a","logicalAnd","bool"),d=dJ(b,"b","logicalAnd","bool");return eX(c.shape,d.shape),dB.runKernel(bG,{a:c,b:d})}}),fs=dM({broadcastTo_:function(a,b){let c=dJ(a,"broadcastTo","x"),d=c.shape;if(ap(b),b.length<c.rank)throw Error(`broadcastTo(): shape.length=${b.length} < input.rank=${c.rank}.`);if(b.length>c.rank){let a=c.shape.slice();for(;a.length<b.length;)a.unshift(1);c=e4(c,a)}let e=c.shape,f=Array.from(b);for(let a=b.length-1;a>=0;a--)if(e[a]===b[a])f[a]=1;else if(1!==c.shape[a])throw Error(`broadcastTo(): [${d}] cannot be broadcast to [${b}].`);if(0===f.map((a,b)=>a>1?b:-1).filter(a=>a>=0).length)return ew(c);let g={x:c};return dB.runKernel(cK,g,{reps:f})}}),ft=dM({where_:function(a,b,c){let d=dJ(b,"a","where"),e=dJ(c,"b","where"),f=dJ(a,"condition","where","bool"),g=eX(eX(f.shape,d.shape),e.shape),h=fs(f,g),i=fs(d,g),j=fs(e,g);return dB.runKernel(cm,{condition:h,t:i,e:j})}}),fu={kernelName:aW,inputsToSave:["x"],gradFunc:e2.gradFunc},fv=dM({split_:function(a,b,c=0){let d=dJ(a,"x","split");return dB.runKernel(cv,{x:d},{numOrSizeSplits:b,axis:c})}}),fw=dM({conv2DBackpropFilter_:function(a,b,c,d,e,f="NHWC",g){let h=a;3===a.rank&&(h=e4(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let i=b;3===i.rank&&(i=e4(b,[1,b.shape[0],b.shape[1],b.shape[2]])),I(4===h.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${h.shape}.`),I(4===i.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${i.shape}.`),I(4===c.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${c}.`);let j="NHWC"===f?h.shape[3]:h.shape[1],k="NHWC"===f?i.shape[3]:i.shape[1];I(j===c[2],()=>`Error in conv2dDerFilter: depth of input ${j}) must match input depth in filter (${c[2]}.`),I(k===c[3],()=>`Error in conv2dDerFilter: depth of dy (${k}) must match output depth for filter (${c[3]}).`),fk("conv2dDerFilter",e,g);let l={x:h,dy:i};return dB.runKernel(aZ,l,{strides:d,pad:e,dataFormat:f,dimRoundingMode:g,filterShape:c})}}),fx=dM({conv2DBackpropInput_:function(a,b,c,d,e,f="NHWC",g){I(a.length===b.rank,()=>`Length of inShape (${a.length}) and rank of dy (${b.rank}) must match`);let h=a,i=b,j=!1;3===b.rank&&(j=!0,i=e4(b,[1,b.shape[0],b.shape[1],b.shape[2]]),h=[1,a[0],a[1],a[2]]),I(4===h.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${h.length}.`),I(4===i.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${i.rank}`),I(4===c.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${c.rank}`);let k="NHWC"===f?h[3]:h[1],l="NHWC"===f?i.shape[3]:i.shape[1];I(k===c.shape[2],()=>`Error in conv2dDerInput: depth of input (${k}) must match input depth for filter ${c.shape[2]}.`),I(l===c.shape[3],()=>`Error in conv2dDerInput: depth of output (${l}) must match output depth for filter ${c.shape[3]}.`),fk("conv2dDerInput",e,g);let m={dy:i,filter:c},n={strides:d,pad:e,dataFormat:f,dimRoundingMode:g,inputShape:h},o=dB.runKernel(a$,m,n);return j?e4(o,[o.shape[1],o.shape[2],o.shape[3]]):o}}),fy=dM({conv2d_:function(a,b,c,d,e="NHWC",f=[1,1],g){let h=dJ(a,"x","conv2d","float32"),i=dJ(b,"filter","conv2d","float32"),j=h,k=!1;3===h.rank&&(k=!0,j=e4(h,[1,h.shape[0],h.shape[1],h.shape[2]])),I(4===j.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${j.rank}.`),I(4===i.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${i.rank}.`),fk("conv2d",d,g);let l="NHWC"===e?j.shape[3]:j.shape[1];I(l===i.shape[2],()=>`Error in conv2d: depth of input (${l}) must match input depth for filter ${i.shape[2]}.`),I(fh(c,f),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${c} and dilations '${f}'`),I(fi(f),()=>"Error in conv2D: Dilated rates should be larger than 0."),I(fi(c),()=>"Error in conv2D: Strides should be larger than 0.");let m={x:j,filter:i},n=dB.runKernel(aY,m,{strides:c,pad:d,dataFormat:e,dilations:f,dimRoundingMode:g});return k?e4(n,[n.shape[1],n.shape[2],n.shape[3]]):n}}),fz=dM({conv3DBackpropFilter_:function(a,b,c,d,e){let f=a;4===a.rank&&(f=e4(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]));let g=b;4===g.rank&&(g=e4(b,[1,b.shape[0],b.shape[1],b.shape[2],b.shape[3]])),I(5===f.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${f.shape}.`),I(5===g.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${g.shape}.`),I(5===c.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${c}.`),I(f.shape[4]===c[3],()=>`Error in conv3dDerFilter: depth of input ${f.shape[4]}) must match input depth in filter (${c[3]}.`),I(g.shape[4]===c[4],()=>`Error in conv3dDerFilter: depth of dy (${g.shape[4]}) must match output depth for filter (${c[4]}).`);let h={x:f,dy:g};return dB.runKernel(a0,h,{strides:d,pad:e,filterShape:c})}}),fA=dM({conv3DBackpropInput_:function(a,b,c,d,e){I(a.length===b.rank,()=>`Length of inShape (${a.length}) and rank of dy (${b.rank}) must match`);let f=a,g=b,h=!1;4===b.rank&&(h=!0,g=e4(b,[1,b.shape[0],b.shape[1],b.shape[2],b.shape[3]]),f=[1,a[0],a[1],a[2],a[3]]);let i=f[4],j=g.shape[4];I(5===f.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${f.length}.`),I(5===g.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${g.rank}`),I(5===c.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${c.rank}`),I(i===c.shape[3],()=>`Error in conv3dDerInput: depth of input (${i}) must match input depth for filter ${c.shape[3]}.`),I(j===c.shape[4],()=>`Error in conv3dDerInput: depth of output (${j}) must match output depth for filter ${c.shape[4]}.`);let k={dy:g,filter:c},l={pad:e,strides:d,inputShape:f},m=dB.runKernel(a1,k,l);return h?e4(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),fB=dM({sin_:function(a){let b=dJ(a,"x","sin","float32");return dB.runKernel("Sin",{x:b})}}),fC=dM({sinh_:function(a){let b=dJ(a,"x","sinh");return dB.runKernel(cp,{x:b})}});function fD(a,b){for(let c=0;c<a.length;++c)if(a[a.length-c-1]!==b-1-c)return!1;return!0}function fE(a,b,c){let d=a.length+b.length,e=[],f=0,g=0;for(let h=0;h<d;h++)-1===c.indexOf(h)?e.push(a[f++]):e.push(b[g++]);return e}function fF(a,b){let c=[],d=a.length;for(let e=0;e<d;e++)-1===b.indexOf(e)&&c.push(a[e]);return[c,b.map(b=>a[b])]}function fG(a,b){return fE(a,b.map(a=>1),b)}function fH(a,b,c){I(fD(b,c),()=>`${a} supports only inner-most axes for now. Got axes ${b} and rank-${c} input.`)}function fI(a,b){if(fD(a,b))return null;let c=[];for(let d=0;d<b;++d)-1===a.indexOf(d)&&c.push(d);return a.forEach(a=>c.push(a)),c}function fJ(a){return a.map((a,b)=>[b,a]).sort((a,b)=>a[1]-b[1]).map(a=>a[0])}function fK(a,b){let c=[];for(let d=b-a;d<b;++d)c.push(d);return c}a.s(["assertAxesAreInnerMostDims",()=>fH,"axesAreInnerMostDims",()=>fD,"combineLocations",()=>fE,"computeOutAndReduceShapes",()=>fF,"expandShapeToKeepDim",()=>fG,"getAxesPermutation",()=>fI,"getInnerMostAxes",()=>fK,"getUndoAxesPermutation",()=>fJ],59596);let fL=dM({cumsum_:function(a,b=0,c=!1,d=!1){let e=dJ(a,"x","cumsum");return dB.runKernel(a4,{x:e},{axis:b,exclusive:c,reverse:d})}}),fM=dM({imag_:function(a){let b=dJ(a,"input","imag");return dB.runKernel(bx,{input:b})}}),fN=dM({real_:function(a){let b=dJ(a,"input","real");return dB.runKernel(b7,{input:b})}}),fO=dM({transpose_:function(a,b,c){let d=dJ(a,"x","transpose");if(null==b&&(b=d.shape.map((a,b)=>b).reverse()),I(d.rank===b.length,()=>`Error in transpose: rank of input ${d.rank} must match length of perm ${b}.`),b.forEach(a=>{I(a>=0&&a<d.rank,()=>`All entries in 'perm' must be between 0 and ${d.rank-1} but got ${b}`)}),d.rank<=1)return d.clone();let e={perm:b};return"complex64"===d.dtype?dT(()=>{let a=fN(d),b=fM(d);return a=dB.runKernel(cN,{x:a},e),b=dB.runKernel(cN,{x:b},e),c&&(b=e3(b)),dN(a,b)}):dB.runKernel(cN,{x:d},e)}});a.s(["transpose",0,fO],829970);let fP=dM({depthwiseConv2dNativeBackpropFilter_:function(a,b,c,d,e,f=[1,1],g){let h=a;3===a.rank&&(h=e4(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let i=b;3===i.rank&&(i=e4(b,[1,b.shape[0],b.shape[1],b.shape[2]]));let j={x:h,dy:i};return dB.runKernel(a9,j,{strides:d,pad:e,dimRoundingMode:g,dilations:f,filterShape:c})}}),fQ=dM({depthwiseConv2dNativeBackpropInput_:function(a,b,c,d,e,f=[1,1],g){let h=b,i=!1;3===b.rank&&(i=!0,h=e4(b,[1,b.shape[0],b.shape[1],b.shape[2]]));let j={dy:h,filter:c},k=dB.runKernel(ba,j,{strides:d,pad:e,dimRoundingMode:g,dilations:f,inputShape:a});return i?e4(k,[k.shape[1],k.shape[2],k.shape[3]]):k}}),fR=dM({exp_:function(a){let b=dJ(a,"x","exp");return dB.runKernel("Exp",{x:b})}}),fS=dM({rsqrt_:function(a){let b=dJ(a,"x","rsqrt","float32");return dB.runKernel(ci,{x:b})}}),fT=dM({tile_:function(a,b){let c=dJ(a,"x","tile","string_or_numeric");return I(c.rank===b.length,()=>`Error in transpose: rank of input ${c.rank} must match length of reps ${b}.`),dB.runKernel(cK,{x:c},{reps:b})}}),fU=dM({stack_:function(a,b=0){let c=dK(a,"tensors","stack","string_or_numeric");return I(c.length>=1,()=>"Pass at least one tensor to tf.stack"),c.length>0&&I(b<=c[0].rank,()=>"Axis must be <= rank of the tensor"),dB.runKernel(b_,c,{axis:b})}}),fV=dM({unsortedSegmentSum_:function(a,b,c){let d=dJ(a,"x","unsortedSegmentSum"),e=dJ(b,"segmentIds","unsortedSegmentSum","int32");return I(P(c),()=>"numSegments must be of dtype int"),dB.runKernel(cQ,{x:d,segmentIds:e},{numSegments:c})}});function fW(a,b){let c=[];for(let d=a;d<b;++d)c.push(d);return c}function fX(a){let b=[];for(let c=0;c<a.length;++c)for(let d=0;d<a[c].length;++d)b.push(a[c][d]);return b}let fY=dM({greater_:function(a,b){let c=dJ(a,"a","greater","string_or_numeric"),d=dJ(b,"b","greater","string_or_numeric");[c,d]=dt(c,d),eX(c.shape,d.shape);let e={a:c,b:d};return dB.runKernel(bt,e)}}),fZ=dM({localResponseNormalizationBackprop_:function(a,b,c,d=5,e=1,f=1,g=.5){return dB.runKernel(bJ,{x:a,y:b,dy:c},{depthRadius:d,bias:e,alpha:f,beta:g})}}),f$=dM({equal_:function(a,b){let c=dJ(a,"a","equal","string_or_numeric"),d=dJ(b,"b","equal","string_or_numeric");[c,d]=dt(c,d),eX(c.shape,d.shape);let e={a:c,b:d};return dB.runKernel(bj,e)}});function f_(a,b,c,d){return b.rank<c.rank&&(b=e4(b,fG(b.shape,d))),a.rank<c.rank&&(a=e4(a,fG(a.shape,d))),{x:()=>eB(a,ev(f$(c,b),a.dtype))}}let f0={kernelName:"Max",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(a,b,c)=>{let{reductionIndices:d}=c,e=b[0],f=b[1],g=W(d,e.shape),h=f_(a,f,e,g);return{x:()=>h.x()}}},f1=dM({less_:function(a,b){let c=dJ(a,"a","less","string_or_numeric"),d=dJ(b,"b","less","string_or_numeric");[c,d]=dt(c,d),eX(c.shape,d.shape);let e={a:c,b:d};return dB.runKernel(bC,e)}}),f2=dM({maxPool3dGrad_:function(a,b,c,d,e,f,g){let h=dJ(a,"dy","maxPool3dGrad"),i=dJ(b,"input","maxPool3dGrad"),j=dJ(c,"output","maxPool3dGrad"),k=h,l=i,m=j,n=!1;4===i.rank&&(n=!0,k=e4(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]]),l=e4(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),m=e4(j,[1,j.shape[0],j.shape[1],j.shape[2],j.shape[3]])),I(5===k.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${k.rank}.`),I(5===l.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),I(5===m.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),fk("maxPool3dGrad",f,g);let o={dy:k,input:l,output:m},p=dB.runKernel(bO,o,{filterSize:d,strides:e,pad:f,dimRoundingMode:g});return n?e4(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),f3=dM({maxPoolGrad_:function(a,b,c,d,e,f,g){let h=dJ(a,"dy","maxPoolGrad"),i=dJ(b,"input","maxPoolGrad"),j=dJ(c,"output","maxPoolGrad");return I(i.rank===h.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${h.rank})`),I(4===h.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${h.rank}.`),I(4===i.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${i.rank}.`),fk("maxPoolGrad",f,g),dB.runKernel(bM,{dy:h,input:i,output:j},{filterSize:d,strides:e,pad:f,dimRoundingMode:g})}});function f4(a,b="float32"){if(ap(a),"complex64"===b)return dN(f4(a,"float32"),f4(a,"float32"));let c=an(L(a),b);return dB.makeTensor(c,a,b)}function f5(a,b="float32"){if(ap(a),"complex64"===b)return dN(f5(a,"float32"),f4(a,"float32"));let c=am(L(a),b);return dB.makeTensor(c,a,b)}let f6=dM({slice_:function(a,b,c){let d=dJ(a,"x","slice","string_or_numeric");if(0===d.rank)throw Error("Slicing scalar is not possible");return dB.runKernel(co,{x:d},{begin:b,size:c})}}),f7=dM({floor_:function(a){let b=dJ(a,"x","floor","float32");return dB.runKernel(bo,{x:b})}}),f8=dM({unstack_:function(a,b=0){let c=dJ(a,"x","unstack","string_or_numeric");return I(b>=-c.shape.length&&b<c.shape.length,()=>`Axis = ${b} is not in [-${c.shape.length}, ${c.shape.length})`),dB.runKernel(cP,{value:c},{axis:b})}}),f9={kernelName:b0,inputsToSave:["x"],gradFunc:(a,b,c)=>{let d=b[0],{paddings:e}=c,f=e.map(a=>a[0]);return{x:()=>f6(a,f,d.shape)}}},ga=dM({log_:function(a){let b=dJ(a,"x","log","float32");return dB.runKernel("Log",{x:b})}});function gb(a,b,c){let d=a.shape.length;I(d===b.length,()=>`Error in slice${d}D: Length of begin ${b} must match the rank of the array (${d}).`),I(d===c.length,()=>`Error in slice${d}D: Length of size ${c} must match the rank of the array (${d}).`);for(let e=0;e<d;++e)I(b[e]+c[e]<=a.shape[e],()=>`Error in slice${d}D: begin[${e}] + size[${e}] (${b[e]+c[e]}) would overflow input.shape[${e}] (${a.shape[e]})`)}function gc(a){let b=[],c=0;for(;a>0;)1&a&&b.push(c),a/=2,c++;return b}function gd(a,b,c){let d=[];for(let e=0;e<a.length;e++)d[e]=Math.ceil((b[e]-a[e])/c[e]);return d}function ge(a,b,c,d){let e=[...a];for(let a=e.length;a<d.length;a++)e.push(1);for(let a=0;a<c;a++)0===a?e[b]=1:(e.splice(b,0,1),e.pop());return e}function gf(a,b){let c=[];for(let d=0;d<a;d++)c.push(b+d);return c}function gg(a,b,c,d,e,f,g,h,i){let j=a.length,k=Array(j),l=Array(j),m=Array(j);if(b.length&&c>0){let i=b[0],j=c+1;k=gh(g,i,j,d,a),l=gi(h,i,j,e,a),m=ge(f,i,j,a)}else for(let b=0;b<j;b++)k[b]=gk(g,d,f,a,b,i),l[b]=gl(h,e,f,a,b,i),m[b]=gj(f,b,i);return{begin:k,end:l,strides:m}}function gh(a,b,c,d,e){let f=[...e],g=gf(c,b);for(let e=0;e<f.length;e++)if(g.indexOf(e)>-1)f[e]=0;else{var h,i,j;let g=(h=b,i=c,(j=e)<=h?j:j-(i-1)),k=d[g];a&1<<g&&(k=0),f[e]=k}return f}function gi(a,b,c,d,e){let f=[...e],g=gf(c,b);for(let e=0;e<f.length;e++)if(g.indexOf(e)>-1)f[e]=Number.MAX_SAFE_INTEGER;else{var h,i,j;let g=(h=b,i=c,(j=e)<=h?j:j-(i-1)),k=d[g];a&1<<g&&(k=Number.MAX_SAFE_INTEGER),f[e]=k}for(let a=0;a<f.length;a++){let b=e[a];f[a]<0&&(f[a]+=b),f[a]=C(0,f[a],e[a])}return f}function gj(a,b,c){let d=a[b];return(c&1<<b||null==d)&&(d=1),d}function gk(a,b,c,d,e,f){let g=b[e],h=c[e]||1;(a&1<<e||f&1<<e||null==g)&&(g=h>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let i=d[e];return g<0&&(g+=i),g=C(0,g,i-1)}function gl(a,b,c,d,e,f){let g=b[e],h=c[e]||1;(a&1<<e||f&1<<e||null==g)&&(g=h>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let i=d[e];return g<0&&(g+=i),g=h>0?C(0,g,i):C(-1,g,i-1)}function gm(a,b,c){let d=c.length;for(let a=0;a<c.length;a++)if(c[a]>1){d=a;break}for(let e=d+1;e<c.length;e++)if(b[e]>0||c[e]!==a[e])return!1;return!0}function gn(a,b){let c=a.length>0?a[a.length-1]:1;for(let d=0;d<a.length-1;d++)c+=a[d]*b[d];return c}function go(a,b,c){let d,e,f=a.shape.length;return(d="number"==typeof b?[b,...Array(f-1).fill(0)]:b.length<f?b.concat(Array(f-b.length).fill(0)):b.slice()).forEach(a=>{I(-1!==a,()=>"slice() does not support negative begin indexing.")}),e=(e=null==c?Array(f).fill(-1):"number"==typeof c?[c,...Array(f-1).fill(-1)]:c.length<f?c.concat(Array(f-c.length).fill(-1)):c).map((b,c)=>b>=0?b:(I(-1===b,()=>`Negative size values should be exactly -1 but got ${b} for the slice() size at index ${c}.`),a.shape[c]-d[c])),[d,e]}function gp(a,b,c,d,e,f,g,h,i){let j;if(null==d?(j=Array(b.length)).fill(1):j=d,null!=g&&(g&g-1)!=0)throw Error("Multiple ellipses in slice is not allowed.");let k=!1,l={dims:j.length,numAddAxisAfterEllipsis:0,begin:b.slice(),end:c.slice(),strides:j.slice(),beginMask:e,endMask:f,ellipsisMask:g,newAxisMask:h,shrinkAxisMask:i};for(let a=0;a<l.dims;a++)k&&(1<<a&h)!=0&&l.numAddAxisAfterEllipsis++,1<<a&g&&(k=!0);!k&&(l.ellipsisMask|=1<<l.dims,l.dims++);let m={dims:a.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};var n=l,o=m;o.beginMask=0,o.endMask=0,o.shrinkAxisMask=0;let p=0;o.beginValid=null!=n.begin,o.endValid=null!=n.end,o.begin=Array(o.dims),o.end=Array(o.dims),o.strides=Array(o.dims),o.finalShapeGatherIndices=[],o.finalShapeGatherIndicesSparse=[],o.inputShapeGatherIndicesSparse=Array(o.dims);for(let a=0;a<n.dims;a++)if(1<<a&n.ellipsisMask){let b=Math.min(o.dims-(n.dims-a)+1+n.numAddAxisAfterEllipsis,o.dims);for(;p<b;p++)o.begin[p]=0,o.end[p]=0,o.strides[p]=1,o.beginMask|=1<<p,o.endMask|=1<<p,o.finalShapeGatherIndices.push(p),o.finalShapeGatherIndicesSparse.push(-1),o.inputShapeGatherIndicesSparse[p]=a}else if(1<<a&n.newAxisMask)o.finalShapeGatherIndices.push(-2),o.finalShapeGatherIndicesSparse.push(-1);else{if(p===o.begin.length)throw Error(`Index out of range using input dim ${p}; input has only ${o.dims} dims, ${o.begin.length}.`);null!=n.begin&&(o.begin[p]=n.begin[a]),null!=n.end&&(o.end[p]=n.end[a]),o.strides[p]=n.strides[a],n.beginMask&1<<a&&(o.beginMask|=1<<p),n.endMask&1<<a&&(o.endMask|=1<<p),n.shrinkAxisMask&1<<a?(o.finalShapeGatherIndices.push(-1),o.finalShapeGatherIndicesSparse.push(-1),o.shrinkAxisMask|=1<<p):(o.finalShapeGatherIndices.push(p),o.finalShapeGatherIndicesSparse.push(a)),o.inputShapeGatherIndicesSparse[p]=a,p++}let q=!0,r=!0,s=!0,t=[],u=[];for(let b=0;b<a.length;++b){let c;if(0===m.strides[b])throw Error(`strides[${b}] must be non-zero`);let d=!!(m.shrinkAxisMask&1<<b),e=a[b];if(-1===e){t.push(d?1:-1);continue}let f=[m.beginMask&1<<b,m.endMask&1<<b],g=[m.strides[b]>0?0:-1,m.strides[b]>0?e:e-1];if(d&&m.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");s=s&&1===m.strides[b];let h=!!(m.beginMask&1<<b&&m.endMask&1<<b);if(m.beginValid&&m.endValid){if(d){let a=m.begin[b]<0?e+m.begin[b]:m.begin[b];if(m.begin[b]=a,m.end[b]=m.begin[b]+1,a<0||a>=e)throw Error(`slice index ${m.begin[b]} of dimension ${b} out of bounds.`)}else m.begin[b]=gq(m.begin[b],0,m.strides[b],e,f,g),m.end[b]=gq(m.end[b],1,m.strides[b],e,f,g);let a=1===m.strides[b]&&0===m.begin[b]&&m.end[b]===e;q=q&&a,r=r&&(0===b&&1===m.strides[b]||a)}else q=q&&1===m.strides[b]&&h,r=r&&(0===b&&1===m.strides[b]||h);let i=!1;if(m.beginValid&&m.endValid?(c=m.end[b]-m.begin[b],i=!0):d?(c=1,i=!0):h&&e>=0&&(c=m.strides[b]<0?-e:e,i=!0),i){let a;a=0===c||c<0!=m.strides[b]<0?0:Math.trunc(c/m.strides[b])+ +(c%m.strides[b]!=0),t.push(a)}else t.push(-1)}for(let a=0;a<m.finalShapeGatherIndices.length;++a){let b=m.finalShapeGatherIndices[a];b>=0?u.push(t[b]):-2===b&&u.push(1)}return{finalShapeSparse:u.filter((a,b)=>-2!==m.finalShapeGatherIndices[b]),finalShape:u,isIdentity:q,sliceDim0:r,isSimpleSlice:s,begin:m.begin,end:m.end,strides:m.strides}}function gq(a,b,c,d,e,f){if(e[b])return c>0?f[b]:f[b+1&1];{let b=a<0?d+a:a;return b<f[0]?f[0]:b>f[1]?f[1]:b}}a.s(["assertParamsValid",()=>gb,"computeFlatOffset",()=>gn,"computeOutShape",()=>gd,"getNormalizedAxes",()=>gg,"isSliceContinous",()=>gm,"maskToAxes",()=>gc,"parseSliceParams",()=>go,"sliceInfo",()=>gp,"startForAxis",()=>gk,"startIndicesWithElidedDims",()=>gh,"stopForAxis",()=>gl,"stopIndicesWithElidedDims",()=>gi,"stridesForAxis",()=>gj,"stridesWithElidedDims",()=>ge],187483);var gr=a.i(187483);function gs(a){return a<=30?a:ai(a,Math.floor(Math.sqrt(a)))}function gt(a,b){let c,d=!1;for(a<=30?(c=a,d=!0):c=ai(a,Math.floor(Math.sqrt(a)));!d;)c>b||c===a?d=!0:c=ai(a,c+1);return c}function gu(a,b,c){let d=[],e=a.length;for(let f=0;f<e;f++)f!==b?d.push(a[f]):d.push(c);return d}function gv(a,b,c,d){let e=b.shape.length,f=a.shape.length;if(0!==d&&(d<-e||d>e))throw Error(`Expect batchDims in the range of [-${e}, ${e}], but got ${d}`);if(d<0&&(d+=e),d>f)throw Error(`batchDims (${d}) must be less than rank(x) (
    ${f}).`);if(c<d)throw Error(`batchDims (${d}) must be less than or equal to axis (${c}).`);for(let c=0;c<d;++c)if(a.shape[c]!==b.shape[c])throw Error(`x.shape[${c}]: ${a.shape[c]} should be equal to indices.shape[${c}]: ${b.shape[c]}.`);let g=a.shape[c],h=[],i=1,j=1,k=1;for(let b=0;b<d;++b)h.push(a.shape[b]),i*=a.shape[b];for(let b=d;b<c;b++)h.push(a.shape[b]),j*=a.shape[b];for(let a=d;a<e;a++)h.push(b.shape[a]);for(let b=c+1;b<f;b++)h.push(a.shape[b]),k*=a.shape[b];return{batchSize:i,sliceSize:k,outerSize:j,dimSize:g,outputShape:h}}a.s(["PARALLELIZE_THRESHOLD",0,30,"computeOptimalWindowSize",()=>gs],650809),a.s(["collectGatherOpShapeInfo",()=>gv,"computeOutShape",()=>gu,"segOpComputeOptimalWindowSize",()=>gt],763065);var gw=a.i(763065);function gx(a){try{return a.map(a=>c9(a))}catch(a){throw Error(`Failed to decode encoded string bytes into utf-8, error: ${a}`)}}function gy(a){return a.map(a=>c8(a))}a.s(["fromStringArrayToUint8",()=>gy,"fromUint8ToStringArray",()=>gx],46893),a.i(46893),a.i(59596);var gz=a.i(528505);function gA(a,b){let c=a[0].length;a.forEach((a,b)=>{I(a.length===c,()=>`Error in concat${c}D: rank of tensors[${b}] must be the same as the rank of the rest (${c})`)}),I(b>=0&&b<c,()=>`Error in concat${c}D: axis must be between 0 and ${c-1}.`);let d=a[0];a.forEach((a,e)=>{for(let f=0;f<c;f++)I(f===b||a[f]===d[f],()=>`Error in concat${c}D: Shape of tensors[${e}] (${a}) does not match the shape of the rest (${d}) along the non-concatenated axis ${e}.`)})}function gB(a,b){let c=a[0].slice();for(let d=1;d<a.length;d++)c[b]+=a[d][b];return c}a.s(["assertParamsConsistent",()=>gA,"computeOutShape",()=>gB],196881),a.i(196881),a.i(436202);let gC=dM({elu_:function(a){let b=dJ(a,"x","elu","float32");return dB.runKernel("Elu",{x:b})}}),gD=dM({leakyRelu_:function(a,b=.2){let c=dJ(a,"x","leakyRelu");return dB.runKernel(bB,{x:c},{alpha:b})}}),gE=dM({prelu_:function(a,b){let c=dJ(a,"x","prelu"),d=dJ(b,"alpha","prelu");return dB.runKernel(b1,{x:c,alpha:d})}}),gF=dM({relu_:function(a){let b=dJ(a,"x","relu");return dB.runKernel(b9,{x:b})}}),gG=dM({relu6_:function(a){let b=dJ(a,"x","relu6");return dB.runKernel(cf,{x:b})}}),gH=dM({sigmoid_:function(a){let b=dJ(a,"x","sigmoid","float32");return dB.runKernel(cr,{x:b})}});function gI(a,b,c){if(null==c||"linear"===c)return a;if("relu"===c)return eB(a,e1(b));throw Error(`Cannot compute gradient for fused activation ${c}.`)}function gJ(a,b){let c=b,d=eW(a.shape,b.shape);return d.length>0&&(c=e5(c,d)),e4(c,a.shape)}function gK(a,b,c,d){if("linear"===b)return a;if("relu"===b)return gF(a);if("elu"===b)return gC(a);if("relu6"===b)return gG(a);if("prelu"===b)return gE(a,c);else if("leakyrelu"===b)return gD(a,d);else if("sigmoid"===b)return gH(a);throw Error(`Unknown fused activation ${b}.`)}let gL=(a,b)=>!(a>0)||"linear"===b;function gM(a,b,c){let d=[];if(null==c&&null==b)return d;if(null==b)for(;d.length<a+c.length;)d.push(-1);else d=b.slice();if(null==c)return d;if(a+c.length!==d.length)throw Error(`rt input.shape and shape=${b} are incompatible: rt input.rank = ${a+c.length}, but shape.rank = ${d.length}`);for(let e=1;e<c.length;++e){let f=c[e],g=d[d.length-c.length+e],h=d[g];if(f>=0)if(h>=0){if(h!==f)throw Error(`rt input.shape and shape=${b} are incompatible: rt input.shape[${e+a}] = ${f} but shape[${e+a}] = ${h}`)}else d[g]=f}return d}function gN(a){let b={FIRST_DIM_SIZE:BM.FIRST_DIM_SIZE,VALUE_ROWIDS:BM.VALUE_ROWIDS,ROW_LENGTHS:BM.ROW_LENGTHS,ROW_SPLITS:BM.ROW_SPLITS,ROW_LIMITS:BM.ROW_LIMITS,ROW_STARTS:BM.ROW_STARTS},c=[];for(let d of a)if(d in b)c.push(b[d]);else break;return c}function gO(a){return 0===a.length?0:a[0]===BM.FIRST_DIM_SIZE?a.length-1:a.length}function gP(a,b){if(null==a||null==b)return;let c=a.length,d=b.length;if(c>=d)throw Error(`defaultValue.shape=${a} and ragged tensor flatValues.shape=${b}, are incompatible: defaultValue.rank = ${c} must be less than ragged tensor input flatValues.rank = ${d})`);for(let e=0;e<Math.min(c,d-1);++e){let c=a[e],d=b[e+1];if(c>=0&&d>=0&&1!==c&&c!==d)throw Error(`defaultValue.shape=${a}, and ragged tensor input flatValues.shape=${b} are incompatible: defaultValue.shape[${e-a.length}] = ${c} but ragged tensor input.flatValues.shape[${e-a.length}] = ${d}`)}}function gQ(a,b,c){return[c*("number"==typeof a?a:a[0]),b*("number"==typeof a?a:a[1])]}function gR(a,b,c,d=!0){let e=[];if(d)(e=e.concat(b.slice(0))).push(a[0]/c),e=e.concat(a.slice(1));else{e=e.concat(a[0]);let c=b.length;for(let d=0;d<c;++d)e=e.concat([a[d+1]/b[d],b[d]]);e=e.concat(a.slice(c+1))}return e}function gS(a,b,c=!0){let d=[];if(c){d.push(b);for(let c=b+1;c<a;++c)c<=2*b?(d.push(c),d.push(c-(b+1))):d.push(c)}else{let c=[],e=[];for(let d=1;d<a;++d)d>=2*b+1||d%2==1?e.push(d):c.push(d);d.push(...c),d.push(0),d.push(...e)}return d}function gT(a,b,c,d=!0){let e=[];d?e.push(a[0]/c):e.push(a[0]*c);for(let c=1;c<a.length;++c)c<=b.length?d?e.push(b[c-1]*a[c]):e.push(a[c]/b[c-1]):e.push(a[c]);return e}function gU(a,b){let c=[0];for(let d=0;d<b;++d)c.push(a[d][0]);return c}function gV(a,b,c){let d=a.slice(0,1);for(let e=0;e<c;++e)d.push(a[e+1]-b[e][0]-b[e][1]);return d}function gW(a,b){let c=a.shape.length,d=b.shape.length;if(c<1)throw Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${c}.`);if(d<1)throw Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${d}.`);if("int32"!==b.dtype)throw Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${b.dtype}.`);if(b.shape[d-1]>c)throw Error(`index innermost dimension length must be <= tensor rank; saw: ${b.shape[d-1]} vs. ${c}`);if(0===L(a.shape))throw Error(`Requested more than 0 entries, but input is empty. Input shape: ${a.shape}.`);let e=b.shape,f=e[e.length-1],g=1;for(let a=0;a<e.length-1;++a)g*=e[a];let h=a.shape,i=e.slice();i.pop();let j=1;for(let a=f;a<c;++a)j*=h[a],i.push(h[a]);let k=[...aj(a.shape).map(a=>a/j),1].slice(0,f);return[i,g,j,k]}function gX(a,b,c){let d=b.rank>1?b.shape[b.rank-1]:1,e=b.rank>1?b.rank-1:1,f=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${c.shape}, indices.shape: ${b.shape}, shape: ${a}, sliceDim: ${d}, and batchDim: ${e}.`;if(c.rank<e)throw Error(f+` update.rank < ${e}. `);if(a.length<d+(c.rank-e))throw Error(f+` Output shape length < ${d+(c.rank-e)}`);if(c.rank!==e+a.length-d)throw Error(f+` update.rank != ${e+a.length-d}`);for(let a=0;a<e;++a)if(c.shape[a]!==b.shape[a])throw Error(f+` updates.shape[${a}] (${c.shape[a]}) != indices.shape[${a}] (${b.shape[a]}).`);for(let b=0;b<c.rank-e;++b)if(c.shape[b+e]!==a[b+d])throw Error(f+` updates.shape[${b+e}] (${c.shape[b+e]}) != shape[${b+e}] (${a[b+e]})`)}function gY(a,b,c){if(b.rank<1)throw Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${b.rank}.`);if(a.rank<1)throw Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${a.rank}.`);if("int32"!==b.dtype)throw Error(`The dtype of 'indices' should be int32, but got dtype: ${b.dtype}`);if(c.length<1)throw Error(`Output rank must be greater or equal to 1, but got shape: ${c}`);if(0===c.length){if(0===b.size)throw Error(`Indices specified for empty output. indices shape: ${b.shape}`);if(0===a.size)throw Error(`Updates specified for empty output. updates shape: ${a.shape}`)}gX(c,b,a)}function gZ(a,b,c){let d=b.shape.length,e=d>1?b.shape[d-1]:1,f=c.length,g=1;for(let a=e;a<f;++a)g*=c[a];let h=e<1?1:e,i=L(b.shape)/h,j=[...aj(c.slice(0,e)),1];return{sliceRank:e,numUpdates:i,sliceSize:g,strides:j,outputSize:L(c)}}function g$(a,b){if(a.length!==b.length)throw Error(`Cannot merge real and imag arrays of different lengths. real:${a.length}, imag: ${b.length}.`);let c=new Float32Array(2*a.length);for(let d=0;d<c.length;d+=2)c[d]=a[d/2],c[d+1]=b[d/2];return c}function g_(a){let b=new Float32Array(a.length/2),c=new Float32Array(a.length/2);for(let d=0;d<a.length;d+=2)b[d/2]=a[d],c[d/2]=a[d+1];return{real:b,imag:c}}function g0(a){let b=Math.ceil(a.length/4),c=new Float32Array(b),d=new Float32Array(b);for(let b=0;b<a.length;b+=4)c[Math.floor(b/4)]=a[b],d[Math.floor(b/4)]=a[b+1];return{real:c,imag:d}}function g1(a){let b=Math.floor(a.length/4),c=new Float32Array(b),d=new Float32Array(b);for(let b=2;b<a.length;b+=4)c[Math.floor(b/4)]=a[b],d[Math.floor(b/4)]=a[b+1];return{real:c,imag:d}}function g2(a,b){return{real:a[2*b],imag:a[2*b+1]}}function g3(a,b,c,d){a[2*d]=b,a[2*d+1]=c}function g4(a,b){let c=new Float32Array(a/2),d=new Float32Array(a/2);for(let e=0;e<Math.ceil(a/2);e++){let f=(b?2:-2)*Math.PI*(e/a);c[e]=Math.cos(f),d[e]=Math.sin(f)}return{real:c,imag:d}}function g5(a,b,c){let d=(c?2:-2)*Math.PI*(a/b);return{real:Math.cos(d),imag:Math.sin(d)}}a.s(["applyActivation",()=>gK,"getFusedBiasGradient",()=>gJ,"getFusedDyActivation",()=>gI,"shouldFuse",0,gL],705517),a.i(705517),a.s([],678745),a.i(678745),(Bw=BM||(BM={}))[Bw.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",Bw[Bw.VALUE_ROWIDS=1]="VALUE_ROWIDS",Bw[Bw.ROW_LENGTHS=2]="ROW_LENGTHS",Bw[Bw.ROW_SPLITS=3]="ROW_SPLITS",Bw[Bw.ROW_LIMITS=4]="ROW_LIMITS",Bw[Bw.ROW_STARTS=5]="ROW_STARTS",a.s(["RowPartitionType",()=>BM,"combineRaggedTensorToTensorShapes",()=>gM,"getRaggedRank",()=>gO,"getRowPartitionTypesHelper",()=>gN,"validateDefaultValueShape",()=>gP],577234),a.i(577234),a.i(650809),a.s(["getImageCenter",()=>gQ],727027),a.i(727027),a.s(["getPermuted",()=>gS,"getReshaped",()=>gR,"getReshapedPermuted",()=>gT,"getSliceBeginCoords",()=>gU,"getSliceSize",()=>gV],301249),a.i(301249),a.s(["prepareAndValidate",()=>gW],883587),a.i(883587),a.s(["calculateShapes",()=>gZ,"validateInput",()=>gY,"validateUpdateShape",()=>gX],780797),a.i(780797),a.s(["SELU_SCALE",0,1.0507009873554805,"SELU_SCALEALPHA",0,1.7580993408473768],664388),a.i(664388),a.s(["ERF_A1",0,.254829592,"ERF_A2",0,-.284496736,"ERF_A3",0,1.421413741,"ERF_A4",0,-1.453152027,"ERF_A5",0,1.061405429,"ERF_P",0,.3275911],737938),a.i(737938),a.i(384572),a.s(["assignToTypedArray",()=>g3,"complexWithEvenIndex",()=>g0,"complexWithOddIndex",()=>g1,"exponent",()=>g5,"exponents",()=>g4,"getComplexWithIndex",()=>g2,"mergeRealAndImagArrays",()=>g$,"splitRealAndImagArrays",()=>g_],109600),a.i(109600);let g6=/->/g;function g7(a,b){let c=((a=a.replace(/\s/g,"")).length-a.replace(g6,"").length)/2;if(c<1)throw Error("Equations without an arrow are not supported.");if(c>1)throw Error('Equation must contain exactly one arrow ("->").');let[d,e]=a.split("->");I(-1===d.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');let f=d.split(","),g=f.length;if(b!==g)throw Error(`Expected ${g} input tensors, received ${b}`);if(g>2)throw Error("Support for more than 2 input tensors is not implemented yet.");let h=[];for(let a=0;a<e.length;++a){let b=e[a];if(!f.some(a=>-1!==a.indexOf(b)))throw Error(`Output subscripts contain the label ${b} not present in the input subscripts.`);-1===h.indexOf(b)&&h.push(b)}for(let a=0;a<d.length;++a){let b=d[a];-1===h.indexOf(b)&&","!==b&&h.push(b)}let i=Array(f.length);for(let a=0;a<g;++a){if(new Set(f[a].split("")).size!==f[a].length)throw Error(`Found duplicate axes in input component ${f[a]}. Support for duplicate axes in input is not implemented yet.`);i[a]=[];for(let b=0;b<f[a].length;++b)i[a].push(h.indexOf(f[a][b]))}let j=h.length,k=e.length,l=[];for(let a=k;a<j;++a)l.push(a);return{allDims:h,summedDims:l,idDims:i}}function g8(a,b){let c=Array(a);c.fill(-1);for(let a=0;a<b.length;++a)c[b[a]]=a;let d=[];for(let b=0;b<a;++b)-1===c[b]&&d.push(b);return{permutationIndices:c=c.filter(a=>-1!==a),expandDims:d}}function g9(a,b,c){let d=Array(a);for(let a=0;a<c.length;++a){let e=c[a].shape;for(let c=0;c<b[a].length;++c)void 0===d[b[a][c]]?d[b[a][c]]=e[c]:I(d[b[a][c]]===e[c],()=>`Expected dimension ${d[b[a][c]]} at axis ${c} of input shaped ${JSON.stringify(e)}, but got dimension ${e[c]}`)}}function ha(a,b){let c=[],d=0;0===a.length&&a.push(-1),d=a.length+1;for(let a=0;a<d;++a)c.push([]);let e=[];for(let d=0;d<a.length;++d)for(let f of function(a,b){let c=[];for(let d=0;d<a.length;++d)(0===a[d].length||-1!==a[d].indexOf(b)||-1===b)&&c.push(d);return c}(b,a[d]))-1===e.indexOf(f)&&(c[d].push(f),e.push(f));return{path:a,steps:c}}function hb(a){return a.every((a,b)=>a===b)}function hc(a,b,c=0){let d=[];if("number"==typeof b)I(a.shape[c]%b==0,()=>"Number of splits must evenly divide the axis."),d=Array(b).fill(a.shape[c]/b);else{I(1>=b.reduce((a,b)=>(-1===b&&(a+=1),a),0),()=>"There should be only one negative value in split array.");let e=b.indexOf(-1);if(-1!==e){let d=b.reduce((a,b)=>b>0?a+b:a);b[e]=a.shape[c]-d}I(a.shape[c]===b.reduce((a,b)=>a+b),()=>"The sum of sizes must match the size of the axis dimension."),d=b}return d}function hd(a){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${a}`}function he(a,b){return`indices(${a}, 0) is invalid: ${b} < 0`}function hf(a,b,c){return`indices(${a}, 0) is invalid: ${b} >= ${c}`}function hg(a,b){return`only one output dimension may be -1, not both ${a} and ${b}`}function hh(a,b){return`size ${a} must be non-negative, not ${b}`}function hi(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function hj(a,b){let c=L(a),d=L(b);return`Input to reshape is a SparseTensor with ${c}
  dense values, but the requested shape requires a multiple of ${d}. inputShape=${a} outputShape= ${b}`}function hk(a,b){let c=L(a),d=L(b);return`Input to reshape is a tensor with ${c} dense values, but the requested shape has ${d}. inputShape=${a} outputShape=${b}`}function hl(){return"segment ids must be >= 0"}function hm(){return"segment ids are not increasing"}function hn(a,b){return`Segment id ${a} out of range [0, ${b}), possibly because segmentIds input is not sorted.`}function ho(a,b,c){return`Bad: indices[${a}] == ${b} out of range [0, ${c})`}a.s(["checkEinsumDimSizes",()=>g9,"decodeEinsumEquation",()=>g7,"getEinsumComputePath",()=>ha,"getEinsumPermutation",()=>g8,"isIdentityPermutation",()=>hb],463852),a.i(463852),a.s(["prepareSplitSize",()=>hc],85239),a.i(85239),a.s(["getSparseFillEmptyRowsIndicesDenseShapeMismatch",()=>hd,"getSparseFillEmptyRowsNegativeIndexErrorMessage",()=>he,"getSparseFillEmptyRowsOutOfRangeIndexErrorMessage",()=>hf],336928),a.i(336928),a.s(["getSparseReshapeEmptyTensorZeroOutputDimErrorMessage",()=>hi,"getSparseReshapeInputOutputMismatchErrorMessage",()=>hk,"getSparseReshapeInputOutputMultipleErrorMessage",()=>hj,"getSparseReshapeMultipleNegativeOneOutputDimErrorMessage",()=>hg,"getSparseReshapeNegativeOutputDimErrorMessage",()=>hh],337600),a.i(337600),a.s(["getSparseSegmentReductionIndicesOutOfRangeErrorMessage",()=>ho,"getSparseSegmentReductionNegativeSegmentIdsErrorMessage",()=>hl,"getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage",()=>hm,"getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage",()=>hn],723186),a.i(723186),a.s(["ERF_A1",0,.254829592,"ERF_A2",0,-.284496736,"ERF_A3",0,1.421413741,"ERF_A4",0,-1.453152027,"ERF_A5",0,1.061405429,"ERF_P",0,.3275911,"PARALLELIZE_THRESHOLD",0,30,"RowPartitionType",()=>BM,"SELU_SCALE",0,1.0507009873554805,"SELU_SCALEALPHA",0,1.7580993408473768,"applyActivation",()=>gK,"assertAndGetBroadcastShape",()=>eX,"assertAxesAreInnerMostDims",()=>fH,"assertParamsConsistent",()=>gA,"assignToTypedArray",()=>g3,"axesAreInnerMostDims",()=>fD,"calculateShapes",()=>gZ,"checkEinsumDimSizes",()=>g9,"checkPadOnDimRoundingMode",()=>fk,"combineLocations",()=>fE,"combineRaggedTensorToTensorShapes",()=>gM,"complexWithEvenIndex",()=>g0,"complexWithOddIndex",()=>g1,"computeConv2DInfo",()=>e9,"computeConv3DInfo",()=>fa,"computeDefaultPad",()=>fb,"computeDilation2DInfo",()=>e6,"computeOptimalWindowSize",()=>gs,"computeOutAndReduceShapes",()=>fF,"computeOutShape",()=>gB,"computePool2DInfo",()=>e7,"computePool3DInfo",()=>e8,"convertConv2DDataFormat",()=>fj,"decodeEinsumEquation",()=>g7,"eitherStridesOrDilationsAreOne",()=>fh,"expandShapeToKeepDim",()=>fG,"exponent",()=>g5,"exponents",()=>g4,"fromStringArrayToUint8",()=>gy,"fromUint8ToStringArray",()=>gx,"getAxesPermutation",()=>fI,"getBroadcastDims",()=>eV,"getComplexWithIndex",()=>g2,"getEinsumComputePath",()=>ha,"getEinsumPermutation",()=>g8,"getFusedBiasGradient",()=>gJ,"getFusedDyActivation",()=>gI,"getImageCenter",()=>gQ,"getInnerMostAxes",()=>fK,"getPermuted",()=>gS,"getRaggedRank",()=>gO,"getReductionAxes",()=>eW,"getReshaped",()=>gR,"getReshapedPermuted",()=>gT,"getRowPartitionTypesHelper",()=>gN,"getSliceBeginCoords",()=>gU,"getSliceSize",()=>gV,"getSparseFillEmptyRowsIndicesDenseShapeMismatch",()=>hd,"getSparseFillEmptyRowsNegativeIndexErrorMessage",()=>he,"getSparseFillEmptyRowsOutOfRangeIndexErrorMessage",()=>hf,"getSparseReshapeEmptyTensorZeroOutputDimErrorMessage",()=>hi,"getSparseReshapeInputOutputMismatchErrorMessage",()=>hk,"getSparseReshapeInputOutputMultipleErrorMessage",()=>hj,"getSparseReshapeMultipleNegativeOneOutputDimErrorMessage",()=>hg,"getSparseReshapeNegativeOutputDimErrorMessage",()=>hh,"getSparseSegmentReductionIndicesOutOfRangeErrorMessage",()=>ho,"getSparseSegmentReductionNegativeSegmentIdsErrorMessage",()=>hl,"getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage",()=>hm,"getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage",()=>hn,"getUndoAxesPermutation",()=>fJ,"isIdentityPermutation",()=>hb,"log",()=>cZ,"mergeRealAndImagArrays",()=>g$,"prepareAndValidate",()=>gW,"prepareSplitSize",()=>hc,"segment_util",0,gw,"shouldFuse",0,gL,"slice_util",0,gr,"splitRealAndImagArrays",()=>g_,"stridesOrDilationsArePositive",()=>fi,"tupleValuesAreOne",()=>fg,"upcastType",()=>dp,"validateDefaultValueShape",()=>gP,"validateInput",()=>gY,"validateUpdateShape",()=>gX,"warn",()=>cY],537368);var hp=a.i(537368),hp=hp;let hq=dM({cumprod_:function(a,b=0,c=!1,d=!1){let e=dJ(a,"x","cumprod");return dB.runKernel(a3,{x:e},{axis:b,exclusive:c,reverse:d})}}),hr=dM({reverse_:function(a,b){let c=dJ(a,"x","reverse");return dB.runKernel(cg,{x:c},{dims:b})}}),hs=dM({logicalNot_:function(a){let b=dJ(a,"x","logicalNot","bool");return dB.runKernel(bH,{x:b})}}),ht=dM({cos_:function(a){let b=dJ(a,"x","cos","float32");return dB.runKernel("Cos",{x:b})}}),hu=dM({cosh_:function(a){let b=dJ(a,"x","cosh","float32");return dB.runKernel(a2,{x:b})}}),hv=dM({pad_:function(a,b,c=0){let d=dJ(a,"x","pad");if(0===d.rank)throw Error("pad(scalar) is not defined. Pass non-scalar to pad");return dB.runKernel(b0,{x:d},{paddings:b,constantValue:c})}}),hw=dM({batchToSpaceND_:function(a,b,c){let d=dJ(a,"x","batchToSpaceND"),e=b.reduce((a,b)=>a*b);return I(d.rank>=1+b.length,()=>`input rank is ${d.rank} but should be > than blockShape.length ${b.length}`),I(c.length===b.length,()=>`crops.length is ${c.length} but should be equal to blockShape.length  ${b.length}`),I(d.shape[0]%e==0,()=>`input tensor batch is ${d.shape[0]} but is not divisible by the product of the elements of blockShape ${b.join(" * ")} === ${e}`),dB.runKernel(aO,{x:d},{blockShape:b,crops:c})}}),hx={kernelName:cu,gradFunc:(a,b,c)=>{let{blockShape:d,paddings:e}=c;return{x:()=>hw(a,d,e)}}},hy=dM({concat_:function(a,b=0){I(a.length>=1,()=>"Pass at least one tensor to concat");let c=dK(a,"tensors","concat","string_or_numeric");return("complex64"===c[0].dtype&&c.forEach(a=>{if("complex64"!==a.dtype)throw Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),1===c.length)?ew(c[0]):dB.runKernel(aX,c,{axis:b})}}),hz={kernelName:cv,gradFunc:(a,b,c)=>{let{axis:d}=c;return{x:()=>hy(a,d)}}},hA=dM({expandDims_:function(a,b=0){let c=dJ(a,"x","expandDims","string_or_numeric");return I(b<=c.rank,()=>"Axis must be <= rank of the tensor"),dB.runKernel(bk,{input:c},{dim:b})}}),hB=dM({gather_:function(a,b,c=0,d=0){let e=dJ(a,"x","gather"),f=dJ(b,"indices","gather","int32");return dB.runKernel(br,{x:e,indices:f},{axis:c,batchDims:d})}});for(let a of[e2,{kernelName:az,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>{let b=eD(ev(c,"float32"));return e3(eA(a,eC(eS(eG(1),b))))}}}},{kernelName:aA,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eA(a,eC(eS(eD(ev(c,"float32")),1)))}}},{kernelName:"Add",inputsToSave:["a","b"],gradFunc:(a,b)=>{let[c,d]=b,e=eX(c.shape,d.shape);return{a:()=>{let b=a,d=eW(c.shape,e);return d.length>0&&(b=e5(b,d)),e4(b,c.shape)},b:()=>{let b=a,c=eW(d.shape,e);return c.length>0&&(b=e5(b,c)),e4(b,d.shape)}}}},{kernelName:aB,saveAllInputs:!0,gradFunc:(a,b)=>{let c={};return b.forEach((b,d)=>{c[d]=()=>a.clone()}),c}},{kernelName:aC,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eE(c)}}},{kernelName:aD,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eE(c)}}},{kernelName:aE,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eA(a,eC(eS(eG(1),eD(ev(c,"float32")))))}}},{kernelName:aF,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eA(a,eC(ey(eG(1),eD(ev(c,"float32")))))}}},{kernelName:aI,inputsToSave:["a","b"],gradFunc:(a,b)=>{let[c,d]=b,e=eX(c.shape,d.shape);return{a:()=>{let b=ey(eD(c),eD(d)),f=eB(a,eA(d,b)),g=eW(c.shape,e);return g.length>0&&(f=e5(f,g)),e4(f,c.shape)},b:()=>{let b=ey(eD(c),eD(d)),f=e3(eB(a,eA(c,b))),g=eW(d.shape,e);return g.length>0&&(f=e5(f,g)),e4(f,d.shape)}}}},{kernelName:aG,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eA(a,ey(eD(ev(c,"float32")),1))}}},{kernelName:aH,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eA(a,eS(eG(1),eD(ev(c,"float32"))))}}},{kernelName:aL,inputsToSave:["x"],gradFunc:(a,b,c)=>{let[d]=b,{filterSize:e,strides:f,pad:g,dimRoundingMode:h}=c;return{x:()=>fl(a,d,e,f,g,h)}}},{kernelName:aJ,inputsToSave:["x"],gradFunc:(a,b,c)=>{let[d]=b,{filterSize:e,strides:f,pad:g}=c;return{x:()=>fm(a,d,e,f,g)}}},{kernelName:aN,inputsToSave:["a","b"],gradFunc:(a,b,c)=>{let[d,e]=b,{transposeA:f,transposeB:g}=c;return f||g?!f&&g?{a:()=>fn(a,e,!1,!1),b:()=>fn(a,d,!0,!1)}:f&&!g?{a:()=>fn(e,a,!1,!0),b:()=>fn(d,a,!1,!1)}:{a:()=>fn(e,a,!0,!0),b:()=>fn(a,d,!0,!0)}:{a:()=>fn(a,e,!1,!0),b:()=>fn(d,a,!0,!1)}}},{kernelName:aO,gradFunc:(a,b,c)=>{let{blockShape:d,crops:e}=c;return{x:()=>fo(a,d,e)}}},{kernelName:"BroadcastTo",gradFunc:(a,b,c)=>{let d=c.inputShape,e=c.shape,f=Array.from(e);for(let a=d.length-1;a>=0;a--)if(d[a]===e[a])f[a]=1;else if(1!==d[a])throw Error(`broadcastTo(): [${d}] cannot be broadcast to [${e}].`);let g=[];for(let a=0;a<f.length;a++)f[a]>1&&g.push(a);return{x:()=>e5(a,g,!0)}}},{kernelName:aS,gradFunc:a=>({x:()=>a.clone()})},{kernelName:aT,gradFunc:a=>({x:()=>eE(a)})},{kernelName:aU,inputsToSave:["x"],gradFunc:(a,b,c)=>{let[d]=b,{clipValueMin:e,clipValueMax:f}=c;return{x:()=>ft(fr(fp(d,e),fq(d,f)),a,eE(a))}}},fu,{kernelName:aX,saveAllInputs:!0,gradFunc:(a,b,c)=>{let d=b.map(a=>a.shape),{axis:e}=c,f=W(e,b[0].shape)[0];return fv(a,d.map(a=>a[f]),f).map(a=>()=>a)}},{kernelName:a$,inputsToSave:["dy","filter"],gradFunc:(a,b,c)=>{let[d,e]=b,{strides:f,pad:g,dataFormat:h,dimRoundingMode:i}=c;return{dy:()=>fy(a,e,f,g,h,1,i),filter:()=>fw(a,d,e.shape,f,g,h,i)}}},{kernelName:aY,inputsToSave:["x","filter"],gradFunc:(a,b,c)=>{let[d,e]=b,{dilations:f,strides:g,pad:h,dataFormat:i}=c;return I(fg(f),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${f}'`),{x:()=>fx(d.shape,a,e,g,h,i),filter:()=>fw(d,a,e.shape,g,h,i)}}},{kernelName:a_,inputsToSave:["x","filter"],gradFunc:(a,b,c)=>{let{dilations:d,strides:e,pad:f}=c;I(fg(d),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${d}'`);let[g,h]=b;return{x:()=>fA(g.shape,a,h,e,f),filter:()=>fz(g,a,h.shape,e,f)}}},{kernelName:"Cos",inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eB(e3(fB(ev(c,"float32"))),a)}}},{kernelName:a2,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eB(fC(ev(c,"float32")),a)}}},{kernelName:a4,inputsToSave:["x"],gradFunc:(a,b,c)=>{let[d]=b,{axis:e,exclusive:f,reverse:g}=c;return{x:()=>{let b=fI([e],d.rank),c=fL(a,e,f,!g);return null!=b&&(c=fO(c,b)),c}}}},{kernelName:a8,inputsToSave:["x","filter"],gradFunc:(a,b,c)=>{let{dilations:d,strides:e,pad:f,dimRoundingMode:g}=c,h=null==d?[1,1]:d;I(fg(h),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${h}'`);let[i,j]=b;return I(4===i.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${i.rank}.`),I(4===j.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${j.rank}.`),I(i.shape[3]===j.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${i.shape[3]}) must match the inChannels dimension in filter ${j.shape[2]}.`),I(fh(e,h),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${e} and dilations '${h}'.`),fk("depthwiseConv2d",f,g),{x:()=>fQ(i.shape,a,j,e,f,h,g),filter:()=>fP(i,a,j.shape,e,f,h,g)}}},{kernelName:bc,inputsToSave:["x","filter"],gradFunc:(a,b,c)=>{let[d,e]=b,f={x:d,filter:e,dy:a},g={x:d,filter:e,dy:a};return{x:()=>dB.runKernel(bd,f,c),filter:()=>dB.runKernel(be,g,c)}}},{kernelName:bg,inputsToSave:["a","b"],gradFunc:(a,b)=>{let[c,d]=b,e=eX(c.shape,d.shape);return{a:()=>{let b=eA(a,ev(d,"float32")),f=eW(c.shape,e);return f.length>0?e4(e5(b,f),c.shape):b},b:()=>{let b=eB(a,ev(c,"float32")),f=eW(d.shape,e);return f.length>0&&(b=e4(e5(b,f),d.shape)),e3(eA(b,ev(eD(d),"float32")))}}}},{kernelName:"Elu",outputsToSave:[!0],gradFunc:(a,b)=>{let[c]=b,d={dy:a,y:c};return{x:()=>dB.runKernel(bi,d)}}},{kernelName:"Erf",inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b,d=eB(fR(e3(eD(c))),2/Math.sqrt(Math.PI));return{x:()=>eB(a,d)}}},{kernelName:"Exp",outputsToSave:[!0],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eB(a,c)}}},{kernelName:bk,inputsToSave:["input"],gradFunc:(a,b)=>{let[c]=b;return{input:()=>e4(a,c.shape)}}},{kernelName:bl,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eB(a,fR(c))}}},{kernelName:bp,inputsToSave:["a","b"],gradFunc:(a,b)=>{let[c,d]=b,e=eX(c.shape,d.shape);return{a:()=>{let b=eA(a,ev(d,"float32")),f=eW(c.shape,e);return f.length>0?e4(e5(b,f),c.shape):b},b:()=>{let b=eB(a,ev(c,"float32")),f=eW(d.shape,e);return f.length>0&&(b=e4(e5(b,f),d.shape)),e3(eA(b,ev(eD(d),"float32")))}}}},{kernelName:bo,gradFunc:a=>({x:()=>eE(a)})},{kernelName:bq,inputsToSave:["x","mean","variance","scale"],gradFunc:(a,b,c)=>{let{varianceEpsilon:d}=c,[e,f,g,h]=b,i=null==h?eG(1):h,j=eW(f.shape,e.shape),k=[];if(1===f.rank){for(let a=0;a<e.shape.length-1;++a)k.push(e.shape[a]);k.push(1)}let l=eS(e,f),m=eB(a,i),n=fS(ey(g,eG(d))),o=eB(eB(eB(n,n),n),eG(-.5));return{x:()=>1===f.rank?e4(eB(eB(a,fT(e4(n,[1,1,1,f.shape[0]]),k)),i),e.shape):e4(eB(eB(a,n),i),e.shape),mean:()=>{let a=eB(eB(n,eG(-1)),m);return 1===f.rank&&(a=e5(a,j)),e4(a,f.shape)},variance:()=>{let a=eB(eB(o,l),m);return 1===f.rank&&(a=e5(a,j)),e4(a,f.shape)},scale:()=>{let b=eB(l,n),c=eB(a,b);return 1===f.rank&&(c=e5(c,j)),e4(c,f.shape)},offset:()=>{let b=a;return 1===f.rank&&(b=e5(b,j)),e4(b,f.shape)}}}},{kernelName:br,inputsToSave:["x","indices"],gradFunc:(a,b,c)=>{let[d,e]=b,{axis:f,batchDims:g}=c,h=W(f,d.shape)[0],i=(a,b,c)=>()=>{let d=a.shape,e=b.size,g=d.slice(0,h),i=g.length,j=d.slice(f,d.length).slice(1),k=j.length,l=fW(0,i),m=fW(i+1,i+1+k),n=e4(c,fX([g,[e],j])),o=e4(b,[e]),p=fX([[i],l,m]),q=fV(fO(n,p),o,a.shape[h]);return fO(q,fJ(p))};if(1!==g)return{x:i(d,e,a),indices:()=>e};{let b=d.shape[0],c=d.split(b,0);return{x:()=>fU(c.map((b,c)=>i(b,e.slice(c,1),a.slice(c,1))())).reshape(d.shape),indices:()=>e}}}},{kernelName:bu,inputsToSave:["a","b"],gradFunc:(a,b)=>{let[c,d]=b;return{a:()=>eE(c),b:()=>eE(d)}}},{kernelName:bv,gradFunc:a=>({x:()=>ev(a,"float32")})},{kernelName:by,gradFunc:a=>({x:()=>eE(a)})},{kernelName:bz,gradFunc:a=>({x:()=>eE(a)})},{kernelName:bA,gradFunc:a=>({x:()=>eE(a)})},{kernelName:bB,inputsToSave:["x"],gradFunc:(a,b,c)=>{let[d]=b,{alpha:e}=c,f=fY(d,0);return{x:()=>ft(f,a,eB(a,e))}}},{kernelName:bF,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eA(a,ey(c,1))}}},{kernelName:"Log",inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eA(a,ev(c,"float32"))}}},{kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(a,b,c)=>{let[d]=b,{axis:e}=c;return{logits:()=>{let b=fR(d);return eS(a,eB(e5(a,e,!0),b))}}}},{kernelName:"LRN",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(a,b,c)=>{let[d,e]=b,{depthRadius:f,bias:g,alpha:h,beta:i}=c;return{x:()=>fZ(d,e,a,f,g,h,i)}}},f0,f0,{kernelName:bK,inputsToSave:["a","b"],gradFunc:(a,b)=>{let[c,d]=b;return{a:()=>eB(a,ev(fp(c,d),"float32")),b:()=>eB(a,ev(f1(c,d),"float32"))}}},{kernelName:bN,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(a,b,c)=>{let[d,e]=b,{filterSize:f,strides:g,pad:h,dimRoundingMode:i}=c;return{x:()=>f2(a,d,e,f,g,h,i)}}},{kernelName:bL,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(a,b,c)=>{let[d,e]=b,{filterSize:f,strides:g,pad:h}=c;return{x:()=>f3(a,d,e,f,g,h)}}},{kernelName:bQ,inputsToSave:["x"],gradFunc:(a,b,c)=>{let[d]=b,{axis:e}=c,f=W(e,d.shape),g=L(fF(d.shape,f)[1]);return{x:()=>{let b=d.shape.slice();return f.forEach(a=>{b[a]=1}),eA(eB(e4(a,b),f5(d.shape,"float32")),g)}}}},{kernelName:"Min",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(a,b,c)=>{let{axis:d}=c,[e,f]=b,g=W(d,e.shape),h=f_(a,f,e,g);return{x:()=>h.x()}}},{kernelName:bR,inputsToSave:["a","b"],gradFunc:(a,b)=>{let[c,d]=b;return{a:()=>eB(a,ev(fq(c,d),"float32")),b:()=>eB(a,ev(fY(c,d),"float32"))}}},{kernelName:bS,inputsToSave:["x"],gradFunc:(a,b,c)=>{let d=b[0],{paddings:e}=c,f=e.map(a=>a[0]);return{x:()=>f6(a,f,d.shape)}}},{kernelName:"Mod",inputsToSave:["a","b"],gradFunc:(a,b)=>{let[c,d]=b,e=eX(c.shape,d.shape);return{a:()=>{let b=eW(c.shape,e);return b.length>0?e4(e5(a,b),c.shape):a},b:()=>{let b=eB(a,e3(f7(eA(c,d)))),f=eW(d.shape,e);return f.length>0?e4(e5(b,f),d.shape):b}}}},{kernelName:bU,inputsToSave:["a","b"],gradFunc:(a,b)=>{let[c,d]=b,e=eX(c.shape,d.shape);return{a:()=>{let b=eB(a,ev(d,"float32")),f=eW(c.shape,e);return f.length>0?e4(e5(b,f),c.shape):b},b:()=>{let b=eB(a,ev(c,"float32")),f=eW(d.shape,e);return f.length>0?e4(e5(b,f),d.shape):b}}}},{kernelName:"Neg",gradFunc:a=>({x:()=>e3(a)})},{kernelName:b$,inputsToSave:["indices"],gradFunc:(a,b)=>{let c=b[0];return{indices:()=>f4(c.shape,"float32")}}},{kernelName:bZ,gradFunc:a=>({x:()=>eE(a)})},{kernelName:b_,saveAllInputs:!0,gradFunc:(a,b,c)=>{let{axis:d}=c;return f8(a,d).map(a=>()=>a)}},f9,f9,{kernelName:"Pow",inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(a,b)=>{let[c,d,e]=b,f=eX(c.shape,d.shape);return{a:()=>{let b=ev(d,"float32"),e=eB(a,eB(b,eR(c,eS(b,eG(1))))),g=eW(c.shape,f);return g.length>0&&(e=e5(e,g)),e4(e,c.shape)},b:()=>{let b=eB(a,eB(e,ft(fY(c,0),ga(c),eE(c)))),g=eW(d.shape,f);return g.length>0&&(b=e5(b,g)),e4(b,d.shape)}}}},{kernelName:b1,inputsToSave:["x","alpha"],gradFunc:(a,b)=>{let[c,d]=b,e=fY(c,0);return{x:()=>ft(e,a,eB(a,d)),alpha:()=>{let b=ft(e,eE(a),eB(a,c)),f=eW(d.shape,a.shape);return f.length>0&&(b=e5(b,f)),e4(b,d.shape)}}}},{kernelName:b2,inputsToSave:["x"],gradFunc:(a,b,c)=>{let[d]=b,{axis:e}=c,f=[];return f=null==e?d.shape.map((a,b)=>b):"number"==typeof e?[e]:e,{x:()=>{var b,c;let e,g,h,i,j,k,l,m,n,o;return b=f,g=(e=d.shape.length)-b.length,h=hp.getAxesPermutation(b,e),i=d,null!=h&&(i=fO(d,h)),k=(j=i.shape.slice()).splice(e-b.length,b.length).reduce((a,b)=>a*b,1),j.push(k),o=(c=i.reshape(j),(l=c.shape.slice())[g]=1,m=e4(a,l),n=eB(hq(c,g,!0,!1),hq(c,g,!0,!0)),o=eB(m,n)).reshape(i.shape),null!=h&&(o=fO(o,hp.getUndoAxesPermutation(h))),o}}}},{kernelName:b8,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eA(a,e3(eD(c)))}}},{kernelName:cf,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b,d=eB(fq(c,6),e1(c));return{x:()=>eB(a,ev(d,"float32"))}}},{kernelName:b9,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eB(a,ev(e1(c),"float32"))}}},{kernelName:ca,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>e4(a,c.shape)}}},{kernelName:cd,inputsToSave:["images"],gradFunc:(a,b,c)=>{let[d]=b,e={dy:a,images:d};return{images:()=>dB.runKernel(ce,e,c)}}},{kernelName:cb,inputsToSave:["images"],gradFunc:(a,b,c)=>{let[d]=b,e={dy:a,images:d};return{images:()=>dB.runKernel(cc,e,c)}}},{kernelName:cg,gradFunc:(a,b,c)=>{let{dims:d}=c,e=W(d,a.shape);return{x:()=>hr(a,e)}}},{kernelName:ch,gradFunc:a=>({x:()=>eE(a)})},{kernelName:ci,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>e3(eA(a,eB(eR(c,1.5),2)))}}},{kernelName:cm,inputsToSave:["condition"],gradFunc:(a,b)=>{let[c]=b;return{condition:()=>ev(eE(c),"float32"),t:()=>eB(a,ev(c,a.dtype)),e:()=>eB(a,ev(hs(c),a.dtype))}}},{kernelName:cn,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>{let b=fY(c,eG(0)),d=eG(1.7580993408473768);return ft(b,eB(a,eG(1.0507009873554805)),eB(eB(a,d),fR(ev(c,"float32"))))}}}},{kernelName:cr,outputsToSave:[!0],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eB(a,eB(c,eS(eG(1),c)))}}},{kernelName:cq,gradFunc:a=>({x:()=>eE(a)})},{kernelName:"Sin",inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eB(ht(ev(c,"float32")),a)}}},{kernelName:cp,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eB(hu(ev(c,"float32")),a)}}},{kernelName:co,inputsToSave:["x"],gradFunc:(a,b,c)=>{let[d]=b,{begin:e,size:f}=c,g=d.shape,[h,i]=go(d,e,f),j=[];for(let b=0;b<a.rank;b++)j.push([h[b],g[b]-h[b]-i[b]]);return{x:()=>hv(a,j)}}},{kernelName:cw,outputsToSave:[!0],gradFunc:(a,b,c)=>{let[d]=b,{dim:e}=c,f=eB(a,d);return{logits:()=>eS(f,eB(e5(f,[e],!0),d))}}},{kernelName:cs,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eB(a,gH(c))}}},hx,hx,hz,hz,{kernelName:ct,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eA(a,eB(eC(ev(c,"float32")),2))}}},{kernelName:cC,inputsToSave:["a","b"],gradFunc:(a,b)=>{let[c,d]=b,e=eG(2);return{a:()=>eB(a,eB(e,eS(c,d))),b:()=>eB(a,eB(e,eS(d,c)))}}},{kernelName:cD,inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eB(a,eB(ev(c,"float32"),2))}}},{kernelName:cS,gradFunc:a=>({x:()=>eE(a)})},{kernelName:"Sub",inputsToSave:["a","b"],gradFunc:(a,b)=>{let[c,d]=b,e=eX(c.shape,d.shape);return{a:()=>{let b=a,d=eW(c.shape,e);return d.length>0&&(b=e5(b,d)),e4(b,c.shape)},b:()=>{let b=a,c=eW(d.shape,e);return c.length>0&&(b=e5(b,c)),e4(e3(b),d.shape)}}}},{kernelName:"Sum",inputsToSave:["x"],gradFunc:(a,b,c)=>{let[d]=b,e=d.shape.slice(),{axis:f}=c;W(f,d.shape).forEach(a=>{e[a]=1});let g=eB(e4(a,e),f5(d.shape,"float32"));return{x:()=>g}}},{kernelName:"Tan",inputsToSave:["x"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eA(a,eD(ht(c)))}}},{kernelName:cJ,outputsToSave:[!0],gradFunc:(a,b)=>{let[c]=b;return{x:()=>eB(eS(eG(1),eD(c)),a)}}},{kernelName:cK,inputsToSave:["x"],gradFunc:(a,b,c)=>{let[d]=b,{reps:e}=c;return{x:()=>{let b=eE(d);if(1===d.rank)for(let c=0;c<e[0];++c)b=ey(b,f6(a,[c*d.shape[0]],[d.shape[0]]));else if(2===d.rank)for(let c=0;c<e[0];++c)for(let f=0;f<e[1];++f)b=ey(b,f6(a,[c*d.shape[0],f*d.shape[1]],[d.shape[0],d.shape[1]]));else if(3===d.rank)for(let c=0;c<e[0];++c)for(let f=0;f<e[1];++f)for(let g=0;g<e[2];++g)b=ey(b,f6(a,[c*d.shape[0],f*d.shape[1],g*d.shape[2]],[d.shape[0],d.shape[1],d.shape[2]]));else if(4===d.rank)for(let c=0;c<e[0];++c)for(let f=0;f<e[1];++f)for(let g=0;g<e[2];++g)for(let h=0;h<e[3];++h)b=ey(b,f6(a,[c*d.shape[0],f*d.shape[1],g*d.shape[2],h*d.shape[3]],[d.shape[0],d.shape[1],d.shape[2],d.shape[3]]));else throw Error(`Gradient for tile operation is not implemented for rank-${d.rank} tensors yet.`);return b}}}},{kernelName:cN,gradFunc:(a,b,c)=>{let{perm:d}=c,e=fJ(d);return{x:()=>fO(a,e)}}},{kernelName:cP,gradFunc:(a,b,c)=>{let{axis:d}=c;return{value:()=>fU(a,d)}}},{kernelName:cQ,inputsToSave:["segmentIds"],gradFunc:(a,b)=>{let[c]=b;return{x:()=>(function(a,b){let c=hB(a,eY(b,eE(b))),d=fp(b,eG(0,"int32")),e=c.rank-d.rank;for(let a=0;a<e;++a)d=hA(d,a+1);d=fr(d,f5(c.shape,"bool"));let f=eE(c);return ft(d,c,f)})(a,c)}}},{kernelName:cR,gradFunc:a=>({x:()=>eE(a)})}])!function(a){let{kernelName:b}=a;c_.has(b)&&aw.getBool("DEBUG")&&cY(`Overriding the gradient for '${b}'`),c_.set(b,a)}(a);dl().prototype.abs=function(){return this.throwIfDisposed(),eU(this)};let hC=dM({acos_:function(a){let b=dJ(a,"x","acos");return dB.runKernel(az,{x:b})}});dl().prototype.acos=function(){return this.throwIfDisposed(),hC(this)};let hD=dM({acosh_:function(a){let b=dJ(a,"x","acosh");return dB.runKernel(aA,{x:b})}});dl().prototype.acosh=function(){return this.throwIfDisposed(),hD(this)},dl().prototype.add=function(a){return this.throwIfDisposed(),ey(this,a)};let hE=dM({all_:function(a,b=null,c=!1){let d=dJ(a,"x","all","bool");return dB.runKernel("All",{x:d},{axis:b,keepDims:c})}});dl().prototype.all=function(a,b){return this.throwIfDisposed(),hE(this,a,b)};let hF=dM({any_:function(a,b=null,c=!1){let d=dJ(a,"x","any","bool");return dB.runKernel("Any",{x:d},{axis:b,keepDims:c})}});dl().prototype.any=function(a,b){return this.throwIfDisposed(),hF(this,a,b)};let hG=dM({argMax_:function(a,b=0){let c=dJ(a,"x","argMax");return dB.runKernel(aC,{x:c},{axis:b})}});dl().prototype.argMax=function(a){return this.throwIfDisposed(),hG(this,a)};let hH=dM({argMin_:function(a,b=0){let c=dJ(a,"x","argMin");return dB.runKernel(aD,{x:c},{axis:b})}});dl().prototype.argMin=function(a){return this.throwIfDisposed(),hH(this,a)},dl().prototype.asScalar=function(){return this.throwIfDisposed(),I(1===this.size,()=>"The array must have only 1 element."),e4(this,[])},dl().prototype.asType=function(a){return this.throwIfDisposed(),ev(this,a)},dl().prototype.as1D=function(){return this.throwIfDisposed(),e4(this,[this.size])},dl().prototype.as2D=function(a,b){return this.throwIfDisposed(),e4(this,[a,b])},dl().prototype.as3D=function(a,b,c){return this.throwIfDisposed(),e4(this,[a,b,c])},dl().prototype.as4D=function(a,b,c,d){return this.throwIfDisposed(),e4(this,[a,b,c,d])},dl().prototype.as5D=function(a,b,c,d,e){return this.throwIfDisposed(),e4(this,[a,b,c,d,e])};let hI=dM({asin_:function(a){let b=dJ(a,"x","asin");return dB.runKernel(aE,{x:b})}});dl().prototype.asin=function(){return this.throwIfDisposed(),hI(this)};let hJ=dM({asinh_:function(a){let b=dJ(a,"x","asinh");return dB.runKernel(aF,{x:b})}});dl().prototype.asinh=function(){return this.throwIfDisposed(),hJ(this)};let hK=dM({atan_:function(a){let b=dJ(a,"x","atan");return dB.runKernel(aG,{x:b})}});dl().prototype.atan=function(){return this.throwIfDisposed(),hK(this)};let hL=dM({atan2_:function(a,b){let c=dJ(a,"a","atan2"),d=dJ(b,"b","atan2");[c,d]=dt(c,d);let e={a:c,b:d};return dB.runKernel(aI,e)}});dl().prototype.atan2=function(a){return this.throwIfDisposed(),hL(this,a)};let hM=dM({atanh_:function(a){let b=dJ(a,"x","atanh");return dB.runKernel(aH,{x:b})}});dl().prototype.atanh=function(){return this.throwIfDisposed(),hM(this)};let hN=dM({avgPool_:function(a,b,c,d,e){let f=dJ(a,"x","avgPool","float32");I(fh(c,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${c} and dilations '1'`);let g=f,h=!1;3===f.rank&&(h=!0,g=e4(f,[1,f.shape[0],f.shape[1],f.shape[2]])),I(4===g.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${g.rank}.`),fk("avgPool",d,e);let i={x:g},j=dB.runKernel(aJ,i,{filterSize:b,strides:c,pad:d,dimRoundingMode:e});return(j=ev(j,f.dtype),h)?e4(j,[j.shape[1],j.shape[2],j.shape[3]]):j}});dl().prototype.avgPool=function(a,b,c,d){return this.throwIfDisposed(),hN(this,a,b,c,d)},dl().prototype.batchToSpaceND=function(a,b){return this.throwIfDisposed(),hw(this,a,b)};let hO=dM({batchNorm_:function(a,b,c,d,e,f){let g,h;null==f&&(f=.001);let i=dJ(a,"x","batchNorm"),j=dJ(b,"mean","batchNorm"),k=dJ(c,"variance","batchNorm");null!=e&&(g=dJ(e,"scale","batchNorm")),null!=d&&(h=dJ(d,"offset","batchNorm")),I(j.rank===k.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(null==h||j.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(null==g||j.rank===g.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let l={x:0===i.rank||1===i.rank?e4(i,[1,1,1,i.size]):2===i.rank?e4(i,[1,1,i.shape[0],i.shape[1]]):3===i.rank?e4(i,[1,i.shape[0],i.shape[1],i.shape[2]]):i,scale:g,offset:h,mean:j,variance:k},m={varianceEpsilon:f};return e4(dB.runKernel(bq,l,m),i.shape)}});dl().prototype.batchNorm=function(a,b,c,d,e){return this.throwIfDisposed(),hO(this,a,b,c,d,e)},dl().prototype.broadcastTo=function(a){return this.throwIfDisposed(),fs(this,a)},dl().prototype.cast=function(a){return this.throwIfDisposed(),ev(this,a)};let hP=dM({ceil_:function(a){let b=dJ(a,"x","ceil","float32");return dB.runKernel(aT,{x:b})}});dl().prototype.ceil=function(){return this.throwIfDisposed(),hP(this)};let hQ=dM({clipByValue_:function(a,b,c){let d=dJ(a,"x","clipByValue");return(I(b<=c,()=>`Error in clip: min (${b}) must be less than or equal to max (${c}).`),b===c)?eP(d.shape,b,d.dtype):dB.runKernel(aU,{x:d},{clipValueMin:b,clipValueMax:c})}});dl().prototype.clipByValue=function(a,b){return this.throwIfDisposed(),hQ(this,a,b)},dl().prototype.concat=function(a,b){return this.throwIfDisposed(),a instanceof dk&&(a=[a]),hy([this,...a],b)};let hR=dM({conv1d_:function(a,b,c,d,e="NWC",f=1,g){let h=dJ(a,"x","conv1d"),i=dJ(b,"filter","conv1d"),j=h,k=!1;2===h.rank&&(k=!0,j=e4(h,[1,h.shape[0],h.shape[1]])),I(3===j.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${j.rank}.`),I(3===i.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${i.rank}.`),fk("conv1d",d,g),I(j.shape[2]===i.shape[1],()=>`Error in conv1d: depth of input (${j.shape[2]}) must match input depth for filter ${i.shape[1]}.`),I(fh(c,f),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${c} and dilation '${f}'`),I(fi(f),()=>"Error in conv1D: Dilated rates should be larger than 0."),I(fi(c),()=>"Error in conv1D: Stride should be larger than 0."),I("NWC"===e,()=>`Error in conv1d: got dataFormat of ${e} but only NWC is currently supported.`);let l=e4(i,[1,i.shape[0],i.shape[1],i.shape[2]]),m=fy(e4(j,[j.shape[0],1,j.shape[1],j.shape[2]]),l,[1,c],d,"NHWC",[1,f],g);return k?e4(m,[m.shape[2],m.shape[3]]):e4(m,[m.shape[0],m.shape[2],m.shape[3]])}});dl().prototype.conv1d=function(a,b,c,d,e,f){return this.throwIfDisposed(),hR(this,a,b,c,d,e,f)};let hS=dM({conv2dTranspose_:function(a,b,c,d,e,f){return fx(c,dJ(a,"x","conv2dTranspose"),dJ(b,"filter","conv2dTranspose"),d,e,"NHWC",f)}});dl().prototype.conv2dTranspose=function(a,b,c,d,e){return this.throwIfDisposed(),hS(this,a,b,c,d,e)},dl().prototype.conv2d=function(a,b,c,d,e,f){return this.throwIfDisposed(),fy(this,a,b,c,d,e,f)},dl().prototype.cos=function(){return this.throwIfDisposed(),ht(this)},dl().prototype.cosh=function(){return this.throwIfDisposed(),hu(this)},dl().prototype.cumprod=function(a,b,c){return this.throwIfDisposed(),hq(this,a,b,c)},dl().prototype.cumsum=function(a,b,c){return this.throwIfDisposed(),fL(this,a,b,c)};let hT=dM({depthToSpace_:function(a,b,c="NHWC"){let d=dJ(a,"x","depthToSpace","float32"),e="NHWC"===c?d.shape[1]:d.shape[2],f="NHWC"===c?d.shape[2]:d.shape[3],g="NHWC"===c?d.shape[3]:d.shape[1];return I(b>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${b}`),I(e*b>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${e} and ${b}  for depthToSpace with input shape
    ${d.shape}`),I(f*b>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${f} and ${b} for depthToSpace with input shape
        ${d.shape}`),I(g%(b*b)==0,()=>`Dimension size must be evenly divisible by ${b*b} but is ${g} for depthToSpace with input shape ${d.shape}`),dB.runKernel(a7,{x:d},{blockSize:b,dataFormat:c})}});dl().prototype.depthToSpace=function(a,b){return this.throwIfDisposed(),hT(this,a,b)};let hU=dM({depthwiseConv2d_:function(a,b,c,d,e="NHWC",f=[1,1],g){let h=dJ(a,"x","depthwiseConv2d","float32"),i=dJ(b,"filter","depthwiseConv2d","float32"),j=h,k=!1;3===h.rank&&(k=!0,j=e4(h,[1,h.shape[0],h.shape[1],h.shape[2]])),I(4===j.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${j.rank}.`),I(4===i.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${i.rank}.`);let l="NHWC"===e?j.shape[3]:j.shape[1];I(l===i.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l}) must match the inChannels dimension in filter ${i.shape[2]}.`),fk("depthwiseConv2d",d,g);let m={x:j,filter:i},n=dB.runKernel(a8,m,{strides:c,pad:d,dataFormat:e,dilations:f,dimRoundingMode:g});return k?e4(n,[n.shape[1],n.shape[2],n.shape[3]]):n}});dl().prototype.depthwiseConv2d=function(a,b,c,d,e,f){return this.throwIfDisposed(),hU(this,a,b,c,d,e,f)};let hV=dM({dilation2d_:function(a,b,c,d,e=[1,1],f="NHWC"){let g=dJ(a,"x","dilation2d"),h=dJ(b,"filter","dilation2d");I(3===g.rank||4===g.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${g.rank}.`),I(3===h.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${h.rank}.`),I("NHWC"===f,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${f}`);let i=g,j=!1;3===g.rank&&(i=e4(g,[1,g.shape[0],g.shape[1],g.shape[2]]),j=!0),I(i.shape[3]===h.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${i.shape[3]} vs ${h.shape[2]}`);let k={x:i,filter:h},l=dB.runKernel(bc,k,{strides:c,pad:d,dilations:e});return j?e4(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});dl().prototype.dilation2d=function(a,b,c,d,e){return this.throwIfDisposed(),hV(this,a,b,c,d,e)};let hW=dM({divNoNan_:function(a,b){let c=dJ(a,"a","div"),d=dJ(b,"b","div");[c,d]=dt(c,d);let e=eA(c,d),f=eE(e);return ft(f$(d,f),f,e)}});dl().prototype.divNoNan=function(a){return this.throwIfDisposed(),hW(this,a)},dl().prototype.div=function(a){return this.throwIfDisposed(),eA(this,a)};let hX=dM({dot_:function(a,b){let c=dJ(a,"t1","dot"),d=dJ(b,"t2","dot");I((1===c.rank||2===c.rank)&&(1===d.rank||2===d.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${c.rank} and ${d.rank}.`);let e=1===c.rank?c.size:c.shape[1],f=1===d.rank?d.size:d.shape[0];if(I(e===f,()=>`Error in dot: inner dimensions of inputs must match, but got ${e} and ${f}.`),1===c.rank&&1===d.rank){let a=fn(e4(c,[1,-1]),e4(d,[-1,1]));return e4(a,[])}if(1===c.rank&&2===d.rank){let a=fn(e4(c,[1,-1]),e4(d,[d.shape[0],d.shape[1]]));return e4(a,[a.size])}if(2!==c.rank||1!==d.rank)return fn(c,e4(d,[d.shape[0],d.shape[1]]));{let a=fn(c,e4(d,[-1,1]));return e4(a,[a.size])}}});dl().prototype.dot=function(a){return this.throwIfDisposed(),hX(this,a)},dl().prototype.elu=function(){return this.throwIfDisposed(),gC(this)},dl().prototype.equal=function(a){return this.throwIfDisposed(),f$(this,a)};let hY=dM({erf_:function(a){let b=dJ(a,"x","erf");I("int32"===b.dtype||"float32"===b.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===b.dtype&&(b=ev(b,"float32"));let c={x:b};return dB.runKernel("Erf",c)}});dl().prototype.erf=function(){return this.throwIfDisposed(),hY(this)};let hZ=dM({max_:function(a,b=null,c=!1){let d=dJ(a,"x","max");return dB.runKernel("Max",{x:d},{reductionIndices:b,keepDims:c})}}),h$=dM({min_:function(a,b=null,c=!1){let d=dJ(a,"x","min");return dB.runKernel("Min",{x:d},{axis:b,keepDims:c})}}),h_=dM({norm_:function(a,b="euclidean",c=null,d=!1){let e=function a(b,c,d=null){if(0===b.rank)return eU(b);if(1!==b.rank&&null===d)return a(e4(b,[-1]),c,d);if(1===b.rank||"number"==typeof d||Array.isArray(d)&&1===d.length){if(1===c)return e5(eU(b),d);if(c===1/0)return hZ(eU(b),d);if(c===-1/0)return h$(eU(b),d);if("euclidean"===c||2===c)return eC(e5(eR(eU(b),eG(2,"int32")),d));throw Error(`Error in norm: invalid ord value: ${c}`)}if(Array.isArray(d)&&2===d.length){if(1===c)return hZ(e5(eU(b),d[0]),d[1]-1);if(c===1/0)return hZ(e5(eU(b),d[1]),d[0]);if(c===-1/0)return h$(e5(eU(b),d[1]),d[0]);if("fro"===c||"euclidean"===c)return eC(e5(eD(b),d));throw Error(`Error in norm: invalid ord value: ${c}`)}throw Error(`Error in norm: invalid axis: ${d}`)}(a=dJ(a,"x","norm"),b,c),f=e.shape;if(d){let b=W(c,a.shape);f=fG(e.shape,b)}return e4(e,f)}});a.s(["norm",0,h_],154846);let h0=dM({euclideanNorm_:function(a,b=null,c=!1){return h_(a,"euclidean",b,c)}});dl().prototype.euclideanNorm=function(a,b){return this.throwIfDisposed(),h0(this,a,b)},dl().prototype.exp=function(){return this.throwIfDisposed(),fR(this)},dl().prototype.expandDims=function(a){return this.throwIfDisposed(),hA(this,a)};let h1=dM({expm1_:function(a){let b=dJ(a,"x","expm1");return dB.runKernel(bl,{x:b})}});dl().prototype.expm1=function(){return this.throwIfDisposed(),h1(this)};let h2=dM({fft_:function(a){return I("complex64"===a.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${a.dtype}.`),dB.runKernel("FFT",{input:a})}});dl().prototype.fft=function(){return this.throwIfDisposed(),h2(this)},dl().prototype.flatten=function(){return this.throwIfDisposed(),e4(this,[this.size])},dl().prototype.floor=function(){return this.throwIfDisposed(),f7(this)},dl().prototype.floorDiv=function(a){return this.throwIfDisposed(),ez(this,a)},dl().prototype.gather=function(a,b,c){return this.throwIfDisposed(),hB(this,a,b,c)},dl().prototype.greaterEqual=function(a){return this.throwIfDisposed(),fp(this,a)},dl().prototype.greater=function(a){return this.throwIfDisposed(),fY(this,a)};let h3=dM({ifft_:function(a){return I("complex64"===a.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${a.dtype}.`),dB.runKernel(bw,{input:a})}});dl().prototype.ifft=function(){return this.throwIfDisposed(),h3(this)};let h4=dM({irfft_:function(a){let b,c=a.shape[a.shape.length-1],d=a.size/c;if(c<=2)b=h3(e4(a,[d,c]));else{let e=[d,2*(c-1)],f=e4(fN(a),[d,c]),g=e4(fM(a),[d,c]),h=hr(f6(f,[0,1],[d,c-2]),1),i=eB(hr(f6(g,[0,1],[d,c-2]),1),eG(-1));b=h3(e4(dN(hy([f,h],1),hy([g,i],1)),[e[0],e[1]]))}if(b=fN(b),3===a.rank&&0!==a.shape[0]){let c=b,d=a.shape[0];b=e4(b,[d,b.shape[0]/d,b.shape[1]]),c.dispose()}return b}});dl().prototype.irfft=function(){return this.throwIfDisposed(),h4(this)};let h5=dM({isFinite_:function(a){let b=dJ(a,"x","isFinite");return dB.runKernel(by,{x:b})}});dl().prototype.isFinite=function(){return this.throwIfDisposed(),h5(this)};let h6=dM({isInf_:function(a){let b=dJ(a,"x","isInf");return dB.runKernel(bz,{x:b})}});dl().prototype.isInf=function(){return this.throwIfDisposed(),h6(this)};let h7=dM({isNaN_:function(a){let b=dJ(a,"x","isNaN");return dB.runKernel(bA,{x:b})}});dl().prototype.isNaN=function(){return this.throwIfDisposed(),h7(this)},dl().prototype.leakyRelu=function(a){return this.throwIfDisposed(),gD(this,a)},dl().prototype.lessEqual=function(a){return this.throwIfDisposed(),fq(this,a)},dl().prototype.less=function(a){return this.throwIfDisposed(),f1(this,a)};let h8=dM({localResponseNormalization_:function(a,b=5,c=1,d=1,e=.5){let f=dJ(a,"x","localResponseNormalization");I(4===f.rank||3===f.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${f.rank}.`),I(P(b),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${b}.`);let g=f,h=!1;3===f.rank&&(h=!0,g=e4(f,[1,f.shape[0],f.shape[1],f.shape[2]]));let i={x:g},j=dB.runKernel("LRN",i,{depthRadius:b,bias:c,alpha:d,beta:e});return h?e4(j,[j.shape[1],j.shape[2],j.shape[3]]):j}});dl().prototype.localResponseNormalization=function(a,b,c,d){return this.throwIfDisposed(),h8(this,a,b,c,d)};let h9=dM({softplus_:function(a){let b=dJ(a,"x","softplus");return dB.runKernel(cs,{x:b})}}),ia=dM({logSigmoid_:function(a){let b=dJ(a,"x","logSigmoid");return eF(a=>({value:e3(h9(e3(a))),gradFunc:b=>eB(b,gH(e3(a)))}))(b)}});dl().prototype.logSigmoid=function(){return this.throwIfDisposed(),ia(this)};let ib=dM({logSoftmax_:function(a,b=-1){let c=dJ(a,"logits","logSoftmax");if(-1===b&&(b=c.rank-1),b!==c.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${c.rank} and axis was ${b}`);return eF((a,c)=>{let d=hZ(a,b,!0),e=eS(a,d),f=eS(ev(e,"float32"),ga(e5(fR(e),b,!0)));return c([f]),{value:f,gradFunc:(a,c)=>{let[d]=c,e=fR(d);return eS(a,eB(e5(a,b,!0),e))}}})(c)}});dl().prototype.logSoftmax=function(a){return this.throwIfDisposed(),ib(this,a)};let ic=dM({logSumExp_:function(a,b=null,c=!1){let d=dJ(a,"x","logSumExp"),e=W(b,d.shape),f=hZ(d,e,!0),g=ga(e5(fR(eS(d,f)),e)),h=ey(e4(f,g.shape),g);if(c){let a=fG(h.shape,e);return e4(h,a)}return h}});dl().prototype.logSumExp=function(a,b){return this.throwIfDisposed(),ic(this,a,b)},dl().prototype.log=function(){return this.throwIfDisposed(),ga(this)};let id=dM({log1p_:function(a){let b=dJ(a,"x","log1p");return dB.runKernel(bF,{x:b})}});dl().prototype.log1p=function(){return this.throwIfDisposed(),id(this)},dl().prototype.logicalAnd=function(a){return this.throwIfDisposed(),fr(this,a)},dl().prototype.logicalNot=function(){return this.throwIfDisposed(),hs(this)};let ie=dM({logicalOr_:function(a,b){let c=dJ(a,"a","logicalOr","bool"),d=dJ(b,"b","logicalOr","bool");return eX(c.shape,d.shape),dB.runKernel(bI,{a:c,b:d})}});dl().prototype.logicalOr=function(a){return this.throwIfDisposed(),ie(this,a)};let ig=dM({logicalXor_:function(a,b){let c=dJ(a,"a","logicalXor","bool"),d=dJ(b,"b","logicalXor","bool");return eX(c.shape,d.shape),fr(ie(a,b),hs(fr(a,b)))}});dl().prototype.logicalXor=function(a){return this.throwIfDisposed(),ig(this,a)},dl().prototype.matMul=function(a,b,c){return this.throwIfDisposed(),fn(this,a,b,c)};let ih=dM({maxPool_:function(a,b,c,d,e){let f=dJ(a,"x","maxPool"),g=f,h=!1;3===f.rank&&(h=!0,g=e4(f,[1,f.shape[0],f.shape[1],f.shape[2]])),I(4===g.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${g.rank}.`),I(fh(c,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${c} and dilations '1'`),fk("maxPool",d,e);let i={x:g},j=dB.runKernel(bL,i,{filterSize:b,strides:c,pad:d,dimRoundingMode:e});return h?e4(j,[j.shape[1],j.shape[2],j.shape[3]]):j}});dl().prototype.maxPool=function(a,b,c,d){return this.throwIfDisposed(),ih(this,a,b,c,d)},dl().prototype.max=function(a,b){return this.throwIfDisposed(),hZ(this,a,b)},dl().prototype.maximum=function(a){return this.throwIfDisposed(),eY(this,a)};let ii=dM({mean_:function(a,b=null,c=!1){let d=dJ(a,"x","mean");return dB.runKernel(bQ,{x:d},{axis:b,keepDims:c})}});dl().prototype.mean=function(a,b){return this.throwIfDisposed(),ii(this,a,b)},dl().prototype.min=function(a,b){return this.throwIfDisposed(),h$(this,a,b)};let ij=dM({minimum_:function(a,b){let c=dJ(a,"a","minimum"),d=dJ(b,"b","minimum");[c,d]=dt(c,d),"bool"===c.dtype&&(c=ev(c,"int32"),d=ev(d,"int32")),eX(c.shape,d.shape);let e={a:c,b:d};return dB.runKernel(bR,e)}});dl().prototype.minimum=function(a){return this.throwIfDisposed(),ij(this,a)};let ik=dM({mirrorPad_:function(a,b,c){I("reflect"===c||"symmetric"===c,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${c}.`);let d=dJ(a,"x","mirrorPad");if(0===d.rank)throw Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");I(b.length===d.rank,()=>`Padding doesn't match input. Must be ${d.rank}. Got ${b.length}.`);let e=+("reflect"===c);for(let a=0;a<d.rank;a++)I(2===b[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),I(b[a][0]>=0&&b[a][0]<=d.shape[a]-e&&b[a][1]>=0&&b[a][1]<=d.shape[a]-e,()=>`Padding in dimension ${a} cannot be greater than or equal to ${d.shape[a]-e} or less than 0 for input of shape ${d.shape}`);return dB.runKernel(bS,{x:d},{paddings:b,mode:c})}});dl().prototype.mirrorPad=function(a,b){return this.throwIfDisposed(),ik(this,a,b)};let il=dM({mod_:function(a,b){let c=dJ(a,"a","mod"),d=dJ(b,"b","mod");[c,d]=dt(c,d);let e={a:c,b:d};return dB.runKernel("Mod",e)}});dl().prototype.mod=function(a){return this.throwIfDisposed(),il(this,a)},dl().prototype.mul=function(a){return this.throwIfDisposed(),eB(this,a)},dl().prototype.neg=function(){return this.throwIfDisposed(),e3(this)},dl().prototype.norm=function(a,b,c){return this.throwIfDisposed(),h_(this,a,b,c)};let im=dM({notEqual_:function(a,b){let c=dJ(a,"a","notEqual","string_or_numeric"),d=dJ(b,"b","notEqual","string_or_numeric");[c,d]=dt(c,d),eX(c.shape,d.shape);let e={a:c,b:d};return dB.runKernel(bV,e)}});dl().prototype.notEqual=function(a){return this.throwIfDisposed(),im(this,a)};let io=dM({oneHot_:function(a,b,c=1,d=0,e="int32"){if(b<2)throw Error(`Error in oneHot: depth must be >=2, but it is ${b}`);let f=dJ(a,"indices","oneHot","int32");return dB.runKernel(b$,{indices:f},{dtype:e,depth:b,onValue:c,offValue:d})}});dl().prototype.oneHot=function(a,b=1,c=0){return this.throwIfDisposed(),io(this,a,b,c)};let ip=dM({onesLike_:function(a){let b=dJ(a,"x","onesLike");return dB.runKernel(bZ,{x:b})}});dl().prototype.onesLike=function(){return this.throwIfDisposed(),ip(this)},dl().prototype.pad=function(a,b){return this.throwIfDisposed(),hv(this,a,b)};let iq=dM({pool_:function(a,b,c,d,e,f,g){var h,i,j,k,l;let m,n,o,p,q,r,s,t,u;null==e&&(e=[1,1]),null==f&&(f=1),0===d&&(d="valid");let v=dJ(a,"x","maxPool"),w=v,x=!1;3===v.rank&&(x=!0,w=e4(v,[1,v.shape[0],v.shape[1],v.shape[2]])),I(fh(f,e),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${f} and dilations '${e}'`);let y=e7(w.shape,b,f,e,d),z=[y.dilationHeight,y.dilationWidth];m="same"===d?(h=[y.filterHeight,y.filterWidth],i=z,o=(n=h.map((a,b)=>a+(a-1)*(i[b]-1)).map(a=>a-1)).map(a=>Math.floor(a/2)),p=n.map((a,b)=>a-o[b]),n.map((a,b)=>[o[b],p[b]])):[[0,0],[0,0]];let A=1===z[0]&&1===z[1],[B,C]=(j=[y.inHeight,y.inWidth],k=z,q=(l=m).map(a=>a[0]),s=j.concat(q,r=l.map(a=>a[1])),t=k.map((a,b)=>(a-s[b]%a)%a),u=r.map((a,b)=>a+t[b]),[k.map((a,b)=>[q[b],u[b]]),k.map((a,b)=>[0,t[b]])]),D=A?d:"valid",E=A?w:fo(w,z,B),F=("avg"===c?()=>hN(E,b,f,D,g):()=>ih(E,b,f,D,g))(),G=A?F:hw(F,z,C);return x?e4(G,[G.shape[1],G.shape[2],G.shape[3]]):G}});dl().prototype.pool=function(a,b,c,d,e,f){return this.throwIfDisposed(),iq(this,a,b,c,d,e,f)},dl().prototype.pow=function(a){return this.throwIfDisposed(),eR(this,a)},dl().prototype.prelu=function(a){return this.throwIfDisposed(),gE(this,a)};let ir=dM({prod_:function(a,b=null,c=!1){let d=dJ(a,"x","prod");"bool"===d.dtype&&(d=ev(d,"int32"));let e={x:d};return dB.runKernel(b2,e,{axis:b,keepDims:c})}});dl().prototype.prod=function(a,b){return this.throwIfDisposed(),ir(this,a,b)};let is=dM({reciprocal_:function(a){let b=dJ(a,"x","reciprocal");return dB.runKernel(b8,{x:b})}});dl().prototype.reciprocal=function(){return this.throwIfDisposed(),is(this)},dl().prototype.relu=function(){return this.throwIfDisposed(),gF(this)},dl().prototype.relu6=function(){return this.throwIfDisposed(),gG(this)},dl().prototype.reshapeAs=function(a){return this.throwIfDisposed(),e4(this,a.shape)},dl().prototype.reshape=function(a){return this.throwIfDisposed(),e4(this,a)};let it=dM({resizeBilinear_:function(a,b,c=!1,d=!1){let e=dJ(a,"images","resizeBilinear");I(3===e.rank||4===e.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${e.rank}.`),I(2===b.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${b}.`),I(!1===d||!1===c,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let f=e,g=!1;3===e.rank&&(g=!0,f=e4(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let[]=b,h={images:f},i=dB.runKernel(cd,h,{alignCorners:c,halfPixelCenters:d,size:b});return g?e4(i,[i.shape[1],i.shape[2],i.shape[3]]):i}});dl().prototype.resizeBilinear=function(a,b,c){return this.throwIfDisposed(),it(this,a,b,c)};let iu=dM({resizeNearestNeighbor_:function(a,b,c=!1,d=!1){let e=dJ(a,"images","resizeNearestNeighbor");I(3===e.rank||4===e.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${e.rank}.`),I(2===b.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${b}.`),I("float32"===e.dtype||"int32"===e.dtype,()=>"`images` must have `int32` or `float32` as dtype"),I(!1===d||!1===c,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let f=e,g=!1;3===e.rank&&(g=!0,f=e4(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let[]=b,h={images:f},i=dB.runKernel(cb,h,{alignCorners:c,halfPixelCenters:d,size:b});return g?e4(i,[i.shape[1],i.shape[2],i.shape[3]]):i}});dl().prototype.resizeNearestNeighbor=function(a,b,c){return this.throwIfDisposed(),iu(this,a,b,c)},dl().prototype.reverse=function(a){return this.throwIfDisposed(),hr(this,a)};let iv=dM({rfft_:function(a,b){let c;I("float32"===a.dtype,()=>`The dtype for rfft() must be real value but got ${a.dtype}`);let d=a.shape[a.shape.length-1],e=a.size/d;if(null!=b&&b<d){let e=a.shape.map(a=>0),f=a.shape.map(a=>a);f[a.shape.length-1]=b,c=f6(a,e,f),d=b}else if(null!=b&&b>d){let e=a.shape.map(a=>a);e[a.shape.length-1]=b-d,c=hy([a,f4(e)],a.shape.length-1),d=b}else c=a;let f=eE(c),g=h2(e4(dN(c,f),[e,d])),h=Math.floor(d/2)+1,i=fN(g),j=fM(g),k=fv(i,[h,d-h],i.shape.length-1),l=fv(j,[h,d-h],j.shape.length-1),m=c.shape.slice();return m[c.shape.length-1]=h,e4(dN(k[0],l[0]),m)}});dl().prototype.rfft=function(){return this.throwIfDisposed(),iv(this)};let iw=dM({round_:function(a){let b=dJ(a,"x","round");return dB.runKernel(ch,{x:b})}});dl().prototype.round=function(){return this.throwIfDisposed(),iw(this)},dl().prototype.rsqrt=function(){return this.throwIfDisposed(),fS(this)};let ix=dM({selu_:function(a){let b=dJ(a,"x","selu");return dB.runKernel(cn,{x:b})}});dl().prototype.selu=function(){return this.throwIfDisposed(),ix(this)};let iy=dM({separableConv2d_:function(a,b,c,d,e,f=[1,1],g="NHWC"){let h=dJ(a,"x","separableConv2d"),i=dJ(b,"depthwiseFilter","separableConv2d"),j=dJ(c,"pointwiseFilter","separableConv2d"),k=h,l=!1;if(3===h.rank&&(l=!0,k=e4(h,[1,h.shape[0],h.shape[1],h.shape[2]])),"NCHW"===g)throw Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");I(4===k.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${k.rank}.`),I(4===i.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${i.rank}.`),I(4===j.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${i.rank}.`),I(1===j.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${j.shape[0]}.`),I(1===j.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${j.shape[1]}.`);let m=i.shape[2],n=i.shape[3];I(j.shape[2]===m*n,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*n}, but got ${j.shape[2]}.`);let o=fy(hU(k,i,d,e,g,f),j,1,"valid",g);return l?e4(o,[o.shape[1],o.shape[2],o.shape[3]]):o}});dl().prototype.separableConv2d=function(a,b,c,d,e,f){return this.throwIfDisposed(),iy(this,a,b,c,d,e,f)},dl().prototype.sigmoid=function(){return this.throwIfDisposed(),gH(this)};let iz=dM({sign_:function(a){let b=dJ(a,"x","sign");return dB.runKernel(cq,{x:b})}});dl().prototype.sign=function(){return this.throwIfDisposed(),iz(this)},dl().prototype.sin=function(){return this.throwIfDisposed(),fB(this)},dl().prototype.sinh=function(){return this.throwIfDisposed(),fC(this)},dl().prototype.slice=function(a,b){return this.throwIfDisposed(),f6(this,a,b)};let iA=dM({softmax_:function(a,b=-1){let c=dJ(a,"logits","softmax","float32");if(-1===b&&(b=c.rank-1),b!==c.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${c.rank} and dim was ${b}`);let d={dim:b};return dB.runKernel(cw,{logits:c},d)}});dl().prototype.softmax=function(a){return this.throwIfDisposed(),iA(this,a)},dl().prototype.softplus=function(){return this.throwIfDisposed(),h9(this)},dl().prototype.spaceToBatchND=function(a,b){return this.throwIfDisposed(),fo(this,a,b)},dl().prototype.split=function(a,b){return this.throwIfDisposed(),fv(this,a,b)},dl().prototype.sqrt=function(){return this.throwIfDisposed(),eC(this)},dl().prototype.square=function(){return this.throwIfDisposed(),eD(this)};let iB=dM({squaredDifference_:function(a,b){let c=dJ(a,"a","squaredDifference"),d=dJ(b,"b","squaredDifference");[c,d]=dt(c,d),eX(c.shape,d.shape);let e={a:c,b:d};return dB.runKernel(cC,e,{})}});dl().prototype.squaredDifference=function(a){return this.throwIfDisposed(),iB(this,a)};let iC=dM({squeeze_:function(a,b){let c=dJ(a,"x","squeeze","string_or_numeric");return e4(c,X(c.shape,b).newShape)}});dl().prototype.squeeze=function(a){return this.throwIfDisposed(),iC(this,a)},dl().prototype.stack=function(a,b){return this.throwIfDisposed(),fU(a instanceof dk?[this,a]:[this,...a],b)},dl().prototype.step=function(a){return this.throwIfDisposed(),e1(this,a)};let iD=dM({stridedSlice_:function(a,b,c,d,e=0,f=0,g=0,h=0,i=0){let j=dJ(a,"x","stridedSlice","string_or_numeric");return dB.runKernel(cF,{x:j},{begin:b,end:c,strides:d,beginMask:e,endMask:f,ellipsisMask:g,newAxisMask:h,shrinkAxisMask:i})}});dl().prototype.stridedSlice=function(a,b,c,d,e,f,g,h){return this.throwIfDisposed(),iD(this,a,b,c,d,e,f,g,h)},dl().prototype.sub=function(a){return this.throwIfDisposed(),eS(this,a)},dl().prototype.sum=function(a,b){return this.throwIfDisposed(),e5(this,a,b)};let iE=dM({tan_:function(a){let b=dJ(a,"x","tan","float32");return dB.runKernel("Tan",{x:b})}});dl().prototype.tan=function(){return this.throwIfDisposed(),iE(this)};let iF=dM({tanh_:function(a){let b=dJ(a,"x","tanh","float32");return dB.runKernel(cJ,{x:b})}});dl().prototype.tanh=function(){return this.throwIfDisposed(),iF(this)},dl().prototype.tile=function(a){return this.throwIfDisposed(),fT(this,a)},dl().prototype.toBool=function(){return this.throwIfDisposed(),ev(this,"bool")},dl().prototype.toFloat=function(){return this.throwIfDisposed(),ev(this,"float32")},dl().prototype.toInt=function(){return this.throwIfDisposed(),ev(this,"int32")};let iG=dM({topk_:function(a,b=1,c=!0){let d=dJ(a,"x","topk");if(0===d.rank)throw Error("topk() expects the input to be of rank 1 or higher");let e=d.shape[d.shape.length-1];if(b<0)throw Error(`'k' passed to topk() must be >= 0 but got ${b}`);if(b>e)throw Error(`'k' passed to topk() must be <= the last dimension (${e}) but got ${b}`);let[f,g]=dB.runKernel(cL,{x:d},{k:b,sorted:c});return{values:f,indices:g}}});dl().prototype.topk=function(a,b){return this.throwIfDisposed(),iG(this,a,b)},dl().prototype.transpose=function(a){return this.throwIfDisposed(),fO(this,a)};let iH=dM({unique_:function(a,b=0){let c=dJ(a,"x","unique","string_or_numeric");I(c.rank>0,()=>"The input tensor must be at least 1D");let[d,e]=dB.runKernel(cO,{x:c},{axis:b});return{values:d,indices:e}}});dl().prototype.unique=function(a){return this.throwIfDisposed(),iH(this,a)},dl().prototype.unsortedSegmentSum=function(a,b){return this.throwIfDisposed(),fV(this,a,b)},dl().prototype.unstack=function(a){return this.throwIfDisposed(),f8(this,a)},dl().prototype.where=function(a,b){return this.throwIfDisposed(),ft(a,this,b)},dl().prototype.zerosLike=function(){return this.throwIfDisposed(),eE(this)},a.i(317594),a.i(134750);var iI=a.i(486301);let iJ=iI.default||iI;function iK(a){return iJ.fromString(a,!0,16)}let iL=iK("c3a5c85c97cb3127"),iM=iK("b492b66fbe98f273"),iN=iK("9ae16a3b2f90404f");function iO(a){return a.xor(a.shru(47))}function iP(a,b,c){let d=a.slice(b,b+c);return iJ.fromBytes(Array.from(d),!0,!0)}function iQ(a,b){return iP(a,b,8)}function iR(a,b){return 0===b?a:a.shru(b).or(a.shl(64-b))}function iS(a,b,c=iK("9ddfea08eb382d69")){let d=a.xor(b).mul(c);d=d.xor(d.shru(47));let e=b.xor(d).mul(c);return(e=e.xor(e.shru(47))).mul(c)}function iT(a,b,c,d){var e,f,g,h,i,j;let k;return e=iQ(a,b),f=iQ(a,b+8),g=iQ(a,b+16),h=iQ(a,b+24),i=c,j=d,i=i.add(e),j=iR(j.add(i).add(h),21),k=i,i=(i=i.add(f)).add(g),j=j.add(iR(i,44)),[i.add(h),j.add(k)]}function iU(a,b=a.length){let c=iJ.fromNumber(81,!0);if(b<=32)if(b<=16)return function(a,b=a.length){if(b>=8){let c=iN.add(2*b),d=iQ(a,0).add(iN),e=iQ(a,b-8);return iS(iR(e,37).mul(c).add(d),iR(d,25).add(e).mul(c),c)}if(b>=4){let c=iN.add(2*b);return iS(iP(a,0,4).shl(3).add(b),iP(a,b-4,4),c)}if(b>0){let c=a[0],d=a[b>>1],e=a[b-1];return iO(iN.mul(c+(d<<8)).xor(iL.mul(b+(e<<2)))).mul(iN)}return iN}(a,b);else return function(a,b=a.length){let c=iN.add(2*b),d=iQ(a,0).mul(iM),e=iQ(a,8),f=iQ(a,b-8).mul(c),g=iQ(a,b-16).mul(iN);return iS(iR(d.add(e),43).add(iR(f,30)).add(g),d.add(iR(e.add(iN),18)).add(f),c)}(a,b);if(b<=64)return function(a,b=a.length){let c=iN.add(2*b),d=iQ(a,0).mul(iN),e=iQ(a,8),f=iQ(a,b-8).mul(c),g=iQ(a,b-16).mul(iN),h=iR(d.add(e),43).add(iR(f,30)).add(g),i=iS(h,d.add(iR(e.add(iN),18)).add(f),c),j=iQ(a,16).mul(c),k=iQ(a,24),l=h.add(iQ(a,b-32)).mul(c),m=i.add(iQ(a,b-24)).mul(c);return iS(iR(j.add(k),43).add(iR(l,30)).add(m),j.add(iR(k.add(d),18)).add(l),c)}(a,b);let d=c,e=c.mul(iM).add(113),f=iO(e.mul(iN).add(113)).mul(iN),g=[iJ.UZERO,iJ.UZERO],h=[iJ.UZERO,iJ.UZERO];d=d.mul(iN).add(iQ(a,0));let i=0,j=(b-1>>6)*64,k=j+(b-1&63)-63;do d=iR(d.add(e).add(g[0]).add(iQ(a,i+8)),37).mul(iM),e=iR(e.add(g[1]).add(iQ(a,i+48)),42).mul(iM),d=d.xor(h[1]),e=e.add(g[0]).add(iQ(a,i+40)),f=iR(f.add(h[0]),33).mul(iM),g=iT(a,i,g[1].mul(iM),d.add(h[0])),h=iT(a,i+32,f.add(h[1]),e.add(iQ(a,i+16))),[f,d]=[d,f],i+=64;while(i!==j)let l=iM.add(f.and(255).shl(1));return i=k,h[0]=h[0].add(b-1&63),g[0]=g[0].add(h[0]),h[0]=h[0].add(g[0]),d=iR(d.add(e).add(g[0]).add(iQ(a,i+8)),37).mul(l),e=iR(e.add(g[1]).add(iQ(a,i+48)),42).mul(l),d=d.xor(h[1].mul(9)),e=e.add(g[0].mul(9).add(iQ(a,i+40))),f=iR(f.add(h[0]),33).mul(l),g=iT(a,i,g[1].mul(l),d.add(h[0])),h=iT(a,i+32,f.add(h[1]),e.add(iQ(a,i+16))),[f,d]=[d,f],iS(iS(g[0],h[0],l).add(iO(e).mul(iL)).add(f),iS(g[1],h[1],l).add(d),l)}a.s(["fingerPrint64",()=>iU,"hexToLong",()=>iK],226100),a.i(226100),a.s(["arraysEqual",()=>O,"arraysEqualWithNull",()=>N,"assert",()=>I,"assertNonNegativeIntegerDimensions",()=>ap,"assertNonNull",()=>K,"assertShapesMatch",()=>J,"bytesFromStringArray",()=>ac,"bytesPerElement",()=>ab,"checkConversionForErrors",()=>$,"clamp",()=>C,"computeStrides",()=>aj,"convertBackendValuesAndArrayBuffer",()=>al,"createScalarValue",()=>c4,"createShuffledIndices",()=>S,"decodeString",()=>c9,"distSquared",()=>H,"encodeString",()=>c8,"fetch",()=>c7,"fingerPrint64",()=>iU,"flatten",()=>db,"getArrayFromDType",()=>Z,"getTypedArrayFromDType",()=>Y,"hasEncodingLoss",()=>aa,"hexToLong",()=>iK,"indexToLoc",()=>ar,"inferDtype",()=>ag,"inferFromImplicitShape",()=>V,"isBoolean",()=>ae,"isFunction",()=>ah,"isInt",()=>P,"isNumber",()=>af,"isPromise",()=>as,"isScalarShape",()=>M,"isString",()=>ad,"isTypedArray",()=>da,"isValidDtype",()=>_,"locToIndex",()=>aq,"makeOnesTypedArray",()=>am,"makeZerosNestedTypedArray",()=>ao,"makeZerosTypedArray",()=>an,"nearestDivisor",()=>ai,"nearestLargerEven",()=>D,"now",()=>c6,"parseAxisParam",()=>W,"randUniform",()=>G,"repeatedTry",()=>U,"rightPad",()=>T,"shuffle",()=>A,"shuffleCombo",()=>B,"sizeFromShape",()=>L,"sizeToSquarishShape",()=>R,"squeezeShape",()=>X,"sum",()=>F,"swap",()=>E,"tanh",()=>Q,"toNestedArray",()=>ak,"toTypedArray",()=>c5],170866);var iV=a.i(170866),iV=iV;class iW extends Error{constructor(a){super(a),Object.setPrototypeOf(this,iW.prototype)}}class iX extends Error{constructor(a){super(a),Object.setPrototypeOf(this,iX.prototype)}}class iY extends Error{constructor(a){super(a),Object.setPrototypeOf(this,iY.prototype)}}class iZ extends Error{constructor(a){super(a),Object.setPrototypeOf(this,iZ.prototype)}}class i$ extends Error{constructor(a){super(a),Object.setPrototypeOf(this,i$.prototype)}}class i_{constructor(a){this.maxEntries=a||100,this.cache=new Map}get(a){let b;return this.cache.has(a)&&(b=this.cache.get(a),this.cache.delete(a),this.cache.set(a,b)),b}put(a,b){if(this.cache.has(a))this.cache.delete(a);else if(this.cache.size>=this.maxEntries){let a=this.cache.keys().next().value;this.cache.delete(a)}this.cache.set(a,b)}getMaxEntries(){return this.maxEntries}setMaxEntries(a){if(a<0)throw Error(`The maxEntries of LRU caches must be at least 0, but got ${a}.`);if(this.maxEntries>a)for(let b=0;b<this.maxEntries-a;b++){let a=this.cache.keys().next().value;this.cache.delete(a)}this.maxEntries=a}}var iV=iV;function i0(a,b){if(Array.isArray(a)){let c=[];for(let d=0;d<b;d++)c=c.concat(a);return c}{let c=Array(b);return c.fill(a),c}}function i1(a,b){if(!a)throw new i$(b)}function i2(a,b){let c=0;for(let d of a)d===b&&c++;return c}function i3(a){return 1===a.length?a[0]:a}function i4(a){return Array.isArray(a)?a:[a]}function i5(a){let b=a.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==b[0]?b:"private"+b}function i6(a){return a.length<=1||-1===a.indexOf("_")?a:a.replace(/[_]+(\w|$)/g,(a,b)=>b.toUpperCase())}let i7={};function i8(a){if(null==a)return null;let b={};return b.className=a.getClassName(),b.config=a.getConfig(),b}function i9(a,b={},c={},d="object",e=!1){if("string"==typeof a){let e;if(a in c)e=c[a];else if(a in i7)e=i7[a];else if(null==(e=b[a]))throw new iY(`Unknown ${d}: ${a}. This may be due to one of the following reasons:
1. The ${d} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${d} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return e}{let f,g;if(null==a.className||null==a.config)throw new iY(`${d}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);let h=a.className;if(h in c?[f,g]=c[h]:h in i7?[f,g]=i7.className:h in b&&([f,g]=b[h]),null==f)throw new iY(`Unknown ${d}: ${h}. This may be due to one of the following reasons:
1. The ${d} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${d} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=g){let b={};for(let a of Object.keys(i7))b[a]=i7[a];for(let a of Object.keys(c))b[a]=c[a];a.config.customObjects=b;let d=Object.assign({},i7);for(let a of Object.keys(c))i7[a]=c[a];!function a(b){if(null!=b&&"object"==typeof b)if(Array.isArray(b))b.forEach(b=>a(b));else for(let c of Object.keys(b)){let d=b[c];null!=d&&"object"==typeof d&&(Array.isArray(d)||"ndarray"!==d.type||"number"!=typeof d.value?a(d):b[c]=d.value)}}(a.config);let h=g(f,a.config,c,e);return i7=Object.assign({},d),h}{let b=Object.assign({},i7);for(let a of Object.keys(c))i7[a]=c[a];let d=new f(a.config);return i7=Object.assign({},b),d}}}function ja(a,b){return -1*(a<b?-1:+(a>b))}function jb(a){if(null==a)return a;let b=[];for(let c of a)-1===b.indexOf(c)&&b.push(c);return b}function jc(a,b,c){if(null!=c&&0>a.indexOf(c))throw new iY(`${c} is not a valid ${b}.  Valid values are ${a} or null/undefined.`)}function jd(a,b,c=0,d=1/0){return i1(c>=0),i1(d>=c),Array.isArray(a)&&a.length>=c&&a.length<=d&&a.every(a=>typeof a===b)}function je(a,b){Array.isArray(a)?(iV.assert(a.length>0,()=>`${b} is unexpectedly an empty array.`),a.forEach((a,c)=>je(a,`element ${c+1} of ${b}`))):iV.assert(Number.isInteger(a)&&a>0,()=>`Expected ${b} to be a positive integer, but got ${function a(b){return null===b?"null":Array.isArray(b)?"["+b.map(b=>a(b)).join(",")+"]":"string"==typeof b?`"${b}"`:`${b}`}(a)}.`)}function jf(a){return"relu"===a?"relu":"linear"===a?"linear":"elu"===a?"elu":null}var jg=a.i(953321),jg=jg;let jh=0,ji={};function jj(a=""){return a in ji||(ji[a]=0),ji[a]+=1,a+ji[a].toString()}var jg=jg,iV=iV;let jk=["channelsFirst","channelsLast"],jl=["nearest","bilinear"],jm=["valid","same","causal"],jn=["max","avg"],jo=["sum","mul","concat","ave"],jp=new Map;function jq(a){jc(jk,"DataFormat",a)}function jr(a){jc(jm,"PaddingMode",a)}function js(a){jc(jn,"PoolMode",a)}let jt=[];function ju(a,b){jt.push(a);try{let a=b();return jt.pop(),a}catch(a){throw jt.pop(),a}}function jv(a){if(!jy(a))throw Error("Not a valid tensor name: '"+a+"'");return(0===jt.length?"":jt.join("/")+"/")+a}function jw(a){if(!jy(a))throw Error("Not a valid tensor name: '"+a+"'");jp.has(a)||jp.set(a,0);let b=jp.get(a);if(jp.set(a,jp.get(a)+1),!(b>0))return a;{let c=`${a}_${b}`;return jp.set(c,1),c}}let jx=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function jy(a){return!!a.match(jx)}let jz=dM({eye_:function(a,b,c,d="float32"){null==b&&(b=a);let e=eu([a,b],d),f=a<=b?a:b;for(let a=0;a<f;++a)e.set(1,a,a);let g=e4(e.toTensor(),[a,b]);if(null==c)return g;if(1===c.length)return fT(hA(g,0),[c[0],1,1]);if(2===c.length)return fT(hA(hA(g,0),0),[c[0],c[1],1,1]);if(3===c.length)return fT(hA(hA(hA(g,0),0),0),[c[0],c[1],c[2],1,1]);throw Error(`eye() currently supports only 1D and 2D batchShapes, but received ${c.length}D.`)}}),jA=dM({fusedConv2d_:function({x:a,filter:b,strides:c,pad:d,dataFormat:e="NHWC",dilations:f=[1,1],dimRoundingMode:g,bias:h,activation:i="linear",preluActivationWeights:j,leakyreluAlpha:k}){let l,m;if(i=i||"linear",!1===gL(dB.state.gradientDepth,i)){I("NHWC"===e,()=>`Error in fused conv2d: got dataFormat of ${e} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let l=fy(a,b,c,d,e,f,g);return null!=h&&(l=ey(l,h)),gK(l,i,j,k)}let n=dJ(a,"x","conv2d","float32"),o=dJ(b,"filter","conv2d","float32"),p=n,q=!1;3===n.rank&&(q=!0,p=e4(n,[1,n.shape[0],n.shape[1],n.shape[2]])),I(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),I(4===o.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${o.rank}.`),fk("fused conv2d",d,g);let r="NHWC"===e?p.shape[3]:p.shape[1];I(o.shape[2]===r,()=>`Error in conv2d: depth of input (${r}) must match input depth for filter ${o.shape[2]}.`),I(fh(c,f),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${c} and dilations '${f}'`);let s=e9(p.shape,o.shape,c,f,d,g);if(null!=h&&(l=dJ(h,"bias","fused conv2d"),[l]=dt(l,n),"NHWC"===e?eX(s.outShape,l.shape):(I(l.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${l.shape.length}.`),I(0===l.shape.length||l.shape[0]===s.outChannels||1===l.shape[0],()=>`Error in fused conv2d: bias shape (${l.shape}) is not compatible with the number of output channels (${s.outChannels})`))),null!=j){let a=j.shape;if(I(a.length<=1||3===a.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${a.length}.`),1===a.length)I(1===a[0]||a[0]===s.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${a}) is not compatible with the number of output channels (${s.outChannels}).`);else if(3===a.length)try{eX(a,s.outShape)}catch(b){throw Error(`Error in fused conv2d: PReLU activation weights (${a}) is not compatible with the output shape of the conv2d (${s.outShape}).`)}m=dJ(j,"prelu weights","fused conv2d")}let t=(a,b)=>{I("NHWC"===e,()=>`Error in gradient of fused conv2D: got dataFormat of ${e} but only NHWC is currently supported.`);let[g,h,j,k]=b,l=gI(a,j,i);I(fg(f),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${f}'`);let m=[fx(h.shape,l,g,c,d),fw(h,l,g.shape,c,d)];if(null!=k){let a=gJ(k,l);m.push(a)}return m},u={x:p,filter:o,bias:l,preluActivationWeights:m},v={strides:c,pad:d,dataFormat:e,dilations:f,dimRoundingMode:g,activation:i,leakyreluAlpha:k};return null==h?eF((a,b,c)=>{let d=dB.runKernel(cW,u,v);return c([b,a,d]),q&&(d=e4(d,[d.shape[1],d.shape[2],d.shape[3]])),{value:d,gradFunc:t}})(p,o):eF((a,b,c,d)=>{let e=dB.runKernel(cW,u,v);return d([b,a,e,c]),q&&(e=e4(e,[e.shape[1],e.shape[2],e.shape[3]])),{value:e,gradFunc:t}})(p,o,l)}}),jB=dM({fusedDepthwiseConv2d_:function({x:a,filter:b,strides:c,pad:d,dataFormat:e="NHWC",dilations:f=[1,1],dimRoundingMode:g,bias:h,activation:i="linear",preluActivationWeights:j,leakyreluAlpha:k}){let l,m;if(!1===gL(dB.state.gradientDepth,i)){let l=hU(a,b,c,d,e,f,g);return null!=h&&(l=ey(l,h)),gK(l,i,j,k)}let n=dJ(a,"x","depthwiseConv2d","float32"),o=dJ(b,"filter","depthwiseConv2d","float32"),p=n,q=!1;3===n.rank&&(q=!0,p=e4(n,[1,n.shape[0],n.shape[1],n.shape[2]])),I(4===p.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),I(4===o.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${o.rank}.`),I(p.shape[3]===o.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${o.shape[2]}.`),null==f&&(f=[1,1]),I(fh(c,f),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${f}'`),fk("fused depthwiseConv2d",d,g);let r=e9(p.shape,o.shape,c,f,d,g,!0);null!=h&&(l=dJ(h,"bias","fused conv2d"),[l]=dt(l,n),eX(r.outShape,l.shape)),null!=j&&(m=dJ(j,"prelu weights","fused depthwiseConv2d"));let s=(a,b)=>{I(fg(f),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${f}'`);let[e,h,j,k]=b,m=gI(a,j,i),n=fQ(h.shape,m,e,c,d,f,g),o=fP(h,m,e.shape,c,d,f,g);return null!=k?[n,o,gJ(l,m)]:[n,o]},t={x:p,filter:o,bias:l,preluActivationWeights:m},u={strides:c,pad:d,dataFormat:e,dilations:f,dimRoundingMode:g,activation:i,leakyreluAlpha:k};return null==h?eF((a,b,c)=>{let d=dB.runKernel(cX,t,u);return c([b,a,d]),q&&(d=e4(d,[d.shape[1],d.shape[2],d.shape[3]])),{value:d,gradFunc:s}})(p,o):eF((a,b,c,d)=>{let e=dB.runKernel(cX,t,u);return d([b,a,e,c]),q&&(e=e4(e,[e.shape[1],e.shape[2],e.shape[3]])),{value:e,gradFunc:s}})(p,o,l)}}),jC=dM({fusedMatMul_:function({a,b,transposeA:c=!1,transposeB:d=!1,bias:e,activation:f="linear",preluActivationWeights:g,leakyreluAlpha:h=.2}){let i,j;if(!1===gL(dB.state.gradientDepth,f)){let i=fn(a,b,c,d);return null!=e&&(i=ey(i,e)),gK(i,f,g,h)}let k=dJ(a,"a","fused matMul"),l=dJ(b,"b","fused matMul");[k,l]=dt(k,l);let m=c?k.shape[k.rank-2]:k.shape[k.rank-1],n=d?l.shape[l.rank-1]:l.shape[l.rank-2],o=c?k.shape[k.rank-1]:k.shape[k.rank-2],p=d?l.shape[l.rank-2]:l.shape[l.rank-1],q=k.shape.slice(0,-2),r=l.shape.slice(0,-2),s=L(q),t=L(r);I(m===n,()=>`Error in fused matMul: inner shapes (${m}) and (${n}) of Tensors with shapes ${k.shape} and ${l.shape} and transposeA=${c} and transposeB=${d} must match.`);let u=eX(k.shape.slice(0,-2),l.shape.slice(0,-2)).concat([o,p]),v=c?e4(k,[s,m,o]):e4(k,[s,o,m]),w=d?e4(l,[t,p,n]):e4(l,[t,n,p]);null!=e&&(i=dJ(e,"bias","fused matMul"),[i]=dt(i,k),eX(u,i.shape)),null!=g&&(j=dJ(g,"prelu weights","fused matMul"));let x=(a,b)=>{let g,h,[i,j,k,l]=b,m=gI(e4(a,k.shape),k,f);return(c||d?!c&&d?(g=fn(m,j,!1,!1),h=fn(m,i,!0,!1)):c&&!d?(g=fn(j,m,!1,!0),h=fn(i,m,!1,!1)):(g=fn(j,m,!0,!0),h=fn(m,i,!0,!0)):(g=fn(m,j,!1,!0),h=fn(i,m,!0,!1)),null!=e)?[g,h,gJ(l,m)]:[g,h]},y={a:v,b:w,bias:i,preluActivationWeights:j},z={transposeA:c,transposeB:d,activation:f,leakyreluAlpha:h};return null==e?eF((a,b,c)=>{let d=dB.runKernel(cV,y,z);return c([a,b,d]),{value:e4(d,u),gradFunc:x}})(v,w):eF((a,b,c,d)=>{let e=dB.runKernel(cV,y,z);return d([a,b,e,c]),{value:e4(e,u),gradFunc:x}})(v,w,i)}});a.s([],170306),a.i(170306),a.s(["conv2d",0,jA,"depthwiseConv2d",0,jB,"matMul",0,jC],744098);var jD=a.i(744098);function jE(a,b){K(a);let c=dH(a,b);if(1!==c.length)throw Error("tensor1d() requires values to be a flat/TypedArray");return dO(a,null,c,b)}function jF(a){return Math.floor(Math.pow(2,Math.ceil(Math.log(a)/Math.log(2))))}function jG(a,b,c){let d=1-a%2,e=new Float32Array(a);for(let f=0;f<a;++f){let g=2*Math.PI*f/(a+d-1);e[f]=b-c*Math.cos(g)}return jE(e,"float32")}a.s(["cosineWindow",()=>jG,"enclosingPowerOfTwo",()=>jF],265432);let jH=dM({hammingWindow_:function(a){return jG(a,.54,.46)}}),jI=dM({hannWindow_:function(a){return jG(a,.5,.5)}});function jJ(a,b,c){if(K(a),null!=b&&2!==b.length)throw Error("tensor2d() requires shape to have two numbers");let d=dH(a,c);if(2!==d.length&&1!==d.length)throw Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===d.length&&null==b)throw Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return dO(a,b,d,c)}let jK=dM({frame_:function(a,b,c,d=!1,e=0){let f=0,g=[];for(;f+b<=a.size;)g.push(f6(a,f,b)),f+=c;if(d)for(;f<a.size;){let d=f+b-a.size,h=hy([f6(a,f,b-d),eP([d],e)]);g.push(h),f+=c}return 0===g.length?jJ([],[0,b]):e4(hy(g),[g.length,b])}}),jL=dM({stft_:function(a,b,c,d,e=jI){return null==d&&(d=jF(b)),iv(eB(jK(a,b,c),e(b)),d)}}),jM=dM({cropAndResize_:function(a,b,c,d,e="bilinear",f=0){let g=dJ(a,"image","cropAndResize"),h=dJ(b,"boxes","cropAndResize","float32"),i=dJ(c,"boxInd","cropAndResize","int32"),j=h.shape[0];return I(4===g.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${g.rank}.`),I(2===h.rank&&4===h.shape[1],()=>`Error in cropAndResize: boxes must be have size [${j},4] but had shape ${h.shape}.`),I(1===i.rank&&i.shape[0]===j,()=>`Error in cropAndResize: boxInd must be have size [${j}] but had shape ${h.shape}.`),I(2===d.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${d.length}.`),I(d[0]>=1&&d[1]>=1,()=>`cropSize must be atleast [1,1], but was ${d}`),I("bilinear"===e||"nearest"===e,()=>`method must be bilinear or nearest, but was ${e}`),dB.runKernel(a5,{image:g,boxes:h,boxInd:i},{method:e,extrapolationValue:f,cropSize:d})}}),jN=dM({flipLeftRight_:function(a){let b=dJ(a,"image","flipLeftRight","float32");return I(4===b.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${b.rank}.`),dB.runKernel(bn,{image:b},{})}}),jO=dM({grayscaleToRGB_:function(a){let b=dJ(a,"image","grayscaleToRGB"),c=b.rank-1,d=b.shape[c];I(b.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${b.rank}.`),I(1===d,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${d}.`);let e=Array(b.rank);return e.fill(1,0,c),e[c]=3,fT(b,e)}}),jP=dM({einsum_:function(a,...b){let c=b.map((a,b)=>dJ(a,`tensors${b}`,"einsum"));return dB.runKernel(bh,c,{equation:a})}}),jQ=dM({rgbToGrayscale_:function(a){let b,c=dJ(a,"image","RGBToGrayscale"),d=c.rank-1,e=c.shape[d];I(c.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${c.rank}.`),I(3===e,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${e}.`);let f=c.dtype,g=ev(c,"float32"),h=jE([.2989,.587,.114]);switch(c.rank){case 2:b=jP("ij,j->i",g,h);break;case 3:b=jP("ijk,k->ij",g,h);break;case 4:b=jP("ijkl,l->ijk",g,h);break;case 5:b=jP("ijklm,m->ijkl",g,h);break;case 6:b=jP("ijklmn,n->ijklm",g,h);break;default:throw Error("Not a valid tensor rank.")}return ev(b=hA(b,-1),f)}}),jR=dM({rotateWithOffset_:function(a,b,c=0,d=.5){let e=dJ(a,"image","rotateWithOffset","float32");return I(4===e.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${e.rank}.`),dB.runKernel(cU,{image:e},{radians:b,fillValue:c,center:d})}});function jS(a,b,c,d,e,f){null==d&&(d=.5),null==e&&(e=-1/0),null==f&&(f=0);let g=a.shape[0];return c=Math.min(c,g),I(0<=d&&d<=1,()=>`iouThreshold must be in [0, 1], but was '${d}'`),I(2===a.rank,()=>`boxes must be a 2D tensor, but was of rank '${a.rank}'`),I(4===a.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${a.shape[1]}`),I(1===b.rank,()=>"scores must be a 1D tensor"),I(b.shape[0]===g,()=>`scores has incompatible shape with boxes. Expected ${g}, but was ${b.shape[0]}`),I(0<=f&&f<=1,()=>`softNmsSigma must be in [0, 1], but was '${f}'`),{maxOutputSize:c,iouThreshold:d,scoreThreshold:e,softNmsSigma:f}}let jT=dM({nonMaxSuppression_:function(a,b,c,d=.5,e=-1/0){let f=dJ(a,"boxes","nonMaxSuppression","float32"),g=dJ(b,"scores","nonMaxSuppression","float32"),h=jS(f,g,c,d,e);c=h.maxOutputSize;let i={maxOutputSize:c,iouThreshold:d=h.iouThreshold,scoreThreshold:e=h.scoreThreshold};return dB.runKernel(bW,{boxes:f,scores:g},i)}});function jU(a,b){return a>b?1:a<b?-1:0}function jV(a,b,c,d,e){return jY(a,b,c,d,e,0)}function jW(a,b,c,d,e,f){return jY(a,b,c,d,e,0,!1,f,!0)}function jX(a,b,c,d,e,f){return jY(a,b,c,d,e,f,!0)}function jY(a,b,c,d,e,f,g=!1,h=!1,i=!1){let j=[];for(let a=0;a<b.length;a++)b[a]>e&&j.push({score:b[a],boxIndex:a,suppressBeginIndex:0});j.sort(jZ);let k=f>0?-.5/f:0,l=[],m=[];for(;l.length<c&&j.length>0;){let b=j.pop(),{score:c,boxIndex:f,suppressBeginIndex:g}=b;if(c<e)break;let h=!1;for(let c=l.length-1;c>=g;--c){let g=function(a,b,c){let d=a.subarray(4*b,4*b+4),e=a.subarray(4*c,4*c+4),f=Math.min(d[0],d[2]),g=Math.min(d[1],d[3]),h=Math.max(d[0],d[2]),i=Math.max(d[1],d[3]),j=Math.min(e[0],e[2]),k=Math.min(e[1],e[3]),l=Math.max(e[0],e[2]),m=Math.max(e[1],e[3]),n=(h-f)*(i-g),o=(l-j)*(m-k);if(n<=0||o<=0)return 0;let p=Math.max(Math.min(h,l)-Math.max(f,j),0)*Math.max(Math.min(i,m)-Math.max(g,k),0);return p/(n+o-p)}(a,f,l[c]);if(g>=d){h=!0;break}if(b.score=b.score*function(a,b,c){let d=Math.exp(b*c*c);return c<=a?d:0}(d,k,g),b.score<=e)break}b.suppressBeginIndex=l.length,!h&&(b.score===c?(l.push(f),m.push(b.score)):b.score>e&&function(a,b,c){let d=function(a,b,c){let d=0,e=a.length,f=0,g=!1;for(;d<e;){let h=c(b,a[f=d+(e-d>>>1)]);h>0?d=f+1:(e=f,g=!h)}return g?d:-d-1}(a,b,c||jU);a.splice(d<0?-(d+1):d,0,b)}(j,b,jZ))}let n=l.length,o=c-n;h&&o>0&&(l.push(...Array(o).fill(0)),m.push(...Array(o).fill(0)));let p={selectedIndices:l};return g&&(p.selectedScores=m),i&&(p.validOutputs=n),p}function jZ(a,b){return a.score-b.score||a.score===b.score&&b.boxIndex-a.boxIndex}async function j$(a,b,c,d=.5,e=-1/0){let f=dJ(a,"boxes","nonMaxSuppressionAsync"),g=dJ(b,"scores","nonMaxSuppressionAsync"),h=jS(f,g,c,d,e);c=h.maxOutputSize,d=h.iouThreshold,e=h.scoreThreshold;let i=await Promise.all([f.data(),g.data()]),{selectedIndices:j}=jV(i[0],i[1],c,d,e);return f!==a&&f.dispose(),g!==b&&g.dispose(),jE(j,"int32")}let j_=dM({nonMaxSuppressionWithScore_:function(a,b,c,d=.5,e=-1/0,f=0){let g=dJ(a,"boxes","nonMaxSuppression"),h=dJ(b,"scores","nonMaxSuppression"),i=jS(g,h,c,d,e,f);c=i.maxOutputSize,d=i.iouThreshold,e=i.scoreThreshold;let j={maxOutputSize:c,iouThreshold:d,scoreThreshold:e,softNmsSigma:f=i.softNmsSigma},k=dB.runKernel(bY,{boxes:g,scores:h},j);return{selectedIndices:k[0],selectedScores:k[1]}}});async function j0(a,b,c,d=.5,e=-1/0,f=0){let g=dJ(a,"boxes","nonMaxSuppressionAsync"),h=dJ(b,"scores","nonMaxSuppressionAsync"),i=jS(g,h,c,d,e,f);c=i.maxOutputSize,d=i.iouThreshold,e=i.scoreThreshold,f=i.softNmsSigma;let j=await Promise.all([g.data(),h.data()]),{selectedIndices:k,selectedScores:l}=jX(j[0],j[1],c,d,e,f);return g!==a&&g.dispose(),h!==b&&h.dispose(),{selectedIndices:jE(k,"int32"),selectedScores:jE(l)}}let j1=dM({nonMaxSuppressionPadded_:function(a,b,c,d=.5,e=-1/0,f=!1){let g=dJ(a,"boxes","nonMaxSuppression"),h=dJ(b,"scores","nonMaxSuppression"),i=jS(g,h,c,d,e,null),j=i.maxOutputSize,k=i.iouThreshold,l=i.scoreThreshold,m=dB.runKernel(bX,{boxes:g,scores:h},{maxOutputSize:j,iouThreshold:k,scoreThreshold:l,padToMaxOutputSize:f});return{selectedIndices:m[0],validOutputs:m[1]}}});async function j2(a,b,c,d=.5,e=-1/0,f=!1){let g=dJ(a,"boxes","nonMaxSuppressionAsync"),h=dJ(b,"scores","nonMaxSuppressionAsync"),i=jS(g,h,c,d,e,null),j=i.maxOutputSize,k=i.iouThreshold,l=i.scoreThreshold,[m,n]=await Promise.all([g.data(),h.data()]),{selectedIndices:o,validOutputs:p}=jW(m,n,j,k,l,f);return g!==a&&g.dispose(),h!==b&&h.dispose(),{selectedIndices:jE(o,"int32"),validOutputs:eG(p,"int32")}}let j3=dM({bincount_:function(a,b,c){let d=dJ(a,"x","bincount"),e=dJ(b,"weights","bincount");return I("int32"===d.dtype,()=>`Error in bincount: input dtype must be int32, but got ${d.dtype}`),I(c>=0,()=>`size must be non-negative, but got ${c}.`),I(e.size===d.size||0===e.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${d.shape}, weights shape: ${e.shape}.`),dB.runKernel(aP,{x:d,weights:e},{size:c})}});function j4(a,b,c=1,d="float32"){if(0===c)throw Error("Cannot have a step of zero");return dB.runKernel(b6,{},{start:a,stop:b,step:c,dtype:d})}let j5=dM({threshold_:function(a,b="binary",c=!1,d=.5){let e,f,g,h,i=dJ(a,"image","threshold"),j=i.shape[0]*i.shape[1],k=eB(jE([d]),255);if(I(3===i.rank,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),I(3===i.shape[2]||1===i.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),I("int32"===i.dtype||"float32"===i.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),I("otsu"===b||"binary"===b,()=>`Method must be binary or otsu, but was ${b}`),3===i.shape[2]){[e,f,g]=fv(i,[1,1,1],-1);let a=eB(e,.2989),b=eB(f,.587),c=eB(g,.114);h=ey(ey(a,b),c)}else h=a;return"otsu"===b&&(k=function(a,b){let c,d,e,f,g,h,i=jE([-1]),j=jE([0]),k=jE([0]);for(let l=0;l<a.size-1;l++){c=f6(a,0,l+1),d=f6(a,l+1),g=eA(e5(c),b),h=eA(e5(d),b),e=eA(e5(eB(c,j4(0,c.size))),e5(c));let m=eP(d.shape,c.size),n=ey(j4(0,d.size),m),o=eS(e,f=eA(e5(eB(d,n)),e5(d))),p=eS(e,f),q=eB(g,h),r=fY(k=eB(eB(q,o),p),j);j=ft(r,k,j),i=ft(r,jE([l]),i)}return i}(j3(ev(iw(h),"int32"),dP([]),256),j)),ev(eB(c?fq(h,k):fY(h,k),255),"int32")}}),j6=dM({transform_:function(a,b,c="nearest",d="constant",e=0,f){let g=dJ(a,"image","transform","float32"),h=dJ(b,"transforms","transform","float32");return I(4===g.rank,()=>`Error in transform: image must be rank 4,but got rank ${g.rank}.`),I(2===h.rank&&(h.shape[0]===g.shape[0]||1===h.shape[0])&&8===h.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),I(null==f||2===f.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${f}.`),dB.runKernel(cM,{image:g,transforms:h},{interpolation:c,fillMode:d,fillValue:e,outputShape:f})}}),j7=dM({bandPart_:function(a,b,c){let d,e,f=dJ(a,"a","bandPart");I(f.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${f.rank}.`);let g=f.shape,[h,i]=f.shape.slice(-2);"number"==typeof b?(I(b%1==0,()=>`bandPart(): numLower must be an integer, got ${b}.`),I(b<=h,()=>`bandPart(): numLower (${b}) must not be greater than the number of rows (${h}).`),d=dJ(b<0?h:b,"numLower","bandPart")):(I("int32"===b.dtype,()=>"bandPart(): numLower's dtype must be an int32."),d=ft(f1(b,0),h,ij(b,h))),"number"==typeof c?(I(c%1==0,()=>`bandPart(): numUpper must be an integer, got ${c}.`),I(c<=i,()=>`bandPart(): numUpper (${c}) must not be greater than the number of columns (${i}).`),e=dJ(c<0?i:c,"numUpper","bandPart")):(I("int32"===c.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),e=ft(f1(c,0),i,ij(c,i)));let j=eS(e4(j4(0,h,1,"int32"),[-1,1]),j4(0,i,1,"int32")),k=fr(fq(j,d),fp(j,e3(e))),l=f4([h,i],f.dtype);return e4(fU(f8(e4(f,[-1,h,i])).map(a=>ft(k,a,l))),g)}}),j8=dM({gramSchmidt_:function(a){let b;if(Array.isArray(a)){b=!1,I(null!=a&&a.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let c=a[0].shape[0];for(let b=1;b<a.length;++b)I(a[b].shape[0]===c,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${a[b].shape[0]} vs. ${c})`)}else b=!0,a=fv(a,a.shape[0],0).map(a=>iC(a,[0]));I(a.length<=a[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${a.length}) exceeds number of dimensions (${a[0].shape[0]}).`);let c=[],d=a;for(let b=0;b<a.length;++b)c.push(dB.tidy(()=>{let a=d[b];if(b>0)for(let d=0;d<b;++d){let b=eB(e5(eB(c[d],a)),c[d]);a=eS(a,b)}return eA(a,h_(a,"euclidean"))}));return b?fU(c,0):c}});function j9(a,b=!1){return dB.tidy(()=>{I(2===a.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${a.shape.length}D Tensor.`);let c=a.shape[0],d=a.shape[1],e=jz(c),f=ew(a),g=jJ([[1]],[1,1]),h=ew(g),i=c>=d?d:c;for(let a=0;a<i;++a){let b=f,i=h,j=e;[h,f,e]=dB.tidy(()=>{let b=f6(f,[a,a],[c-a,1]),i=h_(b),j=f6(f,[a,a],[1,1]),k=ft(fY(j,0),jJ([[-1]]),jJ([[1]])),l=eS(j,eB(k,i)),m=eA(b,l);h=1===m.shape[0]?ew(g):hy([g,f6(m,[1,0],[m.shape[0]-1,m.shape[1]])],0);let n=e3(eA(fn(k,l),i)),o=f6(f,[a,0],[c-a,d]),p=eB(n,h),q=fO(h);if(0===a)f=eS(o,fn(p,fn(q,o)));else{let b=eS(o,fn(p,fn(q,o)));f=hy([f6(f,[0,0],[a,d]),b],0)}let r=fO(p),s=f6(e,[0,a],[c,e.shape[1]-a]);if(0===a)e=eS(s,fn(fn(s,h),r));else{let b=eS(s,fn(fn(s,h),r));e=hy([f6(e,[0,0],[c,a]),b],1)}return[h,f,e]}),dU([b,i,j])}return!b&&c>d&&(e=f6(e,[0,0],[c,d]),f=f6(f,[0,0],[d,d])),[e,f]})}let ka=dM({qr_:function(a,b=!1){if(I(a.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${a.rank}`),2===a.rank)return j9(a,b);{let c=a.shape.slice(0,a.shape.length-2).reduce((a,b)=>a*b),d=f8(e4(a,[c,a.shape[a.shape.length-2],a.shape[a.shape.length-1]]),0),e=[],f=[];return d.forEach(a=>{let[c,d]=j9(a,b);e.push(c),f.push(d)}),[e4(fU(e,0),a.shape),e4(fU(f,0),a.shape)]}}});(Bx=BN||(BN={}))[Bx.NONE=0]="NONE",Bx[Bx.MEAN=1]="MEAN",Bx[Bx.SUM=2]="SUM",Bx[Bx.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS";let kb=dM({computeWeightedLoss_:function(a,b,c=BN.SUM_BY_NONZERO_WEIGHTS){let d=dJ(a,"losses","computeWeightedLoss"),e=null;null!=b&&(e=dJ(b,"weights","computeWeightedLoss"));let f=null==e?d:eB(d,e);if(c===BN.NONE)return f;if(c===BN.SUM)return e5(f);if(c===BN.MEAN)if(null==e)return ii(f);else{let a=d.size/e.size,b=eA(e5(f),e5(e));return a>1?eA(b,eG(a)):b}if(c===BN.SUM_BY_NONZERO_WEIGHTS)if(null==e)return eA(e5(f),eG(d.size));else{let a=ev(e5(im(eB(e,f5(d.shape)),eG(0))),"float32");return eA(e5(f),a)}throw Error(`Unknown reduction: ${c}`)}}),kc=dM({absoluteDifference_:function(a,b,c,d=BN.SUM_BY_NONZERO_WEIGHTS){let e=dJ(a,"labels","absoluteDifference"),f=dJ(b,"predictions","absoluteDifference"),g=null;return null!=c&&(g=dJ(c,"weights","absoluteDifference")),J(e.shape,f.shape,"Error in absoluteDifference: "),kb(eU(eS(e,f)),g,d)}}),kd=dM({cosineDistance_:function(a,b,c,d,e=BN.SUM_BY_NONZERO_WEIGHTS){let f=dJ(a,"labels","cosineDistance"),g=dJ(b,"predictions","cosineDistance"),h=null;return null!=d&&(h=dJ(d,"weights","cosineDistance")),J(f.shape,g.shape,"Error in cosineDistance: "),kb(eS(eG(1),e5(eB(f,g),c,!0)),h,e)}}),ke=dM({hingeLoss_:function(a,b,c,d=BN.SUM_BY_NONZERO_WEIGHTS){let e=dJ(a,"labels","hingeLoss"),f=dJ(b,"predictions","hingeLoss"),g=null;null!=c&&(g=dJ(c,"weights","hingeLoss")),J(e.shape,f.shape,"Error in hingeLoss: ");let h=eG(1);return e=eS(eB(eG(2),e),h),kb(gF(eS(h,eB(e,f))),g,d)}}),kf=dM({huberLoss_:function(a,b,c,d=1,e=BN.SUM_BY_NONZERO_WEIGHTS){let f=dJ(a,"labels","huberLoss"),g=dJ(b,"predictions","huberLoss"),h=null;null!=c&&(h=dJ(c,"weights","huberLoss")),J(f.shape,g.shape,"Error in huberLoss: ");let i=eG(d),j=eU(eS(g,f)),k=ij(j,i),l=eS(j,k);return kb(ey(eB(eG(.5),eD(k)),eB(i,l)),h,e)}}),kg=dM({logLoss_:function(a,b,c,d=1e-7,e=BN.SUM_BY_NONZERO_WEIGHTS){let f=dJ(a,"labels","logLoss"),g=dJ(b,"predictions","logLoss"),h=null;null!=c&&(h=dJ(c,"weights","logLoss")),J(f.shape,g.shape,"Error in logLoss: ");let i=eG(1),j=eG(d),k=e3(eB(f,ga(ey(g,j)))),l=eB(eS(i,f),ga(ey(eS(i,g),j)));return kb(eS(k,l),h,e)}}),kh=dM({meanSquaredError_:function(a,b,c,d=BN.SUM_BY_NONZERO_WEIGHTS){let e=dJ(a,"labels","meanSquaredError"),f=dJ(b,"predictions","meanSquaredError"),g=null;return null!=c&&(g=dJ(c,"weights","meanSquaredError")),J(e.shape,f.shape,"Error in meanSquaredError: "),kb(iB(e,f),g,d)}}),ki=dM({sigmoidCrossEntropy_:function(a,b,c,d=0,e=BN.SUM_BY_NONZERO_WEIGHTS){let f,g,h,i,j,k=dJ(a,"multiClassLabels","sigmoidCrossEntropy"),l=dJ(b,"logits","sigmoidCrossEntropy"),m=null;if(null!=c&&(m=dJ(c,"weights","sigmoidCrossEntropy")),J(k.shape,l.shape,"Error in sigmoidCrossEntropy: "),d>0){let a=eG(d),b=eG(1),c=eG(.5);k=ey(eB(k,eS(b,a)),eB(c,a))}return kb((f=dJ(k,"labels","sigmoidCrossEntropyWithLogits"),g=dJ(l,"logits","sigmoidCrossEntropyWithLogits"),J(f.shape,g.shape,"Error in sigmoidCrossEntropyWithLogits: "),h=gF(g),i=eB(g,f),j=id(fR(e3(eU(g)))),ey(eS(h,i),j)),m,e)}}),kj=dM({softmaxCrossEntropy_:function(a,b,c,d=0,e=BN.SUM_BY_NONZERO_WEIGHTS){let f=dJ(a,"onehotLabels","softmaxCrossEntropy"),g=dJ(b,"logits","softmaxCrossEntropy"),h=null;if(null!=c&&(h=dJ(c,"weights","softmaxCrossEntropy")),J(f.shape,g.shape,"Error in softmaxCrossEntropy: "),d>0){let a=eG(d),b=eG(1),c=eG(f.shape[1]);f=ey(eB(f,eS(b,a)),eA(a,c))}return kb(function(a,b,c=-1){if(-1===c&&(c=b.rank-1),c!==b.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${b.rank} and dim was ${c}`);return eF((a,b,d)=>{let e=ic(b,[c],!0),f=eS(ev(b,"float32"),e);return d([a,f]),{value:e5(e3(eB(f,a)),[c]),gradFunc:(a,b)=>{let[d,e]=b,f=fG(a.shape,[c]);return[eB(e4(a,f),eS(ev(d,"float32"),fR(e))),eB(e4(a,f),eS(fR(e),ev(d,"float32")))]}}})(a,b)}(f,g),h,e)}}),kk=dM({sparseFillEmptyRows_:function(a,b,c,d){let e=dJ(a,"indices","sparseFillEmptyRows","int32"),f=dJ(b,"values","sparseFillEmptyRows"),g=dJ(c,"denseShape","sparseFillEmptyRows","int32"),h=dJ(d,"defaultValue","sparseFillEmptyRows",f.dtype);if(2!==e.rank)throw Error(`Indices should be Tensor2D but received shape
        ${e.shape}`);if(1!==f.rank)throw Error(`Values should be Tensor1D but received shape ${f.shape}`);if(1!==g.rank)throw Error(`Dense shape should be Tensor1D but received shape ${g.shape}`);if(0!==h.rank)throw Error(`Default value should be a scalar but received shape ${h.shape}`);let i=dB.runKernel(cx,{indices:e,values:f,denseShape:g,defaultValue:h});return{outputIndices:i[0],outputValues:i[1],emptyRowIndicator:i[2],reverseIndexMap:i[3]}}}),kl=dM({sparseReshape_:function(a,b,c){let d=dJ(a,"inputIndices","sparseReshape","int32"),e=dJ(b,"inputShape","sparseReshape","int32"),f=dJ(c,"newShape","sparseReshape","int32");if(2!==d.rank)throw Error(`Input indices should be Tensor2D but received shape
        ${d.shape}`);if(1!==e.rank)throw Error(`Input shape should be Tensor1D but received shape ${e.shape}`);if(1!==f.rank)throw Error(`New shape should be Tensor1D but received shape ${f.shape}`);let g=dB.runKernel(cy,{inputIndices:d,inputShape:e,newShape:f});return{outputIndices:g[0],outputShape:g[1]}}}),km=dM({sparseSegmentMean_:function(a,b,c){let d=dJ(a,"data","sparseSegmentMean"),e=dJ(b,"indices","sparseSegmentMean","int32"),f=dJ(c,"segmentIds","sparseSegmentMean","int32");if(d.rank<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==e.rank)throw Error(`Indices should be Tensor1D but received shape
          ${e.shape}`);if(1!==f.rank)throw Error(`Segment ids should be Tensor1D but received shape
          ${f.shape}`);return dB.runKernel(cz,{data:d,indices:e,segmentIds:f})}}),kn=dM({sparseSegmentSum_:function(a,b,c){let d=dJ(a,"data","sparseSegmentSum"),e=dJ(b,"indices","sparseSegmentSum","int32"),f=dJ(c,"segmentIds","sparseSegmentSum","int32");if(d.rank<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==e.rank)throw Error(`Indices should be Tensor1D but received shape
         ${e.shape}`);if(1!==f.rank)throw Error(`Segment ids should be Tensor1D but received shape
         ${f.shape}`);return dB.runKernel(cA,{data:d,indices:e,segmentIds:f})}}),ko=dM({stringNGrams_:function(a,b,c,d,e,f,g,h){let i=dJ(a,"data","stringNGrams","string");if("string"!==i.dtype)throw Error("Data must be of datatype string");if(1!==i.shape.length)throw Error(`Data must be a vector, saw: ${i.shape}`);let j=dJ(b,"dataSplits","stringNGrams");if("int32"!==j.dtype)throw Error("Data splits must be of datatype int32");let k=dB.runKernel(cG,{data:i,dataSplits:j},{separator:c,nGramWidths:d,leftPad:e,rightPad:f,padWidth:g,preserveShortSequences:h});return{nGrams:k[0],nGramsSplits:k[1]}}}),kp=dM({stringSplit_:function(a,b,c=!0){let d=dJ(a,"input","stringSplit","string"),e=dJ(b,"delimiter","stringSplit","string");if(1!==d.rank)throw Error(`Input should be Tensor1D but received shape ${d.shape}`);if(0!==e.rank)throw Error(`Delimiter should be a scalar but received shape ${e.shape}`);let f=dB.runKernel(cH,{input:d,delimiter:e},{skipEmpty:c});return{indices:f[0],values:f[1],shape:f[2]}}}),kq=dM({stringToHashBucketFast_:function(a,b){let c=dJ(a,"input","stringToHashBucketFast","string");if(b<=0)throw Error("Number of buckets must be at least 1");return dB.runKernel(cI,{input:c},{numBuckets:b})}}),kr=dM({staticRegexReplace_:function(a,b,c,d=!0){let e=dJ(a,"input","staticRegexReplace","string");return dB.runKernel(cE,{x:e},{pattern:b,rewrite:c,replaceGlobal:d})}}),ks={fft:h2,ifft:h3,rfft:iv,irfft:h4},kt={hammingWindow:jH,hannWindow:jI,frame:jK,stft:jL},ku={flipLeftRight:jN,grayscaleToRGB:jO,resizeNearestNeighbor:iu,resizeBilinear:it,rgbToGrayscale:jQ,rotateWithOffset:jR,cropAndResize:jM,nonMaxSuppression:jT,nonMaxSuppressionAsync:j$,nonMaxSuppressionWithScore:j_,nonMaxSuppressionWithScoreAsync:j0,nonMaxSuppressionPadded:j1,nonMaxSuppressionPaddedAsync:j2,threshold:j5,transform:j6},kv={bandPart:j7,gramSchmidt:j8,qr:ka},kw={absoluteDifference:kc,computeWeightedLoss:kb,cosineDistance:kd,hingeLoss:ke,huberLoss:kf,logLoss:kg,meanSquaredError:kh,sigmoidCrossEntropy:ki,softmaxCrossEntropy:kj},kx={sparseFillEmptyRows:kk,sparseReshape:kl,sparseSegmentMean:km,sparseSegmentSum:kn},ky={stringNGrams:ko,stringSplit:kp,stringToHashBucketFast:kq,staticRegexReplace:kr};a.s(["image",()=>ku,"linalg",()=>kv,"losses",()=>kw,"signal",()=>kt,"sparse",()=>kx,"spectral",()=>ks,"string",()=>ky],143945);var kz=a.i(999416);class kA{constructor(a,b,c,d,e){this.mean=a,this.stdDev=b,this.dtype=c,this.nextVal=NaN,this.truncated=d,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const f=e||Math.random();this.random=kz.alea(f.toString())}nextValue(){let a,b;if(!isNaN(this.nextVal)){let a=this.nextVal;return this.nextVal=NaN,a}let c=!1;for(;!c;){let d,e,f;do f=(d=2*this.random()-1)*d+(e=2*this.random()-1)*e;while(f>=1||0===f)let g=Math.sqrt(-2*Math.log(f)/f);a=this.mean+this.stdDev*d*g,b=this.mean+this.stdDev*e*g,(!this.truncated||this.isValidTruncated(a))&&(c=!0)}return(!this.truncated||this.isValidTruncated(b))&&(this.nextVal=this.convertValue(b)),this.convertValue(a)}convertValue(a){return null==this.dtype||"float32"===this.dtype?a:Math.round(a)}isValidTruncated(a){return a<=this.upper&&a>=this.lower}}class kB{constructor(a,b,c,d){this.alpha=a,this.beta=1/b,this.dtype=c;const e=d||Math.random();this.randu=kz.alea(e.toString()),this.randn=new kA(0,1,c,!1,this.randu()),a<1?this.d=a+2/3:this.d=a-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let a,b,c,d,e,f;for(;;){do d=this.randn.nextValue(),f=1+this.c*d;while(f<=0)if(f*=f*f,b=1-.331*(a=d*d)*a,c=.5*a+this.d*(1-f+Math.log(f)),(e=this.randu())<b||Math.log(e)<c)break}return f=1/this.beta*this.d*f,this.alpha<1&&(f*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(f)}convertValue(a){return"float32"===this.dtype?a:Math.round(a)}}class kC{constructor(a=0,b=1,c,d){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=a,this.range=b-a,this.dtype=c,null==d&&(d=Math.random()),"number"==typeof d&&(d=d.toString()),!this.canReturnFloat()&&this.range<=1)throw Error(`The difference between ${a} - ${b} <= 1 and dtype is not float`);this.random=kz.alea(d)}convertValue(a){return this.canReturnFloat()?a:Math.round(a)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}let kD=dM({randomUniform_:function(a,b=0,c=1,d="float32",e){ap(a);let f=eu(a,d),g=new kC(b,c,null,e);for(let a=0;a<f.values.length;a++)f.values[a]=g.nextValue();return f.toTensor()}});var jg=jg;let kE=dM({truncatedNormal_:function(a,b=0,c=1,d,e){if(ap(a),null!=d&&"bool"===d)throw Error("Unsupported data type $ { dtype }");let f=new kA(b,c,d,!0,e),g=eu(a,d);for(let a=0;a<g.values.length;a++)g.values[a]=f.nextValue();return g.toTensor()}});var iV=iV;let kF=dM({slice1d_:function(a,b,c){let d=dJ(a,"x","slice1d");return I(1===d.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${d.rank} tensor`),f6(d,[b],[c])}}),kG=dM({slice2d_:function(a,b,c){let d=dJ(a,"x","slice2d");return I(2===d.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${d.rank} tensor`),f6(d,b,c)}}),kH=dM({slice3d_:function(a,b,c){let d=dJ(a,"x","slice3d");return I(3===d.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${d.rank} tensor`),f6(d,b,c)}}),kI=dM({slice4d_:function(a,b,c){let d=dJ(a,"x","slice4d");return I(4===d.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${d.rank} tensor`),f6(d,b,c)}}),kJ=dM({concat1d_:function(a){return hy(a,0)}}),kK=dM({concat2d_:function(a,b){return hy(a,b)}}),kL=dM({concat3d_:function(a,b){return hy(a,b)}}),kM=dM({concat4d_:function(a,b){return hy(a,b)}}),kN=dM({randomNormal_:function(a,b=0,c=1,d,e){if(ap(a),null!=d&&"bool"===d)throw Error(`Unsupported data type ${d}`);let f=new kA(b,c,d,!1,e),g=eu(a,d);for(let a=0;a<g.values.length;a++)g.values[a]=f.nextValue();return g.toTensor()}});var kO=jD;let kP=dM({dropout_:function(a,b,c,d){let e=dJ(a,"x","dropout");if(I("float32"===e.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${e.dtype} tensor instead.`),I(b>=0&&b<1,()=>`rate must be a float in the range [0, 1), but got ${b}.`),0===b)return a instanceof dk?e.clone():e;let f=function(a,b){if(null==b)return a.shape.slice();if(O(a.shape,b))return b;if(a.shape.length===b.length){let c=[];for(let d=0;d<a.shape.length;d++)null==b[d]&&null!=a.shape[d]?c.push(a.shape[d]):c.push(b[d]);return c}return b}(e,c),g=1-b;return eB(e,eA(f7(ey(kD(f,0,1,"float32",d),g)),g))}});function kQ(a,b,c){null==b&&(b=0),null==c&&(c=a.length);let d=1;for(let e=b;e<c;++e)d*=a[e];return d}function kR(a){if(0===a.length)return NaN;let b=1/0;for(let c=0;c<a.length;c++){let d=a[c];d<b&&(b=d)}return b}function kS(a){if(0===a.length)return NaN;let b=-1/0;for(let c=0;c<a.length;c++){let d=a[c];d>b&&(b=d)}return b}function kT(a,b){if(b<a)throw new iY(`end (${b}) < begin (${a}) is forbidden.`);let c=[];for(let d=a;d<b;++d)c.push(d);return c}function kU(){return null==e&&(e=dB.backend.epsilon()),e}function kV(){return"channelsLast"}a.s(["dropout",0,kP],43791);function kW(a,b=-1){let c=a.shape.slice();return b<0&&(b=c.length+b+1),c.splice(b,0,1),e4(a,c)}function kX(a,b,c){return dT(()=>{switch(a.rank){case 1:return kF(a,b,c);case 2:return kG(a,[b,0],[c,a.shape[1]]);case 3:return kH(a,[b,0,0],[c,a.shape[1],a.shape[2]]);case 4:return kI(a,[b,0,0,0],[c,a.shape[1],a.shape[2],a.shape[3]]);case 5:return f6(a,[b,0,0,0,0],[c,a.shape[1],a.shape[2],a.shape[3],a.shape[4]]);case 6:return f6(a,[b,0,0,0,0,0],[c,a.shape[1],a.shape[2],a.shape[3],a.shape[4],a.shape[5]]);default:throw new iY(`sliceAlongFirstAxis() received an unsupported tensor rank: ${a.rank}`)}})}function kY(a,b,c){return dT(()=>{switch(a.rank){case 1:return kF(a,b,c);case 2:return kG(a,[0,b],[a.shape[0],c]);case 3:return kH(a,[0,0,b],[a.shape[0],a.shape[1],c]);case 4:return kI(a,[0,0,0,b],[a.shape[0],a.shape[1],a.shape[2],c]);default:throw new iY(`sliceAlongLastAxis() received an unsupported tensor rank: ${a.rank}`)}})}function kZ(a,b,c,d){return dT(()=>{switch(a.rank){case 1:return kF(a,b,c);case 2:switch(d){case 1:return kX(a,b,c);case 2:return kY(a,b,c);default:throw new iY(`The axis is not within the rank of the tensor ${d}`)}case 3:switch(d){case 1:return kX(a,b,c);case 2:return kH(a,[0,b,0],[a.shape[0],c,a.shape[2]]);case 3:return kY(a,b,c);default:throw new iY(`The axis is not within the rank of the tensor ${d}`)}case 4:switch(d){case 1:return kX(a,b,c);case 2:return kI(a,[0,b,0,0],[a.shape[0],c,a.shape[2],a.shape[3]]);case 3:return kI(a,[0,0,b,0],[a.shape[0],a.shape[1],c,a.shape[3]]);case 4:return kY(a,b,c);default:throw new iY(`The axis is not within the rank of the tensor ${d}`)}default:throw new iY(`sliceAlongLastAxis() received an unsupported tensor rank: ${a.rank}`)}})}function k$(a,b=-1){let c;return b<0&&(b=0!==(c=a[0].rank)?c:0),b===a[0].rank&&(b=-1),hy(a,b)}function k_(a,b){switch(a.rank){case 1:return kJ([a,b]);case 2:return kK([a,b],0);case 3:return kL([a,b],0);case 4:return kM([a,b],0);default:throw new iY(`concatAlongFirstAxis() received an unsupported tensor rank: ${a.rank}`)}}function k0(a,b){if(Array.isArray(b)||(b=[b]),a.rank!==b.length)throw new iY(`The length of input n (${b.length}) does not match the number of dimensions in input x (${a.rank})`);return fT(a,b)}function k1(a,b=0,c=1,d,e){return kN(a,b,c,d,e)}function k2(a,b,c,d){if(a.rank<2||b.rank<2)throw new iZ(`dot requires both inputs to be rank >= 2 but got x shape = ${a.shape} and y shape = ${b.shape}`);if(b.rank>=3&&a.shape.slice(-1)[0]!==b.shape.slice(-2)[0])throw new iZ(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${a.shape} and  y shape = ${b.shape}`);if(2===a.rank&&2===b.rank)return kO.matMul({a,b:b,transposeA:!1,transposeB:!1,bias:d?k4(a.rank,d,kV()):null,activation:c});{let e=a.shape.slice();a=e4(a,[-1,e.pop()]);let f=b.shape.slice(),g=f.pop(),h=f.pop(),i=[...f,g],j=Array.from({length:b.rank},(a,c)=>0===c?b.rank-2:c<=b.rank-2?c-1:c);b=e4(fO(b,j),[h,-1]);let k=[...e,...i];return e4(kO.matMul({a,b,transposeA:!1,transposeB:!1,bias:d?k4(a.rank,d,kV()):null,activation:c}),k)}}function k3(a,b,c){return dT(()=>hB(a,b=Array.isArray(b)?jE(b,"int32"):ev(b,"int32"),c))}function k4(a,b,c){let d=b.shape;if(1!==b.rank&&b.rank!==a)throw new iY(`Unexpected bias dimensions: ${b.rank}; expected it to be 1 or ${a}`);if(5===a){if("channelsFirst"===c)if(1===d.length)return e4(b,[1,d[0],1,1,1]);else return e4(b,[1,d[3],d[0],d[1],d[2]]);else if("channelsLast"===c)if(1===d.length)return e4(b,[1,1,1,1,d[0]]);else return e4(b,[1].concat(d))}else if(4===a){if("channelsFirst"===c)if(1===d.length)return e4(b,[1,d[0],1,1]);else return e4(b,[1,d[2],d[0],d[1]]);else if("channelsLast"===c)if(1===d.length)return e4(b,[1,1,1,d[0]]);else return e4(b,[1].concat(d))}else if(3===a){if("channelsFirst"===c)if(1===d.length)return e4(b,[1,d[0],1]);else return e4(b,[1,d[1],d[0]]);else if("channelsLast"===c)if(1===d.length)return e4(b,[1,1,d[0]]);else return e4(b,[1].concat(d))}else if(a<3)return b;throw new iY(`Unsupported input rank by biasAdd: ${b.rank}`)}function k5(a,b,c){return dT(()=>(null==c&&(c=kV()),jq(c),ey(a,k4(a.rank,b,c))))}function k6(a,b,c=!1){return c?a():b()}let k7=["fanIn","fanOut","fanAvg"],k8=["normal","uniform","truncatedNormal"];class k9 extends jg.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class la extends k9{apply(a,b){return f4(a,b)}}la.className="Zeros",jg.registerClass(la);class lb extends k9{apply(a,b){return f5(a,b)}}lb.className="Ones",jg.registerClass(lb);class lc extends k9{constructor(a){if(super(),"object"!=typeof a)throw new iY(`Expected argument of type ConstantConfig but got ${a}`);if(void 0===a.value)throw new iY(`config must have value set but got ${a}`);this.value=a.value}apply(a,b){return dT(()=>eB(eG(this.value),f5(a,b)))}getConfig(){return{value:this.value}}}lc.className="Constant",jg.registerClass(lc);class ld extends k9{constructor(a){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=a.minval||this.DEFAULT_MINVAL,this.maxval=a.maxval||this.DEFAULT_MAXVAL,this.seed=a.seed}apply(a,b){return kD(a,this.minval,this.maxval,b,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}ld.className="RandomUniform",jg.registerClass(ld);class le extends k9{constructor(a){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=a.mean||this.DEFAULT_MEAN,this.stddev=a.stddev||this.DEFAULT_STDDEV,this.seed=a.seed}apply(a,b){if("float32"!==(b=b||"float32")&&"int32"!==b)throw new iZ(`randomNormal does not support dType ${b}.`);return k1(a,this.mean,this.stddev,b,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}le.className="RandomNormal",jg.registerClass(le);class lf extends k9{constructor(a){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=a.mean||this.DEFAULT_MEAN,this.stddev=a.stddev||this.DEFAULT_STDDEV,this.seed=a.seed}apply(a,b){if("float32"!==(b=b||"float32")&&"int32"!==b)throw new iZ(`truncatedNormal does not support dType ${b}.`);return kE(a,this.mean,this.stddev,b,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}lf.className="TruncatedNormal",jg.registerClass(lf);class lg extends k9{constructor(a){super(),this.gain=null!=a.gain?a.gain:1}apply(a,b){return dT(()=>{if(2===a.length&&a[0]===a[1])return eB(this.gain,jz(a[0]));throw new iY("Identity matrix initializer can only be used for 2D square matrices.")})}getConfig(){return{gain:this.gain}}}lg.className="Identity",jg.registerClass(lg);class lh extends k9{constructor(a){if(super(),a.scale<0)throw new iY(`scale must be a positive float. Got: ${a.scale}`);this.scale=null==a.scale?1:a.scale,this.mode=null==a.mode?"fanIn":a.mode,jc(k7,"FanMode",this.mode),this.distribution=null==a.distribution?"normal":a.distribution,jc(k8,"Distribution",this.distribution),this.seed=a.seed}apply(a,b){let c=function(a,b="channelsLast"){let c,d;if(jq(b),2===a.length)c=a[0],d=a[1];else if(-1!==[3,4,5].indexOf(a.length)){if("channelsFirst"===b){let b=kQ(a,2);c=a[1]*b,d=a[0]*b}else if("channelsLast"===b){let b=kQ(a,0,a.length-2);c=a[a.length-2]*b,d=a[a.length-1]*b}}else{let b=kQ(a);c=Math.sqrt(b),d=Math.sqrt(b)}return[c,d]}(a),d=c[0],e=c[1],f=this.scale;if("fanIn"===this.mode?f/=Math.max(1,d):"fanOut"===this.mode?f/=Math.max(1,e):f/=Math.max(1,(d+e)/2),"normal"===this.distribution){let c=Math.sqrt(f);if("float32"!==(b=b||"float32")&&"int32"!==b)throw new iZ(`${this.getClassName()} does not support dType ${b}.`);return kE(a,0,c,b,this.seed)}{let c=Math.sqrt(3*f);return kD(a,-c,c,b,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}lh.className="VarianceScaling",jg.registerClass(lh);class li extends lh{constructor(a){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==a?null:a.seed})}getClassName(){return lh.className}}li.className="GlorotUniform",jg.registerClass(li);class lj extends lh{constructor(a){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==a?null:a.seed})}getClassName(){return lh.className}}lj.className="GlorotNormal",jg.registerClass(lj);class lk extends lh{constructor(a){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==a?null:a.seed})}getClassName(){return lh.className}}lk.className="HeNormal",jg.registerClass(lk);class ll extends lh{constructor(a){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==a?null:a.seed})}getClassName(){return lh.className}}ll.className="HeUniform",jg.registerClass(ll);class lm extends lh{constructor(a){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==a?null:a.seed})}getClassName(){return lh.className}}lm.className="LeCunNormal",jg.registerClass(lm);class ln extends lh{constructor(a){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==a?null:a.seed})}getClassName(){return lh.className}}ln.className="LeCunUniform",jg.registerClass(ln);class lo extends k9{constructor(a){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==a.gain?this.DEFAULT_GAIN:a.gain,this.seed=a.seed}apply(a,b){return dT(()=>{if(a.length<2)throw new iZ("Shape must be at least 2D.");if("int32"!==b&&"float32"!==b&&void 0!==b)throw TypeError(`Unsupported data type ${b}.`);let c=iV.sizeFromShape(a.slice(0,-1)),d=a[a.length-1],e=c*d;e>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${e}) elements: Slowness may result.`);let f=k1([Math.max(d,c),Math.min(d,c)],0,1,b,this.seed),g=kv.qr(f,!1),h=g[0];return h=eB(h,g[1].flatten().stridedSlice([0],[Math.min(d,c)*Math.min(d,c)],[Math.min(d,c)+1]).sign()),c<d&&(h=h.transpose()),eB(eG(this.gain),h.reshape(a))})}getConfig(){return{gain:this.gain,seed:this.seed}}}lo.className="Orthogonal",jg.registerClass(lo);let lp={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function lq(a,b={}){return i9(a,jg.SerializationMap.getMap().classNameMap,b,"initializer")}function lr(a){if("string"==typeof a){let b=a in lp?lp[a]:a;if("GlorotNormal"===b)return new lj;{if("GlorotUniform"===b)return new li;if("HeNormal"===b)return new lk;if("HeUniform"===b)return new ll;if("LeCunNormal"===b)return new lm;if("LeCunUniform"===b)return new ln;let a={};return a.className=b,a.config={},lq(a)}}return a instanceof k9?a:lq(a)}function ls(a){return Array.isArray(a)&&Array.isArray(a[0])}function lt(a){return 0===a.length?[]:Array.isArray(a[0])?a:[a]}function lu(a){let b;if(Array.isArray(a)){if(1!==a.length)throw new iY(`Expected Tensor length to be 1; got ${a.length}`);b=a[0]}else b=a;return b}function lv(a){if(!(Array.isArray(a)&&Array.isArray(a[0])))return a;if(1===a.length)return a[0];throw new iY(`Expected exactly 1 Shape; got ${a.length}`)}function lw(a){let b=0;for(let c of a)0===c.shape.length?b+=1:b+=c.shape.reduce((a,b)=>a*b);return b}function lx(a,b=!0,c,d){return dB.makeVariable(a,b,c,d)}let ly="Variable";class lz{constructor(a,b="float32",c=ly,d=!0,e=null){this.dtype=null==b?"float32":b,this.shape=a.shape,this.id=jh++,c=null==c?ly:c,this.originalName=jv(c),this.name=jw(this.originalName),this.trainable_=d,this.constraint=e,this.val=lx(a,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(a){return this.assertNotDisposed(),function(a,b){if(a.shape.toString()!==b.shape.toString())throw Error("Shape mismatch: "+JSON.stringify(a.shape)+" vs. "+JSON.stringify(b.shape))}(this.val,a),this.val.id!==a.id&&(this.val.assign(a),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(a){this.trainable_=a,this.val.trainable=a}}function lA(a){return a.map(a=>a.read())}function lB(a){a.forEach(a=>{a[0].write(a[1])})}class lC{constructor(a){this.dtype=a.dtype,this.shape=a.shape,null!=a.shape?this.ndim=a.shape.length:this.ndim=a.ndim,this.maxNDim=a.maxNDim,this.minNDim=a.minNDim,this.axes=a.axes||{}}}class lD{constructor(a,b,c,d,e,f,g){this.dtype=a,this.shape=b,this.sourceLayer=c,this.inputs=d,this.callArgs=e,this.outputTensorIndex=g,this.id=jh++,null!=f&&(this.originalName=jv(f),this.name=jw(this.originalName)),this.rank=b.length}}let lE=0;class lF{constructor(a,b){for(const c of(this.callArgs=b,this.id=lE++,this.outboundLayer=a.outboundLayer,this.inboundLayers=a.inboundLayers,this.nodeIndices=a.nodeIndices,this.tensorIndices=a.tensorIndices,this.inputTensors=a.inputTensors,this.outputTensors=a.outputTensors,this.inputMasks=a.inputMasks,this.outputMasks=a.outputMasks,this.inputShapes=a.inputShapes,this.outputShapes=a.outputShapes,a.inboundLayers))null!=c&&c.outboundNodes.push(this);a.outboundLayer.inboundNodes.push(this)}getConfig(){let a=[];for(let b of this.inboundLayers)null!=b?a.push(b.name):a.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:a,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let lG=0;class lH extends jg.Serializable{constructor(a={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=lG++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let b=a.name;if(!b){const a=this.getClassName();b=i5(a)+"_"+jj(a)}if(this.name=b,this.trainable_=null==a.trainable||a.trainable,null!=a.inputShape||null!=a.batchInputShape){let b;if(null!=a.batchInputShape)b=a.batchInputShape;else if(null!=a.inputShape){let c=null;null!=a.batchSize&&(c=a.batchSize),b=[c].concat(a.inputShape)}this.batchInputShape=b;let c=a.dtype;null==c&&(c=a.inputDType),null==c&&(c="float32"),this.dtype=c}null!=a.weights?this.initialWeights=a.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(a,b){return a.name+"_ib-"+b.toString()}getNodeAtIndex(a,b){if(0===this.inboundNodes.length)throw new iX(`The layer has never been called and thus has no defined ${b}.`);if(this.inboundNodes.length<=a)throw new iY(`Asked to get ${b} at node ${a}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[a]}getInputAt(a){return i3(this.getNodeAtIndex(a,"input").inputTensors)}getOutputAt(a){return i3(this.getNodeAtIndex(a,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new iW(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new iW(`Layer ${this.name} is not connected, no input to return.`);return i3(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new iW(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new iW(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return i3(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(a=>a())}get updates(){return this._updates}get built(){return this._built}set built(a){this._built=a}get trainable(){return this.trainable_}set trainable(a){this._trainableWeights.forEach(b=>b.trainable=a),this.trainable_=a}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(a=>a.trainable):[]}set trainableWeights(a){this._trainableWeights=a}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(a=>!a.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(a){this._nonTrainableWeights=a}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(a){let b=i4(a);if(null==this.inputSpec||0===this.inputSpec.length)return;let c=i4(this.inputSpec);if(b.length!==c.length)throw new iY(`Layer ${this.name} expects ${c.length} inputs, but it received ${b.length} input tensors. Input received: ${a}`);for(let a=0;a<b.length;a++){let d=b[a],e=c[a];if(null==e)continue;let f=d.rank;if(null!=e.ndim&&f!==e.ndim)throw new iY(`Input ${a} is incompatible with layer ${this.name}: expected ndim=${e.ndim}, found ndim=${f}`);if(null!=e.maxNDim&&f>e.maxNDim)throw new iY(`Input ${a} is incompatible with layer ${this.name}: expected max_ndim=${e.maxNDim}, found ndim=${f}`);if(null!=e.minNDim&&f<e.minNDim)throw new iY(`Input ${a} is incompatible with layer ${this.name}: expected min_ndim=${e.minNDim}, found ndim=${f}.`);if(null!=e.dtype&&d.dtype!==e.dtype)throw new iY(`Input ${a} is incompatible with layer ${this.name} : expected dtype=${e.dtype}, found dtype=${d.dtype}.`);if(e.axes){let b=d.shape;for(let c in e.axes){let d=Number(c),f=e.axes[c],g=d>=0?b[d]:b[b.length+d];if(null!=f&&-1===[f,null].indexOf(g))throw new iY(`Input ${a} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${f} but got shape ${b}.`)}}if(null!=e.shape)for(let b=0;b<e.shape.length;++b){let c=e.shape[b],f=d.shape[b];if(null!=c&&null!=f&&c!==f)throw new iY(`Input ${a} is incompatible with layer ${this.name}: expected shape=${e.shape}, found shape=${d.shape}.`)}}}call(a,b){return a}invokeCallHook(a,b){null!=this._callHook&&this._callHook(a,b)}setCallHook(a){this._callHook=a}clearCallHook(){this._callHook=null}apply(a,b){b=b||{},this.assertNotDisposed();let c=i4(a),d=function(a){let b=!0;for(let c of i4(a))if(!(c instanceof lD)){b=!1;break}return b}(a),e=function(a){let b=!0;for(let c of i4(a))if(c instanceof lD){b=!1;break}return b}(a);if(d===e)throw new iY("Arguments to apply() must be all SymbolicTensors or all Tensors");return ju(this.name,()=>{if(!this.built){this.assertInputCompatibility(a);let b=[];for(let c of i4(a))b.push(c.shape);this.build(i3(b)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&e&&(this._refCount=1)}if(this.assertInputCompatibility(a),e){let d=this.call(a,b);this.supportsMasking&&this.setMaskMetadata(a,d);let e=i4(d),f=[];for(let a of e)-1!==c.indexOf(a)&&(a=a.clone()),f.push(a);if(d=i3(f),null!=this.activityRegularizer)throw new iZ("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return d}{let c,d=function(a){a=i4(a);let b=[];for(let c of a)b.push(c.shape);return i3(b)}(a),e=this.computeOutputShape(d),f="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(a)?d[0]:d),c=null!=e&&e.length>0&&Array.isArray(e[0])?e.map((c,d)=>new lD(f,c,this,i4(a),b,this.name,d)):new lD(f,e,this,i4(a),b,this.name),this.addInboundNode(a,c,null,null,d,e,b),this._refCount++,null!=this.activityRegularizer)throw new iZ("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return c}})}warnOnIncompatibleInputShape(a){if(null!=this.batchInputShape)if(a.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(a)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let b=!1;this.batchInputShape.forEach((c,d)=>{null!=c&&null!=a[d]&&a[d]!==c&&(b=!0)}),b&&console.warn(`The shape of the input tensor (${JSON.stringify(a)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new iW(`The layer ${this.name} has never been called and thus has no defined output shape.`);let a=[];for(let b of this.inboundNodes){let c=JSON.stringify(b.outputShapes);-1===a.indexOf(c)&&a.push(c)}if(1===a.length){let a=this.inboundNodes[0].outputShapes;return Array.isArray(a)&&Array.isArray(a[0])&&1===a.length?a[0]:a}throw new iW(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new iX(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return lw(this.weights)}build(a){this.built=!0}getWeights(a=!1){return lA(a?this.trainableWeights:this.weights)}setWeights(a){dT(()=>{let b=this.weights;if(b.length!==a.length)throw new iY(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${a.length}, but the layer was expecting ${b.length} weights. Provided weights: ${a}...`);if(0===b.length)return;let c=[],d=lA(b);for(let e=0;e<d.length;++e){let f=d[e],g=b[e],h=a[e];if(!iV.arraysEqual(f.shape,h.shape))throw new iY(`Layer weight shape ${f.shape} not compatible with provided weight shape ${h.shape}`);c.push([g,h])}lB(c)})}addWeight(a,b,c,d,e,f,g,h){if(-1!==this._addedWeightNames.indexOf(a))throw new iY(`Duplicate weight name ${a} for layer ${this.name}`);this._addedWeightNames.push(a),null==c&&(c="float32"),this.fastWeightInitDuringBuild&&(d=null!=h?h():lr("zeros"));let i=d.apply(b,c),j=new lz(i,c,a,f,g);return i.dispose(),null!=e&&this.addLoss(()=>e.apply(j.read())),null==f&&(f=!0),f?this._trainableWeights.push(j):this._nonTrainableWeights.push(j),j}setFastWeightInitDuringBuild(a){this.fastWeightInitDuringBuild=a}addLoss(a){null==a||Array.isArray(a)&&0===a.length||(a=i4(a),void 0!==this._losses&&null!==this._losses&&this.losses.push(...a))}computeOutputShape(a){return a}computeMask(a,b){if(!this.supportsMasking){if(null!=b)if(Array.isArray(b))b.forEach(a=>{if(null!=a)throw TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return b}setMaskMetadata(a,b,c){if(!this.supportsMasking)return;let d=this.computeMask(a,c),e=i4(b),f=i4(d);if(e.length!==f.length)throw Error(`${this.name} outputs ${e.length} tensors but ${e.length} masks for those tensors`);for(let a=0;a<e.length;a++)e[a].kerasMask=f[a]}addInboundNode(a,b,c,d,e,f,g=null){let h=i4(a);b=i4(b),c=i4(c),d=i4(d),e=lt(e),f=lt(f);let i=[],j=[],k=[];for(let a of h)i.push(a.sourceLayer),j.push(a.nodeIndex),k.push(a.tensorIndex);new lF({outboundLayer:this,inboundLayers:i,nodeIndices:j,tensorIndices:k,inputTensors:h,outputTensors:b,inputMasks:c,outputMasks:d,inputShapes:e,outputShapes:f},g);for(let a=0;a<b.length;a++)b[a].sourceLayer=this,b[a].nodeIndex=this.inboundNodes.length-1,b[a].tensorIndex=a}getConfig(){let a={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(a.batchInputShape=this.batchInputShape),null!=this.dtype&&(a.dtype=this.dtype),a}disposeWeights(){return this.weights.forEach(a=>a.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let a=0;return 0==--this._refCount&&(a=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:a}}}class lI extends lH{constructor(a){if(super({dtype:a.dtype,name:null!=a.name?a.name:jj("input").toString()}),null==a.batchSize&&(a.batchSize=null),null==a.sparse&&(a.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=a.sparse,null!=a.inputShape&&null!=a.batchInputShape)throw new iY("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let b=a.batchInputShape;if(null==b)if(null==a.inputShape)throw new iY("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");else b=[a.batchSize].concat(a.inputShape);else if(null!=a.batchSize)throw new iY("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const c=a.dtype||"float32";this.batchInputShape=b,this.dtype=c,this.inputSpec=[{shape:b}];const d=new lD(this.dtype,this.batchInputShape,this,[],{},this.name);d.nodeIndex=0,d.tensorIndex=0,new lF({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[d],outputTensors:[d],inputMasks:[null],outputMasks:[null],inputShapes:[b],outputShapes:[b]})}apply(a,b){throw new iY(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function lJ(a){if(null==a.batchShape&&null==a.shape)throw Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=a.batchShape&&null!=a.shape)throw new iY("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let b=a.batchShape;null!=a.shape&&null==b&&(b=[null].concat(a.shape));let c=a.dtype;return null==c&&(c="float32"),new lI({batchInputShape:b,name:a.name,dtype:c,sparse:a.sparse}).inboundNodes[0].outputTensors[0]}lI.className="InputLayer",jg.registerClass(lI);class lK{constructor(a){if(this.id2Value={},this.id2Mask={},this.name2Id={},a instanceof lK)for(const b in a.id2Value)this.id2Value[b]=a.id2Value[b],b in a.id2Mask&&(this.id2Mask[b]=a.id2Mask[b]);else{if(null==a)return;for(const b of a)this.add(b.key,b.value)}}add(a,b,c){if(null==this.id2Value[a.id])this.id2Value[a.id]=function(a,b){if(null==a.dtype||a.dtype===b.dtype)return b;try{return ev(b,a.dtype)}catch(c){throw new iY(`The dtype of the feed (${b.dtype}) can not be cast to the dtype of the key '${a.name}' (${a.dtype}).`)}}(a,b),this.name2Id[a.name]=a.id,null!=c&&(this.id2Mask[a.id]=c);else throw new iY(`Duplicate key: name=${a.name}, id=${a.id}`);return this}addFeed(a){this.add(a.key,a.value)}hasKey(a){return null!=this.id2Value[a.id]}names(){return Object.keys(this.name2Id)}getValue(a){if(a instanceof lD)if(null!=this.id2Value[a.id])return this.id2Value[a.id];else throw new iY(`Nonexistent key: ${a.name}`);{let b=this.name2Id[a];if(null==b)throw new iY(`Feed dict has no SymbolicTensor name: ${a}`);return this.id2Value[b]}}getMask(a){if(a instanceof lD)if(null!=this.id2Value[a.id])return this.id2Mask[a.id];else throw new iY(`Nonexistent key: ${a.name}`);{let b=this.name2Id[a];if(null==b)throw new iY(`Feed dict has no SymbolicTensor name: ${a}`);return this.id2Mask[b]}}disposeMasks(){null!=this.id2Mask&&dU(this.id2Mask)}}let lL=new i_,lM=new i_;function lN(a,b,c,d){let e,f=null!=c&&c.training,g=Array.isArray(a),h=g?a:[a],i=h.map(a=>a.name),j=[],k=b.names();for(let a of i)-1!==k.indexOf(a)?j.push(b.getValue(a)):j.push(null);null!=d&&(d.maxNumTensors=-1/0,d.minNumTensors=1/0);let l=i.join(",")+"|"+b.names().sort().join(","),m=lL.get(l);if(null==m){let a=function(a,b){iV.assert(null!=a&&a.length>0,()=>"Expected at least one fetch, got none");let c=[],d={};if(1===a.length){let e=lO(a[0],b);c=e.sorted,d=e.recipientMap}else{let e=new Set;for(let f of a){let{sorted:a,recipientMap:g}=lO(f,b);for(let b of a)e.has(b.name)||(c.push(b),e.add(b.name));for(let a in g)null==d[a]&&(d[a]=new Set),g[a].forEach(b=>d[a].add(b))}}return{sorted:c,recipientCounts:function(a){let b={};for(let c in a)b[c]=a[c].size;return b}(d)}}(h,b);m=a.sorted,e=a.recipientCounts,lL.put(l,m),lM.put(l,e)}e={},f||Object.assign(e,lM.get(l));let n=new lK(b);for(let a=0;a<m.length;++a){if(null!=d){let a=dS().numTensors;a>d.maxNumTensors&&(d.maxNumTensors=a),a<d.minNumTensors&&(d.minNumTensors=a)}let g=m[a],h=g.sourceLayer;if(h instanceof lI)continue;let k=[],l=[],o=[],p=!1;for(let a of g.inputs){let c=n.getValue(a),d=n.getMask(a);k.push(c),l.push(d),null!=d&&(p=!0),!f&&(e[a.name]--,0!==e[a.name]||b.hasKey(a)||-1!==i.indexOf(a.name)||c.isDisposed||!0===a.sourceLayer.stateful||o.push(c))}p&&((c=c||{}).mask=l[0]);let q=i4(h.apply(k,c)),r=null;h.supportsMasking&&(r=h.computeMask(k,l));let s=function(a){let b;if(1===a.sourceLayer.inboundNodes.length)b=a.sourceLayer.output;else{let c=null;for(let b=0;b<a.sourceLayer.inboundNodes.length;++b)for(let d of a.sourceLayer.inboundNodes[b].outputTensors)if(d.id===a.id){c=b;break}b=a.sourceLayer.getOutputAt(c)}return b}(g),t=Array.isArray(s)?s:[s];for(let a=0;a<t.length;++a){n.hasKey(t[a])||n.add(t[a],q[a],Array.isArray(r)?r[0]:r);let b=i.indexOf(t[a].name);-1!==b&&(j[b]=q[a])}f||dU(o)}return n.disposeMasks(),g?j:j[0]}function lO(a,b){let c=new Set,d=[],e={};for(let a of b.names())c.add(a);let f=[],g=[];for(f.push(a);f.length>0;){let a=f[f.length-1];if(c.has(a.name)){f.pop();continue}let b=g[g.length-1]===f.length-1;if(0===a.inputs.length||b)f.pop(),d.push(a),c.add(a.name),b&&g.pop();else for(let b of(g.push(f.length-1),a.inputs))null==e[b.name]&&(e[b.name]=new Set),e[b.name].add(a.name),c.has(b.name)||f.push(b)}return{sorted:d,recipientMap:e}}aw.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function(a){null!=lL&&lL.setMaxEntries(a),null!=lM&&lM.setMaxEntries(a)});var jg=jg;function lP(a,b){return dT(()=>eC(e5(eB(a,a),b,!0)))}class lQ extends jg.Serializable{getConfig(){return{}}}class lR extends lQ{constructor(a){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=a.maxValue?a.maxValue:this.defaultMaxValue,this.axis=null!=a.axis?a.axis:this.defaultAxis}apply(a){return dT(()=>{let b=lP(a,this.axis);return eB(a,eA(hQ(b,0,this.maxValue),ey(kU(),b)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}lR.className="MaxNorm",jg.registerClass(lR);class lS extends lQ{constructor(a){super(),this.defaultAxis=0,this.axis=null!=a.axis?a.axis:this.defaultAxis}apply(a){return dT(()=>eA(a,ey(kU(),lP(a,this.axis))))}getConfig(){return{axis:this.axis}}}lS.className="UnitNorm",jg.registerClass(lS);class lT extends lQ{apply(a){return gF(a)}}lT.className="NonNeg",jg.registerClass(lT);class lU extends lQ{constructor(a){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=a.minValue?a.minValue:this.defaultMinValue,this.maxValue=null!=a.maxValue?a.maxValue:this.defaultMaxValue,this.rate=null!=a.rate?a.rate:this.defaultRate,this.axis=null!=a.axis?a.axis:this.defaultAxis}apply(a){return dT(()=>{let b=lP(a,this.axis),c=ey(eB(this.rate,hQ(b,this.minValue,this.maxValue)),eB(1-this.rate,b));return eB(a,eA(c,ey(kU(),b)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}lU.className="MinMaxNorm",jg.registerClass(lU);let lV={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function lW(a,b={}){return i9(a,jg.SerializationMap.getMap().classNameMap,b,"constraint")}function lX(a){return null==a?null:"string"==typeof a?lW({className:a in lV?lV[a]:a,config:{}}):a instanceof lQ?a:lW(a)}function lY(a){return new lR(a)}function lZ(a){return new lS(a)}function l$(){return new lT}function l_(a){return new lU(a)}function l0(){return new la}function l1(){return new lb}function l2(a){return new lc(a)}function l3(a){return new ld(a)}function l4(a){return new le(a)}function l5(a){return new lf(a)}function l6(a){return new lg(a)}function l7(a){return new lh(a)}function l8(a){return new li(a)}function l9(a){return new lj(a)}function ma(a){return new lk(a)}function mb(a){return new ll(a)}function mc(a){return new lm(a)}function md(a){return new ln(a)}function me(a){return new lo(a)}a.s(["maxNorm",()=>lY,"minMaxNorm",()=>l_,"nonNeg",()=>l$,"unitNorm",()=>lZ],217361),a.i(217361),a.s(["constant",()=>l2,"glorotNormal",()=>l9,"glorotUniform",()=>l8,"heNormal",()=>ma,"heUniform",()=>mb,"identity",()=>l6,"leCunNormal",()=>mc,"leCunUniform",()=>md,"ones",()=>l1,"orthogonal",()=>me,"randomNormal",()=>l4,"randomUniform",()=>l3,"truncatedNormal",()=>l5,"varianceScaling",()=>l7,"zeros",()=>l0],863416),a.i(863416);let mf="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:a=>a();function mg(){return new Promise(a=>mf(()=>a()))}var iV=iV;async function mh(a){if(null==a)return;let b=[],c=[],d=[];for(let e in a){let f=a[e];"number"!=typeof f&&(b.push(f.data()),c.push(e),d.push(f))}if(b.length>0){let e=await Promise.all(b);for(let b=0;b<e.length;++b)a[c[b]]=e[b][0];dU(d)}}function mi(a){if(null!=a)for(let b in a){let c=a[b];"number"!=typeof c&&c.dispose()}}(By=BO||(BO={}))[By.SILENT=0]="SILENT",By[By.VERBOSE=1]="VERBOSE";class mj{constructor(){this.validationData=null}setParams(a){this.params=a}async onEpochBegin(a,b){}async onEpochEnd(a,b){}async onBatchBegin(a,b){}async onBatchEnd(a,b){}async onTrainBegin(a){}async onTrainEnd(a){}setModel(a){}}class mk{constructor(a,b=10){null==a&&(a=[]),this.callbacks=a,this.queueLength=b}append(a){this.callbacks.push(a)}setParams(a){for(let b of this.callbacks)b.setParams(a)}setModel(a){for(let b of this.callbacks)b.setModel(a)}async onEpochBegin(a,b){for(let c of(null==b&&(b={}),this.callbacks))await c.onEpochBegin(a,b)}async onEpochEnd(a,b){for(let c of(null==b&&(b={}),this.callbacks))await c.onEpochEnd(a,b)}async onBatchBegin(a,b){for(let c of(null==b&&(b={}),this.callbacks))await c.onBatchBegin(a,b)}async onBatchEnd(a,b){for(let c of(null==b&&(b={}),this.callbacks))await c.onBatchEnd(a,b)}async onTrainBegin(a){for(let b of(null==a&&(a={}),this.callbacks))await b.onTrainBegin(a)}async onTrainEnd(a){for(let b of(null==a&&(a={}),this.callbacks))await b.onTrainEnd(a)}}class ml extends mj{constructor(){super()}async onEpochBegin(a){this.seen=0,this.totals={}}async onBatchEnd(a,b){null==b&&(b={});let c=null==b.size?0:b.size;for(let a in this.seen+=c,b){let d=b[a];if("number"==typeof d)this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+d*c;else{let b;a in this.totals?b=this.totals[a]:this.totals[a]=0;let e=dT(()=>ey(this.totals[a],eB(d,c)));this.totals[a]=e,null!=b&&b.dispose()}}}async onEpochEnd(a,b){if(null!=b)for(let a of this.params.metrics)null!=this.totals[a]&&("number"==typeof this.totals[a]?b[a]=this.totals[a]/this.seen:dT(()=>{let c=eB(eA(1,this.seen),this.totals[a]);b[a]=c,this.totals[a].dispose(),dV(b[a])}))}}class mm extends mj{async onTrainBegin(a){this.epoch=[],this.history={}}async onEpochEnd(a,b){for(let c in null==b&&(b={}),this.epoch.push(a),b)null==this.history[c]&&(this.history[c]=[]),this.history[c].push(b[c])}async syncData(){let a=[],b=[],c=[];for(let d in this.history){let e=this.history[d];for(let f=0;f<e.length;++f)if("number"!=typeof e[f]){let g=e[f];a.push(g.data()),b.push(d),c.push(f)}}let d=await Promise.all(a);for(let a=0;a<d.length;++a)this.history[b[a]][c[a]].dispose(),this.history[b[a]][c[a]]=d[a][0]}}class mn extends mj{constructor(a,b){if(super(),this.currentEpoch=0,this.nowFunc=a.nowFunc,this.nextFrameFunc=a.nextFrameFunc||mg,this.yieldEvery=b||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=a.onYield)throw Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");iV.isNumber(this.yieldEvery)&&(this.maybeWait=function(a,b,c){let d,e=null!=c?c():iV.now();return(...f)=>{let g=null!=c?c():iV.now();return g-e<b?d:(e=g,d=a(...f))}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=a.onTrainBegin,this.trainEnd=a.onTrainEnd,this.epochBegin=a.onEpochBegin,this.epochEnd=a.onEpochEnd,this.batchBegin=a.onBatchBegin,this.batchEnd=a.onBatchEnd,this.yield=a.onYield}async maybeWait(a,b,c){let d=[];null!=this.yield&&(await mh(c),d.push(this.yield(a,b,c))),d.push(this.nextFrameFunc()),await Promise.all(d)}async onEpochBegin(a,b){this.currentEpoch=a,null!=this.epochBegin&&(await mh(b),await this.epochBegin(a,b))}async onEpochEnd(a,b){let c=[];null!=this.epochEnd&&(await mh(b),c.push(this.epochEnd(a,b))),"epoch"===this.yieldEvery&&c.push(this.nextFrameFunc()),await Promise.all(c)}async onBatchBegin(a,b){null!=this.batchBegin&&(await mh(b),await this.batchBegin(a,b))}async onBatchEnd(a,b){let c=[];null!=this.batchEnd&&(await mh(b),c.push(this.batchEnd(a,b))),"batch"===this.yieldEvery?c.push(this.nextFrameFunc()):iV.isNumber(this.yieldEvery)&&c.push(this.maybeWait(this.currentEpoch,a,b)),await Promise.all(c)}async onTrainBegin(a){null!=this.trainBegin&&(await mh(a),await this.trainBegin(a))}async onTrainEnd(a){null!=this.trainEnd&&(await mh(a),await this.trainEnd(a))}}function mo(a,b){return(null==a&&(a={}),a instanceof mj)?[a]:Array.isArray(a)&&a[0]instanceof mj?a:i4(a).map(a=>new mn(a,b))}class mp{constructor(){}static registerCallbackConstructor(a,b){iV.assert(a>=0&&Number.isInteger(a),()=>`Verbosity level is expected to be an integer >= 0, but got ${a}`),mp.checkForDuplicate(b),null==mp.constructors[a]&&(mp.constructors[a]=[]),mp.constructors[a].push(b)}static checkForDuplicate(a){for(let b in mp.constructors)mp.constructors[+b].forEach(b=>{if(b===a)throw new iY("Duplicate callback constructor.")})}static clear(){mp.constructors={}}static createCallbacks(a){let b=[];for(let c in mp.constructors){let d=+c;a>=d&&b.push(...mp.constructors[d])}return b.map(a=>new a)}}function mq(a,b,c,d,e,f,g,h,i){let j=new mm,k=[new ml,...mp.createCallbacks(b)];null!=a&&k.push(...a),k.push(j);let l=new mk(k);return l.setParams({epochs:c,initialEpoch:d,samples:e,steps:f,batchSize:g,verbose:b,doValidation:h,metrics:i}),{callbackList:l,history:j}}function mr(a){return new Promise(a=>setTimeout(a)).then(a)}mp.constructors={};class ms{constructor(a){if(!aw.getBool("IS_BROWSER"))throw Error("browserDownloads() cannot proceed because the current environment is not a browser.");a.startsWith(ms.URL_SCHEME)&&(a=a.slice(ms.URL_SCHEME.length)),(null==a||0===a.length)&&(a="model"),this.modelJsonFileName=a+".json",this.weightDataFileName=a+".weights.bin"}async save(a){if("undefined"==typeof document)throw Error("Browser downloads are not supported in this environment since `document` is not present");let b=dR.join(a.weightData),c=window.URL.createObjectURL(new Blob([b],{type:"application/octet-stream"}));if(a.modelTopology instanceof ArrayBuffer)throw Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let b=[{paths:["./"+this.weightDataFileName],weights:a.weightSpecs}],d=d5(a,b),e=window.URL.createObjectURL(new Blob([JSON.stringify(d)],{type:"application/json"})),f=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(f.download=this.modelJsonFileName,f.href=e,await mr(()=>f.dispatchEvent(new MouseEvent("click"))),null!=a.weightData){let a=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=c,await mr(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:d8(a)}}}}ms.URL_SCHEME="downloads://";class mt{constructor(a){if(null==a||a.length<1)throw Error(`When calling browserFiles, at least 1 file is required, but received ${a}`);this.jsonFile=a[0],this.weightsFiles=a.slice(1)}async load(){return new Promise((a,b)=>{let c=new FileReader;c.onload=c=>{let d=JSON.parse(c.target.result),e=d.modelTopology;null==e?b(Error(`modelTopology field is missing from file ${this.jsonFile.name}`)):null==d.weightsManifest?b(Error(`weightManifest field is missing from file ${this.jsonFile.name}`)):0===this.weightsFiles.length?a({modelTopology:e}):a(d7(d,a=>this.loadWeights(a)))},c.onerror=a=>b(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),c.readAsText(this.jsonFile)})}loadWeights(a){let b=[],c=[];for(let d of a)b.push(...d.weights),c.push(...d.paths);let d=this.checkManifestAndWeightFiles(a);return Promise.all(c.map(a=>this.loadWeightsFile(a,d[a]))).then(a=>[b,a])}loadWeightsFile(a,b){return new Promise((c,d)=>{let e=new FileReader;e.onload=a=>{c(a.target.result)},e.onerror=b=>d(`Failed to weights data from file of path '${a}'.`),e.readAsArrayBuffer(b)})}checkManifestAndWeightFiles(a){let b=[],c=this.weightsFiles.map(a=>d4(a.name)),d={};for(let e of a)e.paths.forEach(a=>{let e=d4(a);if(-1!==b.indexOf(e))throw Error(`Duplicate file basename found in weights manifest: '${e}'`);if(b.push(e),-1===c.indexOf(e))throw Error(`Weight file with basename '${e}' is not provided.`);d[a]=this.weightsFiles[c.indexOf(e)]});if(b.length!==this.weightsFiles.length)throw Error(`Mismatch in the number of files in weights manifest (${b.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return d}}function mu(a){return new mt(a)}function mv(a,b,c,d){var e,f,g;I(null!=(e=a)&&Array.isArray(e)&&e.length>0,()=>"promises must be a none empty array"),f=c=null==c?0:c,g=d=null==d?1:d,I(f>=0&&f<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${f}`),I(g>=0&&g<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${g}`),I(g>=f,()=>`startFraction must be no more than endFraction, but got startFraction ${f} and endFraction ${g}`);let h=0;return Promise.all(a.map(e=>(e.then(e=>(b(c+ ++h/a.length*(d-c)),e)),e)))}async function mw(a,b){null==b&&(b={});let c=null==b.fetchFunc?aw.platform.fetch:b.fetchFunc,d=a.map(a=>c(a,b.requestInit,{isBinary:!0})),e=(null==b.onProgress?await Promise.all(d):await mv(d,b.onProgress,0,.5)).map(a=>a.arrayBuffer());return null==b.onProgress?await Promise.all(e):await mv(e,b.onProgress,.5,1)}async function mx(a,b="",c,d){return my(a=>mw(a,{requestInit:d}))(a,b,c)}function my(a){return async(b,c="",d)=>{let e=b.map(()=>!1),f={},g=null!=d?d.map(()=>!1):[],h=[];if(b.forEach((a,b)=>{let c=0;a.weights.forEach(a=>{let i=dQ["quantization"in a?a.quantization.dtype:a.dtype]*L(a.shape),j=()=>{e[b]=!0,null==f[b]&&(f[b]=[]),f[b].push({manifestEntry:a,groupOffset:c,sizeBytes:i})};null!=d?d.forEach((b,c)=>{b===a.name&&(j(),g[c]=!0)}):j(),h.push(a.name),c+=i})}),!g.every(a=>a)){let a=d.filter((a,b)=>!g[b]);throw Error(`Could not find weights in manifest with names: ${a.join(", ")}. 
Manifest JSON has weights with names: ${h.join(", ")}.`)}let i=e.reduce((a,b,c)=>(b&&a.push(c),a),[]),j=[];i.forEach(a=>{b[a].paths.forEach(a=>{let b=c+(c.endsWith("/")?"":"/")+a;j.push(b)})});let k=await a(j),l={},m=0;return i.forEach(a=>{let c=b[a].paths.length,d=new dR(k.slice(m,m+c));f[a].forEach(a=>{let b=dY(d.slice(a.groupOffset,a.groupOffset+a.sizeBytes),[a.manifestEntry]);for(let a in b)l[a]=b[a]}),m+=c}),l}}ea.registerSaveRouter(a=>aw.getBool("IS_BROWSER")&&!Array.isArray(a)&&a.startsWith(ms.URL_SCHEME)?function(a="model"){return new ms(a)}(a.slice(ms.URL_SCHEME.length)):null);class mz{constructor(a,b){if(this.DEFAULT_METHOD="POST",null==b&&(b={}),this.weightPathPrefix=b.weightPathPrefix,this.weightUrlConverter=b.weightUrlConverter,null!=b.fetchFunc?(I("function"==typeof b.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=b.fetchFunc):this.fetch=aw.platform.fetch,I(null!=a&&a.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(a)&&I(2===a.length,()=>`URL paths for http must have a length of 2, (actual length is ${a.length}).`),this.path=a,null!=b.requestInit&&null!=b.requestInit.body)throw Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=b.requestInit||{},this.loadOptions=b}async save(a){if(a.modelTopology instanceof ArrayBuffer)throw Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let b=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);b.body=new FormData;let c=[{paths:["./model.weights.bin"],weights:a.weightSpecs}],d=d5(a,c);if(b.body.append("model.json",new Blob([JSON.stringify(d)],{type:"application/json"}),"model.json"),null!=a.weightData){let c=dR.join(a.weightData);b.body.append("model.weights.bin",new Blob([c],{type:"application/octet-stream"}),"model.weights.bin")}let e=await this.fetch(this.path,b);if(e.ok)return{modelArtifactsInfo:d8(a),responses:[e]};throw Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${e.status}.`)}async loadModelJSON(){let a,b=await this.fetch(this.path,this.requestInit);if(!b.ok)throw Error(`Request to ${this.path} failed with status code ${b.status}. Please verify this URL points to the model JSON of the model to load.`);try{a=await b.json()}catch(b){let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",Error(a)}let c=a.modelTopology,d=a.weightsManifest;if(null==c&&null==d)throw Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return a}async load(){return this.loadOptions.streamWeights?this.loadStream():d7(await this.loadModelJSON(),a=>this.loadWeights(a))}async loadStream(){let a=await this.loadModelJSON(),b=await this.getWeightUrls(a.weightsManifest),c=d9(a.weightsManifest),d=()=>{var a,c;let d,e,f;return e=null==(a=this.loadOptions).fetchFunc?aw.platform.fetch:a.fetchFunc,f=0,null==(c=a.onProgress)||c.call(a,0),new ReadableStream({pull:async c=>{for(var g;f<b.length;){d||(d=(await e(b[f],a.requestInit,{isBinary:!0})).body.getReader());let{done:h,value:i}=await d.read();if(h){f++,d=void 0,null==(g=a.onProgress)||g.call(a,f/b.length);continue}c.enqueue(i);return}c.close()}})};return Object.assign(Object.assign({},a),{weightSpecs:c,getWeightStream:d})}async getWeightUrls(a){var b;let c,d,[e,f]=(c=(b=Array.isArray(this.path)?this.path[1]:this.path).lastIndexOf("/"),d=b.lastIndexOf("?"),[b.substring(0,c)+"/",d>c?b.substring(d):""]),g=this.weightPathPrefix||e,h=[],i=[];for(let b of a)for(let a of b.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(a)):h.push(g+a+f);return this.weightUrlConverter&&h.push(...await Promise.all(i)),h}async loadWeights(a){let b=await this.getWeightUrls(a);return[d9(a),await mw(b,this.loadOptions)]}}function mA(a){return null!=a.match(mz.URL_SCHEME_REGEX)}mz.URL_SCHEME_REGEX=/^https?:\/\//;let mB=(a,b)=>{if("undefined"==typeof fetch&&(null==b||null==b.fetchFunc));else if(Array.isArray(a)?a.every(a=>mA(a)):mA(a))return mC(a,b);return null};function mC(a,b){return new mz(a,b)}function mD(a,b){return mC(a,b)}ea.registerSaveRouter(mB),ea.registerLoadRouter(mB);class mE{constructor(a){this.modelArtifacts=a}load(){return this.modelArtifacts}}class mF{constructor(a){this.saveHandler=a}save(a){return this.saveHandler(a)}}class mG{constructor(a){a.load&&(this.load=()=>Promise.resolve(a.load())),a.save&&(this.save=b=>Promise.resolve(a.save(b)))}}function mH(a,b,c,d){let e=arguments;return new mG(mI(...e))}function mI(a,b,c,d){return 1!=arguments.length?(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new mE({modelTopology:a,weightSpecs:b,weightData:c,trainingConfig:d})):null!=a.modelTopology||null!=a.weightSpecs?new mE(a):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new mE({modelTopology:a}))}function mJ(a){return new mF(a)}function mK(a){return new mF(a)}a.s([],235036),a.i(235036),a.s(["CompositeArrayBuffer",()=>dR,"browserFiles",()=>mu,"browserHTTPRequest",()=>mD,"concatenateArrayBuffers",()=>d3,"copyModel",()=>es,"decodeWeights",()=>dY,"decodeWeightsStream",()=>d0,"encodeWeights",()=>dX,"fromMemory",()=>mH,"fromMemorySync",()=>mI,"getLoadHandlers",0,(a,b)=>ea.getLoadHandlers(a,b),"getModelArtifactsForJSON",()=>d7,"getModelArtifactsForJSONSync",()=>d6,"getModelArtifactsInfoForJSON",()=>d8,"getSaveHandlers",0,a=>ea.getSaveHandlers(a),"getWeightSpecs",()=>d9,"http",()=>mC,"isHTTPScheme",()=>mA,"listModels",()=>eq,"loadWeights",()=>mx,"moveModel",()=>et,"registerLoadRouter",0,a=>ea.registerLoadRouter(a),"registerSaveRouter",0,a=>ea.registerSaveRouter(a),"removeModel",()=>er,"weightsLoaderFactory",()=>my,"withSaveHandler",()=>mJ,"withSaveHandlerSync",()=>mK],952490);var mL=a.i(952490),mL=mL,jg=jg,iV=iV,jg=jg;function mM(a,b={},c=!1){return i9(a,jg.SerializationMap.getMap().classNameMap,b,"layer",c)}var iV=iV;function mN(a,b){return dT(()=>{var c;"float32"!==a.dtype&&(a=ev(a,"float32"));let d=e5(eB(c=a,c),b,!0),e=eP(d.shape,kU()),f=eC(eY(d,e));return eA(a,f)})}function mO(a,b){return dT(()=>{var c;return ii(eB(c=eS(b,a),c),-1)})}function mP(a,b){return dT(()=>ii(eU(eS(b,a)),-1))}function mQ(a,b){return dT(()=>{let c=eS(a,b),d=hQ(eU(a),kU(),Number.MAX_VALUE);return eB(100,ii(eU(eA(c,d)),-1))})}function mR(a,b,c=!1){return dT(()=>{if(c)b=iA(b);else{let a=e5(b,b.shape.length-1,!0);b=eA(b,a)}return b=hQ(b,kU(),1-kU()),e3(e5(eB(ev(a,"float32"),ga(b)),b.shape.length-1))})}function mS(a,b,c=!1){return dT(()=>{let d,e=ev(f7((d=[kQ(a.shape)],e4(a,d))),"int32"),f=(b=hQ(b,kU(),1-kU())).shape;return mR(e4(io(e,f[f.length-1]),f),b,c)})}function mT(a,b){return dT(()=>{let c;return ii(function(a,b){if(!iV.arraysEqual(a.shape,b.shape))throw new iY(`logits and labels must have the same shape, but got shapes ${JSON.stringify(a.shape)} and ${JSON.stringify(b.shape)}`);return dT(()=>{let c=gF(b),d=e3(eU(b));return ey(eS(c,eB(b,a)),id(fR(d)))})}(a,c=ga(eA(c=hQ(b,kU(),1-kU()),eS(1,c)))),-1)})}function mU(a,b){return dT(()=>e3(e5(eB(mN(a,-1),mN(b,-1)),-1)))}let mV={meanSquaredError:mO,meanAbsoluteError:mP,meanAbsolutePercentageError:mQ,meanSquaredLogarithmicError:function(a,b){return dT(()=>{var c;return ii(eB(c=eS(ga(ey(1,hQ(b,kU(),Number.MAX_VALUE))),ga(ey(1,hQ(a,kU(),Number.MAX_VALUE)))),c),-1)})},squaredHinge:function(a,b){return dT(()=>{let c=eY(0,eS(1,eB(a,b)));return ii(eB(c,c),-1)})},hinge:function(a,b){return dT(()=>ii(eY(0,eS(1,eB(a,b))),-1))},categoricalHinge:function(a,b){return dT(()=>{let c=e5(eB(a,b),-1),d=hZ(eB(eS(1,a),b),-1);return eY(0,ey(1,eS(d,c)))})},logcosh:function(a,b){return dT(()=>{let c=Math.log(2),d=eS(b,a);return ii(eS(ey(d,h9(eB(-2,d))),c),-1)})},categoricalCrossentropy:mR,sparseCategoricalCrossentropy:mS,binaryCrossentropy:mT,kullbackLeiblerDivergence:function(a,b){return dT(()=>{let c=hQ(a,kU(),1);return e5(eB(a,ga(eA(c,hQ(b,kU(),1)))),-1)})},poisson:function(a,b){return dT(()=>{let c=ga(ey(kU(),b));return ii(eS(b,eB(a,c)),-1)})},cosineProximity:mU};function mW(a){if("string"!=typeof a)return a;{if(a in mV)return mV[a];let b=`Unknown loss ${a}`;throw a.toLowerCase().includes("softmaxcrossentropy")&&(b=`Unknown loss ${a}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new iY(b)}}function mX(a,b){return dT(()=>{let c=eB(.5,ip(b)),d=ev(fY(b,c),a.dtype);return ii(f$(a,d),-1)})}function mY(a,b){return dT(()=>ev(f$(hG(a,-1),hG(b,-1)),"float32"))}function mZ(a,b){return dT(()=>ev(e5(fr(f$(a,1),f$(b,1))),"float32"))}function m$(a,b){return dT(()=>{let c=mZ(a,b),d=ey(c,dT(()=>ev(e5(fr(f$(a,0),f$(b,1))),"float32")));return ev(ft(fY(d,0),eA(c,d),0),"float32")})}function m_(a,b){return mT(a,b)}function m0(a,b){return a.rank===b.rank&&(a=iC(a,[a.rank-1])),(b=hG(b,-1)).dtype!==a.dtype&&(b=ev(b,a.dtype)),ev(f$(a,b),"float32")}let m1={binaryAccuracy:mX,categoricalAccuracy:mY,precision:m$,categoricalCrossentropy:mR,sparseCategoricalCrossentropy:mS,mse:mO,MSE:mO,mae:mP,MAE:mP,mape:mQ,MAPE:mQ,cosine:mU};function m2(a){if(i1(null!==a,`Unknown LossOrMetricFn ${a}`),"string"==typeof a)return a;{let b;for(let c of Object.keys(mV))if(mV[c]===a){b=c;break}if(void 0!==b)return b;for(let c of Object.keys(m1))if(m1[c]===a){b=c;break}return void 0!==b?b:a.name}}let m3=class{static sgd(a){return new e$(a)}static momentum(a,b,c=!1){return new e_(a,b,c)}static rmsprop(a,b=.9,c=0,d=null,e=!1){return new e0(a,b,c,d,e)}static adam(a=.001,b=.9,c=.999,d=null){return new eT(a,b,c,d)}static adadelta(a=.001,b=.95,c=null){return new eO(a,b,c)}static adamax(a=.002,b=.9,c=.999,d=null,e=0){return new eZ(a,b,c,d,e)}static adagrad(a,b=.1){return new eQ(a,b)}};function m4(a,b,c=!1){if(null==a||"object"!=typeof a||Object.getPrototypeOf(a)!==Object.prototype||!function a(b){if(null===b)return!0;if("object"==typeof b)if(Object.getPrototypeOf(b)===Object.prototype){for(let c of Object.keys(b))if("string"!=typeof c||!a(b[c]))return!1;return!0}else{if(!Array.isArray(b))return!1;for(let c of b)if(!a(c))return!1;return!0}{let a=typeof b;return"string"===a||"number"===a||"boolean"===a}}(a))throw Error("User-defined metadata is expected to be a JSON object, but is not.");if(c){let c=JSON.stringify(a);c.length>1048576&&console.warn(`User-defined metadata of model "${b}" is too large in size (length=${c.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function m5(a,b,c=console.log){let d="";for(let c=0;c<a.length;++c)c>0&&(d=d.slice(0,d.length-1)+" "),d+=a[c],d=d.slice(0,b[c]),d+=" ".repeat(b[c]-d.length);c(d)}function m6(a,b,c){return("inboundNodes"===a||"outputLayers"===a||"inputLayers"===a)&&0===b&&"string"==typeof c}function m7(a,b){if(null===a)return null;if("string"==typeof a)return i6(a);if("number"==typeof a||"boolean"==typeof a)return a;if(a instanceof Array){let c=[],d=a.length;for(let e=0;e<d;++e){let d=a[e];m6(b,e,d)?c.push(d):c.push(m7(d,b))}return c}{let b={};for(let c of Object.keys(a)){let d=a[c];if("name"===c&&"string"==typeof d)b[c]=d;else{let a=i6(c);b[a]=m7(d,a)}}return b}}let m8="4.22.0";class m9 extends lH{constructor(a){if(super({}),this.containerNodes=new Set,this.name=a.name,null==this.name){const a=this.getClassName().toLowerCase();this.name=jj(a)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(a.inputs)?this.inputs=a.inputs.slice():this.inputs=[a.inputs],Array.isArray(a.outputs)?this.outputs=a.outputs.slice():this.outputs=[a.outputs],jb(this.inputs).length!==this.inputs.length)throw new iY(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(a=>a.name)}`);for(const a of(jb(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(a=>a.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[],this.outputs)){const b=a.sourceLayer,c=a.nodeIndex,d=a.tensorIndex;this.outputLayers.push(b),this.outputLayersNodeIndices.push(c),this.outputLayersTensorIndices.push(d)}for(const a of this.inputs){const b=a.sourceLayer,c=a.nodeIndex,d=a.tensorIndex;i1(0===c,"input layer has >1 nodes"),i1(0===d,"input layer has >1 tensors"),this.inputLayers.push(b),this.inputLayersNodeIndices.push(c),this.inputLayersTensorIndices.push(d)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const c=this.inputLayers[b];if(!(c instanceof lI))throw TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${a.inputs}. Input ${b} (0-based) originates from layer type ${c.getClassName()}.`);this.inputNames.push(c.name),this.feedInputShapes.push(c.batchInputShape),this.feedInputNames.push(c.name)}for(const a of this.outputLayers)this.outputNames.push(a.name);this.internalInputShapes=this.inputs.map(a=>a.shape),this.internalOutputShapes=this.outputs.map(a=>a.shape);const b={},c={},d={},e={},f={},g=[],h=(a,b,c,d,e,i)=>{(null==d||null==e||null==i)&&(d=a.sourceLayer,e=a.nodeIndex,i=a.tensorIndex);let j=d.inboundNodes[e];if(-1!==c.indexOf(j))throw new iX(`The tensor ${a.name} at layer "${d.name}" is part of a cycle.`);if(-1!==b.indexOf(j))return;this.containerNodes.add(m9.nodeKey(d,e)),d.id in f||(f[d.id]=Object.keys(f).length),-1===c.indexOf(j)&&c.push(j);let k=j.inboundLayers.length;for(let a=0;a<k;a++)h(j.inputTensors[a],b,c,j.inboundLayers[a],j.nodeIndices[a],j.tensorIndices[a]);for(b.push(j);c.indexOf(j)>=0;)c.splice(c.indexOf(j),1);g.push(j)},i=[],j=[];for(const a of this.outputs)h(a,i,j);for(const a of g.slice().reverse()){c[a.id]=a,a.id in b||(b[a.id]=0);let f=b[a.id];f=Math.max(f,null==d[a.outboundLayer.id]?0:d[a.outboundLayer.id]),d[a.outboundLayer.id]=f,e[a.outboundLayer.id]=a.outboundLayer,b[a.id]=f;for(let d=0;d<a.inboundLayers.length;d++){const e=a.inboundLayers[d],g=a.nodeIndices[d],h=e.inboundNodes[g],i=null==b[h.id]?0:b[h.id];b[h.id]=Math.max(f+1,i),c[h.id]=h}}const k={};for(const a in b){const d=b[a];d in k||(k[d]=[]),k[d].push(c[a])}const l={};for(const a in d){const b=d[a];b in l||(l[b]=[]),l[b].push(e[a])}let m=Object.keys(l).map(a=>parseInt(a,10)).sort(ja);for(const a of(this.layers=[],m)){const b=l[a];for(const a of(b.sort((a,b)=>{let c=f[a.id],d=f[b.id];return c<d?-1:+(c>d)}),b))a instanceof m9&&this.internalContainerRefs.push(a),this.layers.push(a)}this.layersByDepth=l,m=Object.keys(k).map(a=>parseInt(a,10)).sort(ja);const n=this.inputs.slice(),o=[];for(const a of m)for(const b of k[a]){const a=b.outboundLayer;if(null!=a){for(const c of b.inputTensors)if(-1===n.indexOf(c))throw new iX(`Graph disconnected: cannot obtain value for tensor ${c} at layer "${a.name}". The following previous layers were accessed without issue: ${o}`);for(const a of b.outputTensors)n.push(a);o.push(a.name)}}this.nodesByDepth=k;const p=this.layers.map(a=>a.name);for(const a of p){const b=p.filter(b=>b===a).length;if(1!==b)throw new iX(`The name "${a}" is used ${b} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(p))}this.outboundNodes=[],this.inboundNodes=[],new lF({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(a=>null),outputMasks:this.outputs.map(a=>null),inputShapes:this.inputs.map(a=>a.shape),outputShapes:this.outputs.map(a=>a.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let a={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(let b of this.layers)a.numDisposedVariables+=b.dispose().numDisposedVariables;for(let b of this.internalContainerRefs)a.numDisposedVariables+=b.dispose().numDisposedVariables}return a.refCountAfterDispose=this._refCount,a}get trainable(){return this.trainable_}set trainable(a){this.layers.forEach(b=>{b._trainableWeights.forEach(b=>b.trainable=a)}),this.trainable_=a}get trainableWeights(){if(this._trainableWeights.length>0)throw new iY("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let a=[];for(let b of this.layers)a=a.concat(b.trainableWeights);return a}get nonTrainableWeights(){let a=[];for(let b of this.layers)a.push(...b.nonTrainableWeights);if(!this.trainable){let b=[];for(let a of this.layers)b.push(...a.trainableWeights);return b.concat(a)}return a}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(a,b=!0){let c={},d=0,e=(a=>{let b=Object.keys(a);if(0===b.length)return!1;let c=b[0].split("/");return!isNaN(parseInt(c[c.length-1],10))})(a);for(let b of(e&&this.parseWeights(a),this.layers))for(let[a,f]of b.weights.entries()){let b=e?`${f.name.split("/").slice(0,-1).join("/")+"/"}${a}`:f.originalName;if(null!=c[b])throw new iY(`Duplicate weight name: ${b}`);c[b]=f,d++}let f=[];for(let d in a){let e=d;if(null==c[d]){let a=d.split("/");e=a.slice(0,-2).concat([a[a.length-1]]).join("/")}if(null!=c[e])f.push([c[e],a[d]]);else if(b)throw new iY(`Provided weight data has no target variable: ${d}`);delete c[e]}if(b){let a=[];for(let b in c)a.push(b);if(a.length>0)throw new iY(`${a.length} of ${d} weights are not set: ${a}`)}lB(f)}parseWeights(a){for(let b in Object.keys(a)){let c=b.split("/"),d=["vars","layer_checkpoint_dependencies"],e=c.map(a=>a.startsWith("_")?a.slice(1):a).filter(a=>!d.includes(a)).join("/");e!==b&&(a[e]=a[b],delete a[b])}}updatedConfig(){let a=this.getConfig(),b={};return b.className=this.getClassName(),b.config=a,b.kerasVersion=`tfjs-layers ${m8}`,b.backend="TensorFlow.js",b}toJSON(a,b=!0){let c=function a(b,c){if(null==b)return null;if("string"==typeof b)return i5(b);if("number"==typeof b||"boolean"==typeof b)return b;if(b instanceof Array){let d=[],e=b.length;for(let f=0;f<e;++f){let e=b[f];m6(c,f,e)?d.push(e):d.push(a(e,c))}return d}{let c={};for(let d of Object.keys(b)){let e=b[d],f=i5(d);("name"===d||"className"===d)&&"string"==typeof e?c[f]=e:c[f]=a(e,d)}return c}}(this.updatedConfig());return b?JSON.stringify(c):c}call(a,b){return dT(()=>{a=i4(a);let c=new lK;for(let b=0;b<this.inputs.length;++b)c.add(this.inputs[b],a[b]);return lN(this.outputs,c,b)})}computeMask(a,b){return dT(()=>{let c;return a=i4(a),c=null==b?i0(null,a.length):i4(b),this.runInternalGraph(a,c)[1]})}computeOutputShape(a){let b=lt(a);if(b.length!==this.inputLayers.length)throw new iY(`Invalid inputShape argument ${a}: model has ${this.inputLayers.length} tensor inputs.`);let c={};for(let a=0;a<b.length;a++){let d=this.inputLayers[a],e=b[a];c[d.name+"_0_0"]=e}let d=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(ja);if(d.length>1)for(let a of d)for(let b of this.nodesByDepth[a]){let a=b.outboundLayer;if(-1!==this.inputLayers.map(a=>a.id).indexOf(a.id))continue;let d=[];for(let a=0;a<b.inboundLayers.length;a++){let e=b.inboundLayers[a],f=b.nodeIndices[a],g=b.tensorIndices[a],h=c[`${e.name}_${f}_${g}`];d.push(h)}let e=lt(a.computeOutputShape(i3(d))),f=a.inboundNodes.indexOf(b);for(let b=0;b<e.length;b++)c[`${a.name}_${f}_${b}`]=e[b]}let e=[],f=[];for(let a=0;a<this.outputLayers.length;a++){let b=this.outputLayers[a],c=this.outputLayersNodeIndices[a],d=this.outputLayersTensorIndices[a],e=`${b.name}_${c}_${d}`;f.push(e)}for(let a=0;a<f.length;a++){let b=f[a];i1(b in c),e.push(c[b])}return i3(e)}runInternalGraph(a,b){null==b&&(b=i0(null,a.length));let c={};for(let d=0;d<this.inputs.length;++d){let e=this.inputs[d],f=a[d],g=b[d];c[e.id]=[f,g]}for(let a of Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(ja))for(let b of this.nodesByDepth[a]){let a=b.outboundLayer,d=b.inputTensors,e=b.outputTensors,f=[];for(let a of d)a.id in c&&f.push(c[a.id]);if(f.length===d.length){let d,g,h,i,j={};if(null!=b.callArgs&&(j=b.callArgs),1===f.length){let[b,c]=f[0];null==j.mask&&(j.mask=c),h=i4(a.call(b,j)),i=i4(a.computeMask(b,c)),d=[b],g=[c]}else d=f.map(a=>a[0]),g=f.map(a=>a[1]),null==j.mask&&(j.mask=g),h=i4(a.call(d,j)),i=i4(a.computeMask(d,g));if(a.activityRegularizer)throw new iZ("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let a=0;a<e.length;++a){let b=e[a],d=h[a],f=i[a];c[b.id]=[d,f]}}}let d=[],e=[],f=[];for(let a of this.outputs){i1(a.id in c,`Could not compute output ${a.name} : ${a.id}`);let[b,g]=c[a.id];f.push(b.shape),d.push(b),e.push(g)}return[d,e,f]}buildNodeConversionMap(a){let b,c={};for(let a of this.layers){b=+(a instanceof m9);for(let d=0;d<a.inboundNodes.length;d++){let e=m9.nodeKey(a,d);this.containerNodes.has(e)&&(c[e]=b,b+=1)}}return c}getLayer(a,b){if(null!=b)return this.findLayer(b);if(null==a)throw new iY("Provide either a layer name or layer index");if("number"==typeof a)return this.findLayer(a);for(let b of this.layers)if(b.name===a)return b;throw new iY(`No such layer: ${a}`)}findLayer(a){if(!(this.layers.length<=a))return this.layers[a];throw new iY(`Was asked to retrieve layer at index ${a}, but model only has ${this.layers.length} layer(s).`)}calculateLosses(){return dT(()=>{let a=[];for(let b of this.layers)for(let c=0;c<b.inboundNodes.length;++c){let d=m9.nodeKey(b,c);this.containerNodes.has(d)&&a.push(...b.calculateLosses())}return a})}getConfig(){let a={name:this.name},b=this.buildNodeConversionMap(this.layers),c=[];for(let a of this.layers){let d=a.getClassName(),e=a.getConfig(),f=[];for(let c=0;c<a.inboundNodes.length;c++){let d=a.inboundNodes[c],e=m9.nodeKey(a,c),g={};if(this.containerNodes.has(e)){if(d.callArgs)try{JSON.stringify(d.callArgs),g=d.callArgs}catch(b){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),g={}}if(d.inboundLayers.length>0){let a=[];for(let c=0;c<d.inboundLayers.length;c++){let e=d.inboundLayers[c],f=d.nodeIndices[c],h=d.tensorIndices[c],i=b[m9.nodeKey(e,f)];null==i&&(i=0),a.push([e.name,i,h,g])}f.push(a)}}}let g={};g.name=a.name,g.className=d,g.config=e,g.inboundNodes=f,c.push(g)}a.layers=c;let d=[];for(let a=0;a<this.inputLayers.length;a++){let c=this.inputLayers[a],e=this.inputLayersNodeIndices[a],f=m9.nodeKey(c,e);if(!this.containerNodes.has(f))continue;let g=b[f];null==g&&(g=0);let h=this.inputLayersTensorIndices[a];d.push([c.name,g,h])}a.inputLayers=d;let e=[];for(let a=0;a<this.outputLayers.length;a++){let c=this.outputLayers[a],d=this.outputLayersNodeIndices[a],f=m9.nodeKey(c,d);if(!this.containerNodes.has(f))continue;let g=b[f];null==g&&(g=0);let h=this.outputLayersTensorIndices[a];e.push([c.name,g,h])}return a.outputLayers=e,a}static fromConfig(a,b,c={},d=!1){let e={},f={};function g(a,b){a.name in f?f[a.name].push(b):f[a.name]=[b]}let h=b.name,i=b.layers;for(let a of i)!function(a){let c=a.name,f=mM(a,null!=b.customObjects?b.customObjects:{});f.setFastWeightInitDuringBuild(d),e[c]=f,a.inboundNodes.forEach(a=>{if(!(a instanceof Array))throw new iY(`Corrupted configuration, expected array for nodeData: ${a}`);g(f,a)})}(a);for(;!function(a){if(null==a)throw new iY(`Invalid value in obj: ${JSON.stringify(a)}`);for(let b in a)if(a.hasOwnProperty(b))return!1;return!0}(f);)for(let a of i){let b=e[a.name];if(b.name in f){let a=f[b.name];for(let c of(delete f[b.name],a))!function(a,b){let c,d=[];for(let f of b){let h=f[0],i=f[1],j=f[2];if(c=null==f[3]?{}:f[3],!(h in e))return void g(a,b);let k=e[h];if(k.inboundNodes.length<=i)return void g(a,b);let l=k.inboundNodes[i];d.push(l.outputTensors[j])}d.length>0&&a.apply(i3(d),c)}(b,c)}}let j=[],k=[];for(let a of b.inputLayers){let b=a[0],c=a[1],d=a[2];i1(b in e);let f=e[b].inboundNodes[c].outputTensors;j.push(f[d])}for(let a of b.outputLayers){let b=a[0],c=a[1],d=a[2];i1(b in e);let f=e[b].inboundNodes[c].outputTensors;k.push(f[d])}return new a({inputs:j,outputs:k,name:h})}get stateful(){if(this._stateful)throw new iY("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let a of this.layers)if(a.stateful)return!0;return!1}resetStates(){dT(()=>{this.layers.forEach(a=>{a.stateful&&a.resetStates()})})}}var iV=iV;function na(a,b){var c="classWeight";let d=b.length;if(null==a||Array.isArray(a)&&0===a.length)return b.map(a=>null);if(1===d)if(Array.isArray(a)&&1===a.length)return a;else if("object"==typeof a&&b[0]in a)return[a[b[0]]];else return[a];if(Array.isArray(a)){if(a.length!==d)throw Error(`Provided ${c} is an array of ${a.length} element(s), but the model has ${d} outputs. Make sure a set of weights is provided for each model output.`);return a}if("object"==typeof a&&Object.keys(a).length>0&&"object"==typeof a[Object.keys(a)[0]]){let c=[];return b.forEach(b=>{b in a?c.push(a[b]):c.push(null)}),c}throw Error(`The model has multiple (${d}) outputs, so ${c} must be either an array with ${d} elements or an object with ${b} keys. Provided ${c} not understood: ${JSON.stringify(a)}`)}async function nb(a,b,c,d){if(null!=b||null!=d)throw Error("Support sampleWeight is not implemented yet");if(null==c)return null;{let b=dT(()=>{if(1===a.shape.length)return ew(a);if(2===a.shape.length)if(a.shape[1]>1)return hG(a,1);else if(1===a.shape[1])return e4(a,[a.shape[0]]);else throw Error(`Encountered unexpected last-dimension size (${a.shape[1]}) during handling of class weights. The size is expected to be >= 1.`);throw Error(`Unexpected rank of target (y) tensor (${a.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),d=Array.from(await b.data());dU(b);let e=[];return d.forEach(a=>{if(null==c[a])throw Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);e.push(c[a])}),jE(e,"float32")}}function nc(a,b){let c,d;c=b.xs,d=b.ys,iV.assert(null!=c&&null!=d,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${b}`);let e=nd("input",a.inputNames,c),f=nd("output",a.outputNames,d),g=e[0].shape[0];iV.assert(e.length===a.inputs.length,()=>`LayersModel has ${a.inputs.length} inputs, but the dataset provides ${e.length} inputs.  (Expected input keys: ${JSON.stringify(a.inputNames)})`),iV.assert(f.length===a.outputs.length,()=>`LayersModel has ${a.outputs.length} outputs, but the dataset provides ${f.length} outputs.  (Expected output keys: ${JSON.stringify(a.outputNames)})`);for(let b=0;b<e.length;b++)iV.assert(e[b].shape[0]===g,()=>`Batch size mismatch: input ${a.inputNames[b]} has ${e[b].shape[0]}; expected  ${g} based on input ${a.inputNames[0]}.`);for(let b=0;b<f.length;b++)iV.assert(f[b].shape[0]===g,()=>`Batch size mismatch: output ${a.outputNames[b]} has ${f[b].shape[0]}; expected  ${g} based on input ${a.inputNames[0]}.`);return{xs:e,ys:f}}function nd(a,b,c){if(c instanceof dk)return[c];if(Array.isArray(c))return iV.assert(c.length===b.length,()=>`Received an array of ${c.length} Tensors, but expected ${b.length} to match the ${a} keys ${b}.`),c;{let d=[];for(let e of b){if(null==c[e])throw new iY(`The feature data generated by the dataset lacks the required ${a} key '${e}'.`);d.push(c[e])}return d}}async function ne(a,b,c){let d=null!=c.batchesPerEpoch;if(iV.assert(null!=a.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),iV.assert(null!=c,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),iV.assert(null!=c.epochs&&c.epochs>0&&Number.isInteger(c.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${c.epochs}`),iV.assert(!d||c.batchesPerEpoch>0&&Number.isInteger(c.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${c.batchesPerEpoch}`),iV.assert(null==c.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),a.isTraining)throw Error("Cannot start training because another fit() call is ongoing.");a.isTraining=!0;try{var e,f;let g,h,i,j,k=null!=c.validationData;if(k)if(nf(c.validationData))iV.assert(null==c.validationBatches||c.validationBatches>0&&Number.isInteger(c.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${c.validationBatches}`);else{let a=function(a){if(3===a.length)throw new iZ("Validation with sample weights is not implemented yet.");return{xs:a[0],ys:a[1]}}(c.validationData);h=a.xs,i=a.ys}let l=a.makeTrainFunction(),m=a.getDedupedMetricsNames();j=k?m.slice().concat(m.map(a=>"val_"+a)):m.slice();let n=mo(c.callbacks,c.yieldEvery),o=null==c.verbose?1:c.verbose,{callbackList:p,history:q}=mq(n,o,c.epochs,null,null,(e=b,f=c,g=null,null!=f.batchesPerEpoch?g=f.batchesPerEpoch:Number.isFinite(e.size)&&(g=e.size),g),null,k,j);p.setModel(a),a.history=q,await p.onTrainBegin(),a.stopTraining_=!1;let r=null==c.initialEpoch?0:c.initialEpoch,s=await b.iterator();for(;r<c.epochs;){let e={};await p.onEpochBegin(r);let f=0,g=0;for(d||(s=await b.iterator());!d||f<c.batchesPerEpoch;){let b=await s.next();if(d&&b.done){console.warn(`You provided \`batchesPerEpoch\` as ${c.batchesPerEpoch}, but your dataset iterator ran out of data after ${f} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${c.batchesPerEpoch*c.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=b.value){let{xs:d,ys:e}=nc(a,b.value),h={};h.batch=g,h.size=d[0].shape[0],await p.onBatchBegin(g,h);let i=[];if(null!=c.classWeight){let b=na(c.classWeight,a.outputNames);for(let a=0;a<b.length;++a)i.push(await nb(e[a],null,b[a]))}let j=d.concat(e).concat(i),k=l(j);dU(j);for(let a=0;a<m.length;++a){let b=m[a],c=k[a];h[b]=c,dV(c)}await p.onBatchEnd(g,h),mi(h),g++,f++}if(d?f>=c.batchesPerEpoch:b.done){if(k){let b;b=nf(c.validationData)?i4(await a.evaluateDataset(c.validationData,{batches:c.validationBatches})):i4(a.evaluate(h,i,{batchSize:null==c.validationBatchSize?32:c.validationBatchSize,verbose:0}));for(let c=0;c<a.metricsNames.length;++c)e[`val_${a.metricsNames[c]}`]=b[c]}break}if(a.stopTraining_)break}if(await p.onEpochEnd(r,e),r++,a.stopTraining_)break}return await p.onTrainEnd(),await a.history.syncData(),a.history}finally{a.isTraining=!1}}function nf(a){return"function"==typeof a.iterator}async function ng(a,b,c){let d=null!=(c=c||{}).batches,e=a.testFunction,f=[];if(c.verbose>0)throw new iZ("Verbose mode is not implemented yet.");iV.assert(!d||c.batches>0&&Number.isInteger(c.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(c.batches)}`);let g="function"==typeof b.next?b:await b.iterator(),h=0,i=0;for(;!d||i<c.batches;){let b=await g.next();if(f=dT(()=>{if(b.value){let{xs:c,ys:d}=nc(a,b.value),g=c.concat(d),j=dT(()=>e(g));if(dU(g),0===i)for(let a=0;a<j.length;++a)f.push(eG(0));let k=g[0].shape[0];for(let a=0;a<j.length;++a){let b=j[a],c=f[a];f[a]=dT(()=>ey(f[a],eB(k,b))),i>0&&dU(c)}dU(j),h+=k,++i}return f}),b.done){d&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${c.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let a=0;a<f.length;++a){let b=f[a];f[a]=eA(f[a],h),dU(b)}return i3(f)}var iV=iV;function nh(a){iV.assert(a>0&&Number.isInteger(a),()=>`batchSize is required to be a positive integer, but got ${a}`)}function ni(a,b,c){return null==a?[null]:Array.isArray(a)?a.map(a=>kX(a,b,c-b)):kX(a,b,c-b)}function nj(a,b){return dT(()=>null==a?null:Array.isArray(a)?a.map(a=>nj(a,b)):k3(a,"int32"===b.dtype?b:ev(b,"int32")))}function nk(a,b){let c=[],d=0,e=null;for(;d<a;)(e=d+b)>=a&&(e=a),c.push([d,e]),d=e;return c}function nl(a){let b=[];a instanceof dk&&(a=[a]);for(let c=0;c<a.length;++c){let d=a[c];if(1===d.rank)b.push(kW(d,1));else if(0===d.rank)throw Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");else b.push(d)}return b}function nm(a,b){if(null==a)return;let c=[];if(b instanceof dk)c.push(b.id);else if(Array.isArray(b))b.forEach(a=>c.push(a.id));else if(null!=b)for(let a in b){let d=b[a];c.push(d.id)}let d=[];if(a instanceof dk)-1===c.indexOf(a.id)&&d.push(a);else if(Array.isArray(a))a.forEach(a=>{-1===c.indexOf(a.id)&&d.push(a)});else if(null!=a)for(let b in a){let e=a[b];-1===c.indexOf(e.id)&&d.push(e)}d.forEach(a=>{a.isDisposed||a.dispose()})}function nn(a){return Array.isArray(a)}function no(a){return!(a instanceof dk)&&!nn(a)}function np(a,b,c,d=!0,e=""){let f;if(null==b||0===b.length){if(null!=a){let b=!1;if(nn(a)&&a.length>0)b=!0;else if(no(a)){for(let c in a)if(a.hasOwnProperty(c)){b=!0;break}}else b=!0;if(b)throw new iY(`Error when checking model ${e} expected no data, but got ${a}`)}return[]}if(null==a)return b.map(a=>null);if(no(a))for(let c of(f=[],b)){if(null==a[c])throw new iY(`No data provided for "${c}". Need data for each key in: ${b}`);f.push(a[c])}else if(nn(a)){if(a.length!==b.length)throw new iY(`Error when checking model ${e}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${b.length} Tensor(s), but instead got the following list of Tensor(s): ${a}`);f=a}else{if(b.length>1)throw new iY(`The model ${e} expects ${b.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${a.shape}`);f=[a]}if(f=nl(f),null!=c)for(let a=0;a<b.length;++a){if(null==c[a])continue;let g=f[a];if(g.shape.length!==c[a].length)throw new iY(`Error when checking ${e}: expected ${b[a]} to have ${c[a].length} dimension(s). but got array with shape ${g.shape}`);for(let b=0;b<c[a].length;++b){if(0===b&&!d)continue;let f=g.shape[b],h=c[a][b];if(null!=h&&h>=0&&f!==h)throw new iY(`${e} expected a batch of elements where each example has shape [${c[a].slice(1,c[a].length)}] (i.e.,tensor shape [*,${c[a].slice(1,c[a].length)}]) but the ${e} received an input with ${g.shape[0]} examples, each with shape [${g.shape.slice(1,g.shape.length)}] (tensor shape [${g.shape}])`)}}return f}function nq(a,b,c,d=!0,e=""){let f;if(Array.isArray(a)){if(a.length!==b.length)throw new iY(`Error when checking model ${e}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${b.length} Tensor(s), but instead got ${a.length} Tensors(s).`);f=a}else{if(b.length>1)throw new iY(`The model expects ${b.length} ${e} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(a.shape)}.`);f=[a]}if(null!=c)for(let a=0;a<b.length;++a){if(null==c[a])continue;let g=f[a];if(g.shape.length!==c[a].length)throw new iY(`Error when checking ${e}: expected ${b[a]} to have ${c[a].length} dimension(s), but got array with shape ${JSON.stringify(g.shape)}`);for(let f=0;f<c[a].length;++f){if(0===f&&!d)continue;let h=g.shape[f],i=c[a][f];if(null!=i&&i!==h)throw new iY(`Error when checking ${e}: expected ${b[a]} to have shape ${JSON.stringify(c[a])} but got array with shape ${JSON.stringify(g.shape)}.`)}}}class nr extends m9{constructor(a){super(a),this.isTraining=!1}summary(a,b,c=console.log){if(!this.built)throw new iY("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(a,b,c,d=console.log){var e;let f,g=function(a){let b=!0,c=[],d=[];for(let b in a.nodesByDepth)c.push(a.nodesByDepth[b]);for(let a of c){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){b=!1;break}d.push(...a)}if(b)for(let c of a.layers){let a=!1;for(let e of c.inboundNodes)if(-1!==d.indexOf(e))if(a){b=!1;break}else a=!0;if(!b)break}return b}(a),h=["Layer (type)","Input Shape","Output shape","Param #"];if(g?(b=b||90,c=c||[.32,.61,.89,1]):(b=b||115,c=c||[.24,.48,.7,.8,1]),c[c.length-1]<=1&&(c=c.map(a=>Math.floor(b*a))),!g)for(let b in h.push("Receives inputs"),f=[],a.nodesByDepth)f.push(...a.nodesByDepth[b]);d("_".repeat(b)),m5(h,c,d),d("=".repeat(b));let i=a.layers;for(let a=0;a<i.length;++a)g?function(a,b,c){let d,e;try{e=a.inboundNodes.map(a=>JSON.stringify(a.inputShapes)).join(",")}catch(a){e="multiple"}try{d=JSON.stringify(a.outputShape)}catch(a){d="multiple"}let f=a.name,g=a.getClassName();m5([`${f} (${g})`,e,d,a.countParams().toString()],b,c)}(i[a],c,d):function(a,b,c,d){let e,f;try{f=a.inboundNodes.map(a=>JSON.stringify(a.inputShapes)).join(",")}catch(a){f="multiple"}try{e=JSON.stringify(a.outputShape)}catch(a){e="multiple"}let g=[];for(let b of a.inboundNodes)if(null==c||!(c.length>0)||-1!==c.indexOf(b))for(let a=0;a<b.inboundLayers.length;++a){let c=b.inboundLayers[a].name,d=b.nodeIndices[a],e=b.tensorIndices[a];g.push(`${c}[${d}][${e}]`)}let h=a.name,i=a.getClassName(),j=0===g.length?"":g[0];m5([`${h} (${i})`,f,e,a.countParams().toString(),j],b,d);for(let a=1;a<g.length;++a)m5(["","","","",g[a]],b,d)}(i[a],c,f,d),d((a===i.length-1?"=":"_").repeat(b));a.checkTrainableWeightsConsistency();let j=null!=(e=a).collectedTrainableWeights?lw(e.collectedTrainableWeights):lw(e.trainableWeights),k=lw(a.nonTrainableWeights);d(`Total params: ${j+k}`),d(`Trainable params: ${j}`),d(`Non-trainable params: ${k}`),d("_".repeat(b))}(this,a,b,c)}compile(a){if(null==a.loss&&(a.loss=[]),this.loss=a.loss,"string"==typeof a.optimizer)this.optimizer_=function(a){let b={Adagrad:()=>m3.adagrad(.01),Adadelta:()=>m3.adadelta(1,.95,kU()),Adam:()=>m3.adam(.001,.9,.999,kU()),Adamax:()=>m3.adamax(.002,.9,.999,kU(),0),RMSProp:()=>m3.rmsprop(.001,.9,0,kU()),SGD:()=>m3.sgd(.01)};if(b.adagrad=b.Adagrad,b.adadelta=b.Adadelta,b.adam=b.Adam,b.adamax=b.Adamax,b.rmsprop=b.RMSProp,b.sgd=b.SGD,a in b)return b[a]();throw new iY(`Unknown Optimizer ${a}`)}(a.optimizer),this.isOptimizerOwned=!0;else{if(!(a.optimizer instanceof eN))throw new iY("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=a.optimizer,this.isOptimizerOwned=!1}let b=[];if(Array.isArray(a.loss)||"string"==typeof a.loss||"function"==typeof a.loss)if(Array.isArray(a.loss)){if(a.loss.length!==this.outputs.length)throw new iY(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${a.loss}.`);b=a.loss.map(a=>mW(a))}else{let c=mW(a.loss);this.outputs.forEach(a=>{b.push(c)})}else{for(let b in a.loss=a.loss,a.loss)if(-1===this.outputNames.indexOf(b))throw new iY(`Unknown entry in loss dictionary: "${b}". Only expected the following keys: ${this.outputNames}`);for(let c of this.outputNames)null==a.loss[c]&&console.warn(`Output "${c}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${c} during training`),b.push(mW(a.loss[c]))}this.lossFunctions=b,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let b=this.internalOutputShapes[a],c=this.outputNames[a];this.feedOutputNames.push(c),this.feedOutputShapes.push(b),this.feedLossFns.push(this.lossFunctions[a])}let c=[];this.metrics=a.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ju("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(-1!==c.indexOf(a))continue;let b=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([b,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let d=function(a,b){let c;if(null==a||Array.isArray(a)&&0===a.length)return b.map(a=>[]);if("string"==typeof a||"function"==typeof a)c=[a];else if(Array.isArray(a)||"object"==typeof a)c=a;else throw TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${a}`);if(Array.isArray(c))return b.map(a=>c);{let a=[];for(let d of b){let b=c.hasOwnProperty(d)?c[d]:[];Array.isArray(b)||(b=[b]),a.push(b)}return a}}(a.metrics,this.outputNames),e=(a,b,c)=>{this.outputNames.length>1&&(b=this.outputNames[a]+"_"+b),this.metricsNames.push(b),this.metricsTensors.push([c,a])};ju("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(-1===c.indexOf(a))(b=>{let c,d,f;for(let g of b){let b;if("string"==typeof g&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(g)){let b,e=this.internalOutputShapes[a];1===e[e.length-1]||this.lossFunctions[a]===mT?-1!==["accuracy","acc"].indexOf(g)?d=mX:-1!==["crossentropy","ce"].indexOf(g)&&(d=m_):this.lossFunctions[a]===mS?-1!==["accuracy","acc"].indexOf(g)?d=m0:-1!==["crossentropy","ce"].indexOf(g)&&(d=mS):-1!==["accuracy","acc"].indexOf(g)?d=mY:-1!==["crossentropy","ce"].indexOf(g)&&(d=mR),-1!==["accuracy","acc"].indexOf(g)?b="acc":-1!==["crossentropy","ce"].indexOf(g)&&(b="ce"),f=d,c=""+b}else f=function(a){if("string"==typeof a&&a in m1)return m1[a];if("string"!=typeof a&&null!=a)return a;throw new iY(`Unknown metric ${a}`)}(g),c=""+m2(g);ju(c,()=>{b=f}),e(a,c,b)}})(d[a])}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(a,b,c={}){let d=null==c.batchSize?32:c.batchSize;nh(d);let e=this.standardizeUserDataXY(a,b,!0,d);try{let a=e[0].concat(e[1]);this.makeTestFunction();let b=this.testFunction,f=this.testLoop(b,a,d,c.verbose,c.steps);return i3(f)}finally{nm(e[0],a),nm(e[1],b)}}async evaluateDataset(a,b){return this.makeTestFunction(),ng(this,a,b)}checkNumSamples(a,b,c,d="steps"){let e;if(null!=c){if(e=null,null!=b)throw new iY(`If ${d} is set, batchSize must be null or undefined.Got batchSize = ${b}`)}else if(null!=a)e=Array.isArray(a)?a[0].shape[0]:a.shape[0];else throw new iY(`Either the input data should have a defined shape, or ${d} shoud be specified.`);return e}execute(a,b){if(Array.isArray(b)&&0===b.length)throw new iY("`outputs` is an empty Array, which is not allowed.");let c=Array.isArray(b),d=c?b:[b],e=this.retrieveSymbolicTensors(d),f=new lK;if(a instanceof dk&&(a=[a]),Array.isArray(a)){if(a.length!==this.inputs.length)throw new iY(`The number of inputs provided (${a.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let b=0;b<this.inputs.length;++b)f.add(this.inputs[b],a[b])}else for(let b of this.inputs){let c=a[b.name];if(null==c)throw new iY(`No value is provided for the model's input ${b.name}`);f.add(b,c)}let g=lN(e,f);return c?g:g[0]}retrieveSymbolicTensors(a){let b=i0(null,a.length),c=a.length;for(let d of this.layers){let e=Array.isArray(d.output)?d.output:[d.output],f=e.map(a=>a.name);for(let d=0;d<a.length;++d){let g=f.indexOf(a[d]);if(-1!==g&&(b[d]=e[g],c--),0===c)break}if(0===c)break}if(c>0){let c=[];throw b.forEach((b,d)=>{null==b&&c.push(a[d])}),new iY(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(c)}`)}return b}predictLoop(a,b=32,c=!1){return dT(()=>{let d=this.checkNumSamples(a);if(c)throw new iZ("Verbose predictLoop() is not implemented yet.");let e=nk(d,b),f=this.outputs.map(a=>[]);for(let b=0;b<e.length;++b)dT(()=>{let c=ni(a,e[b][0],e[b][1]),d=[];if(Array.isArray(c))for(let a=0;a<c.length;++a)d.push({key:this.inputs[a],value:c[a]});else d.push({key:this.inputs[0],value:c});let f=new lK(d);return lN(this.outputs,f)}).forEach((a,b)=>f[b].push(a));return i3(f.map(a=>hy(a,0)))})}predict(a,b={}){let c=nl(a);nq(c,this.inputNames,this.feedInputShapes,!1);try{let a=null==b.batchSize?32:b.batchSize;return nh(a),this.predictLoop(c,a)}finally{nm(c,a)}}predictOnBatch(a){nq(a,this.inputNames,this.feedInputShapes,!0);let b=(Array.isArray(a)?a[0]:a).shape[0];return this.predictLoop(a,b)}standardizeUserDataXY(a,b,c=!0,d){if(null==this.optimizer_)throw new iX("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let e=[];for(let a=0;a<this.feedOutputShapes.length;++a){let b=this.feedOutputShapes[a];this.feedLossFns[a]===mS?e.push(b.slice(0,b.length-1).concat([1])):e.push(b)}a=np(a,this.feedInputNames,this.feedInputShapes,!1,"input"),b=np(b,this.feedOutputNames,e,!1,"target");var f=a,g=b;let h=jb(f.map(a=>a.shape[0]));h.sort();let i=jb(g.map(a=>a.shape[0]));if(i.sort(),h.length>1)throw new iY(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(f.map(a=>a.shape))}`);if(i.length>1)throw new iY(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(g.map(a=>a.shape))}`);if(h.length>0&&i.length>0&&!iV.arraysEqual(h,i))throw new iY(`Input Tensors should have the same number of samples as target Tensors. Found ${h[0]} input sample(s) and ${i[0]} target sample(s).`);if(!function(a,b,c){let d=[mO,mT,mR];for(let e=0;e<a.length;++e){let f=a[e],g=b[e],h=c[e];if(null!=g){if(g===mR&&1===f.shape[f.shape.length-1])throw new iY(`You are passing a target array of shape ${f.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==d.indexOf(g)){let a=f.shape.slice(1),b=h.slice(1);for(let c=0;c<a.length;++c){let d=a[c],e=b[c];if(null!=e&&d!==e)throw new iY(`A target Tensor with shape ${f.shape} was passed for an output of shape ${h}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(b,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=d&&d>0&&a[0].shape[0]%d!=0)throw new iY(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${d}. Found: ${a[0].shape[0]} sample(s).`);return[a,b]}async standardizeUserData(a,b,c,d,e=!0,f){let[g,h]=this.standardizeUserDataXY(a,b,e,f);if(null!=c)throw Error("sample weight is not supported yet.");let i=null;if(null!=d){let a=na(d,this.outputNames);i=[];for(let b=0;b<a.length;++b)i.push(await nb(h[b],null,a[b]))}return[g,h,i]}testLoop(a,b,c,d=0,e){return dT(()=>{let f=this.checkNumSamples(b,c,e,"steps"),g=[];if(d>0)throw new iZ("Verbose mode is not implemented yet.");if(null!=e)throw new iZ("steps mode in testLoop() is not implemented yet");{let d=nk(f,c),e=jE(kT(0,f));for(let c=0;c<d.length;++c){let f=d[c][0],h=d[c][1],i=a(nj(b,kX(e,f,h-f)));if(0===c)for(let a=0;a<i.length;++a)g.push(eG(0));for(let a=0;a<i.length;++a){let b=i[a];g[a]=ey(g[a],eB(h-f,b))}}for(let a=0;a<g.length;++a)g[a]=eA(g[a],f)}return g})}getDedupedMetricsNames(){let a=this.metricsNames,b=[];for(let c=0;c<a.length;++c){let d=a[c],e=d;if(i2(a,d)>1){let b=i2(a.slice(0,c),d);e+=`_${b}`}b.push(e)}return b}makeTrainFunction(){return a=>{let b=[],c=a.slice(0,this.inputs.length),d=a.slice(this.inputs.length,this.inputs.length+this.outputs.length),e=a.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),f=[],g=()=>{let a,g=[];for(let a=0;a<this.inputs.length;++a)g.push({key:this.inputs[a],value:c[a]});let h=new lK(g),i=lN(this.outputs,h,{training:!0});for(let c=0;c<this.lossFunctions.length;++c){let f=(0,this.lossFunctions[c])(d[c],i[c]);null!=e[c]&&(f=eB(f,e[c]));let g=ii(f);b.push(g),a=0===c?f:ey(a,f)}for(let a=0;a<this.metricsTensors.length;++a){let c;if(this.outputs.length>1&&a<this.outputs.length)c=b[a];else{let b=this.metricsTensors[a][0],e=this.metricsTensors[a][1];c=ii(b(d[e],i[e]))}dV(c),f.push(c)}return a=ii(a),this.calculateLosses().forEach(b=>{a=ey(a,b)}),a},h=this.collectedTrainableWeights.map(a=>a.read());return[this.optimizer_.minimize(g,!0,h)].concat(f)}}makeTestFunction(){this.testFunction=a=>dT(()=>{let b,c=[],d=a.slice(0,this.inputs.length),e=a.slice(this.inputs.length,this.inputs.length+this.outputs.length),f=[];for(let a=0;a<this.inputs.length;++a)f.push({key:this.inputs[a],value:d[a]});let g=new lK(f),h=lN(this.outputs,g);for(let a=0;a<this.lossFunctions.length;++a){let d=ii((0,this.lossFunctions[a])(e[a],h[a]));b=0===a?d:ey(b,d),c.push(b)}for(let a=0;a<this.metricsTensors.length;++a){let b=this.metricsTensors[a][0],d=this.metricsTensors[a][1],f=ii(b(e[d],h[d]));c.push(f)}return c})}async fit(a,b,c={}){let d,e,f,g,h,i,j,k,l;if(this.isTraining)throw Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{let m,n,o,p=null==c.batchSize?32:c.batchSize;nh(p);let q=await this.standardizeUserData(a,b,c.sampleWeight,c.classWeight,!1,p);d=q[0],e=q[1],l=q[2];let r=!1;if(null!=c.validationData&&c.validationData.length>0){if(r=!0,2===c.validationData.length)h=c.validationData[0],i=c.validationData[1];else if(3===c.validationData.length)throw new iZ("validationData including sample weights is not supported yet.");else throw new iY(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${c.validationData} is invalid.`);let a=await this.standardizeUserData(h,i,null,null,!0,p);j=a[0],k=a[1],m=j.concat(k)}else if(null!=c.validationSplit&&c.validationSplit>0&&c.validationSplit<1){r=!0;let a=Math.floor(d[0].shape[0]*(1-c.validationSplit)),b=d[0].shape[0];j=ni(d,a,b),f=d,d=ni(d,0,a),k=ni(e,a,b),g=e,e=ni(e,0,a),m=j.concat(k)}else null!=c.validationSteps&&(r=!0);let s=d.concat(e).concat(l);this.checkTrainableWeightsConsistency();let t=this.makeTrainFunction(),u=this.getDedupedMetricsNames();r?(this.makeTestFunction(),n=this.testFunction,o=u.slice().concat(u.map(a=>"val_"+a))):(n=null,m=[],o=u.slice());let v=mo(c.callbacks,c.yieldEvery);return await this.fitLoop(t,s,u,p,c.epochs,c.verbose,v,n,m,c.shuffle,o,c.initialEpoch,null,null)}finally{this.isTraining=!1,nm(d,a),nm(e,b),nm(f,a),nm(g,b),nm(j,h),nm(k,i),null!=l&&dU(l)}}async fitLoop(a,b,c,d,e,f,g,h,i,j,k,l,m,n){let o;null==d&&(d=32),null==e&&(e=1),null==j&&(j=!0),null==l&&(l=0);let p=!1;if(null!=h&&null!=i&&(p=!0),null!=n&&(p=!0,null==m))throw new iY("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let q=this.checkNumSamples(b,d,m,"steps_per_epoch");null!=q&&(o=kT(0,q)),null==f&&(f=1);let{callbackList:r,history:s}=mq(g,f,e,l,q,m,d,p,k);r.setModel(this),this.history=s,await r.onTrainBegin(),this.stopTraining_=!1;for(let f=l;f<e;++f){await r.onEpochBegin(f);let e={};if(null!=m)throw new iZ("stepsPerEpoch mode is not implemented yet.");{if("batch"===j)throw new iZ("batch shuffling is not implemneted yet");j&&iV.shuffle(o);let f=jE(o),g=nk(q,d);for(let j=0;j<g.length;++j){let k={};if(await r.onBatchBegin(j,k),dT(()=>{let l=g[j][0],m=g[j][1],n=kX(f,l,m-l);k.batch=j,k.size=m-l;let o=a(nj(b,n));for(let a=0;a<c.length;++a){let b=c[a],d=o[a];k[b]=d,dV(d)}if(j===g.length-1&&p){let a=this.testLoop(h,i,d);for(let b=0;b<c.length;++b){let d=c[b],f=a[b];dV(f),e["val_"+d]=f}}}),await r.onBatchEnd(j,k),mi(k),this.stopTraining_)break}f.dispose()}if(await r.onEpochEnd(f,e),this.stopTraining_)break}return await r.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(a,b){return ne(this,a,b)}async trainOnBatch(a,b){let c=await this.standardizeUserData(a,b),d=c[0],e=c[1],f=this.makeTrainFunction()(d.concat(e)),g=[];for(let a of f){let b=await a.data();g.push(b[0])}return dU(f),nm(c[0],a),nm(c[1],b),i3(g)}getNamedWeights(a){let b=[],c=null!=a&&a.trainableOnly,d=c?this.trainableWeights:this.weights,e=this.getWeights(c);for(let a=0;a<d.length;++a)(!c||d[a].trainable)&&b.push({name:d[a].originalName,tensor:e[a]});return b}set stopTraining(a){this.stopTraining_=a}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(a){this.optimizer_!==a&&(this.optimizer_=a,this.isOptimizerOwned=!1)}dispose(){let a=super.dispose();if(0===a.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){let b=dS().numTensors;this.optimizer_.dispose(),a.numDisposedVariables+=b-dS().numTensors}return a}getLossIdentifiers(){let a;if("string"==typeof this.loss)a=i5(this.loss);else if(Array.isArray(this.loss)){for(let a of this.loss)if("string"!=typeof a)throw Error("Serialization of non-string loss is not supported.");a=this.loss.map(a=>i5(a))}else{let b=Object.keys(this.loss);a={};let c=this.loss;for(let d of b)if("string"==typeof c[d])a[d]=i5(c[d]);else throw Error("Serialization of non-string loss is not supported.")}return a}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[i5(m2(this.metrics))];{if(Array.isArray(this.metrics))return this.metrics.map(a=>i5(m2(a)));let a={};for(let b in this.metrics)a[b]=i5(m2(this.metrics[b]));return a}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(a){let b,c;if(null!=a.weighted_metrics)throw Error("Loading weight_metrics is not supported yet.");if(null!=a.loss_weights)throw Error("Loading loss_weights is not supported yet.");if(null!=a.sample_weight_mode)throw Error("Loading sample_weight_mode is not supported yet.");let d=mM(m7(a.optimizer_config));if("string"==typeof a.loss)b=i6(a.loss);else if(Array.isArray(a.loss))b=a.loss.map(a=>i6(a));else if(null!=a.loss)for(let c in b={},a.loss)b[c]=i6(a.loss[c]);if(Array.isArray(a.metrics))c=a.metrics.map(a=>i6(a));else if(null!=a.metrics)for(let b in c={},a.metrics)c[b]=i6(a.metrics[b]);this.compile({loss:b,metrics:c,optimizer:d})}async save(a,b){if("string"==typeof a){let b=mL.getSaveHandlers(a);if(0===b.length)throw new iY(`Cannot find any save handlers for URL '${a}'`);if(b.length>1)throw new iY(`Found more than one (${b.length}) save handlers for URL '${a}'`);a=b[0]}if(null==a.save)throw new iY("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let c=await mL.encodeWeights(this.getNamedWeights(b)),d={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${m8}`,convertedBy:null};if(null!=b&&b.includeOptimizer&&null!=this.optimizer){d.trainingConfig=this.getTrainingConfig();let{data:a,specs:b}=await mL.encodeWeights(await this.optimizer.getWeights(),"optimizer");c.specs.push(...b),c.data=mL.concatenateArrayBuffers([c.data,a])}return null!=this.userDefinedMetadata&&(m4(this.userDefinedMetadata,this.name,!0),d.userDefinedMetadata=this.userDefinedMetadata),d.weightData=c.data,d.weightSpecs=c.specs,a.save(d)}setUserDefinedMetadata(a){m4(a,this.name),this.userDefinedMetadata=a}getUserDefinedMetadata(){return this.userDefinedMetadata}}nr.className="Model",jg.registerClass(nr);class ns extends nr{}ns.className="Functional",jg.registerClass(ns);var mL=mL,jg=jg,iV=iV;async function nt(a,b){"modelTopology"in a||(a={modelTopology:a});let c=a.modelTopology;null!=c.model_config&&(c=c.model_config);let d=mM(m7(c),b);if(null!=a.weightsManifest){let b=await mL.loadWeights(a.weightsManifest,a.pathPrefix,d.weights.map(a=>a.originalName)),c={};for(let a of d.weights)c[a.originalName]=b[a.originalName];d.loadWeights(c),dU(b)}return d}class nu extends nr{constructor(a){if(super({inputs:[],outputs:[]}),a=a||{},this.trainable=!0,this.built=!1,this.name=null!=a.name?a.name:jj("sequential_"),null!=a.layers)for(const b of a.layers)this.add(b)}checkShape(a){if(a.inboundNodes[0].outputTensors[0].shape.some(a=>a<0))throw new iY(`Negative dimension size caused by adding layer ${a.name} with input shape [${a.inboundNodes[0].inputTensors[0].shape}]`)}add(a){let b,c=a instanceof nu||a instanceof nr;if(c){if(1!==(b=a).outputs.length)throw new iY("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==b.inputs.length)throw new iY("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===a.inboundNodes.length){if(null==a.batchInputShape)throw new iY("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let b=lJ({batchShape:a.batchInputShape,dtype:a.dtype,name:a.name+"_input"});a.apply(b)}if(c)this.outputs=b.outputs,this.inputs=b.inputs;else{if(1!==a.inboundNodes.length)throw new iY(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${a.name} which has ${a.inboundNodes.length} pre-existing inbound connections.`);if(1!==a.inboundNodes[0].outputTensors.length)throw new iY("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(a),this.outputs=[a.inboundNodes[0].outputTensors[0]],this.inputs=function a(b,c,d){if((null==c||null!=d&&d>0)&&(c=b.sourceLayer,d=b.nodeIndex),0===c.inboundNodes.length)return[b];{let b=c.inboundNodes[d];if(0===b.inboundLayers.length)return b.inputTensors;{let c=[];for(let d=0;d<b.inboundLayers.length;d++)for(let e of a(b.inputTensors[d],b.inboundLayers[d],b.nodeIndices[d]))-1===c.indexOf(e)&&c.push(e);return c}}}(this.outputs[0])}this.inboundNodes=[],new lF({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:i0(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(a=>a.shape),outputShapes:this.outputs[0].shape})}else{let b=a.apply(this.outputs[0]);if(Array.isArray(b))throw TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(a),this.outputs=[b],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(a),this.built=!1}pop(){if(0===this.layers.length)throw TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let a=this.layers.length-1;this.layers[a].outboundNodes=[],this.outputs=[this.layers[a].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(a,b){return null==this.model&&this.build(),this.model.call(a,b)}build(a){if(lv(a),0===this.inputs.length||0===this.outputs.length)throw TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new nr({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(a,b,c=console.log){this.built||this.build(),super.summary(a,b,c)}setWeights(a){null==this.model&&this.build(),this.model.setWeights(a)}evaluate(a,b,c={}){if(!this.built)throw new iX("The model needs to be compiled before being used.");return this.model.evaluate(a,b,c)}async evaluateDataset(a,b){if(!this.built)throw new iX("The model needs to be compiled before being used.");return this.model.evaluateDataset(a,b)}predict(a,b={}){return null==this.model&&this.build(),this.model.predict(a,b)}predictOnBatch(a){return null==this.model&&this.build(),this.model.predictOnBatch(a)}compile(a){this.build(),this.model.compile(a),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(a){this.model.optimizer=a}async fit(a,b,c={}){if(!this.built)throw new iX("The model needs to be compiled before being used.");return this.model.fit(a,b,c)}async fitDataset(a,b){if(!this.built)throw new iX("The model needs to be compiled before being used.");return this.model.fitDataset(a,b)}async trainOnBatch(a,b){return this.model.trainOnBatch(a,b)}static fromConfig(a,b,c={},d=!1){let e,f={};if(b instanceof Array){if(null==b[0].className||"Merge"===b[0].className)throw new iY("Legacy serialization format not supported yet.");e=b}else iV.assert(null!=b.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),e=b.layers,delete b.layers,f=b;let g=new a(f);if(!(g instanceof nu))throw new iZ(`Sequential.fromConfig called on non-Sequential input: ${g}`);for(let a of e){let b=mM(a,void 0,d);d&&b.setFastWeightInitDuringBuild(!0),g.add(b)}return g}set stopTraining(a){if(null==this.model)throw new iY("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=a}get stopTraining(){if(null==this.model)throw new iY("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let a=[];for(let b of this.layers){let c={};c.className=b.getClassName(),c.config=b.getConfig(),a.push(c)}return{name:this.name,layers:a}}}function nv(a){return lJ(a)}nu.className="Sequential",jg.registerClass(nu);var jg=jg,jg=jg;class nw extends jg.Serializable{getConfig(){return{}}}class nx extends nw{apply(a,b=1){return function(a,b=1){if(1!==b)throw new iZ(`Support for alpha values other than 1 (${b}) is not implemented yet.`);return gC(a)}(a,b)}}nx.className="elu",jg.registerClass(nx);class ny extends nw{apply(a){return ix(a)}}ny.className="selu",jg.registerClass(ny);class nz extends nw{apply(a){return gF(a)}}nz.className="relu",jg.registerClass(nz);class nA extends nw{apply(a){return dT(()=>ij(6,gF(a)))}}nA.className="relu6",jg.registerClass(nA);class nB extends nw{apply(a){return a}}nB.className="linear",jg.registerClass(nB);class nC extends nw{apply(a){return gH(a)}}nC.className="sigmoid",jg.registerClass(nC);class nD extends nw{apply(a){return dT(()=>hQ(ey(.5,eB(.2,a)),0,1))}}nD.className="hardSigmoid",jg.registerClass(nD);class nE extends nw{apply(a){return h9(a)}}nE.className="softplus",jg.registerClass(nE);class nF extends nw{apply(a){return dT(()=>eA(a,ey(eU(a),1)))}}nF.className="softsign",jg.registerClass(nF);class nG extends nw{apply(a){return iF(a)}}nG.className="tanh",jg.registerClass(nG);class nH extends nw{apply(a,b=-1){return iA(a,b)}}nH.className="softmax",jg.registerClass(nH);class nI extends nw{apply(a,b=-1){return ib(a,b)}}nI.className="logSoftmax",jg.registerClass(nI);class nJ extends nw{apply(a){return dT(()=>dT(()=>{let b=eB(.5,ey(1,hY(eA(a,Math.sqrt(2)))));return eB(a,b)}))}}nJ.className="gelu",jg.registerClass(nJ);class nK extends nw{apply(a){return dT(()=>eB(.5,eB(a,ey(1,iF(eB(eC(eA(2,Math.PI)),ey(a,eB(.044715,eR(a,3)))))))))}}nK.className="gelu_new",jg.registerClass(nK);class nL extends nw{apply(a){return dT(()=>eB(a,iF(h9(a))))}}nL.className="mish",jg.registerClass(nL);class nM extends nw{apply(a,b=1){return dT(()=>eB(gH(eB(a,b)),a))}}function nN(a){return a.getClassName()}function nO(a,b={}){return i9(a,jg.SerializationMap.getMap().classNameMap,b,"activation")}function nP(a){if(null==a){let a={};return a.className="linear",a.config={},nO(a)}if("string"==typeof a){let b={};return b.className=a,b.config={},nO(b)}return a instanceof nw?a:nO(a)}nM.className="swish",jg.registerClass(nM);var jg=jg;function nQ(a){if(null!=a&&"object"!=typeof a)throw Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${a}`)}class nR extends jg.Serializable{}class nS extends nR{constructor(a){super(),nQ(a),this.l1=null==a||null==a.l1?.01:a.l1,this.l2=null==a||null==a.l2?.01:a.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(a){return dT(()=>{let b=f4([1]);return this.hasL1&&(b=ey(b,e5(eB(this.l1,eU(a))))),this.hasL2&&(b=ey(b,e5(eB(this.l2,eB(a,a))))),e4(b,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(a,b){return new a({l1:b.l1,l2:b.l2})}}nS.className="L1L2",jg.registerClass(nS);let nT={l1l2:"L1L2"};function nU(a,b={}){return i9(a,jg.SerializationMap.getMap().classNameMap,b,"regularizer")}function nV(a){return null==a?null:"string"==typeof a?nU({className:a in nT?nT[a]:a,config:{}}):a instanceof nR?a:nU(a)}class nW extends lH{constructor(a){super(null==a?{}:a),this.supportsMasking=!0,null!=a&&(this.maxValue=a.maxValue)}call(a,b){let c=gF(a=lu(a));return null!=this.maxValue&&(c=hQ(c,0,this.maxValue)),c}computeOutputShape(a){return a}getConfig(){let a={maxValue:this.maxValue};return Object.assign(a,super.getConfig()),a}}nW.className="ReLU",jg.registerClass(nW);class nX extends lH{constructor(a){super(null==a?{}:a),this.DEFAULT_ALPHA=.3,null==a&&(a={}),this.alpha=null==a.alpha?this.DEFAULT_ALPHA:a.alpha}call(a,b){return gD(lu(a),this.alpha)}computeOutputShape(a){return a}getConfig(){let a={alpha:this.alpha};return Object.assign(a,super.getConfig()),a}}nX.className="LeakyReLU",jg.registerClass(nX);class nY extends lH{constructor(a){if(super(null==a?{}:a),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==a&&(a={}),this.supportsMasking=!0,this.alphaInitializer=lr(a.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=nV(a.alphaRegularizer),this.alphaConstraint=lX(a.alphaConstraint),null==a.sharedAxes)this.sharedAxes=null;else if(Array.isArray(a.sharedAxes))this.sharedAxes=a.sharedAxes;else if("number"==typeof a.sharedAxes)this.sharedAxes=[a.sharedAxes];else throw new iY(`Expected sharedAxes to be a number or an array of numbers, but got ${a.sharedAxes}`)}build(a){let b=(a=lv(a)).slice(1);if(null!=this.sharedAxes)for(let a of this.sharedAxes)b[a-1]=1;this.alpha=this.addWeight("alpha",b,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let c={};if(null!=this.sharedAxes)for(let b=1;b<a.length;++b)c[b]=a[b];this.inputSpec=[new lC({ndim:a.length,axes:c})],this.built=!0}call(a,b){return gE(a=lu(a),this.alpha.read())}getConfig(){let a={alphaInitializer:i8(this.alphaInitializer),alphaRegularizer:i8(this.alphaRegularizer),alphaConstraint:i8(this.alphaConstraint),sharedAxes:this.sharedAxes};return Object.assign(a,super.getConfig()),a}}nY.className="PReLU",jg.registerClass(nY);class nZ extends lH{constructor(a){if(super(null==a?{}:a),this.DEFAULT_ALPHA=1,null==a&&(a={}),null!=a.alpha&&a.alpha!==this.DEFAULT_ALPHA)throw new iZ(`Non-default alpha value (${a.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==a.alpha?this.DEFAULT_ALPHA:a.alpha}call(a,b){return gC(lu(a))}computeOutputShape(a){return a}getConfig(){let a={alpha:this.alpha};return Object.assign(a,super.getConfig()),a}}nZ.className="ELU",jg.registerClass(nZ);class n$ extends lH{constructor(a){super(null==a?{}:a),this.DEFAULT_THETA=1,null==a&&(a={}),this.theta=null==a.theta?this.DEFAULT_THETA:a.theta}call(a,b){let c=lu(a);return eB(c,ev(fY(c,this.theta),"float32"))}computeOutputShape(a){return a}getConfig(){let a={theta:this.theta};return Object.assign(a,super.getConfig()),a}}n$.className="ThresholdedReLU",jg.registerClass(n$);class n_ extends lH{constructor(a){super(null==a?{}:a),this.DEFAULT_AXIS=1,null==a&&(a={}),this.softmax=new nH().apply,this.axis=null==a.axis?this.DEFAULT_AXIS:a.axis}call(a,b){return dT(()=>{let c=lu(a),d=b.mask;if(null!=d){let a=eB(eS(f5(c.shape),ev(d,c.dtype)),eG(-1e9));c=ey(c,a)}if(this.axis instanceof Array)if(this.axis.length>1)return fR(eS(c,ic(c,this.axis,!0)));else return this.softmax(c,this.axis[0]);return this.softmax(c,this.axis)})}computeOutputShape(a){return a}getConfig(){let a={axis:this.axis};return Object.assign(a,super.getConfig()),a}}n_.className="Softmax",jg.registerClass(n_);let n0=dM({conv3dTranspose_:function(a,b,c,d,e){return fA(c,dJ(a,"x","conv3dTranspose"),dJ(b,"filter","conv3dTranspose"),d,e)}});var kO=jD;let n1=dM({conv3d_:function(a,b,c,d,e="NDHWC",f=[1,1,1]){let g=dJ(a,"x","conv3d"),h=dJ(b,"filter","conv3d"),i=g,j=!1;4===g.rank&&(j=!0,i=e4(g,[1,g.shape[0],g.shape[1],g.shape[2],g.shape[3]])),I(5===i.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${i.rank}.`),I(5===h.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${h.rank}.`),I(i.shape[4]===h.shape[3],()=>`Error in conv3d: depth of input (${i.shape[4]}) must match input depth for filter ${h.shape[3]}.`),I(fh(c,f),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${c} and dilations '${f}'`),I("NDHWC"===e,()=>`Error in conv3d: got dataFormat of ${e} but only NDHWC is currently supported.`),I(fi(f),()=>"Error in conv3D: Dilated rates should be larger than 0."),I(fi(c),()=>"Error in conv3D: Strides should be larger than 0.");let k={x:i,filter:h},l=dB.runKernel(a_,k,{strides:c,pad:d,dataFormat:e,dilations:f});return j?e4(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}});var jg=jg;function n2(a,b,c){if("number"==typeof a)return i0(a,b);if(a.length!==b)throw new iY(`The ${c} argument must be an integer or tuple of ${b} integers. Received: ${a.length} elements.`);for(let d=0;d<b;++d){let e=a[d];if(e!==parseInt(e.toString(),10))throw new iY(`The ${c} argument must be an integer or tuple of ${b} integers. Received: ${JSON.stringify(a)} including a non-integer number ${e}`)}return a}function n3(a,b,c,d,e=1){return null==a?a:Math.floor((("same"===c?a:a-(b+(b-1)*(e-1))+1)+d-1)/d)}function n4(a,b,c,d){if(null==a)return null;if("valid"===d)a=a*b+kS([c-b,0]);else if("same"===d)a*=b;else throw new iY(`Unsupport padding mode: ${d}.`);return a}function n5(a,b){return dT(()=>(jq(b),"channelsFirst"===b)?fO(a,[0,2,3,1]):a)}function n6(a,b){return dT(()=>(jq(b),"channelsFirst"===b)?fO(a,[0,2,3,4,1]):a)}function n7(a,b,c,d=[1,1],e="valid",f,g,h=null){return dT(()=>{if(null==f&&(f=kV()),jq(f),3!==a.rank&&4!==a.rank)throw new iY(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${a.rank}.`);if(3!==b.rank&&4!==b.rank)throw new iY(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${a.rank}.`);let i=n5(a,f);if("causal"===e)throw new iZ("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return i=kO.conv2d({x:i,filter:b,strides:d,pad:"same"===e?"same":"valid",dilations:g,dataFormat:"NHWC",bias:c,activation:h}),"channelsFirst"===f&&(i=fO(i,[0,3,1,2])),i})}class n8 extends lH{constructor(a,b){if(super(b),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",n8.verifyArgs(b),this.rank=a,je(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new iZ(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=n2(b.kernelSize,a,"kernelSize"),this.strides=n2(null==b.strides?1:b.strides,a,"strides"),this.padding=null==b.padding?"valid":b.padding,jr(this.padding),this.dataFormat=null==b.dataFormat?"channelsLast":b.dataFormat,jq(this.dataFormat),this.activation=nP(b.activation),this.useBias=null==b.useBias||b.useBias,this.biasInitializer=lr(b.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=lX(b.biasConstraint),this.biasRegularizer=nV(b.biasRegularizer),this.activityRegularizer=nV(b.activityRegularizer),this.dilationRate=n2(null==b.dilationRate?1:b.dilationRate,a,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new iY(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new iY(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new iY(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(a){if(i1("kernelSize"in a,"required key 'kernelSize' not in config"),"number"!=typeof a.kernelSize&&!jd(a.kernelSize,"number",1,3))throw new iY(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(a.kernelSize)}.`)}getConfig(){let a={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:nN(this.activation),useBias:this.useBias,biasInitializer:i8(this.biasInitializer),biasRegularizer:i8(this.biasRegularizer),activityRegularizer:i8(this.activityRegularizer),biasConstraint:i8(this.biasConstraint)};return Object.assign(a,super.getConfig()),a}}class n9 extends n8{constructor(a,b){super(a,b),this.kernel=null,n9.verifyArgs(b),this.filters=b.filters,je(this.filters,"filters"),this.kernelInitializer=lr(b.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=lX(b.kernelConstraint),this.kernelRegularizer=nV(b.kernelRegularizer)}build(a){a=lv(a);let b="channelsFirst"===this.dataFormat?1:a.length-1;if(null==a[b])throw new iY(`The channel dimension of the input should be defined. Found ${a[b]}`);let c=a[b],d=this.kernelSize.concat([c,this.filters]);this.kernel=this.addWeight("kernel",d,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[b]:c}}],this.built=!0}call(a,b){return dT(()=>{let b;a=lu(a);let c=null==this.bias?null:this.bias.read(),d=jf(this.activation.getClassName());if(null!=d&&2===this.rank)b=n7(a,this.kernel.read(),c,this.strides,this.padding,this.dataFormat,this.dilationRate,d);else{if(1===this.rank)b=function(a,b,c,d=1,e="valid",f,g=1){return dT(()=>{if(null==f&&(f=kV()),jq(f),3!==a.shape.length)throw new iY(`The input of a conv1dWithBias operation should be 3, but is ${a.shape.length} instead.`);if(3!==b.shape.length)throw new iY(`The kernel for a conv1dWithBias operation should be 3, but is ${b.shape.length} instead`);if(null!=c&&1!==c.shape.length)throw new iY(`The bias for a conv1dWithBias operation should be 1, but is ${c.shape.length} instead`);if("channelsFirst"===f&&(a=fO(a,[0,2,1])),"causal"===e)throw new iZ("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let h=hR(a,b,d,"same"===e?"same":"valid","NWC",g);return null!=c&&(h=k5(h,c)),h})}(a,this.kernel.read(),c,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)b=n7(a,this.kernel.read(),c,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(3===this.rank)b=function(a,b,c,d=[1,1,1],e="valid",f,g){return dT(()=>{if(null==f&&(f=kV()),jq(f),4!==a.rank&&5!==a.rank)throw new iY(`conv3dWithBias expects input to be of rank 4 or 5, but received ${a.rank}.`);if(4!==b.rank&&5!==b.rank)throw new iY(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${a.rank}.`);let h=n6(a,f);if("causal"===e)throw new iZ("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return h=n1(h,b,d,"same"===e?"same":"valid","NDHWC",g),null!=c&&(h=k5(h,c)),"channelsFirst"===f&&(h=fO(h,[0,4,1,2,3])),h})}(a,this.kernel.read(),c,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new iZ("convolutions greater than 3D are not implemented yet.");null!=this.activation&&(b=this.activation.apply(b))}return b})}computeOutputShape(a){a=lv(a);let b=[],c="channelsLast"===this.dataFormat?a.slice(1,a.length-1):a.slice(2);for(let a=0;a<c.length;++a){let d=n3(c[a],this.kernelSize[a],this.padding,this.strides[a],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);b.push(d)}let d=[a[0]];return"channelsLast"===this.dataFormat?(d=d.concat(b)).push(this.filters):(d.push(this.filters),d=d.concat(b)),d}getConfig(){let a={filters:this.filters,kernelInitializer:i8(this.kernelInitializer),kernelRegularizer:i8(this.kernelRegularizer),kernelConstraint:i8(this.kernelConstraint)};return Object.assign(a,super.getConfig()),a}static verifyArgs(a){if(!("filters"in a)||"number"!=typeof a.filters||a.filters<1)throw new iY(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(a.filters)}`)}}class oa extends n9{constructor(a){super(2,a),oa.verifyArgs(a)}getConfig(){let a=super.getConfig();return delete a.rank,a}static verifyArgs(a){if("number"!=typeof a.kernelSize&&!jd(a.kernelSize,"number",1,2))throw new iY(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(a.kernelSize)}.`)}}oa.className="Conv2D",jg.registerClass(oa);class ob extends n9{constructor(a){super(3,a),ob.verifyArgs(a)}getConfig(){let a=super.getConfig();return delete a.rank,a}static verifyArgs(a){if("number"!=typeof a.kernelSize&&!(Array.isArray(a.kernelSize)&&(1===a.kernelSize.length||3===a.kernelSize.length)))throw new iY(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(a.kernelSize)}.`)}}ob.className="Conv3D",jg.registerClass(ob);class oc extends oa{constructor(a){if(super(a),this.inputSpec=[new lC({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new iY(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(a){if(4!==(a=lv(a)).length)throw new iY("Input should have rank 4; Received input shape: "+JSON.stringify(a));let b="channelsFirst"===this.dataFormat?1:a.length-1;if(null==a[b])throw new iY("The channel dimension of the inputs should be defined. Found `None`.");let c=a[b],d=this.kernelSize.concat([this.filters,c]);this.kernel=this.addWeight("kernel",d,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new lC({ndim:4,axes:{[b]:c}})],this.built=!0}call(a,b){return dT(()=>{let b,c,d=lu(a);if(4!==d.shape.length)throw new iY(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${d.shape.length}`);let e=d.shape,f=e[0];"channelsFirst"===this.dataFormat?(b=2,c=3):(b=1,c=2);let g=e[b],h=e[c],i=this.kernelSize[0],j=this.kernelSize[1],k=this.strides[0],l=this.strides[1],m=[f,n4(g,k,i,this.padding),n4(h,l,j,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(d=fO(d,[0,2,3,1]));let n=hS(d,this.kernel.read(),m,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(n=fO(n,[0,3,1,2])),null!=this.bias&&(n=k5(n,this.bias.read(),this.dataFormat)),null!=this.activation&&(n=this.activation.apply(n)),n})}computeOutputShape(a){let b,c,d,e=(a=lv(a)).slice();"channelsFirst"===this.dataFormat?(b=1,c=2,d=3):(b=3,c=1,d=2);let f=this.kernelSize[0],g=this.kernelSize[1],h=this.strides[0],i=this.strides[1];return e[b]=this.filters,e[c]=n4(e[c],h,f,this.padding),e[d]=n4(e[d],i,g,this.padding),e}getConfig(){let a=super.getConfig();return delete a.dilationRate,a}}oc.className="Conv2DTranspose",jg.registerClass(oc);class od extends ob{constructor(a){if(super(a),this.inputSpec=[new lC({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new iY(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(a){if(5!==(a=lv(a)).length)throw new iY("Input should have rank 5; Received input shape: "+JSON.stringify(a));let b="channelsFirst"===this.dataFormat?1:a.length-1;if(null==a[b])throw new iY("The channel dimension of the inputs should be defined. Found `None`.");let c=a[b],d=this.kernelSize.concat([this.filters,c]);this.kernel=this.addWeight("kernel",d,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new lC({ndim:5,axes:{[b]:c}})],this.built=!0}call(a,b){return dT(()=>{let b,c,d,e=lu(a);if(5!==e.shape.length)throw new iY(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);let f=e.shape,g=f[0];"channelsFirst"===this.dataFormat?(d=2,b=3,c=4):(d=1,b=2,c=3);let h=f[d],i=f[b],j=f[c],k=this.kernelSize[0],l=this.kernelSize[1],m=this.kernelSize[2],n=this.strides[0],o=this.strides[1],p=this.strides[2],q=[g,n4(h,n,k,this.padding),n4(i,o,l,this.padding),n4(j,p,m,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=fO(e,[0,2,3,4,1]));let r=n0(e,this.kernel.read(),q,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(r=fO(r,[0,4,1,2,3])),null!==this.bias&&(r=k5(r,this.bias.read(),this.dataFormat)),null!==this.activation&&(r=this.activation.apply(r)),r})}computeOutputShape(a){let b,c,d,e,f=(a=lv(a)).slice();"channelsFirst"===this.dataFormat?(b=1,c=2,d=3,e=4):(b=4,c=1,d=2,e=3);let g=this.kernelSize[0],h=this.kernelSize[1],i=this.kernelSize[2],j=this.strides[0],k=this.strides[1],l=this.strides[2];return f[b]=this.filters,f[c]=n4(f[c],j,g,this.padding),f[d]=n4(f[d],k,h,this.padding),f[e]=n4(f[e],l,i,this.padding),f}getConfig(){let a=super.getConfig();return delete a.dilationRate,a}}od.className="Conv3DTranspose",jg.registerClass(od);class oe extends n9{constructor(a,b){if(super(a,b),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==b.filters)throw new iY("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=b.kernelInitializer||null!=b.kernelRegularizer||null!=b.kernelConstraint)throw new iY("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=b.padding&&"same"!==b.padding&&"valid"!==b.padding)throw new iY(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(b.padding)}`);this.depthMultiplier=null==b.depthMultiplier?1:b.depthMultiplier,this.depthwiseInitializer=lr(b.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=nV(b.depthwiseRegularizer),this.depthwiseConstraint=lX(b.depthwiseConstraint),this.pointwiseInitializer=lr(b.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=nV(b.pointwiseRegularizer),this.pointwiseConstraint=lX(b.pointwiseConstraint)}build(a){if((a=lv(a)).length<this.rank+2)throw new iY(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(a)}`);let b="channelsFirst"===this.dataFormat?1:a.length-1;if(null==a[b]||a[b]<0)throw new iY(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(a[b])}`);let c=a[b],d=this.kernelSize.concat([c,this.depthMultiplier]),e=[];for(let a=0;a<this.rank;++a)e.push(1);e.push(c*this.depthMultiplier,this.filters),this.depthwiseKernel=this.addWeight("depthwise_kernel",d,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",e,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.inputSpec=[new lC({ndim:this.rank+2,axes:{[b]:c}})],this.built=!0}call(a,b){return dT(()=>{let b;if(a=lu(a),1===this.rank)throw new iZ("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(a=fO(a,[0,2,3,1])),b=iy(a,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(b=k5(b,this.bias.read(),this.dataFormat)),null!=this.activation&&(b=this.activation.apply(b)),"channelsFirst"===this.dataFormat&&(b=fO(b,[0,3,1,2])),b})}getConfig(){let a=super.getConfig();return delete a.rank,delete a.kernelInitializer,delete a.kernelRegularizer,delete a.kernelConstraint,a.depthwiseInitializer=i8(this.depthwiseInitializer),a.pointwiseInitializer=i8(this.pointwiseInitializer),a.depthwiseRegularizer=i8(this.depthwiseRegularizer),a.pointwiseRegularizer=i8(this.pointwiseRegularizer),a.depthwiseConstraint=i8(this.depthwiseConstraint),a.pointwiseConstraint=i8(this.pointwiseConstraint),a}}oe.className="SeparableConv";class of extends oe{constructor(a){super(2,a)}}of.className="SeparableConv2D",jg.registerClass(of);class og extends n9{constructor(a){super(1,a),og.verifyArgs(a),this.inputSpec=[{ndim:3}]}getConfig(){let a=super.getConfig();return delete a.rank,delete a.dataFormat,a}static verifyArgs(a){if("number"!=typeof a.kernelSize&&!jd(a.kernelSize,"number",1,1))throw new iY(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(a.kernelSize)}.`)}}og.className="Conv1D",jg.registerClass(og);class oh extends lH{constructor(a){super(a),"number"==typeof a.cropping?this.cropping=[[a.cropping,a.cropping],[a.cropping,a.cropping]]:"number"==typeof a.cropping[0]?this.cropping=[[a.cropping[0],a.cropping[0]],[a.cropping[1],a.cropping[1]]]:this.cropping=a.cropping,this.dataFormat=void 0===a.dataFormat?"channelsLast":a.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(a){return"channelsFirst"===this.dataFormat?[a[0],a[1],a[2]-this.cropping[0][0]-this.cropping[0][1],a[3]-this.cropping[1][0]-this.cropping[1][1]]:[a[0],a[1]-this.cropping[0][0]-this.cropping[0][1],a[2]-this.cropping[1][0]-this.cropping[1][1],a[3]]}call(a,b){return dT(()=>{if(a=lu(a),"channelsLast"===this.dataFormat){let b=kZ(a,this.cropping[0][0],a.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return kZ(b,this.cropping[1][0],a.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{let b=kZ(a,this.cropping[0][0],a.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return kZ(b,this.cropping[1][0],a.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let a={cropping:this.cropping,dataFormat:this.dataFormat};return Object.assign(a,super.getConfig()),a}}oh.className="Cropping2D",jg.registerClass(oh);class oi extends lH{constructor(a){super(a),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==a.size?this.DEFAULT_SIZE:a.size,this.dataFormat=null==a.dataFormat?"channelsLast":a.dataFormat,jq(this.dataFormat),this.interpolation=null==a.interpolation?"nearest":a.interpolation,jc(jl,"InterpolationFormat",this.interpolation)}computeOutputShape(a){if("channelsFirst"===this.dataFormat){let b=null==a[2]?null:this.size[0]*a[2],c=null==a[3]?null:this.size[1]*a[3];return[a[0],a[1],b,c]}{let b=null==a[1]?null:this.size[0]*a[1],c=null==a[2]?null:this.size[1]*a[2];return[a[0],b,c,a[3]]}}call(a,b){return dT(()=>{let b=lu(a),c=b.shape;if("channelsFirst"===this.dataFormat){b=fO(b,[0,2,3,1]);let a=this.size[0]*c[2],d=this.size[1]*c[3];return fO("nearest"===this.interpolation?ku.resizeNearestNeighbor(b,[a,d]):ku.resizeBilinear(b,[a,d]),[0,3,1,2])}{let a=this.size[0]*c[1],d=this.size[1]*c[2];return"nearest"===this.interpolation?ku.resizeNearestNeighbor(b,[a,d]):ku.resizeBilinear(b,[a,d])}})}getConfig(){let a={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation};return Object.assign(a,super.getConfig()),a}}oi.className="UpSampling2D",jg.registerClass(oi);var jg=jg;class oj extends n8{constructor(a){super(2,a),this.depthwiseKernel=null,this.depthMultiplier=null==a.depthMultiplier?1:a.depthMultiplier,this.depthwiseInitializer=lr(a.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=lX(a.depthwiseConstraint),this.depthwiseRegularizer=nV(a.depthwiseRegularizer)}build(a){if((a=lv(a)).length<4)throw new iY(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(a)}.`);let b="channelsFirst"===this.dataFormat?1:3;if(null==a[b]||a[b]<0)throw new iY(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${a[b]}).`);let c=a[b],d=[this.kernelSize[0],this.kernelSize[1],c,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",d,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[c*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(a,b){return dT(()=>{let b=function(a,b,c=[1,1],d="valid",e,f){return dT(()=>{null==e&&(e=kV()),jq(e);let f=n5(a,e);if(4!==a.rank)throw new iY(`Input for depthwiseConv2d is required to be 4-D, but is instead ${a.rank}-D`);if(4!==b.rank)throw new iY(`depthwiseKernel is required to be 4-D, but is instead ${b.rank}-D`);return f=hU(f,b,c,"same"===d?"same":"valid","NHWC",null),"channelsFirst"===e&&(f=fO(f,[0,3,1,2])),f})}(a=lu(a),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,0);return this.useBias&&(b=k5(b,this.bias.read(),this.dataFormat)),null!=this.activation&&(b=this.activation.apply(b)),b})}computeOutputShape(a){a=lv(a);let b="channelsFirst"===this.dataFormat?a[2]:a[1],c="channelsFirst"===this.dataFormat?a[3]:a[2],d="channelsFirst"===this.dataFormat?a[1]*this.depthMultiplier:a[3]*this.depthMultiplier,e=n3(b,this.kernelSize[0],this.padding,this.strides[0]),f=n3(c,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[a[0],d,e,f]:[a[0],e,f,d]}getConfig(){let a=super.getConfig();return a.depthMultiplier=this.depthMultiplier,a.depthwiseInitializer=i8(this.depthwiseInitializer),a.depthwiseRegularizer=i8(this.depthwiseRegularizer),a.depthwiseConstraint=i8(this.depthwiseRegularizer),a}}oj.className="DepthwiseConv2D",jg.registerClass(oj);var jg=jg,iV=iV,jg=jg,iV=iV;function ok(a,b,c,d){if(Array.isArray(a)){if(null!=b||null!=c)throw new iY("When inputs is an array, neither initialState or constants should be provided");null!=d&&(c=a.slice(a.length-d,a.length),a=a.slice(0,a.length-d)),a.length>1&&(b=a.slice(1,a.length)),a=a[0]}function e(a){return null==a||Array.isArray(a)?a:[a]}return{inputs:a,initialState:b=e(b),constants:c=e(c)}}function ol(a,b,c,d=!1,e,f,g=!1,h=!1){return dT(()=>{let i,j,k,l=b.shape.length;if(l<3)throw new iY(`Input should be at least 3D, but is ${l}D.`);let m=[1,0].concat(kT(2,l));if(b=fO(b,m),null!=f)throw new iZ("The rnn() functoin of the deeplearn.js backend does not support constants yet.");g&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=e&&((e=ev(ev(e,"bool"),"float32")).rank===l-1&&(e=hA(e,-1)),e=fO(e,m)),d&&(b=hr(b,0),null!=e&&(e=hr(e,0)));let n=[],o=c,p=b.shape[0],q=f8(b);null!=e&&(j=f8(e));for(let b=0;b<p;++b){let c=q[b],d=dT(()=>a(c,o));if(null==e)i=d[0],o=d[1];else{let a=dT(()=>{let a=j[b],c=eS(ip(a),a);return{output:ey(eB(d[0],a),eB(o[0],c)),newStates:o.map((b,e)=>ey(eB(d[1][e],a),eB(b,c)))}});i=a.output,o=a.newStates}h&&n.push(i)}return h&&(k=fU(n,1)),[i,k,o]})}class om extends lH{constructor(a){let b;if(super(a),null==a.cell)throw new iY("cell property is missing for the constructor of RNN.");if(null==(b=Array.isArray(a.cell)?new ou({cells:a.cell}):a.cell).stateSize)throw new iY("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=b,this.returnSequences=null!=a.returnSequences&&a.returnSequences,this.returnState=null!=a.returnState&&a.returnState,this.goBackwards=null!=a.goBackwards&&a.goBackwards,this._stateful=null!=a.stateful&&a.stateful,this.unroll=null!=a.unroll&&a.unroll,this.supportsMasking=!0,this.inputSpec=[new lC({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?kT(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(a=>null):this.states_}setStates(a){this.states_=a}computeOutputShape(a){let b;ls(a)&&(a=a[0]);let c=this.cell.stateSize;Array.isArray(c)||(c=[c]);let d=c[0];if(b=this.returnSequences?[a[0],a[1],d]:[a[0],d],!this.returnState)return b;{let d=[];for(let b of c)d.push([a[0],b]);return[b].concat(d)}}computeMask(a,b){return dT(()=>{Array.isArray(b)&&(b=b[0]);let a=this.returnSequences?b:null;return this.returnState?[a].concat(this.states.map(a=>null)):a})}get states(){if(null!=this.states_)return this.states_;{let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,b=[];for(let c=0;c<a;++c)b.push(null);return b}}set states(a){this.states_=a}build(a){let b;if(null!=this.numConstants)throw new iZ("Constants support is not implemented in RNN yet.");ls(a)&&(a=a[0]);let c=this.stateful?a[0]:null,d=a.slice(2);this.inputSpec[0]=new lC({shape:[c,null,...d]});let e=[a[0]].concat(a.slice(2));if(this.cell.build(e),b=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!iV.arraysEqual(this.stateSpec.map(a=>a.shape[a.shape.length-1]),b))throw new iY(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=b.map(a=>new lC({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(a,b=!1){dT(()=>{if(!this.stateful)throw new iW("Cannot call resetStates() on an RNN Layer that is not stateful.");let c=this.inputSpec[0].shape[0];if(null==c)throw new iY("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(a=>f4([c,a])):this.states_=[f4([c,this.cell.stateSize])];else if(null==a)dU(this.states_),null!=this.keptStates&&(dU(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(a=>f4([c,a])):this.states_[0]=f4([c,this.cell.stateSize]);else{if(Array.isArray(a)||(a=[a]),a.length!==this.states_.length)throw new iY(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${a.length} state value(s). Input received: ${a}`);!0===b?this.keptStates.push(this.states_.slice()):dU(this.states_);for(let b=0;b<this.states_.length;++b){let d=a[b],e=[c,Array.isArray(this.cell.stateSize)?this.cell.stateSize[b]:this.cell.stateSize];if(!iV.arraysEqual(d.shape,e))throw new iY(`State ${b} is incompatible with layer ${this.name}: expected shape=${e}, received shape=${d.shape}`);this.states_[b]=d}}this.states_=this.states_.map(a=>dV(a.clone()))})}apply(a,b){let c=null==b?null:b.initialState,d=null==b?null:b.constants;null==b&&(b={});let e=ok(a,c,d,this.numConstants);a=e.inputs,c=e.initialState,d=e.constants;let f=[],g=[];if(null!=c){for(let a of(b.initialState=c,f=f.concat(c),this.stateSpec=[],c))this.stateSpec.push(new lC({shape:a.shape}));g=g.concat(this.stateSpec)}if(null!=d&&(b.constants=d,f=f.concat(d),this.numConstants=d.length),!(f[0]instanceof lD))return super.apply(a,b);{let c=[a].concat(f),d=this.inputSpec.concat(g),e=this.inputSpec;this.inputSpec=d;let h=super.apply(c,b);return this.inputSpec=e,h}}call(a,b){return dT(()=>{let c=null==b?null:b.mask,d=null==b?null:b.training,e=null==b?null:b.initialState;a=lu(a),null==e&&(e=this.stateful?this.states_:this.getInitialState(a));let f=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(e.length!==f)throw new iY(`RNN Layer has ${f} state(s) but was passed ${e.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let g={training:d},h=ol((a,b)=>{let c=this.cell.call([a].concat(b),g);return[c[0],c.slice(1)]},a,e,this.goBackwards,c,null,this.unroll,this.returnSequences),i=h[0],j=h[1],k=h[2];this.stateful&&this.resetStates(k,d);let l=this.returnSequences?j:i;return this.returnState?[l].concat(k):l})}getInitialState(a){return dT(()=>{let b=f4(a.shape);return(b=kW(b=e5(b,[1,2])),Array.isArray(this.cell.stateSize))?this.cell.stateSize.map(a=>a>1?k0(b,[1,a]):b):this.cell.stateSize>1?[k0(b,[1,this.cell.stateSize])]:[b]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(a){super.setFastWeightInitDuringBuild(a),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(a)}getConfig(){let a=super.getConfig(),b={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(b.numConstants=this.numConstants);let c=this.cell.getConfig();return this.getClassName()===om.className&&(b.cell={className:this.cell.getClassName(),config:c}),Object.assign(Object.assign(Object.assign({},c),a),b)}static fromConfig(a,b,c={}){let d=mM(b.cell,c);return new a(Object.assign(b,{cell:d}))}}om.className="RNN",jg.registerClass(om);class on extends lH{}class oo extends on{constructor(a){super(a),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=a.units,je(this.units,"units"),this.activation=nP(null==a.activation?this.DEFAULT_ACTIVATION:a.activation),this.useBias=null==a.useBias||a.useBias,this.kernelInitializer=lr(a.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=lr(a.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=lr(a.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=nV(a.kernelRegularizer),this.recurrentRegularizer=nV(a.recurrentRegularizer),this.biasRegularizer=nV(a.biasRegularizer),this.kernelConstraint=lX(a.kernelConstraint),this.recurrentConstraint=lX(a.recurrentConstraint),this.biasConstraint=lX(a.biasConstraint),this.dropout=kR([1,kS([0,null==a.dropout?0:a.dropout])]),this.recurrentDropout=kR([1,kS([0,null==a.recurrentDropout?0:a.recurrentDropout])]),this.dropoutFunc=a.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(a){a=lv(a),this.kernel=this.addWeight("kernel",[a[a.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(a,b){return dT(()=>{let c;if(2!==a.length)throw new iY(`SimpleRNNCell expects 2 input Tensors, got ${a.length}.`);let d=a[1];a=a[0];let e=null!=b.training&&b.training;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ov({ones:()=>ip(a),rate:this.dropout,training:e,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ov({ones:()=>ip(d),rate:this.recurrentDropout,training:e,dropoutFunc:this.dropoutFunc}));let f=this.dropoutMask,g=this.recurrentDropoutMask;c=null!=f?k2(eB(a,f),this.kernel.read()):k2(a,this.kernel.read()),null!=this.bias&&(c=k5(c,this.bias.read())),null!=g&&(d=eB(d,g));let h=ey(c,k2(d,this.recurrentKernel.read()));return null!=this.activation&&(h=this.activation.apply(h)),[h,h]})}getConfig(){let a=super.getConfig(),b={units:this.units,activation:nN(this.activation),useBias:this.useBias,kernelInitializer:i8(this.kernelInitializer),recurrentInitializer:i8(this.recurrentInitializer),biasInitializer:i8(this.biasInitializer),kernelRegularizer:i8(this.kernelRegularizer),recurrentRegularizer:i8(this.recurrentRegularizer),biasRegularizer:i8(this.biasRegularizer),activityRegularizer:i8(this.activityRegularizer),kernelConstraint:i8(this.kernelConstraint),recurrentConstraint:i8(this.recurrentConstraint),biasConstraint:i8(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},a),b)}}oo.className="SimpleRNNCell",jg.registerClass(oo);class op extends om{constructor(a){a.cell=new oo(a),super(a)}call(a,b){return dT(()=>{null!=this.cell.dropoutMask&&(dU(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dU(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let c=null==b?null:b.mask,d=null==b?null:b.training,e=null==b?null:b.initialState;return super.call(a,{mask:c,training:d,initialState:e})})}static fromConfig(a,b){return new a(b)}}op.className="SimpleRNN",jg.registerClass(op);class oq extends on{constructor(a){if(super(a),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",a.resetAfter)throw new iY("GRUCell does not support reset_after parameter set to true.");this.units=a.units,je(this.units,"units"),this.activation=nP(void 0===a.activation?this.DEFAULT_ACTIVATION:a.activation),this.recurrentActivation=nP(void 0===a.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:a.recurrentActivation),this.useBias=null==a.useBias||a.useBias,this.kernelInitializer=lr(a.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=lr(a.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=lr(a.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=nV(a.kernelRegularizer),this.recurrentRegularizer=nV(a.recurrentRegularizer),this.biasRegularizer=nV(a.biasRegularizer),this.kernelConstraint=lX(a.kernelConstraint),this.recurrentConstraint=lX(a.recurrentConstraint),this.biasConstraint=lX(a.biasConstraint),this.dropout=kR([1,kS([0,null==a.dropout?0:a.dropout])]),this.recurrentDropout=kR([1,kS([0,null==a.recurrentDropout?0:a.recurrentDropout])]),this.dropoutFunc=a.dropoutFunc,this.implementation=a.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(a){let b=(a=lv(a))[a.length-1];this.kernel=this.addWeight("kernel",[b,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(a,b){return dT(()=>{let c,d;if(2!==a.length)throw new iY(`GRUCell expects 2 input Tensors (inputs, h, c), got ${a.length}.`);let e=null!=b.training&&b.training,f=a[1];a=a[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ov({ones:()=>ip(a),rate:this.dropout,training:e,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ov({ones:()=>ip(f),rate:this.recurrentDropout,training:e,count:3,dropoutFunc:this.dropoutFunc}));let g=this.dropoutMask,h=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(a=eB(a,g[0]));let i=k2(a,this.kernel.read());this.useBias&&(i=k5(i,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(f=eB(f,h[0]));let j=this.recurrentKernel.read(),[k,l]=fv(j,[2*this.units,this.units],j.rank-1),m=k2(f,k),[n,o,p]=fv(i,3,i.rank-1),[q,r]=fv(m,2,m.rank-1);c=this.recurrentActivation.apply(ey(n,q));let s=k2(eB(this.recurrentActivation.apply(ey(o,r)),f),l);d=this.activation.apply(ey(p,s));let t=ey(eB(c,f),eB(ey(1,e3(c)),d));return[t,t]})}getConfig(){let a=super.getConfig(),b={units:this.units,activation:nN(this.activation),recurrentActivation:nN(this.recurrentActivation),useBias:this.useBias,kernelInitializer:i8(this.kernelInitializer),recurrentInitializer:i8(this.recurrentInitializer),biasInitializer:i8(this.biasInitializer),kernelRegularizer:i8(this.kernelRegularizer),recurrentRegularizer:i8(this.recurrentRegularizer),biasRegularizer:i8(this.biasRegularizer),activityRegularizer:i8(this.activityRegularizer),kernelConstraint:i8(this.kernelConstraint),recurrentConstraint:i8(this.recurrentConstraint),biasConstraint:i8(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},a),b)}}oq.className="GRUCell",jg.registerClass(oq);class or extends om{constructor(a){0===a.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),a.cell=new oq(a),super(a)}call(a,b){return dT(()=>{null!=this.cell.dropoutMask&&(dU(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dU(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let c=null==b?null:b.mask,d=null==b?null:b.training,e=null==b?null:b.initialState;return super.call(a,{mask:c,training:d,initialState:e})})}static fromConfig(a,b){return 0===b.implmentation&&(b.implementation=1),new a(b)}}or.className="GRU",jg.registerClass(or);class os extends on{constructor(a){super(a),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=a.units,je(this.units,"units"),this.activation=nP(void 0===a.activation?this.DEFAULT_ACTIVATION:a.activation),this.recurrentActivation=nP(void 0===a.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:a.recurrentActivation),this.useBias=null==a.useBias||a.useBias,this.kernelInitializer=lr(a.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=lr(a.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=lr(a.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=a.unitForgetBias,this.kernelRegularizer=nV(a.kernelRegularizer),this.recurrentRegularizer=nV(a.recurrentRegularizer),this.biasRegularizer=nV(a.biasRegularizer),this.kernelConstraint=lX(a.kernelConstraint),this.recurrentConstraint=lX(a.recurrentConstraint),this.biasConstraint=lX(a.biasConstraint),this.dropout=kR([1,kS([0,null==a.dropout?0:a.dropout])]),this.recurrentDropout=kR([1,kS([0,null==a.recurrentDropout?0:a.recurrentDropout])]),this.dropoutFunc=a.dropoutFunc,this.implementation=a.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(a){var b;let c,d=(a=lv(a))[a.length-1];if(this.kernel=this.addWeight("kernel",[d,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){let a=this.biasInitializer,d=this.units;c=new((b=class extends k9{apply(b,c){let e=a.apply([d]),f=new lb().apply([d]),g=a.apply([2*d]);return k_(k_(e,f),g)}}).className="CustomInit",b)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,c,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(a,b){return dT(()=>{let c,d,e=null!=b.training&&b.training;if(3!==a.length)throw new iY(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${a.length}.`);let f=a[1],g=a[2];a=a[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ov({ones:()=>ip(a),rate:this.dropout,training:e,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ov({ones:()=>ip(f),rate:this.recurrentDropout,training:e,count:4,dropoutFunc:this.dropoutFunc}));let h=this.dropoutMask,i=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(a=eB(a,h[0]));let j=k2(a,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(f=eB(f,i[0])),j=ey(j,k2(f,this.recurrentKernel.read())),this.useBias&&(j=k5(j,this.bias.read()));let[k,l,m,n]=fv(j,4,j.rank-1);c=this.recurrentActivation.apply(k),d=ey(eB(this.recurrentActivation.apply(l),g),eB(c,this.activation.apply(m)));let o=eB(this.recurrentActivation.apply(n),this.activation.apply(d));return[o,o,d]})}getConfig(){let a=super.getConfig(),b={units:this.units,activation:nN(this.activation),recurrentActivation:nN(this.recurrentActivation),useBias:this.useBias,kernelInitializer:i8(this.kernelInitializer),recurrentInitializer:i8(this.recurrentInitializer),biasInitializer:i8(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:i8(this.kernelRegularizer),recurrentRegularizer:i8(this.recurrentRegularizer),biasRegularizer:i8(this.biasRegularizer),activityRegularizer:i8(this.activityRegularizer),kernelConstraint:i8(this.kernelConstraint),recurrentConstraint:i8(this.recurrentConstraint),biasConstraint:i8(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},a),b)}}os.className="LSTMCell",jg.registerClass(os);class ot extends om{constructor(a){0===a.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),a.cell=new os(a),super(a)}call(a,b){return dT(()=>{null!=this.cell.dropoutMask&&(dU(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dU(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let c=null==b?null:b.mask,d=null==b?null:b.training,e=null==b?null:b.initialState;return super.call(a,{mask:c,training:d,initialState:e})})}static fromConfig(a,b){return 0===b.implmentation&&(b.implementation=1),new a(b)}}ot.className="LSTM",jg.registerClass(ot);class ou extends on{constructor(a){super(a),this.cells=a.cells}get stateSize(){let a=[];for(let b of this.cells.slice().reverse())Array.isArray(b.stateSize)?a.push(...b.stateSize):a.push(b.stateSize);return a}call(a,b){return dT(()=>{let c,d=a.slice(1),e=[];for(let a of this.cells.slice().reverse())Array.isArray(a.stateSize)?e.push(d.splice(0,a.stateSize.length)):e.push(d.splice(0,1));e.reverse();let f=[];for(let g=0;g<this.cells.length;++g){let h=this.cells[g];d=e[g],c=0===g?[a[0]].concat(d):[c[0]].concat(d),c=h.call(c,b),f.push(c.slice(1))}for(let a of(d=[],f.slice().reverse()))d.push(...a);return[c[0]].concat(d)})}build(a){let b;ls(a)&&(a=a[0]),this.cells.forEach((c,d)=>{ju(`RNNCell_${d}`,()=>{c.build(a),b=Array.isArray(c.stateSize)?c.stateSize[0]:c.stateSize,a=[a[0],b]})}),this.built=!0}getConfig(){let a=super.getConfig(),b=this.cells.map(a=>({className:a.getClassName(),config:a.getConfig()}));return Object.assign(Object.assign({},a),{cells:b})}static fromConfig(a,b,c={}){let d=[];for(let a of b.cells)d.push(mM(a,c));return new a({cells:d})}get trainableWeights(){if(!this.trainable)return[];let a=[];for(let b of this.cells)a.push(...b.trainableWeights);return a}get nonTrainableWeights(){let a=[];for(let b of this.cells)a.push(...b.nonTrainableWeights);if(!this.trainable){let b=[];for(let a of this.cells)b.push(...a.trainableWeights);return b.concat(a)}return a}getWeights(){let a=[];for(let b of this.cells)a.push(...b.weights);return lA(a)}setWeights(a){let b=[];for(let c of this.cells){let d=c.weights.length,e=a.splice(d);for(let a=0;a<c.weights.length;++a)b.push([c.weights[a],e[a]])}lB(b)}}function ov(a){let{ones:b,rate:c,training:d=!1,count:e=1,dropoutFunc:f}=a,g=()=>{var a;return null!=f?f(b(),c):(a=b(),dT(()=>kP(a,c,void 0,void 0)))},h=()=>k6(g,b,d);return!e||e<=1?dV(h().clone()):Array(e).fill(void 0).map(h).map(a=>dV(a.clone()))}ou.className="StackedRNNCells",jg.registerClass(ou);var ow=function(a,b){var c={};for(var d in a)Object.prototype.hasOwnProperty.call(a,d)&&0>b.indexOf(d)&&(c[d]=a[d]);if(null!=a&&"function"==typeof Object.getOwnPropertySymbols)for(var e=0,d=Object.getOwnPropertySymbols(a);e<d.length;e++)0>b.indexOf(d[e])&&Object.prototype.propertyIsEnumerable.call(a,d[e])&&(c[d[e]]=a[d[e]]);return c};class ox extends om{constructor(a){if(a.unroll)throw new iZ("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(a.cell))throw new iZ("It is not possible at the moment to stack convolutional cells.");super(a),this.inputSpec=[new lC({ndim:5})]}call(a,b){return dT(()=>{if(null!=this.cell.dropoutMask&&(dU(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dU(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),b&&b.constants)throw new iY("ConvRNN2D cell does not support constants");let c=null==b?null:b.mask,d=null==b?null:b.training,e=null==b?null:b.initialState;return super.call(a,{mask:c,training:d,initialState:e})})}computeOutputShape(a){let b=this.computeSingleOutputShape(a);return this.returnSequences||(b=[b[0],...b.slice(2)]),this.returnState&&(b=[b,...[,,].fill([a[0],...b.slice(-3)])]),b}getInitialState(a){return dT(()=>{let{stateSize:b}=this.cell,c=a.shape,d=this.computeSingleOutputShape(c),e=f4([d[0],...d.slice(2)]);return Array.isArray(b)?Array(b.length).fill(e):[e]})}resetStates(a,b=!1){dT(()=>{if(!this.stateful)throw new iW("Cannot call resetStates() on an RNN Layer that is not stateful.");let c=this.inputSpec[0].shape,d=this.computeSingleOutputShape(c),e=[d[0],...d.slice(2)];if(null==c[0])throw new iY("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>f4(e)):this.states_=[f4(e)];else if(null==a)dU(this.states_),null!=this.keptStates&&(dU(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>f4(e)):this.states_[0]=f4(e);else{if(Array.isArray(a)||(a=[a]),a.length!==this.states_.length)throw new iY(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${a.length} state value(s). Input received: ${a}`);b?this.keptStates.push(this.states_.slice()):dU(this.states_);for(let b=0;b<this.states_.length;++b){let c=a[b];if(!iV.arraysEqual(c.shape,e))throw new iY(`State ${b} is incompatible with layer ${this.name}: expected shape=${e}, received shape=${c.shape}`);this.states_[b]=c}}this.states_=this.states_.map(a=>dV(a.clone()))})}computeSingleOutputShape(a){let{dataFormat:b,filters:c,kernelSize:d,padding:e,strides:f,dilationRate:g}=this.cell,h="channelsFirst"===b,i=a[h?3:2],j=a[h?4:3],k=n3(i,d[0],e,f[0],g[0]),l=n3(j,d[1],e,f[1],g[1]);return[...a.slice(0,2),...h?[c,k,l]:[k,l,c]]}}ox.className="ConvRNN2D";class oy extends os{constructor(a){const{filters:b,kernelSize:c,strides:d,padding:e,dataFormat:f,dilationRate:g}=a;super(Object.assign(Object.assign({},a),{units:b})),this.filters=b,je(this.filters,"filters"),this.kernelSize=n2(c,2,"kernelSize"),this.kernelSize.forEach(a=>je(a,"kernelSize")),this.strides=n2(d||1,2,"strides"),this.strides.forEach(a=>je(a,"strides")),this.padding=e||"valid",jr(this.padding),this.dataFormat=f||"channelsLast",jq(this.dataFormat),this.dilationRate=n2(g||1,2,"dilationRate"),this.dilationRate.forEach(a=>je(a,"dilationRate"))}build(a){var b;a=lv(a);let c="channelsFirst"===this.dataFormat?1:a.length-1;if(null==a[c])throw new iY(`The channel dimension of the input should be defined. Found ${a[c]}`);let d=a[c],e=this.kernelSize.concat([d,4*this.filters]);this.kernel=this.addWeight("kernel",e,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let f=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",f,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let a;if(this.unitForgetBias){let c=this.biasInitializer,d=this.filters;a=new((b=class extends k9{apply(a,b){return k$([c.apply([d]),f5([d]),c.apply([2*d])])}}).className="CustomInit",b)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,a,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(a,b){return dT(()=>{if(3!==a.length)throw new iY(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${a.length}.`);let c=b.training||!1,d=a[0],e=a[1],f=a[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ov({ones:()=>ip(d),rate:this.dropout,training:c,count:4,dropoutFunc:this.dropoutFunc}));let g=this.dropoutMask,h=(a,b,c)=>b&&b[c]?eB(b[c],a):a,i=h(d,g,0),j=h(d,g,1),k=h(d,g,2),l=h(d,g,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ov({ones:()=>ip(e),rate:this.recurrentDropout,training:c,count:4,dropoutFunc:this.dropoutFunc}));let m=this.recurrentDropoutMask,n=h(e,m,0),o=h(e,m,1),p=h(e,m,2),q=h(e,m,3),[r,s,t,u]=fv(this.kernel.read(),4,3),[v,w,x,y]=this.useBias?fv(this.bias.read(),4):[null,null,null,null];i=this.inputConv(i,r,v,this.padding),j=this.inputConv(j,s,w,this.padding),k=this.inputConv(k,t,x,this.padding),l=this.inputConv(l,u,y,this.padding);let[z,A,B,C]=fv(this.recurrentKernel.read(),4,3);n=this.recurrentConv(n,z),o=this.recurrentConv(o,A),p=this.recurrentConv(p,B),q=this.recurrentConv(q,C);let D=this.recurrentActivation.apply(ey(i,n)),E=this.recurrentActivation.apply(ey(j,o)),F=ey(eB(E,f),eB(D,this.activation.apply(ey(k,p)))),G=eB(this.recurrentActivation.apply(ey(l,q)),this.activation.apply(F));return[G,G,F]})}getConfig(){let a=super.getConfig(),{units:b}=a,c=ow(a,["units"]),d={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},c),d)}inputConv(a,b,c,d){let e=fy(a,b,this.strides,d||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return c?k5(e,c,this.dataFormat):e}recurrentConv(a,b){return fy(a,b,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}oy.className="ConvLSTM2DCell",jg.registerClass(oy);class oz extends ox{constructor(a){super(Object.assign(Object.assign({},a),{cell:new oy(a)}))}static fromConfig(a,b){return new a(b)}}oz.className="ConvLSTM2D",jg.registerClass(oz);var jg=jg,iV=iV;class oA extends lH{constructor(a){super(a),this.rate=Math.max(Math.min(a.rate,1),0),this.noiseShape=a.noiseShape,this.seed=a.seed,this.supportsMasking=!0}getNoiseShape(a){if(null==this.noiseShape)return this.noiseShape;let b=a.shape,c=[];for(let a=0;a<this.noiseShape.length;++a)c.push(null==this.noiseShape[a]?b[a]:this.noiseShape[a]);return c}call(a,b){return dT(()=>{this.invokeCallHook(a,b);let c=lu(a);if(0<this.rate&&this.rate<1){let a=null!=b.training&&b.training,d=this.getNoiseShape(c);return k6(()=>{var a,b;return a=this.rate,b=this.seed,dT(()=>kP(c,a,d,b))},()=>c,a)}return a})}getConfig(){let a={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed};return Object.assign(a,super.getConfig()),a}dispose(){return super.dispose()}}oA.className="Dropout",jg.registerClass(oA);class oB extends oA{constructor(a){super(a),this.inputSpec=[{ndim:3}]}getNoiseShape(a){let b=a.shape;return[b[0],1,b[2]]}}oB.className="SpatialDropout1D",jg.registerClass(oB);class oC extends lH{constructor(a){if(super(a),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==a.batchInputShape&&null==a.inputShape&&null!=a.inputDim){let b=null;null!=a.batchSize&&(b=a.batchSize),this.batchInputShape=[b,a.inputDim]}this.units=a.units,je(this.units,"units"),this.activation=nP(a.activation),null!=a.useBias&&(this.useBias=a.useBias),this.kernelInitializer=lr(a.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=lr(a.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=lX(a.kernelConstraint),this.biasConstraint=lX(a.biasConstraint),this.kernelRegularizer=nV(a.kernelRegularizer),this.biasRegularizer=nV(a.biasRegularizer),this.activityRegularizer=nV(a.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(a){let b=(a=lv(a))[a.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[b,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:b}}],this.built=!0}computeOutputShape(a){let b=(a=lv(a)).slice();return b[b.length-1]=this.units,b}call(a,b){return dT(()=>{let c;this.invokeCallHook(a,b);let d=lu(a),e=jf(this.activation.getClassName());return null!=e?c=k2(d,this.kernel.read(),e,this.bias?this.bias.read():null):(c=k2(d,this.kernel.read()),null!=this.bias&&(c=k5(c,this.bias.read())),null!=this.activation&&(c=this.activation.apply(c))),c})}getConfig(){let a={units:this.units,activation:nN(this.activation),useBias:this.useBias,kernelInitializer:i8(this.kernelInitializer),biasInitializer:i8(this.biasInitializer),kernelRegularizer:i8(this.kernelRegularizer),biasRegularizer:i8(this.biasRegularizer),activityRegularizer:i8(this.activityRegularizer),kernelConstraint:i8(this.kernelConstraint),biasConstraint:i8(this.biasConstraint)};return Object.assign(a,super.getConfig()),a}}oC.className="Dense",jg.registerClass(oC);class oD extends lH{constructor(a){super(a=a||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=a.dataFormat}computeOutputShape(a){for(let b of(a=lv(a)).slice(1))if(null==b)throw new iY(`The shape of the input to "Flatten" is not fully defined (got ${a.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[a[0],kQ(a,1)]}call(a,b){return dT(()=>{this.invokeCallHook(a,b);let c=lu(a);if("channelsFirst"===this.dataFormat&&c.rank>1){let a=[0];for(let b=2;b<c.rank;++b)a.push(b);a.push(1),c=fO(c,a)}var d=c;if(d.rank<=1)throw new iY(`batchFlatten requires a minimum rank of 2. Got rank: ${d.rank}.`);let e=[d.shape[0],kQ(d.shape,1)];return e4(d,e)})}getConfig(){let a={};return null!=this.dataFormat&&(a.dataFormat=this.dataFormat),Object.assign(a,super.getConfig()),a}}oD.className="Flatten",jg.registerClass(oD);class oE extends lH{constructor(a){super(a),this.supportsMasking=!0,this.activation=nP(a.activation)}call(a,b){return dT(()=>{this.invokeCallHook(a,b);let c=lu(a);return this.activation.apply(c)})}getConfig(){let a={activation:nN(this.activation)};return Object.assign(a,super.getConfig()),a}}oE.className="Activation",jg.registerClass(oE);class oF extends lH{constructor(a){super(a),this.n=a.n,this.inputSpec=[{ndim:2}]}computeOutputShape(a){return[a[0],this.n,a[1]]}call(a,b){return dT(()=>{var b,c;return b=a=lu(a),c=this.n,dT(()=>{if(2!==b.shape.length)throw new iY(`repeat() expects a rank-2 tensor, but received a rank-${b.shape.length} tensor.`);return k0(kW(b,1),[1,c,1])})})}getConfig(){let a={n:this.n};return Object.assign(a,super.getConfig()),a}}oF.className="RepeatVector",jg.registerClass(oF);class oG extends lH{constructor(a){super(a),this.targetShape=a.targetShape;for(let a=0;a<this.targetShape.length;++a)this.isUnknown(this.targetShape[a])&&(this.targetShape[a]=null)}isUnknown(a){return a<0||null==a}fixUnknownDimension(a,b){let c="Total size of new array must be unchanged.",d=b.slice(),e=1,f=null;for(let a=0;a<d.length;++a){let b=d[a];if(this.isUnknown(b))if(null===f)f=a;else throw new iY("Can only specifiy one unknown dimension.");else e*=b}let g=kQ(a);if(null!==f){if(0===e||g%e!=0)throw new iY(c);d[f]=g/e}else if(g!==e)throw new iY(c);return d}computeOutputShape(a){let b=!1;for(let c=0;c<a.length;++c)if(this.isUnknown(a[c])){b=!0;break}return b?a.slice(0,1).concat(this.targetShape):a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape))}call(a,b){return dT(()=>{this.invokeCallHook(a,b);let c=lu(a),d=c.shape;return e4(c,d.slice(0,1).concat(this.fixUnknownDimension(d.slice(1),this.targetShape)))})}getConfig(){let a={targetShape:this.targetShape};return Object.assign(a,super.getConfig()),a}}oG.className="Reshape",jg.registerClass(oG);class oH extends lH{constructor(a){if(super(a),null==a.dims)throw Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(a.dims))throw Error(`Permute constructor requires \`dims\` to be an Array, but received ${a.dims} instead.`);const b=kT(1,a.dims.length+1);if(!iV.arraysEqual(a.dims.slice().sort(),b))throw Error("Invalid permutation `dims`: "+JSON.stringify(a.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=a.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new lC({ndim:this.dims.length+1})]}computeOutputShape(a){let b=(a=lv(a)).slice();return this.dims.forEach((c,d)=>{b[d+1]=a[c]}),b}call(a,b){return fO(lu(a),this.dimsIncludingBatch)}getConfig(){let a={dims:this.dims};return Object.assign(a,super.getConfig()),a}}oH.className="Permute",jg.registerClass(oH);class oI extends lH{constructor(a){super(null==a?{}:a),this.supportsMasking=!0,null!=a?this.maskValue=null==a.maskValue?0:a.maskValue:this.maskValue=0}computeOutputShape(a){return a}getConfig(){let a=super.getConfig(),b={maskValue:this.maskValue};return Object.assign(b,a),b}computeMask(a,b){return hF(im(lu(a),this.maskValue),-1)}call(a,b){return dT(()=>{this.invokeCallHook(a,b);let c=lu(a),d=hF(im(c,this.maskValue),-1,!0);return eB(c,ev(d,c.dtype))})}}oI.className="Masking",jg.registerClass(oI);var jg=jg;class oJ extends lH{constructor(a){if(super(a),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==a.batchInputShape&&null==a.inputShape){let b=null;null!=a.batchSize&&(b=a.batchSize),null==a.inputLength?this.batchInputShape=[b,null]:this.batchInputShape=[b].concat(i4(a.inputLength))}this.inputDim=a.inputDim,je(this.inputDim,"inputDim"),this.outputDim=a.outputDim,je(this.outputDim,"outputDim"),this.embeddingsInitializer=lr(a.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=nV(a.embeddingsRegularizer),this.activityRegularizer=nV(a.activityRegularizer),this.embeddingsConstraint=lX(a.embeddingsConstraint),this.maskZero=a.maskZero,this.supportsMasking=a.maskZero,this.inputLength=a.inputLength}build(a){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(a){}computeMask(a,b){return dT(()=>this.maskZero?im(a=lu(a),eE(a)):null)}computeOutputShape(a){if(a=lv(a),null==this.inputLength)return[...a,this.outputDim];let b=i4(this.inputLength);if(b.length!==a.length-1)throw new iY(`"inputLength" is ${this.inputLength}, but received input shape has shape ${a}`);{let c=0;for(let d=0;d<b.length;++d){let e=b[d],f=a[d+1];if(null!=e&&null!=f&&e!==f)throw new iY(`"inputLength" is ${this.inputLength}, but received input shape has shape ${a}`);null==e&&(b[c]=f),c++}}return[a[0],...b,this.outputDim]}call(a,b){return dT(()=>{this.invokeCallHook(a,b);let c=lu(a);"int32"!==c.dtype&&(c=ev(c,"int32"));let d=k3(this.embeddings.read(),e4(c,[c.size]));return e4(d,lv(this.computeOutputShape(c.shape)))})}getConfig(){let a={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:i8(this.embeddingsInitializer),embeddingsRegularizer:i8(this.embeddingsRegularizer),activityRegularizer:i8(this.activityRegularizer),embeddingsConstraint:i8(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength};return Object.assign(a,super.getConfig()),a}}oJ.className="Embedding",jg.registerClass(oJ);var iV=iV,jg=jg;class oK extends lH{constructor(a){super(a||{}),this.supportsMasking=!0}mergeFunction(a){throw new iZ}computeElementwiseOpOutputShape(a,b){if(null==a||null==b)return null;if(a.length<b.length)return this.computeElementwiseOpOutputShape(b,a);if(0===b.length)return a;let c=a.slice(0,a.length-b.length);for(let d=0;d<b.length;++d){let e=a[a.length-b.length+d],f=b[d];if(null==e||null==f||e<0||f<0)c.push(null);else if(1===e)c.push(f);else if(1===f)c.push(e);else{if(e!==f)throw new iY("Operands could not be broadcast together with shapes "+JSON.stringify(a)+" "+JSON.stringify(b));c.push(e)}}return c}build(a){if(Array.isArray(a)&&!Array.isArray(a[0])&&(a=[lv(a)]),a.length<2)throw new iY(`A merge layer should be called on an Array of at least 2 inputs. Got ${a.length} input(s).`);let b=[];for(let c of a)null!=c&&null!==c[0]&&b.push(c[0]);if((b=jb(b)).length>1)throw new iY(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(a)}.`);let c=null==a[0]?null:a[0].slice(1);for(let b=1;b<a.length;++b){let d=null==a[b]?null:a[b].slice(1);c=this.computeElementwiseOpOutputShape(c,d)}let d=a.map(a=>a.length);-1===a.indexOf(null)&&1===jb(d).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(a,b){return dT(()=>{if(!this.reshapeRequired)return this.mergeFunction(a);{let b=[],c=a.map(a=>a.rank);if(-1===c.indexOf(null)){let d=kS(c);for(let c of a){let a=c.rank;for(let b=0;b<d-a;++b)c=kW(c,1);b.push(c)}return this.mergeFunction(b)}{let c=!1;for(let d of a){let a=d.rank;if(null==a){let a=d.shape,e=a[0],f=a.slice(1).concat([e]),g=e4(d,[e].concat(kQ(a.slice(1))));g=e4(g=fO(g,[1,0]),f),b.push(g),c=!0}else if(a>1){let e=kT(1,a).concat([0]);b.push(fO(d,e)),c=!0}else b.push(d)}let d=this.mergeFunction(b),e=d.rank;if(c)if(null==e){let a=d.shape,b=a.length,c=a[b-1],e=[c].concat(a.slice(0,a.length-1));d=e4(fO(e4(d,[-1,c]),[1,0]),e)}else e>1&&(d=fO(d,[e-1].concat(kT(0,e-1))));return d}}})}computeOutputShape(a){let b;b=null==a[0]?null:a[0].slice(1);for(let c=1;c<a.length;++c){let d=null==a[c]?null:a[c].slice(1);b=this.computeElementwiseOpOutputShape(b,d)}let c=[];for(let b of a)null!=b&&null!==b[0]&&c.push(b[0]);return 1===(c=jb(c)).length?c.concat(b):[null].concat(b)}computeMask(a,b){return dT(()=>{if(null==b)return null;if(!Array.isArray(b))throw new iY("`mask` should be an Array");if(!Array.isArray(a))throw new iY("`inputs` should be an Array");if(b.length!==a.length)throw new iY(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${a.length} vs ${b.length})`);if(b.every(a=>null==a))return null;let c=(b=b.map(a=>null==a?a:hA(a,0)))[0];for(let a=1;a<b.length-1;++a)c=fr(c,b[a]);return c})}}class oL extends oK{constructor(a){super(a)}mergeFunction(a){return dT(()=>{let b=a[0].clone();for(let c=1;c<a.length;++c)b=ey(b,a[c]);return b})}}oL.className="Add",jg.registerClass(oL);class oM extends oK{constructor(a){super(a)}mergeFunction(a){return dT(()=>{let b=a[0].clone();for(let c=1;c<a.length;++c)b=eB(b,a[c]);return b})}}oM.className="Multiply",jg.registerClass(oM);class oN extends oK{constructor(a){super(a)}mergeFunction(a){return dT(()=>{let b=a[0].clone();for(let c=1;c<a.length;++c)b=ey(b,a[c]);return eB(1/a.length,b)})}}oN.className="Average",jg.registerClass(oN);class oO extends oK{constructor(a){super(a)}mergeFunction(a){return dT(()=>{let b=a[0];for(let c=1;c<a.length;++c)b=eY(b,a[c]);return b})}}oO.className="Maximum",jg.registerClass(oO);class oP extends oK{constructor(a){super(a)}mergeFunction(a){return dT(()=>{let b=a[0];for(let c=1;c<a.length;++c)b=ij(b,a[c]);return b})}}oP.className="Minimum",jg.registerClass(oP);class oQ extends oK{constructor(a){super(a),this.DEFAULT_AXIS=-1,null==a&&(a={}),this.axis=null==a.axis?this.DEFAULT_AXIS:a.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(a){if(!(Array.isArray(a)&&Array.isArray(a[0]))||1===a.length)throw new iY("A `Concatenate` layer should be called on a list of at least 2 inputs");let b=!0;for(let c of a)if(null!=c){b=!1;break}if(b)return;let c=[];for(let b=0;b<a.length;++b){let d=a[b].slice();d.splice(this.axis,1);let e=!1;for(let a of c)if(iV.arraysEqual(a,d)){e=!0;break}e||c.push(d)}if(c.length>1)throw new iY("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(a))}mergeFunction(a){return dT(()=>k$(a,this.axis))}computeOutputShape(a){if(!(Array.isArray(a)&&Array.isArray(a[0])))throw new iY("A `Concatenate` layer should be called on a list of inputs.");let b=a[0].slice(),c=this.axis<0?b.length+this.axis:this.axis;for(let d of a.slice(1)){if(null==b[c]||null==d[c]){b[c]=null;break}b[c]+=d[c]}return b}computeMask(a,b){if(null==b)return null;if(!Array.isArray(b))throw new iY("`mask` should be an array for Concatenate");if(!Array.isArray(a))throw new iY("`inputs` should be an array for Concatenate");if(b.length!==a.length)throw new iY(`Mismatch in the length of mask (${b.length}) and the legnth of inputs (${a.length})`);return dT(()=>{let c=!0;if(b.forEach(a=>{if(null!=a){c=!1;return}}),c)return null;let d=[];for(let c=0;c<a.length;++c)null==b[c]?d.push(ev(ip(a[c]),"bool")):b[c].rank<a[c].rank?d.push(hA(b[c],-1)):d.push(b[c]);return hE(hy(d,this.axis),-1,!1)})}getConfig(){let a={axis:this.axis};return Object.assign(a,super.getConfig()),a}}function oR(a,b){for(;a<0;)a+=b;return a}oQ.className="Concatenate",jg.registerClass(oQ);class oS extends oK{constructor(a){super(a),this.axes=a.axes,this.normalize=null!=a.normalize&&a.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(a){iV.assert(Array.isArray(a)&&2===a.length&&Array.isArray(a[0])&&Array.isArray(a[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let b=a[0],c=a[1];if(b.length>3||c.length>3)throw new iZ("Dot layer does not support tensors of 4D or higher rank yet.");let d=this.interpretAxes(b,c);if(b[d[0]]!==c[d[1]])throw new iY(`Dimension incompatibility: ${b[d[0]]} !== ${c[d[1]]}`)}mergeFunction(a){let b;if(2!==a.length)throw new iY(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${a.length} input(s).`);let c=a[0],d=a[1];b=Array.isArray(this.axes)?this.axes.map((b,c)=>oR(b,a[c].shape.length)):[oR(this.axes,c.shape.length),oR(this.axes,d.shape.length)],this.normalize&&(c=mN(c,b[0]),d=mN(d,b[1]));var e=c,f=d,g=b;if(e.shape.length>3||f.shape.length>3)throw new iZ("batchDot is not implemented for tensors of 4D or higher rank yet");if(iV.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),iV.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${f.shape.length}`),"number"==typeof g&&(g=[g,g]),"complex64"===e.dtype||"complex64"===f.dtype)throw new iZ("batchDot is not implemented for complex64-type Tensors yet.");let h=e.shape.length,i=f.shape.length;null==g&&(g=[h-1,i-2]);let j=g;return dT(()=>{let a,b;if(h>i){a=h-i;let b=[];for(let c=0;c<a;++c)b.push(1);f=e4(f,f.shape.concat(b))}else if(i>h){a=i-h;let b=[];for(let c=0;c<a;++c)b.push(1);e=e4(e,e.shape.concat(b))}else a=0;if(2===e.shape.length&&2===f.shape.length)b=j[0]===j[1]?e5(eB(e,f),j[0]):e5(eB(fO(e,[1,0]),f),j[1]);else{let a=j[0]!==e.shape.length-1,c=j[1]===f.shape.length-1;b=fn(e,f,a,c)}if(a>0){let c;c=h>i?h+i-3:h-1;let d=[];for(let b=c;b<c+a;++b)d.push(b);b=iC(b,d)}return 1===b.shape.length&&(b=hA(b,1)),b})}interpretAxes(a,b){return Array.isArray(this.axes)?this.axes:[oR(this.axes,a.length),oR(this.axes,b.length)]}computeOutputShape(a){iV.assert(Array.isArray(a)&&2===a.length&&Array.isArray(a[0])&&Array.isArray(a[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let b=a[0].slice(),c=a[1].slice();if(b.length>3||c.length>3)throw new iZ("Dot layer does not support tensors of 4D or higher rank yet.");let d=this.interpretAxes(b,c);b.splice(d[0],1),c.splice(d[1],1),c.splice(0,1);let e=b.concat(c);return 1===e.length&&e.push(1),e}computeMask(a,b){return null}getConfig(){let a={axes:this.axes,normalize:this.normalize};return Object.assign(a,super.getConfig()),a}}oS.className="Dot",jg.registerClass(oS);var jg=jg;class oT extends lH{constructor(a){super(a),this.supportsMasking=!0,this.stddev=a.stddev}computeOutputShape(a){return a}getConfig(){let a=super.getConfig(),b={stddev:this.stddev};return Object.assign(b,a),b}call(a,b){return dT(()=>{this.invokeCallHook(a,b);let c=lu(a);return k6(()=>ey(k1(c.shape,0,this.stddev),c),()=>c,b.training||!1)})}}oT.className="GaussianNoise",jg.registerClass(oT);class oU extends lH{constructor(a){super(a),this.supportsMasking=!0,this.rate=a.rate}computeOutputShape(a){return a}getConfig(){let a=super.getConfig(),b={rate:this.rate};return Object.assign(b,a),b}call(a,b){return dT(()=>{this.invokeCallHook(a,b);let c=lu(a);return this.rate>0&&this.rate<1?k6(()=>{let a=Math.sqrt(this.rate/(1-this.rate));return eB(c,k1(c.shape,1,a))},()=>c,b.training||!1):c})}}oU.className="GaussianDropout",jg.registerClass(oU);class oV extends lH{constructor(a){super(a),this.supportsMasking=!0,this.rate=a.rate,this.noiseShape=a.noiseShape}_getNoiseShape(a){return this.noiseShape||lu(a).shape}computeOutputShape(a){return a}getConfig(){let a=super.getConfig(),b={rate:this.rate};return Object.assign(b,a),b}call(a,b){return dT(()=>{if(this.rate<1&&this.rate>0){let c=this._getNoiseShape(a);return k6(()=>{let b=lu(a),d=fp(kD(c),this.rate);d=ev(d,"float32");let e=((1-this.rate)*(1+3.09091329228798*this.rate))**-.5,f=-(-1.7580993408473766*e)*this.rate,g=ey(eB(b,d),eB(ey(d,-1),-1.7580993408473766));return ey(eB(g,e),f)},()=>lu(a),b.training||!1)}return a})}}oV.className="AlphaDropout",jg.registerClass(oV);let oW=dM({batchNorm4d_:function(a,b,c,d,e,f){let g,h,i=dJ(a,"x","batchNorm"),j=dJ(b,"mean","batchNorm"),k=dJ(c,"variance","batchNorm");return null!=e&&(g=dJ(e,"scale","batchNorm")),null!=d&&(h=dJ(d,"offset","batchNorm")),I(4===i.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),I(4===j.rank||1===j.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${j.rank}.`),I(4===k.rank||1===k.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${k.rank}.`),null!=g&&I(4===g.rank||1===g.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${g.rank}.`),null!=h&&I(4===h.rank||1===h.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`),hO(i,j,k,h,g,f)}}),oX=dM({batchNorm3d_:function(a,b,c,d,e,f){let g,h,i=dJ(a,"x","batchNorm"),j=dJ(b,"mean","batchNorm"),k=dJ(c,"variance","batchNorm");return null!=e&&(g=dJ(e,"scale","batchNorm")),null!=d&&(h=dJ(d,"offset","batchNorm")),I(3===i.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),I(3===j.rank||1===j.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${j.rank}.`),I(3===k.rank||1===k.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${k.rank}.`),null!=g&&I(3===g.rank||1===g.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${g.rank}.`),null!=h&&I(3===h.rank||1===h.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`),hO(i,j,k,h,g,f)}}),oY=dM({batchNorm2d_:function(a,b,c,d,e,f){let g,h,i=dJ(a,"x","batchNorm"),j=dJ(b,"mean","batchNorm"),k=dJ(c,"variance","batchNorm");return null!=e&&(g=dJ(e,"scale","batchNorm")),null!=d&&(h=dJ(d,"offset","batchNorm")),I(2===i.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),I(2===j.rank||1===j.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${j.rank}.`),I(2===k.rank||1===k.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${k.rank}.`),null!=g&&I(2===g.rank||1===g.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${g.rank}.`),null!=h&&I(2===h.rank||1===h.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`),hO(i,j,k,h,g,f)}}),oZ=dM({moments_:function(a,b=null,c=!1){let d=W(b,(a=dJ(a,"x","moments")).shape),e=ii(a,d,c),f=e.shape;c||(f=fG(e.shape,d));let g=ii(eD(eS(ev(a,"float32"),e4(e,f))),d,c);return{mean:e,variance:g}}});var jg=jg,iV=iV;function o$(a,b,c,d,e,f=.001){let g;if(2===a.rank)g=oY(a,b,c,d,e,f);else if(3===a.rank)g=oX(a,b,c,d,e,f);else if(4===a.rank)g=oW(a,b,c,d,e,f);else throw new iZ(`batchNormalization is not implemented for array of rank ${a.rank} yet`);return g}class o_ extends lH{constructor(a){null==a&&(a={}),super(a),this.supportsMasking=!0,this.axis=null==a.axis?-1:a.axis,this.momentum=null==a.momentum?.99:a.momentum,this.epsilon=null==a.epsilon?.001:a.epsilon,this.center=null==a.center||a.center,this.scale=null==a.scale||a.scale,this.betaInitializer=lr(a.betaInitializer||"zeros"),this.gammaInitializer=lr(a.gammaInitializer||"ones"),this.movingMeanInitializer=lr(a.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=lr(a.movingVarianceInitializer||"ones"),this.betaConstraint=lX(a.betaConstraint),this.gammaConstraint=lX(a.gammaConstraint),this.betaRegularizer=nV(a.betaRegularizer),this.gammaRegularizer=nV(a.gammaRegularizer)}build(a){a=lv(a);let b=this.axis>=0?this.axis:this.axis+a.length,c=a[b];if(null==c)throw new iY(`Axis ${b} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(a)}.`);this.inputSpec=[new lC({ndim:a.length,axes:{[b]:c}})];let d=[c];this.scale&&(this.gamma=this.addWeight("gamma",d,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",d,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",d,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",d,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(a,b){return dT(()=>{let c=null!=b.training&&b.training,d=lu(a),e=d.shape,f=e.length,g=kT(0,f),h=this.axis>=0?this.axis:this.axis+f;g.splice(h,1);let i=i0(1,f);i[h]=e[h];let j=g.slice();j.sort();let k=!iV.arraysEqual(j,kT(0,f).slice(0,f-1)),l=()=>k?o$(d,e4(this.movingMean.read(),i),e4(this.movingVariance.read(),i),this.center?e4(this.beta.read(),i):null,this.scale?e4(this.gamma.read(),i):null,this.epsilon):o$(d,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon);if(!c)return l();let[m,n,o]=function(a,b,c,d,e=.001){return iV.arraysEqual(d.slice().sort(),kT(0,a.rank-1))?function(a,b,c,d,e=.001){return dT(()=>{let f=oZ(a,d),g=f.mean,h=f.variance;return[o$(a,g,h,c,b,e),g,h]})}(a,b,c,d,e):function(a,b,c,d,e=.001){return dT(()=>{let f=oZ(a,d),g=f.mean,h=f.variance,i=[];for(let b of kT(0,a.rank))-1!==d.indexOf(b)?i.push(1):i.push(a.shape[b]);let j=e4(g,i),k=e4(h,i),l=null==b?null:e4(b,i);return[o$(a,j,k,null==c?null:e4(c,i),l,e),g,h]})}(a,b,c,d,e)}(d,this.gamma.read(),this.beta.read(),g,this.epsilon),p=(a,b,c)=>{dT(()=>{let d=a.read(),e=eB(eS(d,b),1-c);a.write(eS(d,e))})};return p(this.movingMean,n,this.momentum),p(this.movingVariance,o,this.momentum),m})}getConfig(){let a={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:i8(this.betaInitializer),gammaInitializer:i8(this.gammaInitializer),movingMeanInitializer:i8(this.movingMeanInitializer),movingVarianceInitializer:i8(this.movingVarianceInitializer),betaRegularizer:i8(this.betaRegularizer),gammaRegularizer:i8(this.gammaRegularizer),betaConstraint:i8(this.betaConstraint),gammaConstraint:i8(this.gammaConstraint)};return Object.assign(a,super.getConfig()),a}}o_.className="BatchNormalization",jg.registerClass(o_);class o0 extends lH{constructor(a){if(null==a&&(a={}),super(a),this.axis=null==a.axis?-1:a.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const a of this.axis)if(!Number.isInteger(a))throw Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=null==a.epsilon?.001:a.epsilon,this.center=null==a.center||a.center,this.scale=null==a.scale||a.scale,this.betaInitializer=lr(a.betaInitializer||"zeros"),this.gammaInitializer=lr(a.gammaInitializer||"ones"),this.betaRegularizer=nV(a.betaRegularizer),this.gammaRegularizer=nV(a.gammaRegularizer),this.supportsMasking=!0}build(a){let b=(a=lv(a)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=b);for(let a of this.axis)if(a<0||a>=b)throw Error(`Invalid axis: ${a}`);if(this.axis.length!==jb(this.axis).length)throw Error(`Found duplicate axes in: ${this.axis}`);let c=this.axis.map(b=>a[b]);this.scale?this.gamma=this.addWeight("gamma",c,"float32",this.gammaInitializer,this.gammaRegularizer,!0):this.gamma=null,this.center?this.beta=this.addWeight("beta",c,"float32",this.betaInitializer,this.betaRegularizer,!0):this.beta=null,this.built=!0}call(a,b){let c=lu(a),d=c.shape,e=d.length;return dT(()=>{let{mean:a,variance:b}=oZ(c,this.axis,!0),f=i0(1,e);for(let a of this.axis)f[a]=d[a];let g=a=>null!=a&&a.shape.length!==e?e4(a,f):a,h=this.scale?g(this.gamma.read()):null,i=this.center?g(this.beta.read()):null,j=[],k=[];for(let a=0;a<e;++a)-1!==this.axis.indexOf(a)?(j.push(d[a]),k.push(1)):(j.push(1),k.push(d[a]));return a=fT(a,j),b=fT(b,j),null!=h&&(h=fT(h,k)),null!=i&&(i=fT(i,k)),o$(c,a,b,i,h,this.epsilon)})}getConfig(){let a={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:i8(this.betaInitializer),gammaInitializer:i8(this.gammaInitializer),betaRegularizer:i8(this.betaRegularizer),gammaRegularizer:i8(this.gammaRegularizer)};return Object.assign(a,super.getConfig()),a}}o0.className="LayerNormalization",jg.registerClass(o0);var jg=jg;class o1 extends lH{constructor(a){if(null==a&&(a={}),super(a),this.dataFormat=null==a.dataFormat?kV():a.dataFormat,null==a.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof a.padding)this.padding=[[a.padding,a.padding],[a.padding,a.padding]];else{let b,c;if(a.padding=a.padding,2!==a.padding.length)throw new iY(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${a.padding.length} array.`);if("number"==typeof a.padding[0])b=[a.padding[0],a.padding[0]],c=[a.padding[1],a.padding[1]];else{if(a.padding=a.padding,2!==a.padding[0].length)throw new iY(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${a.padding[0].length} array.`);if(b=a.padding[0],2!==a.padding[1].length)throw new iY(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${a.padding[1].length} array.`);c=a.padding[1]}this.padding=[b,c]}this.inputSpec=[new lC({ndim:4})]}computeOutputShape(a){let b,c;return(a=lv(a),"channelsFirst"===this.dataFormat)?(b=null!=a[2]&&a[2]>=0?a[2]+this.padding[0][0]+this.padding[0][1]:null,c=null!=a[3]&&a[3]>=0?a[3]+this.padding[1][0]+this.padding[1][1]:null,[a[0],a[1],b,c]):(b=null!=a[1]&&a[1]>=0?a[1]+this.padding[0][0]+this.padding[0][1]:null,c=null!=a[2]&&a[2]>=0?a[2]+this.padding[1][0]+this.padding[1][1]:null,[a[0],b,c,a[3]])}call(a,b){return dT(()=>{var b,c,d;return b=lu(a),c=this.padding,d=this.dataFormat,dT(()=>{if(4!==b.rank)throw new iY(`temporalPadding expects input tensor to be 4-D, but received a ${b.rank}-D tensor.`);if(null==c&&(c=[[1,1],[1,1]]),2!==c.length||2!==c[0].length||2!==c[1].length)throw new iY("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==d&&(d=kV()),"channelsLast"!==d&&"channelsFirst"!==d)throw new iY(`Unknown data format: ${d}. Supported data formats are 'channelsLast' and 'channelsFirst.`);return hv(b,"channelsFirst"===d?[[0,0],[0,0],c[0],c[1]]:[[0,0],c[0],c[1],[0,0]])})})}getConfig(){let a={padding:this.padding,dataFormat:this.dataFormat};return Object.assign(a,super.getConfig()),a}}o1.className="ZeroPadding2D",jg.registerClass(o1);let o2=dM({avgPool3d_:function(a,b,c,d,e,f="NDHWC"){let g=dJ(a,"x","avgPool3d","float32"),h=g,i=!1;4===g.rank&&(i=!0,h=e4(g,[1,g.shape[0],g.shape[1],g.shape[2],g.shape[3]])),I(5===h.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${h.rank}.`),I("NDHWC"===f,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${f}`),I("number"==typeof c&&c>0||Array.isArray(c)&&c[0]>0&&c[1]>0&&c[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${c}'`),fk("avgPool3d",d,e);let j={x:h},k=dB.runKernel(aL,j,{filterSize:b,strides:c,pad:d,dimRoundingMode:e,dataFormat:f});return(k=ev(k,h.dtype),i)?e4(k,[k.shape[1],k.shape[2],k.shape[3],k.shape[4]]):k}}),o3=dM({maxPool3d_:function(a,b=[1,1,1],c,d,e,f="NDHWC"){let g=dJ(a,"x","maxPool3d"),h=g,i=!1;4===g.rank&&(i=!0,h=e4(g,[1,g.shape[0],g.shape[1],g.shape[2],g.shape[3]])),I(5===h.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${h.rank}.`),I("NDHWC"===f,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${f}`),fk("maxPool3d",d,e);let j={x:h},k=dB.runKernel(bN,j,{filterSize:b,strides:c,pad:d,dimRoundingMode:e,dataFormat:f});return i?e4(k,[k.shape[1],k.shape[2],k.shape[3],k.shape[4]]):k}});var jg=jg;function o4(a,b,c,d,e,f){return dT(()=>{let g;jq(e),js(f),jr(d),null==c&&(c=[1,1]),null==d&&(d="valid"),null==e&&(e=kV()),null==f&&(f="max"),a=n5(a,e);let h="same"===d?"same":"valid";return g="max"===f?ih(a,b,c,h):hN(a,b,c,h),"channelsFirst"===e&&(g=fO(g,[0,3,1,2])),g})}function o5(a,b,c,d,e,f){return dT(()=>{let g;jq(e),js(f),jr(d),null==c&&(c=[1,1,1]),null==d&&(d="valid"),null==e&&(e=kV()),null==f&&(f="max"),a=n6(a,e);let h="same"===d?"same":"valid";return g="max"===f?o3(a,b,c,h):o2(a,b,c,h),"channelsFirst"===e&&(g=fO(g,[0,4,1,2,3])),g})}class o6 extends lH{constructor(a){if(null==a.poolSize&&(a.poolSize=2),super(a),"number"==typeof a.poolSize)this.poolSize=[a.poolSize];else if(Array.isArray(a.poolSize)&&1===a.poolSize.length&&"number"==typeof a.poolSize[0])this.poolSize=a.poolSize;else throw new iY(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(a.poolSize)}`);if(je(this.poolSize,"poolSize"),null==a.strides)this.strides=this.poolSize;else if("number"==typeof a.strides)this.strides=[a.strides];else if(Array.isArray(a.strides)&&1===a.strides.length&&"number"==typeof a.strides[0])this.strides=a.strides;else throw new iY(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(a.strides)}`);je(this.strides,"strides"),this.padding=null==a.padding?"valid":a.padding,jr(this.padding),this.inputSpec=[new lC({ndim:3})]}computeOutputShape(a){let b=n3((a=lv(a))[1],this.poolSize[0],this.padding,this.strides[0]);return[a[0],b,a[2]]}call(a,b){return dT(()=>(this.invokeCallHook(a,b),a=kW(lu(a),2),iC(this.poolingFunction(lu(a),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast"),[2])))}getConfig(){let a={poolSize:this.poolSize,padding:this.padding,strides:this.strides};return Object.assign(a,super.getConfig()),a}}class o7 extends o6{constructor(a){super(a)}poolingFunction(a,b,c,d,e){return jq(e),jr(d),o4(a,b,c,d,e,"max")}}o7.className="MaxPooling1D",jg.registerClass(o7);class o8 extends o6{constructor(a){super(a)}poolingFunction(a,b,c,d,e){return jq(e),jr(d),o4(a,b,c,d,e,"avg")}}o8.className="AveragePooling1D",jg.registerClass(o8);class o9 extends lH{constructor(a){if(null==a.poolSize&&(a.poolSize=[2,2]),super(a),this.poolSize=Array.isArray(a.poolSize)?a.poolSize:[a.poolSize,a.poolSize],null==a.strides)this.strides=this.poolSize;else if(Array.isArray(a.strides)){if(2!==a.strides.length)throw new iY(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${a.strides.length}.`);this.strides=a.strides}else this.strides=[a.strides,a.strides];je(this.poolSize,"poolSize"),je(this.strides,"strides"),this.padding=null==a.padding?"valid":a.padding,this.dataFormat=null==a.dataFormat?"channelsLast":a.dataFormat,jq(this.dataFormat),jr(this.padding),this.inputSpec=[new lC({ndim:4})]}computeOutputShape(a){a=lv(a);let b="channelsFirst"===this.dataFormat?a[2]:a[1],c="channelsFirst"===this.dataFormat?a[3]:a[2];return(b=n3(b,this.poolSize[0],this.padding,this.strides[0]),c=n3(c,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat)?[a[0],a[1],b,c]:[a[0],b,c,a[3]]}call(a,b){return dT(()=>(this.invokeCallHook(a,b),this.poolingFunction(lu(a),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let a={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat};return Object.assign(a,super.getConfig()),a}}class pa extends o9{constructor(a){super(a)}poolingFunction(a,b,c,d,e){return jq(e),jr(d),o4(a,b,c,d,e,"max")}}pa.className="MaxPooling2D",jg.registerClass(pa);class pb extends o9{constructor(a){super(a)}poolingFunction(a,b,c,d,e){return jq(e),jr(d),o4(a,b,c,d,e,"avg")}}pb.className="AveragePooling2D",jg.registerClass(pb);class pc extends lH{constructor(a){if(null==a.poolSize&&(a.poolSize=[2,2,2]),super(a),this.poolSize=Array.isArray(a.poolSize)?a.poolSize:[a.poolSize,a.poolSize,a.poolSize],null==a.strides)this.strides=this.poolSize;else if(Array.isArray(a.strides)){if(3!==a.strides.length)throw new iY(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${a.strides.length}.`);this.strides=a.strides}else this.strides=[a.strides,a.strides,a.strides];je(this.poolSize,"poolSize"),je(this.strides,"strides"),this.padding=null==a.padding?"valid":a.padding,this.dataFormat=null==a.dataFormat?"channelsLast":a.dataFormat,jq(this.dataFormat),jr(this.padding),this.inputSpec=[new lC({ndim:5})]}computeOutputShape(a){a=lv(a);let b="channelsFirst"===this.dataFormat?a[2]:a[1],c="channelsFirst"===this.dataFormat?a[3]:a[2],d="channelsFirst"===this.dataFormat?a[4]:a[3];return(b=n3(b,this.poolSize[0],this.padding,this.strides[0]),c=n3(c,this.poolSize[1],this.padding,this.strides[1]),d=n3(d,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat)?[a[0],a[1],b,c,d]:[a[0],b,c,d,a[4]]}call(a,b){return dT(()=>(this.invokeCallHook(a,b),this.poolingFunction(lu(a),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let a={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat};return Object.assign(a,super.getConfig()),a}}class pd extends pc{constructor(a){super(a)}poolingFunction(a,b,c,d,e){return jq(e),jr(d),o5(a,b,c,d,e,"max")}}pd.className="MaxPooling3D",jg.registerClass(pd);class pe extends pc{constructor(a){super(a)}poolingFunction(a,b,c,d,e){return jq(e),jr(d),o5(a,b,c,d,e,"avg")}}pe.className="AveragePooling3D",jg.registerClass(pe);class pf extends lH{constructor(a){super(a),this.inputSpec=[new lC({ndim:3})]}computeOutputShape(a){return[a[0],a[2]]}call(a,b){throw new iZ}}class pg extends pf{constructor(a){super(a||{})}call(a,b){return dT(()=>ii(lu(a),1))}}pg.className="GlobalAveragePooling1D",jg.registerClass(pg);class ph extends pf{constructor(a){super(a||{})}call(a,b){return dT(()=>hZ(lu(a),1))}}ph.className="GlobalMaxPooling1D",jg.registerClass(ph);class pi extends lH{constructor(a){super(a),this.dataFormat=null==a.dataFormat?"channelsLast":a.dataFormat,jq(this.dataFormat),this.inputSpec=[new lC({ndim:4})]}computeOutputShape(a){return"channelsLast"===this.dataFormat?[a[0],a[3]]:[a[0],a[1]]}call(a,b){throw new iZ}getConfig(){let a={dataFormat:this.dataFormat};return Object.assign(a,super.getConfig()),a}}class pj extends pi{call(a,b){return dT(()=>{let b=lu(a);return"channelsLast"===this.dataFormat?ii(b,[1,2]):ii(b,[2,3])})}}pj.className="GlobalAveragePooling2D",jg.registerClass(pj);class pk extends pi{call(a,b){return dT(()=>{let b=lu(a);return"channelsLast"===this.dataFormat?hZ(b,[1,2]):hZ(b,[2,3])})}}pk.className="GlobalMaxPooling2D",jg.registerClass(pk);var jg=jg;class pl extends lH{constructor(a){super(a),this.layer=a.layer}build(a){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(a){null!=this.layer&&(this.layer.trainable=a)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(a){this.layer.setWeights(a)}getConfig(){let a={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}};return Object.assign(a,super.getConfig()),a}setFastWeightInitDuringBuild(a){super.setFastWeightInitDuringBuild(a),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(a)}static fromConfig(a,b,c={}){let d=mM(b.layer,c);delete b.layer;let e={layer:d};return Object.assign(e,b),new a(e)}}class pm extends pl{constructor(a){super(a),this.supportsMasking=!0}build(a){if((a=lv(a)).length<3)throw new iY(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(a)}`);this.inputSpec=[{shape:a}];let b=[a[0]].concat(a.slice(2));this.layer.built||(this.layer.build(b),this.layer.built=!0),super.build(a)}computeOutputShape(a){let b=[(a=lv(a))[0]].concat(a.slice(2)),c=this.layer.computeOutputShape(b),d=a[1];return[c[0],d].concat(c.slice(1))}call(a,b){return dT(()=>ol((a,c)=>[lu(this.layer.call(a,b)),[]],a=lu(a),[],!1,null,null,!1,!0)[1])}}pm.className="TimeDistributed",jg.registerClass(pm);class pn extends pl{constructor(a){super(a);const b=a.layer.getConfig(),c={};c.className=a.layer.getClassName(),c.config=b,this.forwardLayer=mM(c),b.goBackwards=!0!==b.goBackwards;const d={};if(d.className=a.layer.getClassName(),d.config=b,this.backwardLayer=mM(d),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===a.mergeMode?"concat":a.mergeMode,jc(jo,"BidirectionalMergeMode",this.mergeMode),a.weights)throw new iZ("weights support is not implemented for Bidirectional layer yet.");this._stateful=a.layer.stateful,this.returnSequences=a.layer.returnSequences,this.returnState=a.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=a.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(a){this._trainable=a,null!=this.forwardLayer&&(this.forwardLayer.trainable=a),null!=this.backwardLayer&&(this.backwardLayer.trainable=a)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(a){let b=Math.floor(a.length/2);this.forwardLayer.setWeights(a.slice(0,b)),this.backwardLayer.setWeights(a.slice(b))}computeOutputShape(a){let b,c,d,e=this.forwardLayer.computeOutputShape(a);return(Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),this.returnState&&(d=e.slice(1)),b=e[0],"concat"===this.mergeMode?(b[b.length-1]*=2,c=[b]):c=null==this.mergeMode?[b,b.slice()]:[b],this.returnState)?null==this.mergeMode?c.concat(d).concat(d.slice()):[b].concat(d).concat(d.slice()):i3(c)}apply(a,b){let c=null==b?null:b.initialState,d=null==b?null:b.constants;null==b&&(b={});let e=ok(a,c,d,this.numConstants);if(a=e.inputs,c=e.initialState,d=e.constants,Array.isArray(a)&&(c=a.slice(1),a=a[0]),(null==c||0===c.length)&&null==d)return super.apply(a,b);let f=[],g=[];if(null!=c){let a=c.length;if(a%2>0)throw new iY("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");b.initialState=c,f.push(...c);let d=c.map(a=>new lC({shape:a.shape}));this.forwardLayer.stateSpec=d.slice(0,a/2),this.backwardLayer.stateSpec=d.slice(a/2),g.push(...d)}if(null!=d)throw new iZ("Support for constants in Bidirectional layers is not implemented yet.");let h=f[0]instanceof lD;for(let a of f)if(a instanceof lD!==h)throw new iY("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(!h)return super.apply(a,b);{let c=[a].concat(f),d=this.inputSpec.concat(g),e=this.inputSpec;this.inputSpec=d;let h=super.apply(c,b);return this.inputSpec=e,h}}call(a,b){return dT(()=>{let c,d,e,f,g=b.initialState;if(null==g)c=this.forwardLayer.call(a,b),d=this.backwardLayer.call(a,b);else{let e=g.slice(0,g.length/2),f=g.slice(g.length/2);c=this.forwardLayer.call(a,Object.assign(b,{initialState:e})),d=this.backwardLayer.call(a,Object.assign(b,{initialState:f}))}return(this.returnState&&(Array.isArray(c)&&(e=c.slice(1).concat(d.slice(1))),c=c[0],d=d[0]),this.returnSequences&&(d=hr(d,1)),"concat"===this.mergeMode?f=k$([c,d]):"sum"===this.mergeMode?f=ey(c,d):"ave"===this.mergeMode?f=eB(.5,ey(c,d)):"mul"===this.mergeMode?f=eB(c,d):null==this.mergeMode&&(f=[c,d]),this.returnState)?null==this.mergeMode?f.concat(e):[f].concat(e):f})}resetStates(a){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(a){ju(this.forwardLayer.name,()=>{this.forwardLayer.build(a)}),ju(this.backwardLayer.name,()=>{this.backwardLayer.build(a)}),this.built=!0}computeMask(a,b){let c;if(Array.isArray(b)&&(b=b[0]),c=this.returnSequences?null==this.mergeMode?[b,b]:b:null==this.mergeMode?[null,null]:null,!this.returnState)return c;{let a=this.forwardLayer.states.map(a=>null);return Array.isArray(c)?c.concat(a).concat(a):[c].concat(a).concat(a)}}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(a){super.setFastWeightInitDuringBuild(a),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(a),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(a)}getConfig(){let a={mergeMode:this.mergeMode};return Object.assign(a,super.getConfig()),a}static fromConfig(a,b){let c=mM(b.layer);if(delete b.layer,null!=b.numConstants)throw new iZ("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");return b.layer=c,new a(b)}}pn.className="Bidirectional",jg.registerClass(pn);var jg=jg;class po extends lH{constructor(a){super(a),this.scale=a.scale,a.offset?this.offset=a.offset:this.offset=0}getConfig(){let a={scale:this.scale,offset:this.offset};return Object.assign(a,super.getConfig()),a}call(a,b){return dT(()=>("float32"!==(a=lu(a)).dtype&&(a=ev(a,"float32")),ey(eB(a,this.scale),this.offset)))}}po.className="Rescaling",jg.registerClass(po);var jg=jg;let{resizeBilinear:pp,cropAndResize:pq}=ku;class pr extends lH{constructor(a){super(a),this.height=a.height,this.width=a.width}centerCrop(a,b,c,d,e,f,g,h){return dT(()=>{let i,j=!1,k=[b/f,c/g,(d+b)/f,(e+c)/g],l=[];3===a.rank?(j=!0,i=fU([a])):i=a;for(let a=0;a<i.shape[0];a++)l.push(k);let m=pq(i,dP(l,[l.length,4]),j4(0,l.length,1,"int32"),[d,e],"nearest");if(j)return ev(lu(f8(m)),h);return ev(m,h)})}upsize(a,b,c,d){return dT(()=>ev(pp(a,[b,c]),d))}call(a,b){return dT(()=>{let b=lu(a),c=b.dtype,d=b.shape,e=d[d.length-3],f=d[d.length-2],g=0;e!==this.height&&(g=Math.floor((e-this.height)/2));let h=0;return(f!==this.width&&0===(h=Math.floor((f-this.width)/2))&&(h=1),g>=0&&h>=0)?this.centerCrop(b,g,h,this.height,this.width,e,f,c):this.upsize(a,this.height,this.width,c)})}getConfig(){let a={height:this.height,width:this.width};return Object.assign(a,super.getConfig()),a}computeOutputShape(a){let b=(a=lv(a)).length-3,c=a.length-2;return a[b]=this.height,a[c]=this.width,a}}pr.className="CenterCrop",jg.registerClass(pr);var jg=jg;let ps=dM({denseBincount_:function(a,b,c,d=!1){let e=dJ(a,"x","denseBincount"),f=dJ(b,"weights","denseBincount");return I("int32"===e.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${e.dtype}`),I(e.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${e.rank}.`),I(c>=0,()=>`size must be non-negative, but got ${c}.`),I(f.size===e.size||0===f.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${e.shape}, weights shape: ${f.shape}.`),dB.runKernel(a6,{x:e,weights:f},{size:c,binaryOutput:d})}});class pt extends lH{constructor(a){super(a),this.numTokens=a.numTokens,a.outputMode?this.outputMode=a.outputMode:this.outputMode="multiHot"}getConfig(){let a={numTokens:this.numTokens,outputMode:this.outputMode};return Object.assign(a,super.getConfig()),a}computeOutputShape(a){return null==(a=lv(a))?[this.numTokens]:("oneHot"===this.outputMode&&1!==a[a.length-1]?a.push(this.numTokens):a[a.length-1]=this.numTokens,a)}call(a,b){return dT(()=>{let c;if("int32"!==(a=lu(a)).dtype&&(a=ev(a,"int32")),void 0!==b.countWeights){if("count"!==this.outputMode)throw new iY(`countWeights is not used when outputMode !== count.
              Received countWeights=${b.countWeights}`);c=lu(b.countWeights)}let d=hZ(a),e=h$(a),f=fY(this.numTokens,d).bufferSync().get(0),g=fp(e,0).bufferSync().get(0);if(!(f&&g))throw new iY(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(a,b,c,d){let e,f=lu(a);if("int32"!==f.dtype&&(f=ev(f,"int32")),"int"===b)return f;let g=f.shape;if(0===f.rank&&(f=hA(f,-1)),"oneHot"===b&&1!==f.shape[f.shape.length-1]&&(f=hA(f,-1)),f.rank>2)throw new iY(`When outputMode is not int, maximum output rank is 2 Received outputMode ${b} and input shape ${g} which would result in output rank ${f.rank}.`);let h=["multiHot","oneHot"].includes(b),i=f;if(e=void 0!==d&&"count"===b?ps(i,d,c,h):ps(i,[],c,h),"tfIdf"!==b)return e;if(d)return eB(e,d);throw new iY("When outputMode is 'tfIdf', weights must be provided.")}(a,this.outputMode,this.numTokens,c)})}}pt.className="CategoryEncoding",jg.registerClass(pt);var jg=jg;let pu=new Set(["bilinear","nearest"]);class pv extends lH{constructor(a){if(super(a),this.height=a.height,this.width=a.width,a.interpolation)if(pu.has(a.interpolation))this.interpolation=a.interpolation;else throw new iY(`Invalid interpolation parameter: ${a.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!a.cropToAspectRatio}computeOutputShape(a){let b=(a=lv(a))[2];return[this.height,this.width,b]}getConfig(){let a={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio};return Object.assign(a,super.getConfig()),a}call(a,b){return dT(()=>{let b=[this.height,this.width];if("bilinear"===this.interpolation)return ku.resizeBilinear(a,b,!this.cropToAspectRatio);if("nearest"===this.interpolation)return ku.resizeNearestNeighbor(a,b,!this.cropToAspectRatio);throw Error(`Interpolation is ${this.interpolation} but only ${[...pu]} are supported`)})}}pv.className="Resizing",jg.registerClass(pv);var jg=jg;class pw{constructor(a){this.seed=a}next(){if(void 0!==this.seed)return this.seed++}}pw.className="RandomSeed";class px extends lH{constructor(a){super(a),this.randomGenerator=new pw(a.seed)}getConfig(){let a={seed:this.randomGenerator.seed};return Object.assign(a,super.getConfig()),a}}px.className="BaseRandomLayer";let py=new Set(["bilinear","nearest"]);class pz extends px{constructor(a){super(a);const{factor:b,interpolation:c="bilinear"}=a;if(this.factor=b,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new iY(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new iY(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new iY(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(c)if(py.has(c))this.interpolation=c;else throw new iY(`Invalid interpolation parameter: ${c} is not implemented`)}getConfig(){let a={factor:this.factor,interpolation:this.interpolation};return Object.assign(a,super.getConfig()),a}computeOutputShape(a){let b=(a=lv(a))[2];return[this.imgHeight,-1,b]}call(a,b){return dT(()=>{let b=lu(a);this.imgHeight=b.shape[b.shape.length-3];let c=b.shape[b.shape.length-2];this.widthFactor=kD([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let d=this.widthFactor.dataSync()[0]*c;d=Math.round(d);let e=[this.imgHeight,d];switch(this.interpolation){case"bilinear":return ku.resizeBilinear(a,e);case"nearest":return ku.resizeNearestNeighbor(a,e);default:throw Error(`Interpolation is ${this.interpolation}
          but only ${[...py]} are supported`)}})}}function pA(a){return new lI(a)}function pB(a){return new nZ(a)}function pC(a){return new nW(a)}function pD(a){return new nX(a)}function pE(a){return new nY(a)}function pF(a){return new n_(a)}function pG(a){return new n$(a)}function pH(a){return new og(a)}function pI(a){return new oa(a)}function pJ(a){return new oc(a)}function pK(a){return new ob(a)}function pL(a){return new od(a)}function pM(a){return new of(a)}function pN(a){return new oh(a)}function pO(a){return new oi(a)}function pP(a){return new oj(a)}function pQ(a){return new oE(a)}function pR(a){return new oC(a)}function pS(a){return new oA(a)}function pT(a){return new oB(a)}function pU(a){return new oD(a)}function pV(a){return new oF(a)}function pW(a){return new oG(a)}function pX(a){return new oH(a)}function pY(a){return new oJ(a)}function pZ(a){return new oL(a)}function p$(a){return new oN(a)}function p_(a){return new oQ(a)}function p0(a){return new oO(a)}function p1(a){return new oP(a)}function p2(a){return new oM(a)}function p3(a){return new oS(a)}function p4(a){return new o_(a)}function p5(a){return new o0(a)}function p6(a){return new o1(a)}function p7(a){return new o8(a)}function p8(a){return p7(a)}function p9(a){return p7(a)}function qa(a){return new pb(a)}function qb(a){return qa(a)}function qc(a){return qa(a)}function qd(a){return new pe(a)}function qe(a){return qd(a)}function qf(a){return qd(a)}function qg(a){return new pg(a)}function qh(a){return new pj(a)}function qi(a){return new ph(a)}function qj(a){return new pk(a)}function qk(a){return new o7(a)}function ql(a){return new pa(a)}function qm(a){return new pd(a)}function qn(a){return new or(a)}function qo(a){return new oq(a)}function qp(a){return new ot(a)}function qq(a){return new os(a)}function qr(a){return new op(a)}function qs(a){return new oo(a)}function qt(a){return new oz(a)}function qu(a){return new oy(a)}function qv(a){return new om(a)}function qw(a){return new ou(a)}function qx(a){return new pn(a)}function qy(a){return new pm(a)}function qz(a){return new oT(a)}function qA(a){return new oU(a)}function qB(a){return new oV(a)}function qC(a){return new oI(a)}function qD(a){return new po(a)}function qE(a){return new pr(a)}function qF(a){return new pv(a)}function qG(a){return new pt(a)}function qH(a){return new pz(a)}function qI(a,b){return mX(a,b)}function qJ(a,b){return mT(a,b)}function qK(a,b){return m0(a,b)}function qL(a,b){return mY(a,b)}function qM(a,b){return mR(a,b)}function qN(a,b){return m$(a,b)}function qO(a,b){return dT(()=>{let c=mZ(a,b),d=ey(c,dT(()=>ev(e5(fr(f$(a,1),f$(b,0))),"float32")));return ev(ft(fY(d,0),eA(c,d),0),"float32")})}function qP(a,b){return mU(a,b)}function qQ(a,b){return mP(a,b)}function qR(a,b){return mQ(a,b)}function qS(a,b){return mQ(a,b)}function qT(a,b){return mQ(a,b)}function qU(a,b){return mO(a,b)}function qV(a,b){return mO(a,b)}function qW(a,b){return mO(a,b)}function qX(a,b){return dT(()=>{let c=a.sub(b).square().sum(),d=a.sub(a.mean()).square().sum();return eG(1).sub(c.div(d))})}function qY(a){return new nS(a)}function qZ(a){return nQ(a),new nS({l1:null!=a?a.l1:null,l2:0})}function q$(a){return nQ(a),new nS({l2:null!=a?a.l2:null,l1:0})}pz.className="RandomWidth",jg.registerClass(pz),a.s(["activation",()=>pQ,"add",()=>pZ,"alphaDropout",()=>qB,"average",()=>p$,"averagePooling1d",()=>p7,"averagePooling2d",()=>qa,"averagePooling3d",()=>qd,"avgPool1d",()=>p8,"avgPool2d",()=>qb,"avgPool3d",()=>qe,"avgPooling1d",()=>p9,"avgPooling2d",()=>qc,"avgPooling3d",()=>qf,"batchNormalization",()=>p4,"bidirectional",()=>qx,"categoryEncoding",()=>qG,"centerCrop",()=>qE,"concatenate",()=>p_,"conv1d",()=>pH,"conv2d",()=>pI,"conv2dTranspose",()=>pJ,"conv3d",()=>pK,"conv3dTranspose",()=>pL,"convLstm2d",()=>qt,"convLstm2dCell",()=>qu,"cropping2D",()=>pN,"dense",()=>pR,"depthwiseConv2d",()=>pP,"dot",()=>p3,"dropout",()=>pS,"elu",()=>pB,"embedding",()=>pY,"flatten",()=>pU,"gaussianDropout",()=>qA,"gaussianNoise",()=>qz,"globalAveragePooling1d",()=>qg,"globalAveragePooling2d",()=>qh,"globalMaxPool1d",0,qi,"globalMaxPool2d",0,qj,"globalMaxPooling1d",()=>qi,"globalMaxPooling2d",()=>qj,"gru",()=>qn,"gruCell",()=>qo,"inputLayer",()=>pA,"layerNormalization",()=>p5,"leakyReLU",()=>pD,"lstm",()=>qp,"lstmCell",()=>qq,"masking",()=>qC,"maxPool1d",0,qk,"maxPool2d",0,ql,"maxPooling1d",()=>qk,"maxPooling2d",()=>ql,"maxPooling3d",()=>qm,"maximum",()=>p0,"minimum",()=>p1,"multiply",()=>p2,"permute",()=>pX,"prelu",()=>pE,"randomWidth",()=>qH,"reLU",()=>pC,"repeatVector",()=>pV,"rescaling",()=>qD,"reshape",()=>pW,"resizing",()=>qF,"rnn",()=>qv,"separableConv2d",()=>pM,"simpleRNN",()=>qr,"simpleRNNCell",()=>qs,"softmax",()=>pF,"spatialDropout1d",()=>pT,"stackedRNNCells",()=>qw,"thresholdedReLU",()=>pG,"timeDistributed",()=>qy,"upSampling2d",()=>pO,"zeroPadding2d",()=>p6],127491),a.i(127491),a.s(["Layer",()=>lH,"RNN",()=>om,"RNNCell",()=>on,"activation",()=>pQ,"add",()=>pZ,"alphaDropout",()=>qB,"average",()=>p$,"averagePooling1d",()=>p7,"averagePooling2d",()=>qa,"averagePooling3d",()=>qd,"avgPool1d",()=>p8,"avgPool2d",()=>qb,"avgPool3d",()=>qe,"avgPooling1d",()=>p9,"avgPooling2d",()=>qc,"avgPooling3d",()=>qf,"batchNormalization",()=>p4,"bidirectional",()=>qx,"categoryEncoding",()=>qG,"centerCrop",()=>qE,"concatenate",()=>p_,"conv1d",()=>pH,"conv2d",()=>pI,"conv2dTranspose",()=>pJ,"conv3d",()=>pK,"conv3dTranspose",()=>pL,"convLstm2d",()=>qt,"convLstm2dCell",()=>qu,"cropping2D",()=>pN,"dense",()=>pR,"depthwiseConv2d",()=>pP,"dot",()=>p3,"dropout",()=>pS,"elu",()=>pB,"embedding",()=>pY,"flatten",()=>pU,"gaussianDropout",()=>qA,"gaussianNoise",()=>qz,"globalAveragePooling1d",()=>qg,"globalAveragePooling2d",()=>qh,"globalMaxPool1d",0,qi,"globalMaxPool2d",0,qj,"globalMaxPooling1d",()=>qi,"globalMaxPooling2d",()=>qj,"gru",()=>qn,"gruCell",()=>qo,"input",()=>nv,"inputLayer",()=>pA,"layerNormalization",()=>p5,"leakyReLU",()=>pD,"lstm",()=>qp,"lstmCell",()=>qq,"masking",()=>qC,"maxPool1d",0,qk,"maxPool2d",0,ql,"maxPooling1d",()=>qk,"maxPooling2d",()=>ql,"maxPooling3d",()=>qm,"maximum",()=>p0,"minimum",()=>p1,"multiply",()=>p2,"permute",()=>pX,"prelu",()=>pE,"randomWidth",()=>qH,"reLU",()=>pC,"repeatVector",()=>pV,"rescaling",()=>qD,"reshape",()=>pW,"resizing",()=>qF,"rnn",()=>qv,"separableConv2d",()=>pM,"simpleRNN",()=>qr,"simpleRNNCell",()=>qs,"softmax",()=>pF,"spatialDropout1d",()=>pT,"stackedRNNCells",()=>qw,"thresholdedReLU",()=>pG,"timeDistributed",()=>qy,"upSampling2d",()=>pO,"zeroPadding2d",()=>p6],673577),a.i(673577),a.s(["MAPE",()=>qS,"MSE",()=>qV,"binaryAccuracy",()=>qI,"binaryCrossentropy",()=>qJ,"categoricalAccuracy",()=>qL,"categoricalCrossentropy",()=>qM,"cosineProximity",()=>qP,"mape",()=>qT,"meanAbsoluteError",()=>qQ,"meanAbsolutePercentageError",()=>qR,"meanSquaredError",()=>qU,"mse",()=>qW,"precision",()=>qN,"r2Score",()=>qX,"recall",()=>qO,"sparseCategoricalAccuracy",()=>qK],262752),a.i(262752),a.s([],377224),a.i(377224),a.s(["modelFromJSON",()=>nt],765622),a.i(765622),a.s(["l1",()=>qZ,"l1l2",()=>qY,"l2",()=>q$],133559),a.i(133559);aw.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,a=>{a&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var mL=mL,iV=iV;(Bz=BP||(BP={}))[Bz.DT_INVALID=0]="DT_INVALID",Bz[Bz.DT_FLOAT=1]="DT_FLOAT",Bz[Bz.DT_DOUBLE=2]="DT_DOUBLE",Bz[Bz.DT_INT32=3]="DT_INT32",Bz[Bz.DT_UINT8=4]="DT_UINT8",Bz[Bz.DT_INT16=5]="DT_INT16",Bz[Bz.DT_INT8=6]="DT_INT8",Bz[Bz.DT_STRING=7]="DT_STRING",Bz[Bz.DT_COMPLEX64=8]="DT_COMPLEX64",Bz[Bz.DT_INT64=9]="DT_INT64",Bz[Bz.DT_BOOL=10]="DT_BOOL",Bz[Bz.DT_QINT8=11]="DT_QINT8",Bz[Bz.DT_QUINT8=12]="DT_QUINT8",Bz[Bz.DT_QINT32=13]="DT_QINT32",Bz[Bz.DT_BFLOAT16=14]="DT_BFLOAT16",Bz[Bz.DT_QINT16=15]="DT_QINT16",Bz[Bz.DT_QUINT16=16]="DT_QUINT16",Bz[Bz.DT_UINT16=17]="DT_UINT16",Bz[Bz.DT_COMPLEX128=18]="DT_COMPLEX128",Bz[Bz.DT_HALF=19]="DT_HALF",Bz[Bz.DT_RESOURCE=20]="DT_RESOURCE",Bz[Bz.DT_VARIANT=21]="DT_VARIANT",Bz[Bz.DT_UINT32=22]="DT_UINT32",Bz[Bz.DT_UINT64=23]="DT_UINT64",Bz[Bz.DT_FLOAT_REF=101]="DT_FLOAT_REF",Bz[Bz.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",Bz[Bz.DT_INT32_REF=103]="DT_INT32_REF",Bz[Bz.DT_UINT8_REF=104]="DT_UINT8_REF",Bz[Bz.DT_INT16_REF=105]="DT_INT16_REF",Bz[Bz.DT_INT8_REF=106]="DT_INT8_REF",Bz[Bz.DT_STRING_REF=107]="DT_STRING_REF",Bz[Bz.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",Bz[Bz.DT_INT64_REF=109]="DT_INT64_REF",Bz[Bz.DT_BOOL_REF=110]="DT_BOOL_REF",Bz[Bz.DT_QINT8_REF=111]="DT_QINT8_REF",Bz[Bz.DT_QUINT8_REF=112]="DT_QUINT8_REF",Bz[Bz.DT_QINT32_REF=113]="DT_QINT32_REF",Bz[Bz.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",Bz[Bz.DT_QINT16_REF=115]="DT_QINT16_REF",Bz[Bz.DT_QUINT16_REF=116]="DT_QUINT16_REF",Bz[Bz.DT_UINT16_REF=117]="DT_UINT16_REF",Bz[Bz.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",Bz[Bz.DT_HALF_REF=119]="DT_HALF_REF",Bz[Bz.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",Bz[Bz.DT_VARIANT_REF=121]="DT_VARIANT_REF",Bz[Bz.DT_UINT32_REF=122]="DT_UINT32_REF",Bz[Bz.DT_UINT64_REF=123]="DT_UINT64_REF",(BB=(BA=BQ||(BQ={})).CheckpointFormatVersion||(BA.CheckpointFormatVersion={}))[BB.LEGACY=0]="LEGACY",BB[BB.V1=1]="V1",BB[BB.V2=2]="V2";var iV=iV;a.s(["json",0,[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]],464423),a.i(464423),a.s(["json",0,[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]],935384),a.i(935384),a.s(["json",0,[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}]],481566),a.i(481566),a.s(["json",0,[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]],979510),a.i(979510),a.s(["json",0,[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]],623464),a.i(623464),a.s(["json",0,[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]],259172),a.i(259172),a.s(["json",0,[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]],535508),a.i(535508),a.s(["json",0,[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]],451441),a.i(451441),a.s(["json",0,[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]],720638),a.i(720638),a.s(["json",0,[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}]],487737),a.i(487737),a.s(["json",0,[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}]],88900),a.i(88900),a.s(["json",0,[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}]],290406),a.i(290406),a.s(["json",0,[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}]],150190),a.i(150190),a.s(["json",0,[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]],904672),a.i(904672),a.s(["json",0,[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]],750380),a.i(750380),a.s(["json",0,[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}]],259176),a.i(259176),a.s(["json",0,[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]],844545),a.i(844545),a.s(["json",0,[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}]],307091),a.i(307091),a.s(["json",0,[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}]],339499),a.i(339499);var iV=iV,iV=iV;a.s([],185538),a.i(185538),a.i(143945);let q_=dM({addN_:function(a){I(Array.isArray(a),()=>"The argument passed to tf.addN() must be a list of tensors"),I(a.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${a.length}`);let b=a.map((a,b)=>dJ(a,`tensors${b}`,"addN")),c=b[0];return b.forEach(a=>{if(a.dtype!==c.dtype)throw Error("All tensors passed to tf.addN() must have the same dtype")}),b.forEach(a=>{if(!O(a.shape,c.shape))throw Error("All tensors passed to tf.addN() must have the same shape")}),dB.runKernel(aB,b)}}),q0=dM({basicLSTMCell_:function(a,b,c,d,e,f){let g=dJ(a,"forgetBias","basicLSTMCell"),h=dJ(b,"lstmKernel","basicLSTMCell"),i=dJ(c,"lstmBias","basicLSTMCell"),j=dJ(d,"data","basicLSTMCell"),k=dJ(e,"c","basicLSTMCell"),l=ey(fn(hy([j,dJ(f,"h","basicLSTMCell")],1),h),i),m=l.shape[0],n=l.shape[1]/4,o=[m,n],p=f6(l,[0,0],o),q=f6(l,[0,n],o),r=f6(l,[0,2*n],o),s=f6(l,[0,3*n],o),t=ey(eB(gH(p),iF(q)),eB(k,gH(ey(g,r)))),u=eB(iF(t),gH(s));return[t,u]}}),q1=dM({bitwiseAnd_:function(a,b){let c=dJ(a,"x","bitwiseAnd"),d=dJ(b,"y","bitwiseAnd");if(!O(c.shape,d.shape))throw Error(`BitwiseAnd: Tensors must have the same shape. x: ${c.shape}, y: ${d.shape}`);if("int32"!==c.dtype||"int32"!==d.dtype)throw Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${c.dtype} and type of y: ${d.dtype}`);return dB.runKernel(aQ,{a:c,b:d})}}),q2=dM({broadcastArgs_:function(a,b){let c=dJ(a,"s0","broadcastArgs","int32"),d=dJ(b,"s1","broadcastArgs","int32");if(1!==c.rank)throw Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${c.rank}`);if(1!==d.rank)throw Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${d.rank}`);return dB.runKernel(aR,{s0:c,s1:d})}}),q3=dM({diag_:function(a){let b=dJ(a,"x","diag");return dB.runKernel(bb,{x:b})}}),q4=dM({ensureShape_:function(a,b){let c=dJ(a,"x","ensureShape","string_or_numeric");if(!N(c.shape,b))throw Error(`EnsureShape: Shape of tensor ${c.shape} is not compatible with expected shape ${b}`);return a}});function q5(a,b,c){if(c<=0)throw Error("The number of values should be positive.");return dB.runKernel(bE,{},{start:a,stop:b,num:c})}let q6=dM({searchSorted_:function(a,b,c="left"){let d=dJ(a,"sortedSequence","searchSorted"),e=dJ(b,"values","searchSorted"),f=d.shape[d.shape.length-1],g=e.shape[e.shape.length-1],h=e4(d,[-1,f]),i=e4(e,[-1,g]);if(h.rank<2)throw Error("Sorted input argument must be at least 2-dimensional");if(h.shape[0]!==i.shape[0])throw Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(L(i.shape)>=0x80000000)throw Error("values tensor size must less than 2147483648");if(h.shape[1]>=0x80000000)throw Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${h.shape[1]}`);return dB.runKernel(cl,{sortedSequence:h,values:i},{side:c})}});function q7(a,b){return q6(a,b,"left")}a.s(["searchSorted",0,q6],103041);let q8=dM({maxPoolWithArgmax_:function(a,b,c,d,e=!1){let f=dJ(a,"x","maxPoolWithArgmax"),g=dB.runKernel(bP,{x:f},{filterSize:b,strides:c,pad:d,includeBatchInIndex:e});return{result:g[0],indexes:g[1]}}});function q9(a,b,{indexing:c="xy"}={}){if("xy"!==c&&"ij"!==c)throw TypeError(`${c} is not a valid third argument to meshgrid`);if(void 0===a)return[];let d=dJ(a,"x","meshgrid",a instanceof dk?a.dtype:"float32");if(void 0===b)return[d];let e=dJ(b,"y","meshgrid",b instanceof dk?b.dtype:"float32"),f=L(d.shape),g=L(e.shape);return"xy"===c?(d=e4(d,[1,-1]),e=e4(e,[-1,1]),[fn(f5([g,1],d.dtype),d),fn(e,f5([1,f],e.dtype))]):(d=e4(d,[-1,1]),e=e4(e,[1,-1]),[fn(d,f5([1,g],d.dtype)),fn(f5([f,1],e.dtype),e)])}let ra=dM({multiRNNCell_:function(a,b,c,d){let e=dJ(b,"data","multiRNNCell"),f=dK(c,"c","multiRNNCell"),g=dK(d,"h","multiRNNCell"),h=e,i=[];for(let b=0;b<a.length;b++){let c=a[b](h,f[b],g[b]);i.push(c[0]),i.push(c[1]),h=c[1]}let j=[],k=[];for(let a=0;a<i.length;a+=2)j.push(i[a]),k.push(i[a+1]);return[j,k]}}),rb=dM({multinomial_:function(a,b,c,d=!1){let e=dJ(a,"logits","multinomial"),f=e.size,g=e.rank;if(f<2)throw Error(`Error in multinomial: you need at least 2 outcomes, but got ${f}.`);if(g>2)throw Error(`Rank of probabilities must be 1 or 2, but is ${g}`);c=c||Math.random();let h=1===g?e4(e,[1,-1]):e,i={numSamples:b,seed:c,normalized:d},j=dB.runKernel(bT,{logits:h},i);return 1===g?e4(j,[j.size]):j}}),rc=dM({outerProduct_:function(a,b){let c=dJ(a,"v1","outerProduct"),d=dJ(b,"v2","outerProduct");return I(1===c.rank&&1===d.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${c.rank} and ${d.rank}.`),fn(e4(c,[-1,1]),e4(d,[1,-1]))}}),rd=dM({pad1d_:function(a,b,c=0){return I(2===b.length,()=>"Invalid number of paddings. Must be length of 2."),hv(a,[b],c)}}),re=dM({pad2d_:function(a,b,c=0){return I(2===b.length&&2===b[0].length&&2===b[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),hv(a,b,c)}}),rf=dM({pad3d_:function(a,b,c=0){return I(3===b.length&&2===b[0].length&&2===b[1].length&&2===b[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),hv(a,b,c)}}),rg=dM({pad4d_:function(a,b,c=0){return I(4===b.length&&2===b[0].length&&2===b[1].length&&2===b[2].length&&2===b[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),hv(a,b,c)}}),rh=dM({raggedGather_:function(a,b,c,d){let e=a.map((a,b)=>dJ(a,`tensors${b}`,"raggedGather","int32")),f=dJ(b,"paramsDenseValues","raggedGather"),g=dJ(c,"indices","raggedGather","int32"),h=dB.runKernel(b3,{paramsNestedSplits:e,paramsDenseValues:f,indices:g},{outputRaggedRank:d});return{outputNestedSplits:h.slice(0,h.length-1),outputDenseValues:h[h.length-1]}}}),ri=dM({raggedRange_:function(a,b,c){let d=dJ(a,"starts","raggedRange"),e=dJ(b,"limits","raggedRange",d.dtype),f=dJ(c,"deltas","raggedRange",d.dtype),g=dB.runKernel(b4,{starts:d,limits:e,deltas:f});return{rtNestedSplits:g[0],rtDenseValues:g[1]}}}),rj=dM({raggedTensorToTensor_:function(a,b,c,d,e){let f=dJ(a,"shape","raggedTensorToTensor","int32"),g=dJ(b,"values","raggedTensorToTensor"),h=dJ(c,"defaultValue","raggedTensorToTensor",g.dtype),i=d.map((a,b)=>dJ(a,`tensors${b}`,"raggedTensorToTensor","int32"));return dB.runKernel(b5,{shape:f,values:g,defaultValue:h,rowPartitionTensors:i},{rowPartitionTypes:e})}}),rk=dM({rand_:function(a,b,c){ap(a);let d=L(a),e=null;if(null==c||"float32"===c)e=new Float32Array(d);else if("int32"===c)e=new Int32Array(d);else if("bool"===c)e=new Uint8Array(d);else throw Error(`Unknown data type ${c}`);for(let a=0;a<d;a++)e[a]=b();return dB.makeTensor(e,a,c)}}),rl=dM({randomGamma_:function(a,b,c=1,d="float32",e){if(ap(a),null==c&&(c=1),null==d&&(d="float32"),"float32"!==d&&"int32"!==d)throw Error(`Unsupported data type ${d}`);let f=new kB(b,c,d,e),g=eu(a,d);for(let a=0;a<g.values.length;a++)g.values[a]=f.nextValue();return g.toTensor()}}),rm=dM({randomStandardNormal_:function(a,b,c){if(null!=b&&"bool"===b)throw Error(`Unsupported data type ${b}`);return kN(a,0,1,b,c)}}),rn=dM({randomUniformInt_:function(a,b,c,d){return kD(a,b,c,"int32",d)}}),ro=dM({reverse1d_:function(a){let b=dJ(a,"x","reverse");return I(1===b.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${b.rank}.`),hr(b,0)}}),rp=dM({reverse2d_:function(a,b){let c=dJ(a,"x","reverse");return I(2===c.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${c.rank}.`),hr(c,b)}}),rq=dM({reverse3d_:function(a,b){let c=dJ(a,"x","reverse");return I(3===c.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${c.rank}.`),hr(c,b)}}),rr=dM({reverse4d_:function(a,b){let c=dJ(a,"x","reverse");return I(4===c.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${c.rank}.`),hr(c,b)}});async function rs(a,b){let c=dJ(a,"x","setdiff1d"),d=dJ(b,"y","setdiff1d");I(c.dtype===d.dtype,()=>`x and y should have the same dtype, but got x (${c.dtype}) and y (${d.dtype}).`),I(1===c.rank,()=>`x should be 1D tensor, but got x (${c.shape}).`),I(1===d.rank,()=>`y should be 1D tensor, but got y (${d.shape}).`);let e=await c.data(),f=new Set(await d.data()),g=0;for(let a=0;a<e.length;a++)!f.has(e[a])&&g++;let h=new dh([g],c.dtype),i=new dh([g],"int32");for(let a=0,b=0;a<e.length;a++)!f.has(e[a])&&(h.values[b]=e[a],i.values[b]=a,b++);return[h.toTensor(),i.toTensor()]}function rt(a,b,c){if(K(a),null!=b&&3!==b.length)throw Error("tensor3d() requires shape to have three numbers");let d=dH(a,c);if(3!==d.length&&1!==d.length)throw Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===d.length&&null==b)throw Error("tensor3d() requires shape to be provided when `values` are a flat array");return dO(a,b,d,c)}function ru(a,b,c){if(K(a),null!=b&&4!==b.length)throw Error("tensor4d() requires shape to have four numbers");let d=dH(a,c);if(4!==d.length&&1!==d.length)throw Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===d.length&&null==b)throw Error("tensor4d() requires shape to be provided when `values` are a flat array");return dO(a,b,d,c)}function rv(a,b,c){if(K(a),null!=b&&5!==b.length)throw Error("tensor5d() requires shape to have five numbers");let d=dH(a,c);if(5!==d.length&&1!==d.length)throw Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===d.length&&null==b)throw Error("tensor5d() requires shape to be provided when `values` are a flat array");return dO(a,b,d,c)}function rw(a,b,c){if(K(a),null!=b&&6!==b.length)throw Error("tensor6d() requires shape to have six numbers");let d=dH(a,c);if(6!==d.length&&1!==d.length)throw Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===d.length&&null==b)throw Error("tensor6d() requires shape to be provided when `values` are a flat array");return dO(a,b=b||d,d,c)}let rx=dM({tensorScatterUpdate_:function(a,b,c){let d=dJ(a,"tensor","tensorScatterupdate"),e=dJ(b,"indices","tensorScatterupdate","int32"),f=dJ(c,"updates","tensorScatterupdate");if(gY(f,e,d.shape),d.dtype!==f.dtype)throw Error(`tensor and updates must have the same dtype, instead they are ${d.dtype} and ${f.dtype}.`);return dB.runKernel(ck,{tensor:d,indices:e,updates:f},{})}});function ry(a,b){return q6(a,b,"right")}function rz(a,b){let c=[];for(let a=0;a<b.length;a++)b[a]&&c.push(a);let d=eu(a,"int32"),e=eu([c.length,a.length],"int32");for(let b=0;b<c.length;b++){let f=d.indexToLoc(c[b]),g=b*a.length;e.values.set(f,g)}return e.toTensor()}async function rA(a){let b=dJ(a,"condition","whereAsync","bool"),c=await b.data(),d=rz(b.shape,c);return a!==b&&b.dispose(),d}async function rB(a,b,c){let d=dJ(a,"tensor","boolMask"),e=dJ(b,"mask","boolMask","bool"),f=null==c?0:c,g=e.rank,h=d.shape;I(g>0,()=>"mask cannot be scalar"),J(h.slice(f,f+g),e.shape,"mask's shape must match the first K dimensions of tensor's shape,");let i=1;for(let a=f;a<f+g;a++)i*=h[a];let j=e4(d,h.slice(0,f).concat([i],h.slice(f+g))),k=e4(e,[-1]),l=await rA(k),m=iC(l,[1]),n=hB(j,m,f);return a!==d&&d.dispose(),b!==e&&e.dispose(),m.dispose(),j.dispose(),k.dispose(),l.dispose(),n}a.s(["booleanMaskAsync",0,rB],489419),a.i(489419),a.i(829970),a.i(154846);let rC=dM({movingAverage_:function(a,b,c,d,e=!0){let f=dJ(a,"v","movingAverage"),g=dJ(b,"x","movingAverage"),h=dJ(c,"decay","movingAverage");du(f,g),I(O(f.shape,g.shape),()=>"Shape mismatch in v and x");let i=eG(1),j=eS(i,h),k=eB(eS(g,f),j);return e&&(I(null!=d,()=>"When using zeroDebias: true, step is required."),k=eA(k,eS(i,eR(h,dJ(d,"step","movingAverage"))))),ey(f,k)}});a.s(["movingAverage",0,rC],123837),a.i(123837);let rD=dM({scatterND_:function(a,b,c){ap(c);let d=dJ(a,"indices","scatterND","int32"),e=dJ(b,"updates","scatterND");return gY(e,d,c),dB.runKernel(cj,{indices:d,updates:e},{shape:c})}});a.s(["scatterND",0,rD],779365),a.i(779365),a.i(103041);let rE=dM({sparseToDense_:function(a,b,c,d=0){ap(c);let e=dJ(a,"sparseIndices","sparseToDense","int32"),f=dJ(b,"sparseValues","sparseToDense","string_or_numeric"),g=dJ(d,"defaultValue","sparseToDense",f.dtype);if("int32"!==e.dtype)throw Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let h=e.rank>0?e.shape[0]:1,i=e.rank>1?e.shape[1]:1;if(c.length!==i)throw Error(`outputShape has incorrect number of elements:, ${c.length}, should be: ${i}.`);let j=f.size;if(0!==f.rank&&(1!==f.rank||j!==h))throw Error(`sparseValues has incorrect shape ${f.shape}, should be [] or [${h}]`);if(f.dtype!==g.dtype)throw Error("sparseValues.dtype must match defaultValues.dtype");return dB.runKernel(cB,{sparseIndices:e,sparseValues:f,defaultValue:g},{outputShape:c})}});a.s(["sparseToDense",0,rE],200985),a.i(200985);let rF=dM({gatherND_:function(a,b){let c=dJ(b,"indices","gatherND","int32"),d=dJ(a,"x","gatherND","string_or_numeric");return dB.runKernel(bs,{params:d,indices:c})}});async function rG(a,b,c=1){let d=dJ(a,"predictions","inTopK"),e=dJ(b,"targets","inTopK");I(d.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${d.rank}`),I(d.rank-1===e.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${d.rank} and targets rank ${e.rank}`),J(d.shape.slice(0,d.shape.length-1),e.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let f=d.shape[d.shape.length-1];I(c>0&&c<=f,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${f}), but got ${c}`);let g=await d.data(),h=await e.data(),[i,j]=[g.length/f,f],k=Z("bool",i);for(let a=0;a<i;a++){let b=a*j,d=g.subarray(b,b+j),e=[];for(let a=0;a<d.length;a++)e.push({value:d[a],index:a});e.sort((a,b)=>b.value-a.value),k[a]=0;for(let b=0;b<c;b++)if(e[b].index===h[a]){k[a]=1;break}}return a!==d&&d.dispose(),b!==e&&e.dispose(),dP(k,e.shape,"bool")}a.s(["gatherND",0,rF],263219),a.i(263219),a.i(43791),a.i(265432),a.s(["inTopKAsync",0,rG],622613),a.i(622613),a.s(["OP_SCOPE_SUFFIX",0,dL,"abs",0,eU,"acos",0,hC,"acosh",0,hD,"add",0,ey,"addN",0,q_,"all",0,hE,"any",0,hF,"argMax",0,hG,"argMin",0,hH,"asin",0,hI,"asinh",0,hJ,"atan",0,hK,"atan2",0,hL,"atanh",0,hM,"avgPool",0,hN,"avgPool3d",0,o2,"basicLSTMCell",0,q0,"batchNorm",0,hO,"batchNorm2d",0,oY,"batchNorm3d",0,oX,"batchNorm4d",0,oW,"batchToSpaceND",0,hw,"bincount",0,j3,"bitwiseAnd",0,q1,"booleanMaskAsync",0,rB,"broadcastArgs",0,q2,"broadcastTo",0,fs,"buffer",()=>eu,"cast",0,ev,"ceil",0,hP,"clipByValue",0,hQ,"clone",0,ew,"complex",0,dN,"concat",0,hy,"concat1d",0,kJ,"concat2d",0,kK,"concat3d",0,kL,"concat4d",0,kM,"conv1d",0,hR,"conv2d",0,fy,"conv2dTranspose",0,hS,"conv3d",0,n1,"conv3dTranspose",0,n0,"cos",0,ht,"cosh",0,hu,"cosineWindow",()=>jG,"cumprod",0,hq,"cumsum",0,fL,"denseBincount",0,ps,"depthToSpace",0,hT,"depthwiseConv2d",0,hU,"diag",0,q3,"dilation2d",0,hV,"div",0,eA,"divNoNan",0,hW,"dot",0,hX,"dropout",0,kP,"einsum",0,jP,"elu",0,gC,"enclosingPowerOfTwo",()=>jF,"ensureShape",0,q4,"equal",0,f$,"erf",0,hY,"euclideanNorm",0,h0,"exp",0,fR,"expandDims",0,hA,"expm1",0,h1,"eye",0,jz,"fft",0,h2,"fill",()=>eP,"floor",0,f7,"floorDiv",0,ez,"fused",0,jD,"gather",0,hB,"gatherND",0,rF,"greater",0,fY,"greaterEqual",0,fp,"ifft",0,h3,"imag",0,fM,"image",()=>ku,"inTopKAsync",0,rG,"irfft",0,h4,"isFinite",0,h5,"isInf",0,h6,"isNaN",0,h7,"leakyRelu",0,gD,"less",0,f1,"lessEqual",0,fq,"linalg",()=>kv,"linspace",()=>q5,"localResponseNormalization",0,h8,"log",0,ga,"log1p",0,id,"logSigmoid",0,ia,"logSoftmax",0,ib,"logSumExp",0,ic,"logicalAnd",0,fr,"logicalNot",0,hs,"logicalOr",0,ie,"logicalXor",0,ig,"losses",()=>kw,"lowerBound",()=>q7,"matMul",0,fn,"max",0,hZ,"maxPool",0,ih,"maxPool3d",0,o3,"maxPoolWithArgmax",0,q8,"maximum",0,eY,"mean",0,ii,"meshgrid",()=>q9,"min",0,h$,"minimum",0,ij,"mirrorPad",0,ik,"mod",0,il,"moments",0,oZ,"movingAverage",0,rC,"mul",0,eB,"multiRNNCell",0,ra,"multinomial",0,rb,"neg",0,e3,"norm",0,h_,"notEqual",0,im,"oneHot",0,io,"ones",()=>f5,"onesLike",0,ip,"op",()=>dM,"outerProduct",0,rc,"pad",0,hv,"pad1d",0,rd,"pad2d",0,re,"pad3d",0,rf,"pad4d",0,rg,"pool",0,iq,"pow",0,eR,"prelu",0,gE,"print",()=>ex,"prod",0,ir,"raggedGather",0,rh,"raggedRange",0,ri,"raggedTensorToTensor",0,rj,"rand",0,rk,"randomGamma",0,rl,"randomNormal",0,kN,"randomStandardNormal",0,rm,"randomUniform",0,kD,"randomUniformInt",0,rn,"range",()=>j4,"real",0,fN,"reciprocal",0,is,"relu",0,gF,"relu6",0,gG,"reshape",0,e4,"reverse",0,hr,"reverse1d",0,ro,"reverse2d",0,rp,"reverse3d",0,rq,"reverse4d",0,rr,"rfft",0,iv,"round",0,iw,"rsqrt",0,fS,"scalar",()=>eG,"scatterND",0,rD,"searchSorted",0,q6,"selu",0,ix,"separableConv2d",0,iy,"setdiff1dAsync",0,rs,"sigmoid",0,gH,"sign",0,iz,"signal",()=>kt,"sin",0,fB,"sinh",0,fC,"slice",0,f6,"slice1d",0,kF,"slice2d",0,kG,"slice3d",0,kH,"slice4d",0,kI,"softmax",0,iA,"softplus",0,h9,"spaceToBatchND",0,fo,"sparse",()=>kx,"sparseToDense",0,rE,"spectral",()=>ks,"split",0,fv,"sqrt",0,eC,"square",0,eD,"squaredDifference",0,iB,"squeeze",0,iC,"stack",0,fU,"step",0,e1,"stridedSlice",0,iD,"string",()=>ky,"sub",0,eS,"sum",0,e5,"tan",0,iE,"tanh",0,iF,"tensor",()=>dP,"tensor1d",()=>jE,"tensor2d",()=>jJ,"tensor3d",()=>rt,"tensor4d",()=>ru,"tensor5d",()=>rv,"tensor6d",()=>rw,"tensorScatterUpdate",0,rx,"tile",0,fT,"topk",0,iG,"transpose",0,fO,"truncatedNormal",0,kE,"unique",0,iH,"unsortedSegmentSum",0,fV,"unstack",0,f8,"upperBound",()=>ry,"variable",()=>lx,"where",0,ft,"whereAsync",0,rA,"zeros",()=>f4,"zerosLike",0,eE],590225),a.i(590225),a.s(["OP_SCOPE_SUFFIX",0,dL,"abs",0,eU,"acos",0,hC,"acosh",0,hD,"add",0,ey,"addN",0,q_,"all",0,hE,"any",0,hF,"argMax",0,hG,"argMin",0,hH,"asin",0,hI,"asinh",0,hJ,"atan",0,hK,"atan2",0,hL,"atanh",0,hM,"avgPool",0,hN,"avgPool3d",0,o2,"basicLSTMCell",0,q0,"batchNorm",0,hO,"batchNorm2d",0,oY,"batchNorm3d",0,oX,"batchNorm4d",0,oW,"batchToSpaceND",0,hw,"bincount",0,j3,"bitwiseAnd",0,q1,"booleanMaskAsync",0,rB,"broadcastArgs",0,q2,"broadcastTo",0,fs,"buffer",()=>eu,"cast",0,ev,"ceil",0,hP,"clipByValue",0,hQ,"clone",0,ew,"complex",0,dN,"concat",0,hy,"concat1d",0,kJ,"concat2d",0,kK,"concat3d",0,kL,"concat4d",0,kM,"conv1d",0,hR,"conv2d",0,fy,"conv2dTranspose",0,hS,"conv3d",0,n1,"conv3dTranspose",0,n0,"cos",0,ht,"cosh",0,hu,"cosineWindow",()=>jG,"cumprod",0,hq,"cumsum",0,fL,"denseBincount",0,ps,"depthToSpace",0,hT,"depthwiseConv2d",0,hU,"diag",0,q3,"dilation2d",0,hV,"div",0,eA,"divNoNan",0,hW,"dot",0,hX,"dropout",0,kP,"einsum",0,jP,"elu",0,gC,"enclosingPowerOfTwo",()=>jF,"ensureShape",0,q4,"equal",0,f$,"erf",0,hY,"euclideanNorm",0,h0,"exp",0,fR,"expandDims",0,hA,"expm1",0,h1,"eye",0,jz,"fft",0,h2,"fill",()=>eP,"floor",0,f7,"floorDiv",0,ez,"fused",()=>jD,"gather",0,hB,"gatherND",0,rF,"greater",0,fY,"greaterEqual",0,fp,"ifft",0,h3,"imag",0,fM,"image",()=>ku,"inTopKAsync",0,rG,"irfft",0,h4,"isFinite",0,h5,"isInf",0,h6,"isNaN",0,h7,"leakyRelu",0,gD,"less",0,f1,"lessEqual",0,fq,"linalg",()=>kv,"linspace",()=>q5,"localResponseNormalization",0,h8,"log",0,ga,"log1p",0,id,"logSigmoid",0,ia,"logSoftmax",0,ib,"logSumExp",0,ic,"logicalAnd",0,fr,"logicalNot",0,hs,"logicalOr",0,ie,"logicalXor",0,ig,"losses",()=>kw,"lowerBound",()=>q7,"matMul",0,fn,"max",0,hZ,"maxPool",0,ih,"maxPool3d",0,o3,"maxPoolWithArgmax",0,q8,"maximum",0,eY,"mean",0,ii,"meshgrid",()=>q9,"min",0,h$,"minimum",0,ij,"mirrorPad",0,ik,"mod",0,il,"moments",0,oZ,"movingAverage",0,rC,"mul",0,eB,"multiRNNCell",0,ra,"multinomial",0,rb,"neg",0,e3,"norm",0,h_,"notEqual",0,im,"oneHot",0,io,"ones",()=>f5,"onesLike",0,ip,"op",()=>dM,"outerProduct",0,rc,"pad",0,hv,"pad1d",0,rd,"pad2d",0,re,"pad3d",0,rf,"pad4d",0,rg,"pool",0,iq,"pow",0,eR,"prelu",0,gE,"print",()=>ex,"prod",0,ir,"raggedGather",0,rh,"raggedRange",0,ri,"raggedTensorToTensor",0,rj,"rand",0,rk,"randomGamma",0,rl,"randomNormal",0,kN,"randomStandardNormal",0,rm,"randomUniform",0,kD,"randomUniformInt",0,rn,"range",()=>j4,"real",0,fN,"reciprocal",0,is,"relu",0,gF,"relu6",0,gG,"reshape",0,e4,"reverse",0,hr,"reverse1d",0,ro,"reverse2d",0,rp,"reverse3d",0,rq,"reverse4d",0,rr,"rfft",0,iv,"round",0,iw,"rsqrt",0,fS,"scalar",()=>eG,"scatterND",0,rD,"searchSorted",0,q6,"selu",0,ix,"separableConv2d",0,iy,"setdiff1dAsync",0,rs,"sigmoid",0,gH,"sign",0,iz,"signal",()=>kt,"sin",0,fB,"sinh",0,fC,"slice",0,f6,"slice1d",0,kF,"slice2d",0,kG,"slice3d",0,kH,"slice4d",0,kI,"softmax",0,iA,"softplus",0,h9,"spaceToBatchND",0,fo,"sparse",()=>kx,"sparseToDense",0,rE,"spectral",()=>ks,"split",0,fv,"sqrt",0,eC,"square",0,eD,"squaredDifference",0,iB,"squeeze",0,iC,"stack",0,fU,"step",0,e1,"stridedSlice",0,iD,"string",()=>ky,"sub",0,eS,"sum",0,e5,"tan",0,iE,"tanh",0,iF,"tensor",()=>dP,"tensor1d",()=>jE,"tensor2d",()=>jJ,"tensor3d",()=>rt,"tensor4d",()=>ru,"tensor5d",()=>rv,"tensor6d",()=>rw,"tensorScatterUpdate",0,rx,"tile",0,fT,"topk",0,iG,"transpose",0,fO,"truncatedNormal",0,kE,"unique",0,iH,"unsortedSegmentSum",0,fV,"unstack",0,f8,"upperBound",()=>ry,"variable",()=>lx,"where",0,ft,"whereAsync",0,rA,"zeros",()=>f4,"zerosLike",0,eE],305856),a.i(305856);var iV=iV,iV=iV,iV=iV,iV=iV,rH=a.i(899899),rH=rH,iV=iV,iV=iV;function rI(a,b,c=new Map,d=new Set){if(null==a)return null;if("function"==typeof Blob&&a instanceof Blob)return a.slice();if(d.has(a))throw Error("Circular references are not supported.");if(c.has(a))return c.get(a);let e=b(a);if(e.recurse&&null!==e.value)throw Error("A deep map function may not return both a value and recurse=true.");if(!e.recurse)return c.set(a,e.value),e.value;if(rL(a)){let e=Array.isArray(a)?[]:{};for(let f in d.add(a),a){let g=rI(a[f],b,c,d);e[f]=g}return d.delete(a),a.__proto__&&(e.__proto__=a.__proto__),e}throw Error(`Can't recurse into non-iterable type: ${a}`)}function rJ(a){return null===a?null:rL(a[0])?{value:null,recurse:!0}:{value:a,recurse:!1}}async function rK(a,b){let c=new Map;for(let d of(rI(a,b,c),Array.from(c.keys()))){let a=c.get(d);if(iV.isPromise(a)){let b=await a;c.set(d,b)}}return rI(a,b,c)}function rL(b){let c=!1;if(aw.get("IS_BROWSER"))c=b instanceof TextDecoder;else{let{StringDecoder:d}=a.r(99348);c=b instanceof d}return null!=b&&!ArrayBuffer.isView(b)&&(Array.isArray(b)||"object"==typeof b&&!(b instanceof dk)&&!(b instanceof Promise)&&!c)}function rM(a){return a instanceof dk?{value:a.clone(),recurse:!1}:rL(a)?{value:null,recurse:!0}:{value:a,recurse:!1}}class rN{constructor(a){if(this.capacity=a,this.begin=0,this.end=0,null==a)throw RangeError("Can't create a ring buffer of unknown capacity.");if(a<1)throw RangeError("Can't create ring buffer of capacity < 1.");this.data=Array(a),this.doubledCapacity=2*a}wrap(a){for(;a<0;)a+=this.doubledCapacity;return a%this.doubledCapacity}get(a){if(a<0)throw RangeError("Can't get item at a negative index.");return this.data[a%this.capacity]}set(a,b){if(a<0)throw RangeError("Can't set item at a negative index.");this.data[a%this.capacity]=b}length(){let a=this.end-this.begin;return a<0&&(a=this.doubledCapacity+a),a}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(a){if(this.isFull())throw RangeError("Ring buffer is full.");this.set(this.end,a),this.end=this.wrap(this.end+1)}pushAll(a){for(let b of a)this.push(b)}pop(){if(this.isEmpty())throw RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let a=this.get(this.end);return this.set(this.end,void 0),a}unshift(a){if(this.isFull())throw RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,a)}shift(){if(this.isEmpty())throw RangeError("Ring buffer is empty.");let a=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),a}shuffleExcise(a){if(this.isEmpty())throw RangeError("Ring buffer is empty.");let b=this.wrap(this.begin+a),c=this.get(b);return this.set(b,this.pop()),c}}class rO extends rN{constructor(){super(rO.INITIAL_CAPACITY)}isFull(){return!1}push(a){super.isFull()&&this.expand(),super.push(a)}unshift(a){super.isFull()&&this.expand(),super.unshift(a)}expand(){let a=2*this.capacity,b=Array(a),c=this.length();for(let a=0;a<c;a++)b[a]=this.get(this.wrap(this.begin+a));this.data=b,this.capacity=a,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=c}}rO.INITIAL_CAPACITY=32;class rP{async toArray(){let a=[],b=await this.next();for(;!b.done;)a.push(b.value),b=await this.next();return a}async toArrayForTest(){let a=this.prefetch(100),b=[],c=await a.next();for(;!c.done;)b.push(c.value),c=await a.next();return b}async resolveFully(){let a=await this.next();for(;!a.done;)a=await this.next()}async resolveWhile(a){let b=await this.next(),c=a(b.value);for(;!b.done&&c;)c=a((b=await this.next()).value)}handleErrors(a){return new rY(this,a)}filter(a){return new rW(this,a)}map(a){return new rX(this,a)}mapAsync(a){return new rZ(this,a)}serialMapAsync(a){return new rZ(this,a).serial()}flatmap(a){return new r_(this,a)}async forEachAsync(a){return this.map(a).resolveFully()}async serialForEach(a){return this.serialMapAsync(a).resolveWhile(a=>!0===a)}rowMajorBatch(a,b=!0){return new rV(this,a,b)}columnMajorBatch(a,b=!0,c=rJ){return this.rowMajorBatch(a,b).map(a=>(function(a,b=rJ){return function a(b,c,d=new Set){let e=b[0];if(d.has(e))throw Error("Circular references are not supported.");let f=c(b);if(f.recurse&&null!==f.value)throw Error("A deep zip function may not return both a value and recurse=true.");if(!f.recurse)return f.value;if(rL(e)){let f=Array.isArray(e)?[]:{};for(let g in d.add(e),e){let e=a(b.map(a=>a[g]),c,d);f[g]=e}return d.delete(e),f}throw Error(`Can't recurse into non-iterable type: ${e}`)}(a,b)})(a,c))}concatenate(a,b){return new r0(new rQ([this,a]),b)}take(a){return a<0||null==a?this:new rU(this,a)}skip(a){return a<0||null==a?this:new rT(this,a)}prefetch(a){return new r2(this,a)}shuffle(a,b){return new r3(this,a,b)}serial(){return new rS(this)}}class rQ extends rP{constructor(a){super(),this.items=a,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let a=this.items[this.trav];return this.trav++,{value:rI(a,rM),done:!1}}}class rR extends rP{constructor(a){super(),this.nextFn=a}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(a){throw a.message=`Error thrown while iterating through a dataset: ${a.message}`,a}}}class rS extends rP{constructor(a){super(),this.upstream=a,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class rT extends rP{constructor(a,b){super(),this.upstream=a,this.maxCount=b,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let a=await this.upstream.next();if(a.done)return a;dU(a.value)}return this.upstream.next()}}class rU extends rP{constructor(a,b){super(),this.upstream=a,this.maxCount=b,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class rV extends rP{constructor(a,b,c=!0){super(),this.upstream=a,this.batchSize=b,this.enableSmallLastBatch=c,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let a=[];for(;a.length<this.batchSize;){let b=await this.upstream.next();if(b.done){if(this.enableSmallLastBatch&&a.length>0)return{value:a,done:!1};return{value:null,done:!0}}a.push(b.value)}return{value:a,done:!1}}}class rW extends rP{constructor(a,b){super(),this.upstream=a,this.predicate=b,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let a=await this.upstream.next();if(a.done||this.predicate(a.value))return a;dU(a.value)}}}class rX extends rP{constructor(a,b){super(),this.upstream=a,this.transform=b}summary(){return`${this.upstream.summary()} -> Map`}async next(){let a=await this.upstream.next();if(a.done)return{value:null,done:!0};let b=rH.getTensorsInContainer(a.value),c=this.transform(a.value),d=rH.getTensorsInContainer(c);for(let a of b)rH.isTensorInList(a,d)||a.dispose();return{value:c,done:!1}}}class rY extends rP{constructor(a,b){super(),this.upstream=a,this.handler=b,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(a){if(!this.handler(a))return{value:null,done:!0}}}}class rZ extends rP{constructor(a,b){super(),this.upstream=a,this.transform=b}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let a=await this.upstream.next();if(a.done)return{value:null,done:!0};let b=rH.getTensorsInContainer(a.value),c=await this.transform(a.value),d=rH.getTensorsInContainer(c);for(let a of b)rH.isTensorInList(a,d)||a.dispose();return{value:c,done:!1}}}class r$ extends rP{constructor(){super(),this.outputQueue=new rO,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class r_ extends r${constructor(a,b){super(),this.upstream=a,this.transform=b}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let a=await this.upstream.next();if(a.done)return!1;let b=rH.getTensorsInContainer(a.value),c=this.transform(a.value),d=rH.getTensorsInContainer(c);for(let a of(this.outputQueue.pushAll(c),b))rH.isTensorInList(a,d)||a.dispose();return!0}}class r0 extends rP{constructor(a,b){super(),this.baseErrorHandler=b,this.lastRead=null,this.iterator=null,this.moreIterators=a}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(a){if(await a,null==this.iterator){let a=await this.moreIterators.next();if(a.done)return{value:null,done:!0};this.iterator=a.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let b=await this.iterator.next();return b.done?(this.iterator=null,this.readFromChain(a)):b}}(BC=BR||(BR={}))[BC.FAIL=0]="FAIL",BC[BC.SHORTEST=1]="SHORTEST",BC[BC.LONGEST=2]="LONGEST";class r1 extends rP{constructor(a,b=BR.FAIL){super(),this.iterators=a,this.mismatchMode=b,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(a){await a;let b=0,c=0,d=await rK(this.iterators,function(a){return a instanceof rP?{value:a.next().then(a=>(b++,a.done&&c++,a.value)),recurse:!1}:{value:null,recurse:!0}});if(b===c)return{value:null,done:!0};if(c>0)switch(this.mismatchMode){case BR.FAIL:throw Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case BR.SHORTEST:return{value:null,done:!0};case BR.LONGEST:}return this.count++,{value:d,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class r2 extends rP{constructor(a,b){super(),this.upstream=a,this.bufferSize=b,this.buffer=new rN(b)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let a=this.upstream.next();this.buffer.push(a)}}next(){return this.refill(),this.buffer.shift()}}class r3 extends r2{constructor(a,b,c){super(a,b),this.upstream=a,this.windowSize=b,this.upstreamExhausted=!1,this.random=kz.alea(c||iV.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(a){return Math.floor(this.random()*a)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let a=this.chooseIndex(),b=await this.buffer.shuffleExcise(a);if(!b.done)return this.refill(),b;this.upstreamExhausted=!0}return{value:null,done:!0}}}class r4{constructor(){this.size=null}batch(a,b=!0){let c=this;return iV.assert(a>0,()=>`batchSize needs to be positive, but it is
      ${a}`),r5(async()=>(await c.iterator()).columnMajorBatch(a,b,r8),this.size===1/0||null==this.size?this.size:b?Math.ceil(this.size/a):Math.floor(this.size/a))}concatenate(a){let b=this;return r5(async()=>(await b.iterator()).concatenate(await a.iterator()),this.size===1/0||a.size===1/0?1/0:null!=this.size&&null!=a.size?this.size+a.size:null)}filter(a){let b=this;return r5(async()=>(await b.iterator()).filter(b=>dT(()=>a(b))),this.size===1/0?1/0:null)}async forEachAsync(a){return(await this.iterator()).forEachAsync(a)}map(a){let b=this;return r5(async()=>(await b.iterator()).map(b=>dT(()=>a(b))),this.size)}mapAsync(a){let b=this;return r5(async()=>(await b.iterator()).mapAsync(a),this.size)}prefetch(a){if(null==a)throw RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let b=this;return r5(async()=>(await b.iterator()).prefetch(a),this.size)}repeat(a){let b=this;return r5(async()=>new r0(new rR(async()=>({value:await b.iterator(),done:!1})).take(a),void 0),null!=this.size&&a>0?this.size*a:0===a?0:null!=this.size&&(void 0===a||a<0)?1/0:null)}skip(a){let b=this;return r5(async()=>(await b.iterator()).skip(a),null!=this.size&&a>=0&&this.size>=a?this.size-a:null!=this.size&&(this.size<a||void 0===a||a<0)?0:null)}shuffle(a,b,c=!0){if(null==a||a<0)if(null==this.size)throw RangeError("`Dataset.shuffle()` requires bufferSize to be specified.");else throw RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let d=this,e=kz.alea(b||iV.now().toString());return r5(async()=>{let b=e.int32();return c&&(b+=e.int32()),(await d.iterator()).shuffle(a,b.toString())},this.size)}take(a){let b=this;return r5(async()=>(await b.iterator()).take(a),null!=this.size&&this.size>a?a:null!=this.size&&this.size<=a?this.size:null)}async toArray(){if(this.size===1/0)throw Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function r5(a,b=null){return new class extends r4{constructor(){super(...arguments),this.size=b}async iterator(){return a()}}}function r6(a){return r5(async()=>new rQ(a),a.length)}function r7(a){let b;if(!rL(a))throw Error("The argument to zip() must be an object or array.");if(Array.isArray(a))for(let c=0;c<a.length;c++)b=null==b?a[c].size:Math.min(b,a[c].size);else if(a instanceof Object)for(let c in a)b=null==b?a[c].size:Math.min(b,a[c].size);return r5(async()=>(function(a,b=BR.FAIL){return new r1(a,b)})(await rK(a,a=>{if(a instanceof r4)return{value:a.iterator(),recurse:!1};if(rL(a))return{value:null,recurse:!0};throw Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")}),BR.SHORTEST),b)}function r8(a){var b,c;if(null===a)return null;return null==(b=a[0])||null===(c=b)||"object"!=typeof c&&"function"!=typeof c||Array.isArray(b)||"object"==typeof b&&b instanceof dk||iV.isTypedArray(b)?{value:function(a){if(0===a.length)throw Error("Can't make a batch of zero elements.");return a[0]instanceof dk?fU(a):dP(a)}(a),recurse:!1}:{value:null,recurse:!0}}r4.MAX_BUFFER_SIZE=1e4;var iV=iV;class r9 extends r4{constructor(a){super(),this.input=a}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map(a=>(a.endsWith("\r")&&(a=a.slice(0,-1)),a))}}let sa=Symbol("out"),sb=Symbol("field"),sc=Symbol("quote"),sd=Symbol("quoteafterquote"),se=Symbol("quoteinquote");class sf extends r4{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let a=await this.maybeReadHeaderLine();if(this.fullColumnNames||a)this.fullColumnNames&&a&&iV.assert(a.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+a.length.toString()+").");else throw Error("Column names must be provided if there is no header line.");this.fullColumnNames||(this.fullColumnNames=a);let b=this.fullColumnNames.reduce((a,b)=>(a[b]=a[b]+1||1,a),{}),c=Object.keys(b).filter(a=>b[a]>1);if(iV.assert(0===c.length,()=>"Duplicate column names found: "+c.toString()),this.columnConfigs){for(let a of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(a))throw Error('The key "'+a+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(!this.hasHeader)return null;{let a=await this.base.iterator(),b=await a.next();if(b.done)throw Error("No data was found for CSV parsing.");let c=b.value;return this.parseRow(c,!1)}}constructor(a,b){super(),this.input=a,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new r9(a),b||(b={}),this.hasHeader=!1!==b.hasHeader,this.fullColumnNames=b.columnNames,this.columnConfigs=b.columnConfigs,this.configuredColumnsOnly=b.configuredColumnsOnly,b.delimWhitespace?(iV.assert(null==b.delimiter,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=b.delimiter?b.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let a=await this.base.iterator();return this.hasHeader&&(a=a.skip(1)),a.map(a=>this.makeDataElement(a))}makeDataElement(a){let b=this.parseRow(a),c={},d={};for(let e=0;e<this.fullColumnNames.length;e++){let f=this.fullColumnNames[e],g=this.columnConfigs?this.columnConfigs[f]:null;if(!this.configuredColumnsOnly||g){let h=b[e],i=null;if(""===h)if(g&&void 0!==g.default)i=g.default;else if(g&&(g.required||g.isLabel))throw Error(`Required column ${f} is empty in this line: ${a}`);else i=void 0;else{let a=Number(h);if(isNaN(a))i=g&&"bool"===g.dtype?this.getBoolean(h):h;else if(g&&g.dtype)switch(g.dtype){case"float32":default:i=a;break;case"int32":i=Math.floor(a);break;case"bool":i=this.getBoolean(h)}else i=a}g&&g.isLabel?d[f]=i:c[f]=i}}return 0===Object.keys(d).length?c:{xs:c,ys:d}}getBoolean(a){return+("1"===a||"true"===a.toLowerCase())}parseRow(a,b=!0){let c=[],d=0,e=a.length,f=sa;for(let b=0;b<e;b++)switch(f){case sa:switch(a.charAt(b)){case'"':d=b+1,f=sc;break;case this.delimiter:if(d=b+1," "===this.delimiter&&this.delimWhitespace)break;c.push(""),f=sa;break;default:f=sb,d=b}break;case sb:a.charAt(b)===this.delimiter&&(c.push(a.substring(d,b)),f=sa,d=b+1);break;case sc:'"'===a.charAt(b)&&(f=sd);break;case sd:switch(a.charAt(b)){case this.delimiter:c.push(a.substring(d,b-1)),f=sa,d=b+1;break;case'"':f=sc;break;default:f=se}break;case se:'"'===a.charAt(b)&&(f=sc)}if(f===sd?c.push(a.substring(d,e-1)):c.push(a.substring(d)),b&&c.length!==this.fullColumnNames.length)throw Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${c}`);return c}}var iV=iV;class sg extends rP{constructor(a){super(),this.microphoneConfig=a,this.isClosed=!1,this.fftSize=a.fftSize||1024;const b=Math.log2(this.fftSize);if(this.fftSize<0||b<4||b>14||!Number.isInteger(b))throw Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=a.numFramesPerSpectrogram||43,this.sampleRateHz=a.sampleRateHz,this.columnTruncateLength=a.columnTruncateLength||this.fftSize,this.audioTrackConstraints=a.audioTrackConstraints,this.smoothingTimeConstant=a.smoothingTimeConstant||0,this.includeSpectrogram=!1!==a.includeSpectrogram,this.includeWaveform=!0===a.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(a={}){if(!aw.get("IS_BROWSER"))throw Error("microphone API is only supported in browser environment.");let b=new sg(a);return await b.start(),b}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(a){throw Error(`Error thrown while initializing video stream: ${a.message}`)}if(!this.stream)throw Error("Could not obtain audio from microphone.");let a=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new a,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;let b=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,b.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){let a,b;if(this.isClosed)return{value:null,done:!0};let c=await this.getAudioData();if(this.includeSpectrogram){let b=this.flattenQueue(c.freqDataQueue);a=this.getTensorFromAudioDataArray(b,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let a=this.flattenQueue(c.timeDataQueue);b=this.getTensorFromAudioDataArray(a,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:a,waveform:b},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let a=[],b=[],c=0;return new Promise(d=>{let e=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&d({freqDataQueue:a,timeDataQueue:b}),a.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),b.push(this.timeData.slice())),++c===this.numFrames&&(clearInterval(e),d({freqDataQueue:a,timeDataQueue:b}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){!this.isClosed&&(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(a){let b=a[0].length,c=new Float32Array(a.length*b);return a.forEach((a,d)=>c.set(a,d*b)),c}getTensorFromAudioDataArray(a,b){let c=new Float32Array(iV.sizeFromShape(b));return c.set(a,c.length-a.length),dP(c,b)}}let sh=!1;function si(a,b=3){let c,d;if(b>4)throw Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==a)throw Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,g=!1,h=!1,i=!1,j=!1,k=!1;if(a.data instanceof Uint8Array)e=!0;else if("undefined"!=typeof ImageData&&a instanceof ImageData)g=!0;else if("undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement)h=!0;else if("undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement)i=!0;else if(null!=a.getContext)j=!0;else if("undefined"!=typeof ImageBitmap&&a instanceof ImageBitmap)k=!0;else throw Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${a.constructor.name}`);if(null!=c0(cT,dB.backendName))return dB.runKernel(cT,{pixels:a},{numChannels:b});let[l,m]=h?[a.videoWidth,a.videoHeight]:[a.width,a.height];if(j)c=a.getContext("2d").getImageData(0,0,l,m).data;else if(g||e)c=a.data;else if(i||h||k){if(null==f)if("undefined"==typeof document)if("undefined"!=typeof OffscreenCanvas&&"undefined"!=typeof OffscreenCanvasRenderingContext2D)f=new OffscreenCanvas(1,1).getContext("2d");else throw Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else f=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});f.canvas.width=l,f.canvas.height=m,f.drawImage(a,0,0,l,m),c=f.getImageData(0,0,l,m).data}if(4===b)d=new Int32Array(c);else{let a=l*m;d=new Int32Array(a*b);for(let e=0;e<a;e++)for(let a=0;a<b;++a)d[e*b+a]=c[4*e+a]}return rt(d,[m,l,b],"int32")}async function sj(a,b=3){return aw.getBool("WRAP_TO_IMAGEBITMAP"),si(a,b)}function sk(a){if(2!==a.rank&&3!==a.rank)throw Error(`toPixels only supports rank 2 or 3 tensors, got rank ${a.rank}.`);let b=2===a.rank?1:a.shape[2];if(b>4||2===b)throw Error(`toPixels only supports depth of size 1, 3 or 4 but got ${b}`);if("float32"!==a.dtype&&"int32"!==a.dtype)throw Error(`Unsupported type for toPixels: ${a.dtype}. Please use float32 or int32 tensors.`)}async function sl(a,b){let c=dJ(a,"img","toPixels");if(!(a instanceof dk)){let a=c;c=ev(a,"int32"),a.dispose()}sk(c);let[d,e]=c.shape.slice(0,2),f=2===c.rank?1:c.shape[2],g=await c.data(),h="float32"===c.dtype?255:1,i=new Uint8ClampedArray(e*d*4);for(let a=0;a<d*e;++a){let b=[0,0,0,255];for(let d=0;d<f;d++){let e=g[a*f+d];if("float32"===c.dtype){if(e<0||e>1)throw Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${e}.`)}else if("int32"===c.dtype&&(e<0||e>255))throw Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${e}.`);1===f?(b[0]=e*h,b[1]=e*h,b[2]=e*h):b[d]=e*h}let d=4*a;i[d+0]=Math.round(b[0]),i[d+1]=Math.round(b[1]),i[d+2]=Math.round(b[2]),i[d+3]=Math.round(b[3])}if(null!=b){sh||null!=c0(bf,dB.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),sh=!0),b.width=e,b.height=d;let a=b.getContext("2d"),c=new ImageData(i,e,d);a.putImageData(c,0,0)}return c!==a&&c.dispose(),i}function sm(a,b,c){let d=dJ(a,"img","draw");if(!(a instanceof dk)){let a=d;d=ev(a,"int32"),a.dispose()}sk(d);var e=null==c?void 0:c.imageOptions;let f=(null==e?void 0:e.alpha)||1;if(f>1||f<0)throw Error(`Alpha value ${f} is suppoed to be in range [0 - 1].`);let g={image:d};dB.runKernel(bf,g,{canvas:b,options:c})}let sn=dM({fromPixels_:si});a.s(["draw",()=>sm,"fromPixels",0,sn,"fromPixelsAsync",()=>sj,"toPixels",()=>sl],766532);var so=a.i(766532),so=so,iV=iV;class sp extends rP{constructor(a,b){if(super(),this.webcamVideoElement=a,this.webcamConfig=b,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=jE([0],"int32"),this.webcamConfig.centerCrop){const a=this.webcamConfig.resizeWidth/this.webcamVideoElement.width,b=this.webcamConfig.resizeHeight/this.webcamVideoElement.height,c=(1-a)/2,d=(1-b)/2;this.cropBox=jJ([d,c,b+d,c+a],[1,4])}else this.cropBox=jJ([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(a,b={}){if(!aw.get("IS_BROWSER"))throw Error("tf.data.webcam is only supported in browser environment.");if(!a){if(a=document.createElement("video"),!b.resizeWidth||!b.resizeHeight)throw Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");a.width=b.resizeWidth,a.height=b.resizeHeight}let c=new sp(a,b);return await c.start(),c}async start(){this.webcamConfig.facingMode&&iV.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(a){throw a.message=`Error thrown while initializing video stream: ${a.message}`,a}if(!this.stream)throw Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(a){console.log(a),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(a=>{this.webcamVideoElement.onloadedmetadata=()=>{a()}})}async next(){let a;if(this.isClosed)return{value:null,done:!0};try{a=so.fromPixels(this.webcamVideoElement)}catch(a){throw Error(`Error thrown converting video to pixels: ${JSON.stringify(a)}`)}if(!this.resize)return{value:a,done:!1};try{return{value:this.cropAndResizeFrame(a),done:!1}}catch(a){throw Error(`Error thrown cropping the video: ${a.message}`)}finally{a.dispose()}}needToResize(){return!!this.webcamConfig.resizeWidth&&!!this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight)}cropAndResizeFrame(a){return dT(()=>{let b,c=hA(ev(a,"float32"),0),d=(b=ku.cropAndResize(c,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear")).shape;return e4(b,d.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(a=>a.stop());try{this.webcamVideoElement.srcObject=null}catch(a){console.log(a),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw Error("Can not convert infinite video stream to array.")}}class sq{}var iV=iV,iV=iV;class sr extends rP{split(a){return new ss(this,a)}}class ss extends sr{constructor(a,b){super(),this.upstream=a,this.impl=new st(a,b)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class st extends r${constructor(a,b){super(),this.upstream=a,this.separator=b,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let a=await this.upstream.next();if(a.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);let b=a.value.split(this.separator);for(let a of(b[0]=this.carryover+b[0],b.slice(0,-1)))this.outputQueue.push(a);return this.carryover=b[b.length-1],!0}}class su extends rP{decodeUTF8(){return new sv(this)}}class sv extends sr{constructor(a){super(),this.upstream=a,this.impl=new sw(a)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class sw extends r${constructor(b){if(super(),this.upstream=b,aw.get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:b}=a.r(99348);this.decoder=new b("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let a,b,c=await this.upstream.next();return!c.done&&(a=c.value,b=aw.get("IS_BROWSER")?this.decoder.decode(a,{stream:!0}):this.decoder.write(Buffer.from(a.buffer)),this.outputQueue.push(b),!0)}}class sx extends su{constructor(a,b={}){super(),this.file=a,this.options=b,iV.assert(a instanceof Uint8Array||!!aw.get("IS_BROWSER")&&(a instanceof File||a instanceof Blob),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=b.offset||0,this.chunkSize=b.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};let a=new Promise((a,b)=>{let c=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)a(new Uint8Array(this.file.slice(this.offset,c)));else{let d=new FileReader;d.onload=c=>{let e=d.result;if(e instanceof ArrayBuffer&&(e=new Uint8Array(e)),!(e instanceof Uint8Array))return b(TypeError("FileReader returned unknown type."));a(e)},d.onabort=a=>b(Error("Aborted")),d.onerror=a=>b(Error(a.type));let e=this.file.slice(this.offset,c);d.readAsArrayBuffer(e)}this.offset=c});return{value:await a,done:!1}}}async function sy(a,b={},c){let d,e;"string"==typeof a?d=a:(d=a.url,e=sz(a));let f=await (c||iV.fetch)(d,e);if(f.ok)return new sx(new Uint8Array(await f.arrayBuffer()),b);throw Error(f.statusText)}let sz=a=>({method:a.method,headers:a.headers,body:a.body,mode:a.mode,credentials:a.credentials,cache:a.cache,redirect:a.redirect,referrer:a.referrer,integrity:a.integrity});function sA(a){return"string"==typeof a&&"file://"===a.slice(0,7)}class sB extends sq{constructor(a,b={}){super(),this.input=a,this.options=b}async iterator(){if(sA(this.input)&&aw.get("IS_NODE")){let b=a.r(522734);this.input=b.readFileSync(this.input.slice(7))}return new sx(this.input,this.options)}}class sC extends sq{constructor(a,b={}){super(),this.url=a,this.fileOptions=b}async iterator(){return sA(this.url)?new sB(this.url,this.fileOptions).iterator():sy(this.url,this.fileOptions)}}function sD(a,b={}){return new sf(new sC(a),b)}function sE(a){let b=new rR(a);return r5(async()=>b)}function sF(a){return r5(async()=>{let b=await a();return new rR(()=>b.next())})}async function sG(a,b){return sp.create(a,b)}async function sH(a){return sg.create(a)}a.s([],45593),a.i(45593),a.s(["CSVDataset",()=>sf,"Dataset",()=>r4,"FileDataSource",()=>sB,"TextLineDataset",()=>r9,"URLDataSource",()=>sC,"array",()=>r6,"csv",()=>sD,"func",()=>sE,"generator",()=>sF,"microphone",()=>sH,"version_data",()=>"4.22.0","webcam",()=>sG,"zip",()=>r7],635935),a.i(635935);var hp=hp;a.s([],384846),a.i(384846),a.s(["nonMaxSuppressionV3Impl",()=>jV,"nonMaxSuppressionV4Impl",()=>jW,"nonMaxSuppressionV5Impl",()=>jX,"whereImpl",()=>rz],495488);var sI=a.i(495488),sI=sI,iV=iV,iV=iV;function sJ(a,b){Array.isArray(a)||(a=[a]),a.forEach(a=>{null!=a&&iV.assert("complex64"!==a.dtype,()=>`${b} does not support complex64 tensors in the CPU backend.`)})}let sK=sI.whereImpl;class sL extends y{nextDataId(){return sL.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new x(this,dB)}write(a,b,c){this.firstUse&&(this.firstUse=!1,aw.get("IS_NODE")&&hp.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));let d={id:this.nextDataId()};return this.data.set(d,{values:a,dtype:c,refCount:1}),d}makeTensorInfo(a,b,c){let d;if("string"===b&&null!=c&&c.length>0&&iV.isString(c[0])){let e=c.map(a=>iV.encodeString(a));d=this.write(e,a,b)}else d=this.write(c,a,b);return{dataId:d,shape:a,dtype:b}}refCount(a){return this.data.has(a)?this.data.get(a).refCount:0}incRef(a){let b=this.data.get(a);b.refCount++}decRef(a){if(this.data.has(a)){let b=this.data.get(a);b.refCount--}}move(a,b,c,d,e){this.data.set(a,{values:b,dtype:d,refCount:e})}numDataIds(){return this.data.numDataIds()}async read(a){return this.readSync(a)}readSync(a){let{dtype:b,complexTensorInfos:c}=this.data.get(a);if("complex64"===b){let a=this.readSync(c.real.dataId),b=this.readSync(c.imag.dataId);return hp.mergeRealAndImagArrays(a,b)}return iV.convertBackendValuesAndArrayBuffer(this.data.get(a).values,b)}bufferSync(a){let b=this.readSync(a.dataId);if("string"===a.dtype)try{let c=b.map(a=>iV.decodeString(a));return eu(a.shape,a.dtype,c)}catch(a){throw Error("Failed to decode encoded string bytes into utf-8")}return eu(a.shape,a.dtype,b)}makeOutput(a,b,c){return dB.makeTensorFromTensorInfo(this.makeTensorInfo(b,c,a),this)}disposeData(a,b=!1){if(this.data.has(a)){if(this.data.get(a).refCount--,!b&&this.data.get(a).refCount>0)return!1;let{complexTensorInfos:c}=this.data.get(a);null!=c&&(this.disposeData(c.real.dataId,!0),this.disposeData(c.imag.dataId,!0)),this.data.delete(a)}return!0}disposeIntermediateTensorInfo(a){this.disposeData(a.dataId)}async time(a){let b=iV.now();return a(),{kernelMs:iV.now()-b}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(a){sJ([a],"where");let b=this.readSync(a.dataId);return sK(a.shape,b)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}sL.nextDataId=0,a.s([],972467),a.i(972467);var iV=iV;function sM(a){let b=new Float32Array(a.length);for(let c=0;c<a.length;++c)b[c]=Math.abs(a[c]);return b}var hp=hp,iV=iV;function sN(a){return(b,c,d,e,f)=>{let g=hp.assertAndGetBroadcastShape(b,c),h=g.length,i=iV.computeStrides(g),j=iV.sizeFromShape(g),k=iV.getTypedArrayFromDType(f,j),l=b.length,m=c.length,n=iV.computeStrides(b),o=iV.computeStrides(c),p=hp.getBroadcastDims(b,g),q=hp.getBroadcastDims(c,g);if(p.length+q.length===0)for(let b=0;b<k.length;++b)k[b]=a(d[b%d.length],e[b%e.length]);else for(let b=0;b<k.length;++b){let c=iV.indexToLoc(b,h,i),f=c.slice(-l);p.forEach(a=>f[a]=0);let g=iV.locToIndex(f,l,n),j=c.slice(-m);q.forEach(a=>j[a]=0);let r=iV.locToIndex(j,m,o);k[b]=a(d[g],e[r])}return[k,g]}}var hp=hp,iV=iV,iV=iV,iV=iV;function sO(a){let{inputs:b,backend:c}=a,{real:d,imag:e}=b,f=c.data.get(d.dataId).values,g=c.data.get(e.dataId).values,h=c.makeTensorInfo(d.shape,"complex64");return c.data.get(h.dataId).complexTensorInfos={real:c.makeTensorInfo(d.shape,"float32",f),imag:c.makeTensorInfo(e.shape,"float32",g)},h}function sP(a,b,c="float32"){if("complex64"===c)return sO({inputs:{real:sP(a,b,"float32"),imag:sP(a,b,"float32")},backend:a});let d=iV.makeZerosTypedArray(iV.sizeFromShape(b),c);return a.makeTensorInfo(b,c,d)}function sQ(a){let{inputs:b,backend:c}=a,{x:d}=b;return c.incRef(d.dataId),{dataId:d.dataId,shape:d.shape,dtype:d.dtype}}function sR(a){let{inputs:b,backend:c}=a,{input:d}=b,e=c.data.get(d.dataId).complexTensorInfos.real,f=c.data.get(e.dataId).values;return c.makeTensorInfo(e.shape,e.dtype,f)}function sS(a,b,c,d){if("int32"===d)return[b,"int32",Int32Array.from(a)];if("bool"===d){let d=iV.toTypedArray([0],c),[e,f]=sN((a,b)=>+(a!==b))(b,[],a,d,"bool");return[f,"bool",e]}throw Error(`Error in Cast: failed to cast ${c} to ${d}`)}function sT(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{dtype:f}=d;if("complex64"===f){if("complex64"===e.dtype)return sQ({inputs:{x:e},backend:c});let a=sP(c,e.shape,e.dtype),b=sT({inputs:{x:e},backend:c,attrs:{dtype:"float32"}}),d=sO({inputs:{real:b,imag:a},backend:c});return c.disposeIntermediateTensorInfo(a),c.disposeIntermediateTensorInfo(b),d}if("complex64"===e.dtype){let a=sR({inputs:{input:e},backend:c}),b=sT({inputs:{x:a},backend:c,attrs:{dtype:f}});return c.disposeIntermediateTensorInfo(a),b}if(!iV.hasEncodingLoss(e.dtype,f)){let a=sQ({inputs:{x:e},backend:c});return{dataId:a.dataId,shape:a.shape,dtype:f}}let[g,h,i]=sS(c.data.get(e.dataId).values,e.shape,e.dtype,f);return c.makeTensorInfo(g,h,i)}function sU(a,b,c,d){return null==c?({inputs:c,backend:e})=>{let{a:f,b:g}=c;sJ([f,g],a);let h=e.data.get(f.dataId).values,i=e.data.get(g.dataId).values,j="string"===f.dtype?hp.fromUint8ToStringArray(h):h,k="string"===f.dtype?hp.fromUint8ToStringArray(i):i,l=d||f.dtype,[m,n]=b(f.shape,g.shape,j,k,l);return e.makeTensorInfo(n,l,m)}:({inputs:a,backend:e})=>{let{a:f,b:g}=a;if("complex64"===f.dtype||"complex64"===g.dtype){let a=sT({inputs:{x:f},backend:e,attrs:{dtype:"complex64"}}),b=e.data.get(a.dataId),d=b.complexTensorInfos.real,h=b.complexTensorInfos.imag,i=e.data.get(d.dataId).values,j=e.data.get(h.dataId).values,k=sT({inputs:{x:g},backend:e,attrs:{dtype:"complex64"}}),l=e.data.get(k.dataId),m=l.complexTensorInfos.real,n=l.complexTensorInfos.imag,o=e.data.get(m.dataId).values,p=e.data.get(n.dataId).values,[q,r,s]=c(f.shape,g.shape,i,j,o,p),t=e.makeTensorInfo(s,"float32",q),u=e.makeTensorInfo(s,"float32",r),v=sO({inputs:{real:t,imag:u},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(k),e.disposeIntermediateTensorInfo(t),e.disposeIntermediateTensorInfo(u),v}{let a=e.data.get(f.dataId).values,c=e.data.get(g.dataId).values,h=d||f.dtype,[i,j]=b(f.shape,g.shape,a,c,h);return e.makeTensorInfo(j,h,i)}}}function sV(a){return(b,c,d,e,f,g)=>{let h=hp.assertAndGetBroadcastShape(b,c),i=iV.sizeFromShape(h),j=h.length,k=iV.computeStrides(h),l=iV.getTypedArrayFromDType("float32",i),m=iV.getTypedArrayFromDType("float32",i),n=hp.getBroadcastDims(b,h),o=hp.getBroadcastDims(c,h),p=hp.mergeRealAndImagArrays(d,e),q=hp.mergeRealAndImagArrays(f,g),r=b.length,s=iV.computeStrides(b),t=c.length,u=iV.computeStrides(c);if(n.length+o.length===0)for(let b=0;b<l.length;b++){let c=b%p.length,d=b%q.length,e=a(p[2*c],p[2*c+1],q[2*d],q[2*d+1]);l[b]=e.real,m[b]=e.imag}else for(let b=0;b<l.length;b++){let c=iV.indexToLoc(b,j,k),d=c.slice(-r);n.forEach(a=>d[a]=0);let e=iV.locToIndex(d,r,s),f=c.slice(-t);o.forEach(a=>f[a]=0);let g=iV.locToIndex(f,t,u),h=a(p[2*e],p[2*e+1],q[2*g],q[2*g+1]);l[b]=h.real,m[b]=h.imag}return[l,m,h]}}let sW=sN((a,b)=>a+b),sX=sU("Add",sW,sV((a,b,c,d)=>({real:a+c,imag:b+d})));var iV=iV;function sY(a,b,c,d,e){let f=iV.sizeFromShape(d),g=iV.makeZerosTypedArray(e,c);for(let c=0;c<a.length;c++){let d=a[c];if(d<0)throw Error("Input x must be non-negative!");d>=e||(f>0?g[d]+=b[c]:g[d]+=1)}return g}function sZ(a,b,c,d=!1){let e=a.shape[0],f=a.shape[1],g=eu([e,c],b.dtype);for(let h=0;h<e;h++)for(let e=0;e<f;e++){let f=a.get(h,e);if(f<0)throw Error("Input x must be non-negative!");f>=c||(d?g.set(1,h,f):b.size>0?g.set(g.get(h,f)+b.get(h,e),h,f):g.set(g.get(h,f)+1,h,f))}return g}let s$=sN((a,b)=>a&b),s_=sU(aQ,s$);var iV=iV;function s0(a){return(b,c,d)=>{let e=iV.getArrayFromDType(c,b.length);for(let c=0;c<b.length;++c)e[c]=a(b[c],d);return e}}var hp=hp;function s1(a,b,c){return s2(a,s0(b),c)}function s2(a,b,c){return({inputs:d,attrs:e,backend:f})=>{let g,{x:h}=d;sJ(h,a);let i=f.data.get(h.dataId).values;if("string"===h.dtype){if(!Array.isArray(i))throw Error("String tensor's value was not an instance of Array");g=hp.fromUint8ToStringArray(i)}else g=i;let j=c||h.dtype,k=b(g,j,e);return f.makeTensorInfo(h.shape,j,k)}}let s3=s0(a=>Math.ceil(a)),s4=s2(aT,s3);var hp=hp,iV=iV;function s5(a,b,c,d){let e=iV.getArrayFromDType(c,iV.sizeFromShape(b));if(d&&"string"!==c){let b=0;a.forEach(a=>{let c=iV.sizeFromShape(a.shape);e.set(a.vals,b),b+=c})}else{let d=0;a.forEach(a=>{let f="string"===c?hp.fromUint8ToStringArray(a.vals):a.vals,g=0;for(let c=0;c<a.shape[0];++c){let h=c*b[1]+d;for(let b=0;b<a.shape[1];++b)e[h+b]=f[g++]}d+=a.shape[1]})}return e}let s6=sN((a,b)=>+(a===b)),s7=sU(bj,s6,null,"bool"),s8=s0(a=>Math.exp(a)),s9=s2("Exp",s8,"float32"),ta=s0(a=>Math.expm1(a)),tb=s2(bl,ta),tc=s0(a=>Math.floor(a)),td=s2(bo,tc),te=sN((a,b)=>Math.floor(a/b)),tf=sU(bp,te,null,"int32");function tg(a,b,c,d,e,f,g,h,i){let j=eu([d,f],c);for(let c=0;c<d;c++){let d=[],k=0;for(let b=0;b<e;b++){let f=a[c*e+b];k+=f*g[b],d.push(f)}if(k<0||k>=i/f)throw Error(`Invalid indices: ${d} does not index into ${h}`);for(let a=0;a<f;a++)j.values[c*f+a]=b.get(...b.indexToLoc(k*f+a))}return j}function th(a,b,c){let d=eu(c,a.dtype);for(let c=0;c<d.size;++c){let e=d.indexToLoc(c).slice(),f=e[0],g=e[2],h=b.locToIndex([f,g]);e[2]=b.values[h];let i=a.locToIndex(e);0<=i&&i<a.values.length&&(d.values[c]=a.values[i])}return d}let ti=sN((a,b)=>+(a>b)),tj=sU(bt,ti,null,"bool"),tk=sN((a,b)=>+(a>=b)),tl=sU(bu,tk,null,"bool"),tm=sN((a,b)=>+(a<b)),tn=sU(bC,tm,null,"bool"),to=sN((a,b)=>+(a<=b)),tp=sU(bD,to,null,"bool");var iV=iV;function tq(a,b,c){let d=(b-a)/(c-1),e=iV.makeZerosTypedArray(c,"float32");e[0]=a;for(let a=1;a<e.length;a++)e[a]=e[a-1]+d;return e}let tr=s0(a=>Math.log(a)),ts=s2("Log",tr);var iV=iV;function tt(a,b,c,d){let e=iV.getTypedArrayFromDType(d,iV.sizeFromShape(c));for(let c=0;c<e.length;++c){let d=c*b,f=a[d];for(let c=0;c<b;++c){let b=a[d+c];(Number.isNaN(b)||b>f)&&(f=b)}e[c]=f}return e}let tu=sN((a,b)=>Math.max(a,b)),tv=sU(bK,tu),tw=sN((a,b)=>Math.min(a,b)),tx=sU(bR,tw),ty=sN((a,b)=>a*b),tz=sU(bU,ty,sV((a,b,c,d)=>({real:a*c-b*d,imag:a*d+b*c})));var iV=iV;function tA(a,b,c){return ty([],b,iV.createScalarValue(-1,c),a,c)}let tB=sN((a,b)=>+(a!==b)),tC=sU(bV,tB,null,"bool");var hp=hp,iV=iV,iV=iV;function tD(a,b,c,d,e){let f=b.length,g=iV.sizeFromShape(b),h=iV.computeStrides(b),i=iV.computeStrides(e),j=iV.getTypedArrayFromDType(c,iV.sizeFromShape(e));for(let b=0;b<g;++b){let c=iV.indexToLoc(b,f,h),e=Array(c.length);for(let a=0;a<e.length;a++)e[a]=c[d[a]];j[iV.locToIndex(e,f,i)]=a[b]}return j}function tE(a){let{inputs:b,attrs:c,backend:d}=a,{x:e}=b,{perm:f}=c;sJ(e,"transpose");let g=Array(e.shape.length);for(let a=0;a<g.length;a++)g[a]=e.shape[f[a]];let h=tD(d.data.get(e.dataId).values,e.shape,e.dtype,f,g);return{dataId:d.write(h,g,e.dtype),shape:g,dtype:e.dtype}}function tF(a,b,c,d){let[e,f]=hp.computeOutAndReduceShapes(a,d),g=dp(b,"int32"),h=iV.makeZerosTypedArray(iV.sizeFromShape(e),g),i=iV.sizeFromShape(f);for(let a=0;a<h.length;++a){let b=a*i,d=1;for(let a=0;a<i;++a)d*=c[b+a];h[a]=d}return{outVals:h,outShape:e,outDtype:g}}var iV=iV;function tG(a,b){let c=a.slice(0,b);for(;c.length<b;)c.push(1);for(let d=b;d<a.length;d++)c[b-1]*=a[d];return c}function tH(a,b,c,d,e,f,g,h){let i,j,k,l;if(0===a.length)throw Error("paramsNestedSplits must be non empty");if(0===b[0].length)throw Error("Split tensors must not be scalars");let m=b[0][0]-1;if(f.forEach((a,b)=>{if(a<0||a>=m){let c=iV.indexToLoc(b,g.length,iV.computeStrides(g)).join(",");throw Error(`indices[${c}] = ${a} is not in [0, ${m})`)}}),0===d.length)throw Error("params.rank must be nonzero");let{outSplits:n,valueSlices:o,numValues:p}=function(a,b,c,d){let e=[],f=0,g=Array(b.length-1+c.length).fill(null).map(()=>[0]);for(let a=0;a<c.length;++a){let b=c[a],e=a===c.length-1?d:c[a+1].length;if(0===b.length)throw Error("Ragged splits may not be empty");if(b[0]<0)throw Error("Ragged splits must be non-negative");if(b[b.length-1]>e)throw Error("Ragged splits must not point past values");for(let a=1;a<b.length;++a)if(b[a-1]>b[a])throw Error("Ragged splits must be sorted in ascending order")}let h=1;for(let a=0;a<b.length-1;++a){h*=b[a];let c=b[a+1];for(let b=1;b<h+1;++b)g[a].push(b*c)}for(let d=0;d<a.length;++d){let h=a[d],i=a[d]+1;for(let a=0;a<c.length;++a){let d=c[a],e=a+b.length-1;if(e>=0){let a=g[e],b=a[a.length-1]-d[h];for(let a=h;a<i;++a)g[e].push(d[a+1]+b)}h=d[h],i=d[i]}i!==h&&(e.push([h,i]),f+=i-h)}return{outSplits:g,valueSlices:e,numValues:f}}(f,g,a,d[0]),q=function(a){let b=[];for(let c=0;c<a.length;++c){let d=a[c].length,e=iV.getArrayFromDType("int32",d);b.push(e),a[c].forEach((a,b)=>e[b]=a)}return b}(n),r=((i=d.slice())[0]=p,j=iV.getArrayFromDType(e,iV.sizeFromShape(i)),l=0===(k=c.length)?0:k/d[0],!function(a,b,c,d,e,f){let g=tG(b,2)[1],h=tG(f,2)[1],i=0;for(let b of c)for(let c=b[0];c<b[1];++c){for(let b=0;b<d;++b)e[i*h+b]=a[c*g+b];++i}}(c,d,o,l,j,i),[j,i]);return[q,r[0],r[1]]}var iV=iV;function tI(a,b,c,d,e,f,g){if(b.length>1)throw Error("starts must be a scalar or vector");if(e.length>1)throw Error("limits must be a scalar or vector");if(g.length>1)throw Error("deltas must be a scalar or vector");let h=0===b.length,i=0===e.length,j=0===g.length,k=[];h||k.push(b[0]),i||k.push(e[0]),j||k.push(g[0]);for(let a=1;a<k.length;++a)if(k[a]!==k[a-1])throw Error("starts, limits, and deltas must have the same shape");let l=0===k.length?1:k[0],m=iV.getArrayFromDType("int32",l+1);m[0]=0;for(let b=0;b<l;++b){let c,e=h?a[0]:a[b],g=i?d[0]:d[b],k=j?f[0]:f[b];if(0===k)throw Error("Requires delta != 0");if(k>0&&g<e||k<0&&g>e)c=0;else if((c=Math.ceil(Math.abs((g-e)/k)))>0x7fffffff)throw Error("Requires ((limit - start) / delta) <= 2147483647");m[b+1]=m[b]+c}let n=m[l],o=iV.getArrayFromDType(c,n),p=0;for(let b=0;b<l;++b){let c=m[b+1]-m[b],d=h?a[0]:a[b],e=j?f[0]:f[b];for(let a=0;a<c;++a)o[p++]=d,d+=e}return[m,o]}var hp=hp,iV=iV,tJ=hp.RowPartitionType;class tK{constructor(a,b,c,d,e,f,g,h,i,j){this.shape=a,this.shapeShape=b,this.values=c,this.valuesShape=d,this.valuesDType=e,this.defaultValue=f,this.defaultValueShape=g,this.rowPartitionValues=h,this.rowPartitionValuesShapes=i,this.rowPartitionTypes=hp.getRowPartitionTypesHelper(j),this.raggedRank=hp.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(a){return this.rowPartitionTypes[0]===tJ.FIRST_DIM_SIZE?this.rowPartitionTypes[a+1]:this.rowPartitionTypes[a]}getRowPartitionTensor(a){return this.rowPartitionTypes[0]===tJ.FIRST_DIM_SIZE?this.rowPartitionValues[a+1]:this.rowPartitionValues[a]}getMaxWidth(a){let b=this.getRowPartitionTensor(a-1);switch(this.getRowPartitionTypeByDimension(a-1)){case tJ.VALUE_ROWIDS:return tK.getMaxWidthValueRowID(b);case tJ.ROW_SPLITS:return tK.getMaxWidthRowSplit(b);default:throw Error(`Cannot handle partition type ${tJ[this.getRowPartitionTypeByDimension(a-1)]}`)}}static getMaxWidthRowSplit(a){let b=a.length;if(0===b||1===b)return 0;let c=0;for(let d=0;d<b-1;++d){let b=a[d+1]-a[d];b>c&&(c=b)}return c}static getMaxWidthValueRowID(a){let b=a.length;if(0===b)return 0;let c=0,d=a[0],e=0;for(let f=1;f<b;++f){let b=a[f];b!==d&&(d=b,e=Math.max(f-c,e),c=f)}return Math.max(b-c,e)}tensorShapeFromTensor(a,b,c=!0){if(0===b.length){if(-1===a[0])return[];throw Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return tM(a,c)}calculateOutputSize(a){let b=this.valuesShape,c=this.defaultValueShape;hp.validateDefaultValueShape(c,b);let d=this.tensorShapeFromTensor(this.shape,this.shapeShape),e=hp.combineRaggedTensorToTensorShapes(this.raggedRank,d,b);e[0]<0&&(e[0]=a);for(let a=1;a<=this.raggedRank;++a)e[a]<0&&(e[a]=this.getMaxWidth(a));return e}calculateFirstParentOutputIndex(a,b,c){let d=Math.min(a,c),e=[],f=0;for(let a=0;a<d;++a,f+=b)e.push(f);for(let b=d;b<a;++b)e.push(-1);return iV.assert(e.length===a,()=>"Final length of result must be equal to firstDimension."),e}calculateOutputIndexRowSplit(a,b,c,d){let e=a.length,f=[];for(let g=0;g<e-1;++g){let e=a[g+1]-a[g],h=Math.min(d,e),i=b[g];-1===i&&(h=0);for(let a=0;a<h;++a)f.push(i),i+=c;for(let a=0;a<e-h;++a)f.push(-1)}if(e>0&&f.length!==a[e-1])throw Error("Invalid row split size.");return f}calculateOutputIndexValueRowID(a,b,c,d){let e=a.length,f=[];if(0===e)return[];let g=0,h=a[0];if(h>=b.length)throw Error(`Got currentValueRowId=${h}, which is not less than ${b.length}`);let i=b[h];f.push(i);for(let j=1;j<e;++j){let e=a[j];if(e===h)i>=0&&(++g<d?i+=c:i=-1);else{if(g=0,h=e,e>=b.length)throw Error(`Got nextValueRowId=${e} which is not less than ${b.length}`);i=b[e]}f.push(i)}if(f.length!==a.length)throw Error("Invalid row ids.");return f}calculateOutputIndex(a,b,c,d){let e=this.getRowPartitionTensor(a),f=this.getRowPartitionTypeByDimension(a);switch(f){case tJ.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(e,b,c,d);case tJ.ROW_SPLITS:if(e.length-1>b.length)throw Error(`Row partition size is greater than output size: ${e.length-1} > ${b.length}`);return this.calculateOutputIndexRowSplit(e,b,c,d);default:throw Error(`Unsupported partition type: ${tJ[f]}`)}}getFirstDimensionSize(){let a=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw Error("No row_partition_types given.");let b=this.rowPartitionTypes[0];switch(b){case tJ.FIRST_DIM_SIZE:return a[0];case tJ.VALUE_ROWIDS:throw Error("Cannot handle VALUE_ROWIDS in first dimension.");case tJ.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw Error(`Cannot handle type ${tJ[b]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw Error("Invalid first partition input. Tensor requires at least one element.");let a=this.getFirstDimensionSize(),b=this.calculateOutputSize(a),c=Array(this.raggedRank+1);c[c.length-1]=1;for(let a=c.length-2;a>=0;--a)c[a]=c[a+1]*b[a+1];let d=tM(b,!1),e=iV.getArrayFromDType(this.valuesDType,iV.sizeFromShape(d));if(c[0]*b[0]>0){let f=this.calculateFirstParentOutputIndex(a,c[0],b[0]);for(let a=1;a<=this.raggedRank;++a)f=this.calculateOutputIndex(a-1,f,c[a],b[a]);this.setOutput(this.raggedRank,f,e,d)}return[d,e]}setOutput(a,b,c,d){if(0===c.length)return;let e=this.values,f=d.slice();f=f.slice(a+1);let g=iV.sizeFromShape(f),h=b.length,i=this.defaultValue;if(i.length!==g&&1!==i.length){let a=this.defaultValueShape;dT(()=>{i=fs(e4(i,a),f).dataSync()})}let j=0,k=0,l=0;for(let a=0;a<=h;++a){let d=a<h?b[a]:-1;if(d===l){++l;continue}if(k<l){let a=e.subarray(j*g);tL(c.subarray(k*g),a,(l-k)*g)}if(a>=h&&(d=Math.floor(c.length/g)),d>l)if(1===this.defaultValue.length)c.subarray(l*g,d*g).fill(this.defaultValue[0]),l=d;else for(;d>l;)tL(c.slice(l*g),i,g),++l;d<0?(j=a+1,k=l):(j=a,l=(k=l)+1)}}}function tL(a,b,c){for(let d=0;d<c;d++)a[d]=b[d]}function tM(a,b){let c=[];for(let d of a){if(d<0){if(!b)throw Error(`Dimension ${d} must be >= 0`);if(d<-1)throw Error(`Dimension ${d} must be >= -1`);d=-1}c.push(d)}return c}function tN(a,b,c,d,e,f,g,h,i,j){return new tK(a,b,c,d,e,f,g,h,i,j).compute()}var iV=iV;function tO(a,b,c,d){let e=a===b,f=a<b&&c<0,g=b<a&&c>1;if(e||f||g)return iV.makeZerosTypedArray(0,d);let h=Math.abs(Math.ceil((b-a)/c)),i=iV.makeZerosTypedArray(h,d);b<a&&1===c&&(c=-1),i[0]=a;for(let a=1;a<i.length;a++)i[a]=i[a-1]+c;return i}let tP=s0(a=>1/Math.sqrt(a)),tQ=s2(ci,tP);function tR(a,b,c,d,e,f,g,h,i,j){let k=a.values,l=b.values;if(0===d)return eu(c,b.dtype);let m=i instanceof dh?i:eu([d/e,e],b.dtype);"string"==typeof i||"number"==typeof i?m.values.fill(i):"boolean"==typeof i&&m.values.fill(+i);for(let a=0;a<f;a++){let f=[],i=0;for(let b=0;b<g;b++){let c=k[a*g+b];f.push(c),i+=c*h[b]}if(i<0||i>=d/e)throw Error(`Invalid indices: ${f} does not index into ${c}`);for(let c=0;c<e;c++)j?m.values[i*e+c]+=l[a*e+c]:m.values[i*e+c]=0===b.rank?l[0]:l[a*e+c]}return m}let tS=s0(a=>1/(1+Math.exp(-a))),tT=s1(cr,a=>1/(1+Math.exp(-a)));var hp=hp,tU=gr,iV=iV;function tV(a,b,c,d,e){let f=tU.isSliceContinous(d,b,c),g=iV.sizeFromShape(c),h=iV.computeStrides(d);if(f){let c=tU.computeFlatOffset(b,h);return"string"===e?a.slice(c,c+g):a.subarray(c,c+g)}let i="string"===e?hp.fromUint8ToStringArray(a):a,j=eu(d,e,i),k=eu(c,e);for(let a=0;a<k.size;++a){let c=k.indexToLoc(a),d=c.map((a,c)=>a+b[c]);k.set(j.get(...d),...c)}return"string"===e?hp.fromStringArrayToUint8(k.values):k.values}function tW(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{begin:f,size:g}=d;sJ(e,"slice");let[h,i]=tU.parseSliceParams(e,f,g);tU.assertParamsValid(e,h,i);let j=tV(c.data.get(e.dataId).values,h,i,e.shape,e.dtype);return c.makeTensorInfo(i,e.dtype,j)}var hp=hp,iV=iV;function tX(a,b,c,d,e,f,g){let h=b[0],i=f[0],j=Array(i),k=Array(h),l=b[1];if(0===i){if(0!==h)throw Error(hp.getSparseFillEmptyRowsIndicesDenseShapeMismatch(h));return[iV.getArrayFromDType(c,0),[0,l],iV.getArrayFromDType(e,0),j,k]}let m=!0,n=0,o=Array(i).fill(0);for(let b=0;b<h;++b){let c=a[b*l];if(c<0)throw Error(hp.getSparseFillEmptyRowsNegativeIndexErrorMessage(b,c));if(c>=i)throw Error(hp.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(b,c,i));++o[c],m=m&&c>=n,n=c}let p=!0;for(let a=0;a<i;++a){let b=0===o[a];j[a]=b,p=p&&!b,o[a]=Math.max(o[a],1),a>0&&(o[a]+=o[a-1])}if(p&&m){for(let a=0;a<h;++a)k[a]=a;return[a,[h,l],d,j,k]}{let b=o[i-1],f=iV.getArrayFromDType(c,b*l),m=iV.getArrayFromDType(e,b),n=Array(i).fill(0);for(let b=0;b<h;++b){let c=a[b*l],e=n[c],g=(0===c?0:o[c-1])+e;n[c]++;for(let c=0;c<l;++c)f[g*l+c]=a[b*l+c];m[g]=d[b],k[b]=g}for(let a=0;a<i;++a)if(0===n[a]){let b=0===a?0:o[a-1];f[b*l+0]=a;for(let a=1;a<l;++a)f[b*l+a]=0;m[b]=g}return[f,[b,l],m,j,k]}}var hp=hp,iV=iV;function tY(a,b,c,d,e){let f=iV.sizeFromShape(d),g=b[0],h=e.length,i=[],j=1,k=-1;for(let a=0;a<h;++a){let b=e[a];if(-1===b){if(-1!==k)throw Error(hp.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(k,a));k=a,i.push(1)}else{if(b<0)throw Error(hp.getSparseReshapeNegativeOutputDimErrorMessage(a,b));j*=b,i.push(b)}}if(-1!==k){if(j<=0)throw Error(hp.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let a=Math.trunc(f/j);if(j*a!==f)throw Error(hp.getSparseReshapeInputOutputMultipleErrorMessage(d,i));i[k]=a}if(iV.sizeFromShape(i)!==f)throw Error(hp.getSparseReshapeInputOutputMismatchErrorMessage(d,i));let l=d.length,m=[];if(l>0){m[l-1]=1;for(let a=l-2;a>=0;--a)m[a]=m[a+1]*d[a+1]}let n=[];if(h>0){n[h-1]=1;for(let a=h-2;a>=0;--a)n[a]=n[a+1]*i[a+1]}let o=iV.getArrayFromDType(c,g*h);for(let b=0;b<g;++b){let c=0;for(let d=0;d<l;++d)c+=a[b*l+d]*m[d];for(let a=0;a<h;++a)o[b*h+a]=Math.trunc(c/n[a]),c%=n[a]}return[o,[g,h],i]}var hp=hp,iV=iV;function tZ(a,b,c,d,e,f=!1,g=0){let h=d.length,i=[b[0],a.length/b[0]],j=i[1],k=h>0?e[h-1]+1:0;if(k<0)throw Error(hp.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let l=b.slice();l[0]=k;let m=l.reduce((a,b)=>a*b,1),n=iV.getArrayFromDType(c,m);if(0===h)return k>0&&n.fill(g),[n,l];if(k<=0)throw Error(hp.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let o=0,p=1,q=0,r=e[0];for(;;){let b=0;if(p<h){if(r===(b=e[p])){++p;continue}if(r>=b)throw Error(hp.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(r<0||r>=k)throw Error(hp.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(r,k));r>q&&n.fill(g,q*j,r*j);for(let b=o;b<p;++b){let c=d[b];if(c<0||c>=i[0])throw Error(hp.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(b,d[b],i[0]));for(let b=0;b<j;b++)n[r*j+b]+=a[c*j+b]}if(f)for(let a=0;a<j;a++)n[r*j+a]/=p-o;if(o=p,++p,q=r+1,r=b,p>h)break}return q<k&&n.fill(g,q*j,k*j),[n,l]}let t$=s0(a=>Math.sqrt(a)),t_=s1(ct,a=>Math.sqrt(a)),t0=sN((a,b)=>{let c=a-b;return c*c}),t1=sU(cC,t0),t2=s0((a,b)=>{let{pattern:c,replaceGlobal:d,rewrite:e}=b;return a.replace(new RegExp(c,d?"g":""),e)}),t3=s2(cE,t2);function t4(a,b,c,d){let e=eu(a,b.dtype);for(let a=0;a<e.size;a++){let f=e.indexToLoc(a),g=Array(f.length);for(let a=0;a<g.length;a++)g[a]=f[a]*c[a]+d[a];e.set(b.get(...g),...f)}return e}var iV=iV;class t5{constructor(a,b,c,d,e,f){this.separator=iV.encodeString(a),this.nGramWidths=b,this.leftPad=iV.encodeString(c),this.rightPad=iV.encodeString(d),this.padWidth=e,this.preserveShort=f}getPadWidth(a){return Math.min(this.padWidth<0?a-1:this.padWidth,a-1)}getNumNGrams(a,b){return Math.max(0,a+2*this.getPadWidth(b)-b+1)}createNGrams(a,b,c,d,e,f){for(let g=0;g<e;++g){let h,i=this.getPadWidth(f),j=Math.max(0,i-g),k=Math.max(0,i-(e-(g+1))),l=f-(j+k),m=b+(j>0?0:g-i);h=0+j*this.leftPad.length;for(let b=0;b<l;++b)h+=a[m+b].length;h+=k*this.rightPad.length,h+=(j+k+l-1)*this.separator.length,c[d+g]=new Uint8Array(h);let n=c[d+g],o=0,p=a=>a.forEach(a=>n[o++]=a);for(let a=0;a<j;++a)p(this.leftPad),p(this.separator);for(let b=0;b<l-1;++b)p(a[m+b]),p(this.separator);if(l>0){p(a[m+l-1]);for(let a=0;a<k;++a)p(this.separator),p(this.rightPad)}else{for(let a=0;a<k-1;++a)p(this.rightPad),p(this.separator);p(this.rightPad)}}}compute(a,b){let c=a.length,d=b.length;if(d>0){let a=b[0];if(0!==a)throw Error(`First split value must be 0, got ${a}`);for(let e=1;e<d;++e){let d=b[e]>=a;if(!(d=d&&b[e]<=c))throw Error(`Invalid split value ${b[e]}, must be in [${a}, ${c}]`);a=b[e]}if(a!==c)throw Error(`Last split value must be data size. Expected ${c}, got ${a}`)}let e=d-1,f=iV.getArrayFromDType("int32",d);if(0===c||0===d){let a=Array(c);for(let a=0;a<=e;++a)f[a]=0;return[a,f]}f[0]=0;for(let a=1;a<=e;++a){let c=b[a]-b[a-1],d=0;this.nGramWidths.forEach(a=>{d+=this.getNumNGrams(c,a)}),this.preserveShort&&c>0&&0===d&&(d=1),f[a]=f[a-1]+d}let g=Array(f[e]);for(let c=0;c<e;++c){let d=b[c],e=f[c];if(this.nGramWidths.forEach(f=>{let h=b[c+1]-b[c],i=this.getNumNGrams(h,f);this.createNGrams(a,d,g,e,i,f),e+=i}),this.preserveShort&&e===f[c]){let f=b[c+1]-b[c];if(0===f)continue;let h=f+2*this.padWidth;this.createNGrams(a,d,g,e,1,h)}}return[g,f]}}function t6(a,b,c,d,e,f,g,h){return new t5(c,d,e,f,g,h).compute(a,b)}var iV=iV;function t7(a,b,c){let d=a.length,e=[],f=0,g=0,h=Array(d);for(let i=0;i<d;++i){let d=e.length;!function(a,b,c,d){if(!a.length)return;if(0===b.length){for(let b=0;b<a.length;++b)d.push(a.subarray(b,b+1));return}if(1===b.length){let e=b[0],f=a.indexOf(e);for(;-1!==f;){let b=a.subarray(0,f);c&&0===b.length||d.push(b),f=(a=a.subarray(f+1)).indexOf(e)}c&&0===a.length||d.push(a);return}let e=0;for(let f=0;f<a.length+1;f++)if(f===a.length||-1!==b.indexOf(a[f])){let b=a.subarray(e,f);c&&0===b.length||d.push(b),e=f+1}}(a[i],b,c,e);let j=e.length-d;h[i]=j,f+=j,g=Math.max(g,j)}let i=iV.getArrayFromDType("int32",2*f),j=Array(f),k=[d,g],l=0;for(let a=0;a<d;++a)for(let b=0;b<h[a];++b)i[2*l]=a,i[2*l+1]=b,j[l]=e[l],++l;return[i,j,k]}var iV=iV;function t8(a,b){let c=iV.getArrayFromDType("int32",a.length);for(let d=0;d<a.length;++d)c[d]=iV.fingerPrint64(a[d]).modulo(b).getLowBitsUnsigned();return c}let t9=sN((a,b)=>a-b),ua=sU("Sub",t9,sV((a,b,c,d)=>({real:a-c,imag:b-d})));function ub(a,b){let c=Array(a.rank);for(let d=0;d<c.length;d++)c[d]=a.shape[d]*b[d];let d=eu(c,a.dtype);for(let b=0;b<d.values.length;++b){let c=d.indexToLoc(b),e=Array(a.rank);for(let b=0;b<e.length;b++)e[b]=c[b]%a.shape[b];let f=a.locToIndex(e);d.values[b]=a.values[f]}return d}var iV=iV;let uc=(a,b)=>{let c=b.value-a.value;return 0===c?a.index-b.index:c};function ud(a,b,c,d,e){let f=b[b.length-1],[g,h]=[a.length/f,f],i=iV.getTypedArrayFromDType(c,g*d),j=iV.getTypedArrayFromDType("int32",g*d);for(let b=0;b<g;b++){let c=b*h,f=a.subarray(c,c+h),g=Array(f.length);f.forEach((a,b)=>g[b]={value:a,index:b}),d<g.length&&(!function a(b,c,d=0,e=b.length-1){for(;e>d;){if(e-d>600){let f=e-d+1,g=c-d+1,h=Math.log(f),i=.5*Math.exp(2*h/3),j=.5*Math.sqrt(h*i*(f-i)/f)*Math.sign(g-f/2),k=Math.max(d,Math.floor(c-g*i/f+j)),l=Math.min(e,Math.floor(c+(f-g)*i/f+j));a(b,c,k,l)}let f=b[c],g=d,h=e;for(iV.swap(b,d,c),uc(b[e],f)>0&&iV.swap(b,d,e);g<h;){for(iV.swap(b,g,h),g++,h--;0>uc(b[g],f);)g+=1;for(;uc(b[h],f)>0;)h-=1}0===uc(b[d],f)?iV.swap(b,d,h):(h+=1,iV.swap(b,h,e)),h<=c&&(d=h+1),c<=h&&(e=h-1)}}(g,d),g=g.slice(0,d)),e&&g.sort(uc);let k=b*d,l=i.subarray(k,k+d),m=j.subarray(k,k+d);for(let a=0;a<d;a++)l[a]=g[a].value,m[a]=g[a].index}let k=b.slice();return k[k.length-1]=d,[eu(k,c,i),eu(k,"int32",j)]}var iV=iV;function ue(a,b,c,d){let e=iV.parseAxisParam(b,c)[0],f=[1,c[0],1];for(let a=0;a<e;a++)f[0]*=c[a];f[1]=c[e];for(let a=e+1;a<c.length;a++)f[2]*=c[a];let g=new Map,h=new Int32Array(c[e]),i=new dh(f,d,a),j=[],k=1===f[0]&&1===f[2];for(let b=0;b<c[e];b++){let c;if(k)c=a[b].toString();else{let a=[];for(let c=0;c<f[0];c++)for(let d=0;d<f[2];d++)a.push(i.get(c,b,d));c=a.join(",")}let d=g.get(c);if(null!=d)h[b]=d;else{let a=g.size;g.set(c,a),h[b]=a,j.push(b)}}let l=f.slice();l[1]=g.size;let m=new dh(l,d);j.forEach((a,b)=>{for(let c=0;c<f[0];c++)for(let d=0;d<f[2];d++)m.set(i.get(c,a,d),c,b,d)});let n=c.slice();return n[e]=l[1],{outputValues:m.values,outputShape:n,indices:h}}a.s(["addImpl",0,sW,"bincountImpl",()=>sY,"bincountReduceImpl",()=>sZ,"bitwiseAndImpl",0,s$,"castImpl",()=>sS,"ceilImpl",0,s3,"concatImpl",()=>s5,"equalImpl",0,s6,"expImpl",0,s8,"expm1Impl",0,ta,"floorDivImpl",0,te,"floorImpl",0,tc,"gatherNdImpl",()=>tg,"gatherV2Impl",()=>th,"greaterEqualImpl",0,tk,"greaterImpl",0,ti,"lessEqualImpl",0,to,"lessImpl",0,tm,"linSpaceImpl",()=>tq,"logImpl",0,tr,"maxImpl",()=>tt,"maximumImpl",0,tu,"minimumImpl",0,tw,"multiplyImpl",0,ty,"negImpl",()=>tA,"notEqualImpl",0,tB,"prodImpl",()=>tF,"raggedGatherImpl",()=>tH,"raggedRangeImpl",()=>tI,"raggedTensorToTensorImpl",()=>tN,"rangeImpl",()=>tO,"rsqrtImpl",0,tP,"scatterImpl",()=>tR,"sigmoidImpl",0,tS,"simpleAbsImpl",()=>sM,"sliceImpl",()=>tV,"sparseFillEmptyRowsImpl",()=>tX,"sparseReshapeImpl",()=>tY,"sparseSegmentReductionImpl",()=>tZ,"sqrtImpl",0,t$,"squaredDifferenceImpl",0,t0,"staticRegexReplaceImpl",0,t2,"stridedSliceImpl",()=>t4,"stringNGramsImpl",()=>t6,"stringSplitImpl",()=>t7,"stringToHashBucketFastImpl",()=>t8,"subImpl",0,t9,"tileImpl",()=>ub,"topKImpl",()=>ud,"transposeImpl",()=>tD,"uniqueImpl",()=>ue],725502);var uf=a.i(725502);dW("cpu",()=>new sL,1),a.s([],28496);let ug=s1("Elu",a=>a>=0?a:Math.exp(a)-1);var iV=iV;function uh(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{alpha:f}=d;sJ([e],"leakyRelu");let g=iV.sizeFromShape(e.shape),h=c.data.get(e.dataId).values,i=iV.getTypedArrayFromDType("float32",g);for(let a=0;a<h.length;a++)i[a]=h[a]<0?f*h[a]:h[a];return c.makeTensorInfo(e.shape,"float32",i)}let ui=sN((a,b)=>a<0?b*a:a);function uj(a){let{inputs:b,backend:c}=a,{x:d,alpha:e}=b;sJ([d,e],"prelu");let f=c.data.get(d.dataId).values,g=c.data.get(e.dataId).values,[h,i]=ui(d.shape,e.shape,f,g,"float32");return c.makeTensorInfo(i,"float32",h)}let uk=s1(b9,a=>Math.max(0,a)),ul=s1(cf,a=>Math.min(Math.max(0,a),6));function um(a,b,c,d,e){if("linear"===c)return sQ({inputs:{x:b},backend:a});if("relu"===c)return uk({inputs:{x:b},backend:a});if("elu"===c)return ug({inputs:{x:b},backend:a});if("relu6"===c)return ul({inputs:{x:b},backend:a});if("prelu"===c)return uj({inputs:{x:b,alpha:d},backend:a});else if("leakyrelu"===c)return uh({inputs:{x:b},backend:a,attrs:{alpha:e}});else if("sigmoid"===c)return tT({inputs:{x:b},backend:a});throw Error(`Activation ${c} has not been implemented for the CPU backend.`)}var un=gz,iV=iV,iV=iV;function uo(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{shape:f}=d,g=iV.sizeFromShape(e.shape),h=iV.inferFromImplicitShape(f,g),i=iV.sizeFromShape(h);iV.assert(g===i,()=>`The new shape (${h}) has ${i} elements and the old shape (${e.shape}) has ${g} elements. The new shape and old shape must have the same number of elements.`),c.incRef(e.dataId);let j=c.data.get(e.dataId);if(null!=j.complexTensorInfos){let a=j.complexTensorInfos.real,b=j.complexTensorInfos.imag;a.shape=h,b.shape=h}return{dataId:e.dataId,shape:h,dtype:e.dtype}}function up(a){let{inputs:b,backend:c,attrs:d}=a,{a:e,b:f}=b,{transposeA:g,transposeB:h}=d;sJ([e,f],"matMul");let i=e.shape.length,j=f.shape.length,k=g?e.shape[i-2]:e.shape[i-1],l=h?f.shape[j-1]:f.shape[j-2],m=g?e.shape[i-1]:e.shape[i-2],n=h?f.shape[j-2]:f.shape[j-1],o=e.shape.slice(0,-2),p=f.shape.slice(0,-2),q=iV.sizeFromShape(o),r=iV.sizeFromShape(p),s=un.assertAndGetBroadcastShape(e.shape.slice(0,-2),f.shape.slice(0,-2)).concat([m,n]);iV.assert(k===l,()=>`Error in matMul: inner shapes (${k}) and (${l}) of Tensors with shapes ${e.shape} and ${f.shape} and transposeA=${g} and transposeB=${h} must match.`);let t=uo({inputs:{x:e},backend:c,attrs:{shape:g?[q,k,m]:[q,m,k]}}),u=uo({inputs:{x:f},backend:c,attrs:{shape:h?[r,n,l]:[r,l,n]}}),v=g?t.shape[1]:t.shape[2],w=g?t.shape[2]:t.shape[1],x=h?u.shape[1]:u.shape[2],y=Math.max(q,r),z=c.data.get(t.dataId).values,A=c.data.get(u.dataId).values,B=iV.computeStrides(t.shape),C=iV.computeStrides(u.shape),[D,E,F]=g?[B[0],1,B[1]]:[B[0],B[1],1],[G,H,I]=h?[1,C[1],C[0]]:[C[1],1,C[0]],J=w*x,K=eu([y,w,x],t.dtype),L=K.values,M=c.blockSize;for(let a=0;a<y;a++){let b=a%q,c=a%r;for(let d=0;d<w;d+=M){let e=Math.min(d+M,w);for(let f=0;f<x;f+=M){let g=Math.min(f+M,x);for(let h=0;h<v;h+=M){let i=Math.min(h+M,v);for(let j=d;j<e;j++)for(let d=f;d<g;d++){let e=0;for(let a=h;a<i;a++)e+=z[b*D+j*E+a*F]*A[a*G+d*H+c*I];L[a*J+(j*x+d)]+=e}}}}}return c.disposeIntermediateTensorInfo(t),c.disposeIntermediateTensorInfo(u),c.makeTensorInfo(s,K.dtype,K.values)}let uq=s1(az,a=>Math.acos(a)),ur=s1(aA,a=>Math.acosh(a));var hp=hp,iV=iV,hp=hp,iV=iV,hp=hp,iV=iV,hp=hp,iV=iV;let us=s1(aE,a=>Math.asin(a)),ut=s1(aF,a=>Math.asinh(a)),uu=s1(aG,a=>Math.atan(a)),uv=sU(aI,sN((a,b)=>Math.atan2(a,b))),uw=s1(aH,a=>Math.atanh(a));var hp=hp,iV=iV;function ux(a,b,c,d,e,f){let g=e.strideHeight,h=e.strideWidth,i=e.dilationHeight,j=e.dilationWidth,k=e.effectiveFilterHeight,l=e.effectiveFilterWidth,m=e.padInfo.top,n=e.padInfo.left,o="max"===f?-1/0:1/0,p=eu(e.outShape,c),q=p.values,r=e.outShape[1]*e.outShape[2]*e.outShape[3],s=e.outShape[2]*e.outShape[3],t=e.outShape[3];for(let b=0;b<e.batchSize;++b){let c=b*r,p=b*d[0];for(let b=0;b<e.inChannels;++b)for(let r=0;r<e.outHeight;++r){let u=r*g-m,v=Math.max(0,u),w=Math.min(e.inHeight,k+u),x=c+r*s;for(let c=0;c<e.outWidth;++c){let g=c*h-n,k=Math.max(0,g),m=Math.min(e.inWidth,l+g),r=o,s=0,u=0;for(let c=v;c<w;c+=i){let e=p+c*d[1];for(let c=k;c<m;c+=j){let g=a[e+c*d[2]+b];"max"===f&&g>r?r=g:"avg"===f&&(s+=g,u++)}if(isNaN(r))break}q[x+c*t+b]="avg"===f?s/u:r}}}return p}function uy(a,b,c,d,e=!1,f=!1){let g=eu(d.outShape,"int32"),h=d.strideHeight,i=d.strideWidth,j=d.dilationHeight,k=d.dilationWidth,l=d.effectiveFilterHeight,m=d.effectiveFilterWidth,n=d.padInfo.top,o=d.padInfo.left,p=eu(b,c,a);for(let a=0;a<d.batchSize;++a)for(let b=0;b<d.inChannels;++b)for(let c=0;c<d.outHeight;++c){let q=c*h-n,r=q;for(;r<0;)r+=j;let s=Math.min(d.inHeight,l+q);for(let h=0;h<d.outWidth;++h){let l=h*i-o,n=l;for(;n<0;)n+=k;let t=Math.min(d.inWidth,m+l),u=-1/0,v=-1;for(let c=r;c<s;c+=j){let g=c-q;for(let h=n;h<t;h+=k){let i=h-l,j=p.get(a,c,h,b);j>u&&(u=j,v=e?f?((a*d.inHeight+c)*d.inWidth+h)*d.inChannels+b:(c*d.inWidth+h)*d.inChannels+b:g*m+i)}}g.set(v,a,c,h,b)}}return g}function uz(a,b,c,d,e,f){let g=e.strideDepth,h=e.strideHeight,i=e.strideWidth,j=e.dilationDepth,k=e.dilationHeight,l=e.dilationWidth,m=e.effectiveFilterDepth,n=e.effectiveFilterHeight,o=e.effectiveFilterWidth,p=e.padInfo.front,q=e.padInfo.top,r=e.padInfo.left,s="max"===f?-1/0:1/0,t=eu(e.outShape,c),u=t.values,v=e.outShape[1]*e.outShape[2]*e.outShape[3]*e.outShape[4],w=e.outShape[2]*e.outShape[3]*e.outShape[4],x=e.outShape[3]*e.outShape[4],y=e.outShape[4];for(let b=0;b<e.batchSize;++b){let c=b*v,t=b*d[0];for(let b=0;b<e.inChannels;++b)for(let v=0;v<e.outDepth;++v){let z=v*g-p,A=z;for(;A<0;)A+=j;let B=Math.min(e.inDepth,m+z),C=c+v*w;for(let c=0;c<e.outHeight;++c){let g=c*h-q,m=g;for(;m<0;)m+=k;let p=Math.min(e.inHeight,n+g),v=C+c*x;for(let c=0;c<e.outWidth;++c){let g=c*i-r,h=g;for(;h<0;)h+=l;let n=Math.min(e.inWidth,o+g),q=v+c*y,w=s,x=0,z=0;for(let c=A;c<B;c+=j){let e=t+c*d[1];for(let c=m;c<p;c+=k){let g=e+c*d[2];for(let c=h;c<n;c+=l){let e=a[g+c*d[3]+b];if("max"===f&&e>w?w=e:"avg"===f&&(x+=e,z++),isNaN(w))break}if(isNaN(w))break}if(isNaN(w))break}u[q+b]="avg"===f?x/Math.max(z,1):w}}}}return t}var hp=hp,iV=iV,hp=hp,hp=hp,iV=iV,hp=hp,hp=hp;let uA=s1(aU,(a,b)=>a>b.clipValueMax?b.clipValueMax:a<b.clipValueMin?b.clipValueMin:a);var iV=iV,hp=hp,iV=iV;function uB(a){let{inputs:b,backend:c}=a,{input:d}=b,e=c.data.get(d.dataId).complexTensorInfos.imag,f=c.data.get(e.dataId).values;return c.makeTensorInfo(e.shape,e.dtype,f)}function uC(a){let{inputs:b,backend:c,attrs:d}=a,{axis:e}=d,f=iV.parseAxisParam(e,b[0].shape)[0],g=b.map(a=>a.shape);hp.assertParamsConsistent(g,f);let h=hp.computeOutShape(b.map(a=>a.shape),f);if(0===iV.sizeFromShape(h))return c.makeTensorInfo(h,b[0].dtype,[]);let i=b.filter(a=>iV.sizeFromShape(a.shape)>0);if(1===i.length)return sQ({inputs:{x:i[0]},backend:c});if("complex64"===i[0].dtype){let a=i.map(a=>sR({inputs:{input:a},backend:c})),b=i.map(a=>uB({inputs:{input:a},backend:c})),d=uC({inputs:a,backend:c,attrs:{axis:f}}),e=uC({inputs:b,backend:c,attrs:{axis:f}}),g=sO({inputs:{real:d,imag:e},backend:c});return a.forEach(a=>c.disposeIntermediateTensorInfo(a)),b.forEach(a=>c.disposeIntermediateTensorInfo(a)),c.disposeIntermediateTensorInfo(d),c.disposeIntermediateTensorInfo(e),g}let j=i.map(a=>{let b=iV.sizeFromShape(a.shape.slice(f));return uo({inputs:{x:a},backend:c,attrs:{shape:[-1,b]}})}),k=j.map(a=>({vals:c.data.get(a.dataId).values,shape:a.shape}));h=hp.computeOutShape(j.map(a=>a.shape),1);let l=1===j[0].shape[0],m=s5(k,h,b[0].dtype,l),n=hp.computeOutShape(i.map(a=>a.shape),f),o=c.makeTensorInfo(n,b[0].dtype,m);return j.forEach(a=>c.disposeIntermediateTensorInfo(a)),o}var hp=hp,iV=iV;function uD(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,filter:f}=b,{strides:g,pad:h,dataFormat:i,dilations:j,dimRoundingMode:k}=d;sJ([e,f],"conv2d");let l=hp.convertConv2DDataFormat(i),m=hp.computeConv2DInfo(e.shape,f.shape,g,j,h,k,!1,l),n=m.filterHeight,o=m.filterWidth,p=m.dilationHeight,q=m.dilationWidth,r=m.padInfo.left,s=m.padInfo.top,t="channelsLast"===m.dataFormat,u=new dh(m.outShape,e.dtype),v=iV.computeStrides(e.shape),w=iV.computeStrides(f.shape),x=v[0],y=t?v[1]:v[2],z=t?v[2]:1,A=t?1:v[1],B=u.strides[0],C=t?u.strides[1]:u.strides[2],D=t?u.strides[2]:1,E=t?1:u.strides[1],F=c.data.get(e.dataId).values,G=c.data.get(f.dataId).values,H=u.values;for(let a=0;a<m.batchSize;++a){let b=a*x,c=a*B;for(let a=0;a<m.outHeight;++a){let d=c+a*C,e=a*m.strideHeight-s;for(let a=0;a<n;++a){let c=e+a*p;if(c<0||c>=m.inHeight)continue;let f=a*w[0],g=b+c*y;for(let a=0;a<m.outWidth;++a){let b=d+a*D,c=a*m.strideWidth-r;for(let a=0;a<o;++a){let d=c+a*q;if(d<0||d>=m.inWidth)continue;let e=f+a*w[1],h=g+d*z,i=e;for(let a=0;a<m.inChannels;++a){let c=F[h+a*A];for(let a=0;a<m.outChannels;++a)H[b+a*E]+=c*G[i+a];i+=m.outChannels}}}}}}return c.makeTensorInfo(u.shape,u.dtype,H)}var hp=hp,hp=hp,iV=iV,hp=hp,iV=iV,hp=hp,iV=iV,hp=hp,iV=iV;let uE=s1("Cos",a=>Math.cos(a)),uF=s1(a2,a=>Math.cosh(a));var iV=iV,hp=hp,iV=iV,hp=hp,iV=iV,iV=iV,hp=hp,iV=iV;function uG(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,filter:f}=b,{strides:g,pad:h,dilations:i,dimRoundingMode:j}=d;sJ([e,f],"depthwiseConv2DNative");let k=iV.computeStrides(e.shape),l=iV.computeStrides(f.shape),m=i;null==m&&(m=[1,1]),iV.assert(hp.eitherStridesOrDilationsAreOne(g,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${g} and dilations '${m}'`);let n=hp.computeConv2DInfo(e.shape,f.shape,g,m,h,j,!0),{filterHeight:o,filterWidth:p,dilationHeight:q,dilationWidth:r,padInfo:s}=n,t=s.left,u=s.top,v=n.outChannels/n.inChannels,w=new dh(n.outShape,e.dtype),x=c.data.get(e.dataId).values,y=c.data.get(f.dataId).values,z=w.values;for(let a=0;a<n.batchSize;++a){let b=a*k[0],c=a*w.strides[0];for(let a=0;a<n.outHeight;++a){let d=c+a*w.strides[1],e=a*n.strideHeight-u;for(let a=0;a<o;++a){let c=e+a*q;if(c<0||c>=n.inHeight)continue;let f=a*l[0],g=b+c*k[1];for(let a=0;a<n.outWidth;++a){let b=d+a*w.strides[2],c=a*n.strideWidth-t;for(let a=0;a<p;++a){let d=c+a*r;if(d<0||d>=n.inWidth)continue;let e=f+a*l[1],h=g+d*n.inChannels,i=b,j=e;for(let a=0;a<n.inChannels;++a){let b=x[h+a];for(let a=0;a<v;++a)z[i+a]+=b*y[j+a];i+=v,j+=v}}}}}}return c.makeTensorInfo(w.shape,w.dtype,w.values)}var hp=hp,hp=hp,iV=iV,iV=iV,hp=hp,iV=iV,hp=hp,iV=iV,hp=hp,iV=iV,hp=hp,iV=iV,hp=hp,iV=iV;function uH(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f}=c,{axis:g,keepDims:h}=e;sJ(f,"sum");let i=(b="bool"===f.dtype?sT({inputs:{x:f},backend:d,attrs:{dtype:"int32"}}):sQ({inputs:{x:f},backend:d})).shape.length,j=iV.parseAxisParam(g,b.shape),k=hp.getAxesPermutation(j,i),l=j,m=b;null!=k&&(m=tE({inputs:{x:b},backend:d,attrs:{perm:k}}),l=hp.getInnerMostAxes(l.length,i)),hp.assertAxesAreInnerMostDims("sum",l,m.shape.length);let[n,o]=hp.computeOutAndReduceShapes(m.shape,l),p=sP(d,n,hp.upcastType(m.dtype,"int32")),q=iV.sizeFromShape(o),r=d.data.get(p.dataId).values,s=d.data.get(m.dataId).values;for(let a=0;a<r.length;++a){let b=a*q,c=0;for(let a=0;a<q;++a)c+=s[b+a];r[a]=c}if(h){let a=hp.expandShapeToKeepDim(p.shape,j),b=p;p=uo({inputs:{x:p},backend:d,attrs:{shape:a}}),d.disposeIntermediateTensorInfo(b)}return d.disposeIntermediateTensorInfo(b),null!=k&&d.disposeIntermediateTensorInfo(m),p}var iV=iV,hp=hp;let uI=hp.ERF_P,uJ=hp.ERF_A1,uK=hp.ERF_A2,uL=hp.ERF_A3,uM=hp.ERF_A4,uN=hp.ERF_A5,uO=s1("Erf",a=>{let b=Math.sign(a),c=Math.abs(a),d=1/(1+uI*c);return b*(1-((((uN*d+uM)*d+uL)*d+uK)*d+uJ)*d*Math.exp(-c*c))});var iV=iV;function uP(a){let{inputs:b,backend:c,attrs:d}=a,{input:e}=b,{dim:f}=d,g=e.shape.length,h=e.shape.slice(),i=f;return f<0&&(iV.assert(-(g+1)<=f,()=>`Axis must be in the interval [${-(g+1)}, ${g}]`),i=g+f+1),h.splice(i,0,1),uo({inputs:{x:e},backend:c,attrs:{shape:h}})}var iV=iV,hp=hp,iV=iV;let uQ=sU(bg,sN((a,b)=>a/b)),uR={kernelName:bg,backendName:"cpu",kernelFunc:uQ};function uS(a,b,c){let d=a.shape,e=d[0],f=d[1],g=c.data.get(a.dataId),h=g.complexTensorInfos.real,i=g.complexTensorInfos.imag,j=[e,f],k=iV.sizeFromShape(j),l=iV.getTypedArrayFromDType("float32",k),m=iV.getTypedArrayFromDType("float32",k);for(let a=0;a<e;a++){let d=tW({inputs:{x:h},backend:c,attrs:{begin:[a,0],size:[1,f]}}),e=tW({inputs:{x:i},backend:c,attrs:{begin:[a,0],size:[1,f]}}),g=sO({inputs:{real:d,imag:e},backend:c}),{real:j,imag:k}=function(a,b,c){var d;let e=iV.sizeFromShape(a.shape),f=c.data.get(a.dataId),g=c.data.get(f.complexTensorInfos.real.dataId).values,h=c.data.get(f.complexTensorInfos.imag.dataId).values;if(((d=e)&d-1)==0){let d=function a(b,c,d,e,f){if(1===d)return{real:b,imag:c};let g=hp.mergeRealAndImagArrays(b,c),h=d/2,i=hp.complexWithEvenIndex(g),j=i.real,k=i.imag,l=[j.length],m=f.makeTensorInfo(l,"float32",j),n=f.makeTensorInfo(l,"float32",k),o=sO({inputs:{real:m,imag:n},backend:f}),p=hp.complexWithOddIndex(g),q=p.real,r=p.imag,s=[q.length],t=f.makeTensorInfo(s,"float32",q),u=f.makeTensorInfo(s,"float32",r),v=sO({inputs:{real:t,imag:u},backend:f}),w=a(j,k,h,e,f),x=w.real,y=w.imag,z=[x.length],A=f.makeTensorInfo(z,"float32",x),B=f.makeTensorInfo(z,"float32",y),C=sO({inputs:{real:A,imag:B},backend:f}),D=a(q,r,h,e,f),E=D.real,F=D.imag,G=[E.length],H=f.makeTensorInfo(G,"float32",E),I=f.makeTensorInfo(G,"float32",F),J=sO({inputs:{real:H,imag:I},backend:f}),K=hp.exponents(d,e),L=[K.real.length],M=f.makeTensorInfo(L,"float32",K.real),N=f.makeTensorInfo(L,"float32",K.imag),O=sO({inputs:{real:M,imag:N},backend:f}),P=tz({inputs:{a:O,b:J},backend:f}),Q=sX({inputs:{a:C,b:P},backend:f}),R=ua({inputs:{a:C,b:P},backend:f}),S=sR({inputs:{input:Q},backend:f}),T=sR({inputs:{input:R},backend:f}),U=uB({inputs:{input:Q},backend:f}),V=uB({inputs:{input:R},backend:f}),W=uC({inputs:[S,T],backend:f,attrs:{axis:0}}),X=uC({inputs:[U,V],backend:f,attrs:{axis:0}}),Y=f.data.get(W.dataId).values,Z=f.data.get(X.dataId).values;return f.disposeIntermediateTensorInfo(m),f.disposeIntermediateTensorInfo(n),f.disposeIntermediateTensorInfo(o),f.disposeIntermediateTensorInfo(t),f.disposeIntermediateTensorInfo(u),f.disposeIntermediateTensorInfo(v),f.disposeIntermediateTensorInfo(A),f.disposeIntermediateTensorInfo(B),f.disposeIntermediateTensorInfo(C),f.disposeIntermediateTensorInfo(H),f.disposeIntermediateTensorInfo(I),f.disposeIntermediateTensorInfo(J),f.disposeIntermediateTensorInfo(M),f.disposeIntermediateTensorInfo(N),f.disposeIntermediateTensorInfo(O),f.disposeIntermediateTensorInfo(P),f.disposeIntermediateTensorInfo(Q),f.disposeIntermediateTensorInfo(R),f.disposeIntermediateTensorInfo(S),f.disposeIntermediateTensorInfo(U),f.disposeIntermediateTensorInfo(T),f.disposeIntermediateTensorInfo(V),f.disposeIntermediateTensorInfo(W),f.disposeIntermediateTensorInfo(X),{real:Y,imag:Z}}(g,h,e,b,c),f=[a.shape[0],a.shape[1]];if(b){let a=c.makeTensorInfo(f,"float32",d.real),b=c.makeTensorInfo(f,"float32",d.imag),g=c.makeTensorInfo([],"float32",iV.createScalarValue(e,"float32")),h=sQ({inputs:{x:g},backend:c}),i=uR.kernelFunc({inputs:{a:a,b:g},backend:c}),j=uR.kernelFunc({inputs:{a:b,b:h},backend:c}),k=c.data.get(i.dataId).values,l=c.data.get(j.dataId).values;return c.disposeIntermediateTensorInfo(a),c.disposeIntermediateTensorInfo(b),c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(h),c.disposeIntermediateTensorInfo(i),c.disposeIntermediateTensorInfo(j),{real:k,imag:l}}return d}{let a=function(a,b,c){let d=new Float32Array(2*b);for(let e=0;e<b;e++){let f=0,g=0;for(let d=0;d<b;d++){let h=hp.exponent(e*d,b,c),i=hp.getComplexWithIndex(a,d);f+=i.real*h.real-i.imag*h.imag,g+=i.real*h.imag+i.imag*h.real}c&&(f/=b,g/=b),hp.assignToTypedArray(d,f,g,e)}return d}(hp.mergeRealAndImagArrays(g,h),e,b);return hp.splitRealAndImagArrays(a)}}(g,b,c),n=hp.mergeRealAndImagArrays(j,k);for(let b=0;b<f;b++){let c=hp.getComplexWithIndex(n,b);l[a*f+b]=c.real,m[a*f+b]=c.imag}c.disposeIntermediateTensorInfo(d),c.disposeIntermediateTensorInfo(e),c.disposeIntermediateTensorInfo(g)}let n=c.makeTensorInfo(j,"float32",l),o=c.makeTensorInfo(j,"float32",m),p=sO({inputs:{real:n,imag:o},backend:c});return c.disposeIntermediateTensorInfo(n),c.disposeIntermediateTensorInfo(o),p}var iV=iV;function uT(a){var b,c;let{backend:d,attrs:e}=a,{shape:f,value:g,dtype:h}=e,i=h||iV.inferDtype(g),j=iV.getArrayFromDType(i,iV.sizeFromShape(f));return b=j,c=g,b.fill(c),d.makeTensorInfo(f,i,j)}var iV=iV,hp=hp,iV=iV,hp=hp,iV=iV,iV=iV;let uU=s1(by,a=>+!!Number.isFinite(a),"bool"),uV=s1(bz,a=>+(Math.abs(a)===1/0),"bool"),uW=s1(bA,a=>+!!Number.isNaN(a),"bool"),uX=s1(bF,a=>Math.log1p(a)),uY=sU(bG,sN((a,b)=>a&&b),null,"bool"),uZ=s1(bH,a=>+!a,"bool"),u$=sU(bI,sN((a,b)=>a||b),null,"bool");var iV=iV,iV=iV,hp=hp,iV=iV;function u_(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{reductionIndices:f,keepDims:g}=d,h=e.shape,i=h.length,j=iV.parseAxisParam(f,h),k=j,l=hp.getAxesPermutation(k,i),m=c.data.get(e.dataId).values;if(null!=l){let a=Array(i);for(let b=0;b<a.length;b++)a[b]=h[l[b]];m=tD(m,h,e.dtype,l,a),k=hp.getInnerMostAxes(k.length,i),h=a}sJ(e,"max"),hp.assertAxesAreInnerMostDims("max",k,i);let[n,o]=hp.computeOutAndReduceShapes(h,k),p=tt(m,iV.sizeFromShape(o),n,e.dtype),q=c.write(p,n,e.dtype),r=n;return g&&(r=hp.expandShapeToKeepDim(n,j)),{dataId:q,shape:r,dtype:e.dtype}}var hp=hp,iV=iV,hp=hp,iV=iV,hp=hp,hp=hp,hp=hp,iV=iV,hp=hp,iV=iV,hp=hp,iV=iV,iV=iV;let u0=sU("Mod",sN((a,b)=>{let c=a%b;return a<0&&b<0||a>=0&&b>=0?c:(c+b)%b}));var iV=iV,hp=hp,iV=iV;function u1(a){let{inputs:b,backend:c,attrs:d}=a,{logits:e}=b,{dim:f}=d,g=e.shape.length,h=f;if(-1===h&&(h=g-1),h!==g-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${g} and dim was ${h}`);let i=iV.parseAxisParam([h],e.shape),j=u_({inputs:{x:e},backend:c,attrs:{reductionIndices:i,keepDims:!1}}),k=hp.expandShapeToKeepDim(j.shape,i),l=uo({inputs:{x:j},backend:c,attrs:{shape:k}}),m=ua({inputs:{a:e,b:l},backend:c}),n=s9({inputs:{x:m},backend:c}),o=uH({inputs:{x:n},backend:c,attrs:{axis:i,keepDims:!1}}),p=uo({inputs:{x:o},backend:c,attrs:{shape:k}}),q=uQ({inputs:{a:n,b:p},backend:c});return c.disposeIntermediateTensorInfo(j),c.disposeIntermediateTensorInfo(l),c.disposeIntermediateTensorInfo(m),c.disposeIntermediateTensorInfo(n),c.disposeIntermediateTensorInfo(o),c.disposeIntermediateTensorInfo(p),q}var sI=sI;let u2=sI.nonMaxSuppressionV3Impl;var sI=sI;let u3=sI.nonMaxSuppressionV4Impl;var sI=sI;let u4=sI.nonMaxSuppressionV5Impl;var iV=iV;function u5(a){let{inputs:b,backend:c}=a,{x:d}=b;if("string"===d.dtype)throw Error("zerosLike is not supported for string tensors");if("complex64"!==d.dtype)return uT({backend:c,attrs:{shape:d.shape,value:0,dtype:d.dtype}});{let a=sR({inputs:{input:d},backend:c}),b=u5({inputs:{x:a},backend:c}),e=uB({inputs:{input:d},backend:c}),f=u5({inputs:{x:e},backend:c}),g=sO({inputs:{real:b,imag:f},backend:c});return c.disposeIntermediateTensorInfo(a),c.disposeIntermediateTensorInfo(b),c.disposeIntermediateTensorInfo(e),c.disposeIntermediateTensorInfo(f),g}}var iV=iV;function u6(a){let{inputs:b,backend:c,attrs:d}=a,{axis:e}=d;if(1===b.length)return uP({inputs:{input:b[0]},backend:c,attrs:{dim:e}});let f=b[0].shape,g=b[0].dtype;b.forEach(a=>{iV.assertShapesMatch(f,a.shape,"All tensors passed to stack must have matching shapes"),iV.assert(g===a.dtype,()=>"All tensors passed to stack must have matching dtypes")});let h=[],i=uC({inputs:b.map(a=>{let b=uP({inputs:{input:a},backend:c,attrs:{dim:e}});return h.push(b),b}),backend:c,attrs:{axis:e}});return h.forEach(a=>c.disposeIntermediateTensorInfo(a)),i}var iV=iV;let u7={kernelName:b0,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{paddings:f,constantValue:g}=d;sJ(e,"pad");let h=f.map((a,b)=>a[0]+e.shape[b]+a[1]),i=f.map(a=>a[0]),j=c.data.get(e.dataId).values,k=iV.sizeFromShape(e.shape),l=e.shape.length,m=iV.computeStrides(e.shape),n=iV.sizeFromShape(h),o=h.length,p=iV.computeStrides(h),q=iV.getTypedArrayFromDType(e.dtype,n);0!==g&&q.fill(g);for(let a=0;a<k;a++){let b=iV.indexToLoc(a,l,m).map((a,b)=>a+i[b]);q[iV.locToIndex(b,o,p)]=j[a]}return{dataId:c.write(q,h,e.dtype),shape:h,dtype:e.dtype}}},u8=sU("Pow",sN((a,b)=>Math.pow(a,b))),u9=s1(b8,a=>1/a);var iV=iV,iV=iV,iV=iV,iV=iV,iV=iV,hp=hp,iV=iV;let va=s1(ch,a=>{let b=Math.floor(a);return a-b<.5?Math.floor(a):a-b>.5?Math.ceil(a):b%2==0?b:b+1});var hp=hp,iV=iV,iV=iV,hp=hp;let vb=hp.SELU_SCALEALPHA,vc=hp.SELU_SCALE,vd=s1(cn,a=>a>=0?vc*a:vb*(Math.exp(a)-1)),ve=s1(cq,a=>a<0?-1:+(a>0)),vf=s1("Sin",a=>Math.sin(a)),vg=s1(cp,a=>Math.sinh(a)),vh=Math.log(11920928955078125e-23)+2,vi=s1(cs,a=>{let b=Math.exp(a);return a<vh?b:a>-vh?a:Math.log(1+b)});var hp=hp,iV=iV,hp=hp,iV=iV,hp=hp,iV=iV;let vj=s1(cS,(a,b)=>isNaN(a)?NaN:a>0?1:b.alpha);var tU=gr,iV=iV;let vk=s1("Tan",a=>Math.tan(a)),vl=s1(cJ,a=>Math.tanh(a));var hp=hp,iV=iV;function vm(a,b,c){switch(c){case"reflect":var d,e,f,g,h=a,i=b;let j=h;if(j<0)if(i<=1)j=0;else{let a=2*i;j<a&&(j=a*Math.trunc(-j/a)+j),j=j<-i?j+a:-j-1}else if(j>i-1)if(i<=1)j=0;else{let a=2*i;(j-=a*Math.trunc(j/a))>=i&&(j=a-j-1)}return iV.clamp(0,j,i-1);case"wrap":let k;return d=a,e=b,(k=d)<0?e<=1?k=0:k+=e*(Math.trunc(-k/(e-1))+1):k>e-1&&(e<=1?k=0:k-=e*Math.trunc(k/(e-1))),iV.clamp(0,k,e-1);case"nearest":return f=a,g=b,iV.clamp(0,f,g-1);default:return a}}function vn(a,b,c,d,e,f,g,h,i,j,k){return 0<=h&&h<b&&0<=i&&i<c?a[g*d+h*e+i*f+j]:k}var iV=iV;for(let a of[{kernelName:cV,backendName:"cpu",kernelFunc:function(a){let b,c,d,{inputs:e,backend:f,attrs:g}=a,{a:h,b:i,bias:j,preluActivationWeights:k}=e,{transposeA:l,transposeB:m,activation:n,leakyreluAlpha:o}=g,p=[];for(let a of(b=up({inputs:{a:h,b:i},attrs:{transposeA:l,transposeB:m},backend:f}),j&&(c=sX({inputs:{a:b,b:j},backend:f}),p.push(b),b=c),n&&(d=um(f,b,n,k,o),p.push(b),b=d),p))f.disposeIntermediateTensorInfo(a);return b}},{kernelName:"Abs",backendName:"cpu",kernelFunc:a=>{let{x:b}=a.inputs,c=a.backend;sJ(b,"abs");let d=new Float32Array(iV.sizeFromShape(b.shape));return d=sM(c.data.get(b.dataId).values),c.makeOutput(d,b.shape,b.dtype)}},{kernelName:az,backendName:"cpu",kernelFunc:uq},{kernelName:aA,backendName:"cpu",kernelFunc:ur},{kernelName:"Add",backendName:"cpu",kernelFunc:sX},{kernelName:aB,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c}=a;sJ(b,"addN");let d=b.map(a=>c.data.get(a.dataId).values),e=eu(b[0].shape,b[0].dtype),f=e.values;for(let a=0;a<b.length;a++){let b=d[a];for(let a=0;a<f.length;a++)f[a]+=b[a]}return c.makeTensorInfo(e.shape,e.dtype,e.values)}},{kernelName:"All",backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{axis:f,keepDims:g}=d;sJ(e,"all");let h=iV.parseAxisParam(f,e.shape),i=h,j=hp.getAxesPermutation(i,e.shape.length),k=e;null!=j&&(k=tE({inputs:{x:e},backend:c,attrs:{perm:j}}),i=hp.getInnerMostAxes(i.length,e.shape.length)),hp.assertAxesAreInnerMostDims("all",i,k.shape.length);let[l,m]=hp.computeOutAndReduceShapes(k.shape,i),n=iV.sizeFromShape(m),o=iV.makeZerosTypedArray(iV.sizeFromShape(l),k.dtype),p=c.data.get(k.dataId).values;for(let a=0;a<o.length;++a){let b=a*n,c=p[b];for(let a=0;a<n;++a){let d=p[b+a];c=c&&d}o[a]=c}null!=j&&c.disposeIntermediateTensorInfo(k);let q=c.makeTensorInfo(l,k.dtype,o);if(g){let a=uo({inputs:{x:q},backend:c,attrs:{shape:hp.expandShapeToKeepDim(l,h)}});return c.disposeIntermediateTensorInfo(q),a}return q}},{kernelName:"Any",backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{axis:f,keepDims:g}=d;sJ(e,"any");let h=iV.parseAxisParam(f,e.shape),i=h,j=hp.getAxesPermutation(i,e.shape.length),k=e;null!=j&&(k=tE({inputs:{x:e},backend:c,attrs:{perm:j}}),i=hp.getInnerMostAxes(i.length,e.shape.length)),hp.assertAxesAreInnerMostDims("any",i,k.shape.length);let[l,m]=hp.computeOutAndReduceShapes(k.shape,i),n=iV.sizeFromShape(m),o=iV.makeZerosTypedArray(iV.sizeFromShape(l),k.dtype),p=c.data.get(k.dataId).values;for(let a=0;a<o.length;++a){let b=a*n,c=p[b];for(let a=0;a<n;++a){let d=p[b+a];c=c||d}o[a]=c}null!=j&&c.disposeIntermediateTensorInfo(k);let q=c.makeTensorInfo(l,k.dtype,o);if(g){let a=uo({inputs:{x:q},backend:c,attrs:{shape:hp.expandShapeToKeepDim(l,h)}});return c.disposeIntermediateTensorInfo(q),a}return q}},{kernelName:aC,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{axis:f}=d;sJ(e,"argMax");let g=iV.parseAxisParam(f,e.shape),h=hp.getAxesPermutation(g,e.shape.length),i=e,j=[];null!=h&&(j.push(i=tE({inputs:{x:e},backend:c,attrs:{perm:h}})),g=hp.getInnerMostAxes(g.length,i.shape.length)),g=[g[0]],hp.assertAxesAreInnerMostDims("argMax",g,i.shape.length);let[k,l]=hp.computeOutAndReduceShapes(i.shape,g),m=iV.sizeFromShape(k),n=iV.makeZerosTypedArray(m,"int32"),o=iV.sizeFromShape(l),p=c.data.get(i.dataId).values;for(let a=0;a<n.length;++a){let b=a*o,c=p[b],d=0;for(let a=0;a<o;++a){let e=p[b+a];e>c&&(c=e,d=a)}n[a]=d}return j.forEach(a=>c.disposeIntermediateTensorInfo(a)),c.makeTensorInfo(k,"int32",n)}},{kernelName:aD,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{axis:f}=d;sJ(e,"argMin");let g=iV.parseAxisParam(f,e.shape),h=hp.getAxesPermutation(g,e.shape.length),i=e,j=[];null!=h&&(j.push(i=tE({inputs:{x:e},backend:c,attrs:{perm:h}})),g=hp.getInnerMostAxes(g.length,i.shape.length)),g=[g[0]],hp.assertAxesAreInnerMostDims("argMin",g,i.shape.length);let[k,l]=hp.computeOutAndReduceShapes(i.shape,g),m=iV.sizeFromShape(k),n=iV.makeZerosTypedArray(m,"int32"),o=iV.sizeFromShape(l),p=c.data.get(i.dataId).values;for(let a=0;a<n.length;++a){let b=a*o,c=p[b],d=0;for(let a=0;a<o;++a){let e=p[b+a];e<c&&(c=e,d=a)}n[a]=d}return j.forEach(a=>c.disposeIntermediateTensorInfo(a)),c.makeTensorInfo(k,"int32",n)}},{kernelName:aE,backendName:"cpu",kernelFunc:us},{kernelName:aF,backendName:"cpu",kernelFunc:ut},{kernelName:aG,backendName:"cpu",kernelFunc:uu},{kernelName:aI,backendName:"cpu",kernelFunc:uv},{kernelName:aH,backendName:"cpu",kernelFunc:uw},{kernelName:aJ,backendName:"cpu",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f}=c;sJ(f,"avgPool");let{filterSize:g,strides:h,pad:i,dimRoundingMode:j}=e;iV.assert(hp.eitherStridesOrDilationsAreOne(h,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${h} and dilations '1'`);let k=hp.computePool2DInfo(f.shape,g,h,1,i,j);if(1===k.filterWidth&&1===k.filterHeight&&iV.arraysEqual(k.inShape,k.outShape))b=sQ({inputs:{x:f},backend:d});else{let a=d.data.get(f.dataId).values,c=iV.computeStrides(f.shape),e=ux(a,f.shape,f.dtype,c,k,"avg");b=d.makeTensorInfo(k.outShape,f.dtype,e.values)}return b}},{kernelName:aL,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{filterSize:f,strides:g,pad:h,dimRoundingMode:i,dataFormat:j}=d;sJ(e,"avgPool3d");let k=hp.computePool3DInfo(e.shape,f,g,1,h,i,j),l=uz(c.data.get(e.dataId).values,e.shape,e.dtype,iV.computeStrides(e.shape),k,"avg");return c.makeTensorInfo(l.shape,"float32",l.values)}},{kernelName:aM,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{dy:e,input:f}=b,{filterSize:g,strides:h,pad:i,dimRoundingMode:j}=d;sJ([e,f],"avgPool3DGrad");let k=hp.computePool3DInfo(f.shape,g,h,1,i,j),l=k.strideDepth,m=k.strideHeight,n=k.strideWidth,o=k.filterDepth,p=k.filterHeight,q=k.filterWidth,r=k.dilationDepth,s=k.dilationHeight,t=k.dilationWidth,u=k.effectiveFilterDepth,v=k.effectiveFilterHeight,w=k.effectiveFilterWidth,x=u-1-k.padInfo.front,y=w-1-k.padInfo.left,z=v-1-k.padInfo.top,A=eu(f.shape,"float32"),B=1/(o*p*q),C=c.bufferSync(e);for(let a=0;a<k.batchSize;++a)for(let b=0;b<k.inChannels;++b)for(let c=0;c<k.inDepth;++c)for(let d=0;d<k.inHeight;++d)for(let e=0;e<k.inWidth;++e){let f=c-x,g=d-z,h=e-y,i=0;for(let c=0;c<u;c+=r){let d=(f+c)/l;if(!(d<0)&&!(d>=k.outDepth)&&Math.floor(d)===d)for(let c=0;c<v;c+=s){let e=(g+c)/m;if(!(e<0)&&!(e>=k.outHeight)&&Math.floor(e)===e)for(let c=0;c<w;c+=t){let f=(h+c)/n;f<0||f>=k.outWidth||Math.floor(f)!==f||(i+=C.get(a,d,e,f,b))}}}A.set(i*B,a,c,d,e,b)}return c.makeTensorInfo(A.shape,A.dtype,A.values)}},{kernelName:aK,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{dy:e,input:f}=b;sJ([e,f],"avgPoolGrad");let{filterSize:g,strides:h,pad:i}=d,j=hp.computePool2DInfo(f.shape,g,h,1,i),k=j.strideHeight,l=j.strideWidth,m=j.filterHeight,n=j.filterWidth,o=j.dilationHeight,p=j.dilationWidth,q=j.effectiveFilterHeight,r=j.effectiveFilterWidth,s=r-1-j.padInfo.left,t=q-1-j.padInfo.top,u=eu(f.shape,"float32"),v=1/(m*n),w=c.data.get(e.dataId).values,x=eu(e.shape,"float32",w);for(let a=0;a<j.batchSize;++a)for(let b=0;b<j.inChannels;++b)for(let c=0;c<j.inHeight;++c)for(let d=0;d<j.inWidth;++d){let e=c-t,f=d-s,g=0;for(let c=0;c<q;c+=o){let d=(e+c)/k;if(!(d<0)&&!(d>=j.outHeight)&&Math.floor(d)===d)for(let c=0;c<r;c+=p){let e=(f+c)/l;e<0||e>=j.outWidth||Math.floor(e)!==e||(g+=x.get(a,d,e,b))}}u.set(g*v,a,c,d,b)}return c.makeTensorInfo(u.shape,u.dtype,u.values)}},{kernelName:aN,backendName:"cpu",kernelFunc:up},{kernelName:bq,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,scale:f,offset:g,mean:h,variance:i}=b;iV.assert(h.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),iV.assert(null==g||h.shape.length===g.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),iV.assert(null==f||h.shape.length===f.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),sJ([e,h,i,f,g],"batchNorm");let{varianceEpsilon:j}=d;null==j&&(j=.001);let k=c.data.get(e.dataId).values,l=c.data.get(h.dataId).values,m=c.data.get(i.dataId).values,n=f?c.data.get(f.dataId).values:new Float32Array([1]),o=g?c.data.get(g.dataId).values:new Float32Array([0]),p=new Float32Array(k.length),q=o.length,r=n.length,s=m.length,t=l.length,u=0,v=0,w=0,x=0;for(let a=0;a<k.length;++a)p[a]=o[u++]+(k[a]-l[v++])*n[w++]/Math.sqrt(m[x++]+j),u>=q&&(u=0),v>=t&&(v=0),w>=r&&(w=0),x>=s&&(x=0);return c.makeTensorInfo(e.shape,e.dtype,p)}},{kernelName:aO,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{blockShape:f,crops:g}=d;sJ([e],"batchToSpaceND");let h=f.reduce((a,b)=>a*b),i=hp.getReshaped(e.shape,f,h),j=hp.getPermuted(i.length,f.length),k=hp.getReshapedPermuted(e.shape,f,h),l=hp.getSliceBeginCoords(g,f.length),m=hp.getSliceSize(k,g,f.length),n=uo({inputs:{x:e},backend:c,attrs:{shape:i}}),o=tE({inputs:{x:n},backend:c,attrs:{perm:j}}),p=uo({inputs:{x:o},backend:c,attrs:{shape:k}}),q=tW({inputs:{x:p},backend:c,attrs:{begin:l,size:m}});return c.disposeIntermediateTensorInfo(n),c.disposeIntermediateTensorInfo(o),c.disposeIntermediateTensorInfo(p),q}},{kernelName:aP,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,weights:f}=b,{size:g}=d,h=sY(c.data.get(e.dataId).values,c.data.get(f.dataId).values,f.dtype,f.shape,g);return c.makeTensorInfo([g],f.dtype,h)}},{kernelName:aQ,backendName:"cpu",kernelFunc:s_},{kernelName:aR,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c}=a,{s0:d,s1:e}=b,f=c.data.get(d.dataId).values,g=c.data.get(e.dataId).values,h=hp.assertAndGetBroadcastShape(Array.from(f),Array.from(g));return c.makeTensorInfo([h.length],"int32",Int32Array.from(h))}},{kernelName:aS,backendName:"cpu",kernelFunc:sT},{kernelName:aT,backendName:"cpu",kernelFunc:s4},{kernelName:aU,backendName:"cpu",kernelFunc:uA},{kernelName:aV,backendName:"cpu",kernelFunc:sO},{kernelName:aW,backendName:"cpu",kernelFunc:a=>{let{x:b}=a.inputs,c=a.backend,d=new Float32Array(iV.sizeFromShape(b.shape)),e=c.data.get(b.dataId),f=e.complexTensorInfos.real,g=e.complexTensorInfos.imag,h=c.data.get(f.dataId).values,i=c.data.get(g.dataId).values;for(let a=0;a<h.length;a++){let b=h[a],c=i[a];d[a]=Math.hypot(b,c)}return c.makeOutput(d,b.shape,"float32")}},{kernelName:aX,backendName:"cpu",kernelFunc:uC},{kernelName:aY,backendName:"cpu",kernelFunc:uD},{kernelName:aZ,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,dy:f}=b,{strides:g,pad:h,dataFormat:i,dimRoundingMode:j,filterShape:k}=d;sJ([e,f],"conv2dBackpropFilter");let l=hp.convertConv2DDataFormat(i),m=hp.computeConv2DInfo(e.shape,k,g,1,h,j,!1,l),{strideHeight:n,strideWidth:o,filterHeight:p,filterWidth:q}=m,r="channelsLast"===m.dataFormat,s=new dh(m.filterShape,"float32"),t=m.padInfo.left,u=m.padInfo.top,v=c.data.get(e.dataId).values,w=c.data.get(f.dataId).values,x=new dh(e.shape,e.dtype,v),y=new dh(f.shape,f.dtype,w);for(let a=0;a<p;++a){let b=Math.max(0,Math.ceil((u-a)/n)),c=Math.min(m.outHeight,(m.inHeight+u-a)/n);for(let d=0;d<q;++d){let e=Math.max(0,Math.ceil((t-d)/o)),f=Math.min(m.outWidth,(m.inWidth+t-d)/o);for(let g=0;g<m.inChannels;++g)for(let h=0;h<m.outChannels;++h){let i=0;for(let j=0;j<m.batchSize;++j)for(let k=b;k<c;++k){let b=a+k*n-u;for(let a=e;a<f;++a){let c=d+a*o-t;r?i+=x.get(j,b,c,g)*y.get(j,k,a,h):i+=x.get(j,g,b,c)*y.get(j,h,k,a)}}s.set(i,a,d,g,h)}}}return c.makeTensorInfo(s.shape,s.dtype,s.values)}},{kernelName:a$,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{dy:e,filter:f}=b,{inputShape:g,strides:h,pad:i,dataFormat:j,dimRoundingMode:k}=d;sJ([e,f],"conv2dBackpropInput");let l=iV.computeStrides(f.shape),m=iV.computeStrides(e.shape),n=hp.convertConv2DDataFormat(j),o=hp.computeConv2DInfo(g,f.shape,h,1,i,k,!1,n),p=new dh(o.inShape,"float32"),q=p.values,r=c.data.get(e.dataId).values,s=c.data.get(f.dataId).values,[t,u,v]=l,{batchSize:w,filterHeight:x,filterWidth:y,inChannels:z,inHeight:A,inWidth:B,outChannels:C,outHeight:D,outWidth:E,strideHeight:F,strideWidth:G}=o;n=o.dataFormat;let H=x-1-o.padInfo.top,I=y-1-o.padInfo.left,J="channelsLast"===n,K=p.strides[0],L=J?p.strides[1]:p.strides[2],M=J?p.strides[2]:1,N=J?1:p.strides[1],O=m[0],P=J?m[1]:m[2],Q=J?m[2]:1,R=J?1:m[1];for(let a=0;a<w;++a)for(let b=0;b<z;++b)for(let c=0;c<A;++c){let d=c-H,e=Math.max(0,Math.ceil(d/F)),f=Math.min(D,(x+d)/F);for(let g=0;g<B;++g){let h=g-I,i=Math.max(0,Math.ceil(h/G)),j=Math.min(E,(y+h)/G),k=0;for(let c=e;c<f;++c){let e=c*F-d;for(let d=i;d<j;++d){let f=d*G-h,g=O*a+P*c+Q*d,i=t*(x-1-e)+u*(y-1-f)+v*b;for(let a=0;a<C;++a)k+=r[g+R*a]*s[i+a]}}q[K*a+L*c+M*g+N*b]=k}}return c.makeTensorInfo(p.shape,p.dtype,p.values)}},{kernelName:a_,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,filter:f}=b,{strides:g,pad:h,dilations:i}=d;sJ([e,f],"conv3d");let j=hp.computeConv3DInfo(e.shape,f.shape,g,i,h),{filterDepth:k,filterHeight:l,filterWidth:m,dilationDepth:n,dilationHeight:o,dilationWidth:p,padInfo:q}=j,r=q.front,s=q.left,t=q.top,u=new dh(j.outShape,e.dtype),v=c.data.get(e.dataId).values,w=c.data.get(f.dataId).values,x=u.values,y=iV.computeStrides(e.shape),z=iV.computeStrides(f.shape);for(let a=0;a<j.batchSize;++a){let b=a*y[0],c=a*u.strides[0];for(let a=0;a<j.outDepth;++a){let d=c+a*u.strides[1],e=a*j.strideDepth-r;for(let a=0;a<k;++a){let c=e+a*n;if(c<0||c>=j.inDepth)continue;let f=a*z[0],g=b+c*y[1];for(let a=0;a<j.outHeight;++a){let b=d+a*u.strides[2],c=a*j.strideHeight-t;for(let a=0;a<l;++a){let d=c+a*o;if(d<0||d>=j.inHeight)continue;let e=f+a*z[1],h=g+d*y[2];for(let a=0;a<j.outWidth;++a){let c=b+a*j.outChannels,d=a*j.strideWidth-s;for(let a=0;a<m;++a){let b=d+a*p;if(b<0||b>=j.inWidth)continue;let f=e+a*z[2],g=h+b*j.inChannels,i=f;for(let a=0;a<j.inChannels;++a){let b=v[g+a];for(let a=0;a<j.outChannels;++a)x[c+a]+=b*w[i+a];i+=j.outChannels}}}}}}}}return c.makeTensorInfo(u.shape,u.dtype,u.values)}},{kernelName:a0,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,dy:f}=b,{strides:g,pad:h,filterShape:i}=d;sJ([e,f],"conv3dBackpropFilterV2");let j=iV.computeStrides(e.shape),k=iV.computeStrides(f.shape),l=hp.computeConv3DInfo(e.shape,i,g,1,h),m=l.strideDepth,n=l.strideHeight,o=l.strideWidth,p=l.filterDepth,q=l.filterHeight,r=l.filterWidth,s=new dh(l.filterShape,"float32"),t=s.values,[u,v,w,x]=s.strides,y=c.data.get(f.dataId).values,[z,A,B,C]=k,D=c.data.get(e.dataId).values,[E,F,G,H]=j,I=l.padInfo.front,J=l.padInfo.left,K=l.padInfo.top;for(let a=0;a<p;++a){let b=Math.max(0,Math.ceil((I-a)/m)),c=Math.min(l.outDepth,(l.inDepth+I-a)/m),d=a*u;for(let e=0;e<q;++e){let f=Math.max(0,Math.ceil((K-e)/n)),g=Math.min(l.outHeight,(l.inHeight+K-e)/n),h=e*v+d;for(let d=0;d<r;++d){let i=Math.max(0,Math.ceil((J-d)/o)),j=Math.min(l.outWidth,(l.inWidth+J-d)/o),k=d*w+h;for(let h=0;h<l.inChannels;++h){let p=h*x+k;for(let k=0;k<l.outChannels;++k){let q=0;for(let p=0;p<l.batchSize;++p){let l=p*E,r=p*z;for(let p=b;p<c;++p){let b=(a+p*m-I)*F+l,c=p*A+r;for(let a=f;a<g;++a){let f=(e+a*n-K)*G+b,g=a*B+c;for(let a=i;a<j;++a){let b=(d+a*o-J)*H+f,c=a*C+g;q+=D[b+h]*y[c+k]}}}}t[p+k]=q}}}}}return c.makeTensorInfo(s.shape,s.dtype,s.values)}},{kernelName:a1,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{dy:e,filter:f}=b,{pad:g,strides:h,inputShape:i}=d;sJ([e],"conv3dBackpropInputV2");let j=iV.computeStrides(e.shape),k=iV.computeStrides(f.shape),l=hp.computeConv3DInfo(i,f.shape,h,1,g),m=new dh(l.inShape,"float32"),n=m.values,[o,p,q,r]=m.strides,s=c.data.get(e.dataId).values,[t,u,v,w]=j,x=c.data.get(f.dataId).values,[y,z,A,B]=k,{batchSize:C,filterDepth:D,filterHeight:E,filterWidth:F,inChannels:G,inDepth:H,inHeight:I,inWidth:J,outChannels:K,outDepth:L,outHeight:M,outWidth:N,strideDepth:O,strideHeight:P,strideWidth:Q}=l,R=D-1-l.padInfo.front,S=E-1-l.padInfo.top,T=F-1-l.padInfo.left;for(let a=0;a<C;++a)for(let b=0;b<G;++b)for(let c=0;c<H;++c){let d=c-R,e=Math.max(0,Math.ceil(d/O)),f=Math.min(L,(D+d)/O);for(let g=0;g<I;++g){let h=g-S,i=Math.max(0,Math.ceil(h/P)),j=Math.min(M,(E+h)/P);for(let k=0;k<J;++k){let l=k-T,m=Math.max(0,Math.ceil(l/Q)),C=Math.min(N,(F+l)/Q),G=0;for(let c=e;c<f;++c){let e=c*O-d;for(let d=i;d<j;++d){let f=d*P-h;for(let g=m;g<C;++g){let h=g*Q-l,i=t*a+u*c+v*d+w*g,j=y*(D-1-e)+z*(E-1-f)+A*(F-1-h)+B*b;for(let a=0;a<K;++a)G+=s[i+a]*x[j+a]}}}n[o*a+p*c+q*g+r*k+b]=G}}}return c.makeTensorInfo(m.shape,m.dtype,m.values)}},{kernelName:"Cos",backendName:"cpu",kernelFunc:uE},{kernelName:a2,backendName:"cpu",kernelFunc:uF},{kernelName:a5,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{image:e,boxes:f,boxInd:g}=b,{cropSize:h,method:i,extrapolationValue:j}=d,[k,l,m,n]=e.shape,o=f.shape[0],[p,q]=h,r=eu([o,p,q,n],"float32"),s=c.data.get(f.dataId).values,t=c.data.get(g.dataId).values,u=c.data.get(e.dataId).values,v=iV.computeStrides(e.shape),w=iV.computeStrides(r.shape);for(let a=0;a<o;a++){let b=4*a,c=s[b],d=s[b+1],e=s[b+2],f=s[b+3],g=t[a];if(g>=k)continue;let h=p>1?(e-c)*(l-1)/(p-1):0,o=q>1?(f-d)*(m-1)/(q-1):0;for(let b=0;b<p;b++){let k=p>1?c*(l-1)+b*h:.5*(c+e)*(l-1);if(k<0||k>l-1){for(let c=0;c<q;c++)for(let d=0;d<n;d++){let e=d+c*w[2]+b*w[1]+a*w[0];r.values[e]=j}continue}if("bilinear"===i){let c=Math.floor(k),e=Math.ceil(k),h=k-c;for(let i=0;i<q;i++){let k=q>1?d*(m-1)+i*o:.5*(d+f)*(m-1);if(k<0||k>m-1){for(let c=0;c<n;c++){let d=c+i*w[2]+b*w[1]+a*w[0];r.values[d]=j}continue}let l=Math.floor(k),p=Math.ceil(k),s=k-l;for(let d=0;d<n;d++){let f=d+l*v[2]+c*v[1]+g*v[0],j=u[f],k=u[f=d+p*v[2]+c*v[1]+g*v[0]],m=u[f=d+l*v[2]+e*v[1]+g*v[0]],n=u[f=d+p*v[2]+e*v[1]+g*v[0]],o=j+(k-j)*s,q=m+(n-m)*s;f=d+i*w[2]+b*w[1]+a*w[0],r.values[f]=o+(q-o)*h}}}else for(let c=0;c<q;++c){let e=q>1?d*(m-1)+c*o:.5*(d+f)*(m-1);if(e<0||e>m-1){for(let d=0;d<n;d++){let e=d+c*w[2]+b*w[1]+a*w[0];r.values[e]=j}continue}let h=Math.round(e),i=Math.round(k);for(let d=0;d<n;d++){let e=d+h*v[2]+i*v[1]+g*v[0],f=d+c*w[2]+b*w[1]+a*w[0];r.values[f]=u[e]}}}}return c.makeTensorInfo(r.shape,r.dtype,r.values)}},{kernelName:a3,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{axis:f,exclusive:g,reverse:h}=d;sJ(e,"cumprod");let i=hp.getAxesPermutation([f],e.shape.length),j=e;null!=i&&(j=tE({inputs:{x:e},backend:c,attrs:{perm:i}}));let k=hp.getInnerMostAxes(1,e.shape.length)[0];if(k!==j.shape.length-1)throw Error(`backend.cumprod in CPU expects an inner-most axis=${j.shape.length-1} but got axis=${k}`);let l=dp(j.dtype,"int32"),m=iV.makeOnesTypedArray(iV.sizeFromShape(j.shape),l),n=c.data.get(j.dataId).values,o=j.shape[j.shape.length-1],p=h?(a,b)=>a+o-b-1:(a,b)=>a+b;for(let a=0;a<n.length;a+=o)for(let b=0;b<o;b++){let c=p(a,b);if(0===b)m[c]=g?1:n[c];else{let d=p(a,b-1);m[c]=g?n[d]*m[d]:n[c]*m[d]}}let q=c.makeTensorInfo(j.shape,l,m);if(null!=i){let a=tE({inputs:{x:q},backend:c,attrs:{perm:hp.getUndoAxesPermutation(i)}});return c.disposeIntermediateTensorInfo(q),c.disposeIntermediateTensorInfo(j),a}return q}},{kernelName:a4,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{axis:f,exclusive:g,reverse:h}=d;sJ(e,"cumsum");let i=hp.getAxesPermutation([f],e.shape.length),j=e;null!=i&&(j=tE({inputs:{x:e},backend:c,attrs:{perm:i}}));let k=hp.getInnerMostAxes(1,e.shape.length)[0];if(k!==j.shape.length-1)throw Error(`backend.cumsum in CPU expects an inner-most axis=${j.shape.length-1} but got axis=${k}`);let l=dp(j.dtype,"int32"),m=iV.makeZerosTypedArray(iV.sizeFromShape(j.shape),l),n=c.data.get(j.dataId).values,o=j.shape[j.shape.length-1],p=h?(a,b)=>a+o-b-1:(a,b)=>a+b;for(let a=0;a<n.length;a+=o)for(let b=0;b<o;b++){let c=p(a,b);if(0===b)m[c]=g?0:n[c];else{let d=p(a,b-1);m[c]=g?n[d]+m[d]:n[c]+m[d]}}let q=c.makeTensorInfo(j.shape,l,m);if(null!=i){let a=tE({inputs:{x:q},backend:c,attrs:{perm:hp.getUndoAxesPermutation(i)}});return c.disposeIntermediateTensorInfo(q),c.disposeIntermediateTensorInfo(j),a}return q}},{kernelName:a6,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,weights:f}=b,{size:g,binaryOutput:h}=d;if(1===e.shape.length){let a=sY(c.data.get(e.dataId).values,c.data.get(f.dataId).values,f.dtype,f.shape,g);return c.makeTensorInfo([g],f.dtype,a)}if(2===e.shape.length){let a=sZ(c.bufferSync(e),c.bufferSync(f),g,h);return c.makeTensorInfo(a.shape,f.dtype,a.values)}throw Error(`Error in denseBincount: input must be at most rank 2, but got rank${e.shape.length}.`)}},{kernelName:a7,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{blockSize:f,dataFormat:g}=d;iV.assert("NHWC"===g,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${g}`);let h=e.shape[0],i=e.shape[1],j=e.shape[2],k=e.shape[3],l=i*f,m=j*f,n=k/(f*f),o=c.data.get(e.dataId).values,p=new Float32Array(h*l*m*n),q=0;for(let a=0;a<h;++a)for(let b=0;b<l;++b){let c=Math.floor(b/f),d=b%f;for(let b=0;b<m;++b){let e=Math.floor(b/f),g=b%f,h=(d*f+g)*n;for(let b=0;b<n;++b){let d=b+h+k*(e+j*(c+i*a));p[q++]=o[d]}}}return c.makeTensorInfo([h,l,m,n],e.dtype,p)}},{kernelName:a8,backendName:"cpu",kernelFunc:uG},{kernelName:a9,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,dy:f}=b,{strides:g,dilations:h,pad:i,dimRoundingMode:j,filterShape:k}=d;sJ([e,f],"depthwiseConv2dNativeBackpropFilter");let l=hp.computeConv2DInfo(e.shape,k,g,h,i,j,!0),{strideHeight:m,strideWidth:n,filterHeight:o,filterWidth:p}=l,q=new dh(l.filterShape,"float32"),r=l.padInfo.left,s=l.padInfo.top,t=l.outChannels/l.inChannels,u=c.data.get(e.dataId).values,v=new dh(e.shape,e.dtype,u),w=c.data.get(f.dataId).values,x=new dh(f.shape,f.dtype,w);for(let a=0;a<o;++a){let b=Math.max(0,Math.ceil((s-a)/m)),c=Math.min(l.outHeight,(l.inHeight+s-a)/m);for(let d=0;d<p;++d){let e=Math.max(0,Math.ceil((r-d)/n)),f=Math.min(l.outWidth,(l.inWidth+r-d)/n);for(let g=0;g<l.outChannels;++g){let h=Math.trunc(g/t),i=g%t,j=0;for(let i=0;i<l.batchSize;++i)for(let k=b;k<c;++k){let b=a+k*m-s;for(let a=e;a<f;++a){let c=d+a*n-r;j+=v.get(i,b,c,h)*x.get(i,k,a,g)}}q.set(j,a,d,h,i)}}}return c.makeTensorInfo(q.shape,q.dtype,q.values)}},{kernelName:ba,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{dy:e,filter:f}=b,{strides:g,dilations:h,pad:i,dimRoundingMode:j,inputShape:k}=d;sJ([e,f],"depthwiseConv2DNativeBackpropInput");let l=iV.computeStrides(e.shape),m=iV.computeStrides(f.shape),n=hp.computeConv2DInfo(k,f.shape,g,h,i,j,!0),o=new dh(n.inShape,"float32"),p=o.values,[q,r,s]=o.strides,t=c.data.get(e.dataId).values,[u,v,w]=l,x=c.data.get(f.dataId).values,[y,z,A]=m,{batchSize:B,filterHeight:C,filterWidth:D,inChannels:E,inHeight:F,inWidth:G,outChannels:H,outHeight:I,outWidth:J,strideHeight:K,strideWidth:L}=n,M=C-1-n.padInfo.top,N=D-1-n.padInfo.left,O=H/E;for(let a=0;a<B;++a)for(let b=0;b<E;++b)for(let c=0;c<F;++c){let d=c-M,e=Math.max(0,Math.ceil(d/K)),f=Math.min(I,(C+d)/K);for(let g=0;g<G;++g){let h=g-N,i=Math.max(0,Math.ceil(h/L)),j=Math.min(J,(D+h)/L),k=0;for(let c=e;c<f;++c){let e=c*K-d;for(let d=i;d<j;++d){let f=d*L-h,g=u*a+v*c+w*d,i=y*(C-1-e)+z*(D-1-f)+A*b;for(let a=0;a<O;++a)k+=t[g+(b*O+a)]*x[i+a]}}p[q*a+r*c+s*g+b]=k}}return c.makeTensorInfo(o.shape,o.dtype,o.values)}},{kernelName:bb,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c}=a,{x:d}=b,e=iV.sizeFromShape(d.shape),f=c.data.get(d.dataId).values,g=eu([e,e],d.dtype),h=g.values;for(let a=0;a<f.length;a++)h[a*e+a]=f[a];let i=[...d.shape,...d.shape];return c.makeTensorInfo(i,g.dtype,g.values)}},{kernelName:bc,backendName:"cpu",kernelFunc:({inputs:a,backend:b,attrs:c})=>{let{x:d,filter:e}=a,{strides:f,pad:g,dilations:h}=c,i=b.data.get(d.dataId).values,j=d.shape.length,k=b.data.get(e.dataId).values,l=e.shape.length,{batchSize:m,inHeight:n,inWidth:o,inChannels:p,outHeight:q,outWidth:r,padInfo:s,strideHeight:t,strideWidth:u,filterHeight:v,filterWidth:w,dilationHeight:x,dilationWidth:y,outShape:z}=hp.computeDilation2DInfo(d.shape,e.shape,f,g,"NHWC",h),A=iV.sizeFromShape(z),B=z.length,C=iV.getArrayFromDType(d.dtype,A);for(let a=0;a<m;++a)for(let b=0;b<q;++b){let c=b*t-s.top;for(let f=0;f<r;++f){let g=f*u-s.left;for(let h=0;h<p;++h){let m=Number.MIN_SAFE_INTEGER;for(let b=0;b<v;++b){let f=c+b*x;if(f>=0&&f<n)for(let c=0;c<w;++c){let n=g+c*y;if(n>=0&&n<o){let g=iV.locToIndex([a,f,n,h],j,iV.computeStrides(d.shape)),o=iV.locToIndex([b,c,h],l,iV.computeStrides(e.shape)),p=i[g]+k[o];p>m&&(m=p)}}}C[iV.locToIndex([a,b,f,h],B,iV.computeStrides(z))]=m}}}return{dataId:b.write(iV.toTypedArray(C,d.dtype),z,d.dtype),shape:z,dtype:d.dtype}}},{kernelName:be,backendName:"cpu",kernelFunc:({inputs:a,backend:b,attrs:c})=>{let{x:d,filter:e,dy:f}=a,{strides:g,pad:h,dilations:i}=c,j=iV.toNestedArray(d.shape,b.data.get(d.dataId).values),k=iV.toNestedArray(e.shape,b.data.get(e.dataId).values),{batchSize:l,inHeight:m,inWidth:n,inChannels:o,outHeight:p,outWidth:q,padInfo:r,strideHeight:s,strideWidth:t,filterHeight:u,filterWidth:v,dilationHeight:w,dilationWidth:x,outShape:y}=hp.computeDilation2DInfo(d.shape,e.shape,g,h,"NHWC",i);iV.assert(f.rank===y.length,()=>`Error in ${be}, dy must have the same rank as output ${y.length}, but got ${f.rank}`);let z=iV.toNestedArray(y,b.data.get(f.dataId).values),A=iV.makeZerosNestedTypedArray(e.shape,e.dtype);for(let a=0;a<l;++a)for(let b=0;b<p;++b){let c=b*s-r.top;for(let d=0;d<q;++d){let e=d*t-r.left;for(let f=0;f<o;++f){let g=Number.MIN_SAFE_INTEGER,h=0,i=0;for(let b=0;b<u;++b){let d=c+b*w;if(d>=0&&d<m)for(let c=0;c<v;++c){let l=e+c*x;if(l>=0&&l<n){let e=j[a][d][l][f]+k[b][c][f];e>g&&(g=e,h=b,i=c)}}}A[h][i][f]+=z[a][b][d][f]}}}return{dataId:b.write(iV.toTypedArray(A,d.dtype),e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},{kernelName:bd,backendName:"cpu",kernelFunc:({inputs:a,backend:b,attrs:c})=>{let{x:d,filter:e,dy:f}=a,{strides:g,pad:h,dilations:i}=c,j=iV.toNestedArray(d.shape,b.data.get(d.dataId).values),k=iV.toNestedArray(e.shape,b.data.get(e.dataId).values),{batchSize:l,inHeight:m,inWidth:n,inChannels:o,outHeight:p,outWidth:q,padInfo:r,strideHeight:s,strideWidth:t,filterHeight:u,filterWidth:v,dilationHeight:w,dilationWidth:x,outShape:y}=hp.computeDilation2DInfo(d.shape,e.shape,g,h,"NHWC",i);iV.assert(f.rank===y.length,()=>`Error in ${bd}, dy must have the same rank as output ${y.length}, but got ${f.rank}`);let z=iV.toNestedArray(y,b.data.get(f.dataId).values),A=iV.makeZerosNestedTypedArray(d.shape,d.dtype);for(let a=0;a<l;++a)for(let b=0;b<p;++b){let c=b*s-r.top;for(let d=0;d<q;++d){let e=d*t-r.left;for(let f=0;f<o;++f){let g=Number.MIN_SAFE_INTEGER,h=c<0?0:c,i=e<0?0:e;for(let b=0;b<u;++b){let d=c+b*w;if(d>=0&&d<m)for(let c=0;c<v;++c){let l=e+c*x;if(l>=0&&l<n){let e=j[a][d][l][f]+k[b][c][f];e>g&&(g=e,h=d,i=l)}}}A[a][h][i][f]+=z[a][b][d][f]}}}return{dataId:b.write(iV.toTypedArray(A,d.dtype),d.shape,d.dtype),shape:d.shape,dtype:d.dtype}}},{kernelName:bf,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{image:e}=b,{canvas:f,options:g}=d,{contextOptions:h,imageOptions:i}=g||{},j=(null==i?void 0:i.alpha)||1,k=(null==h?void 0:h.contextType)||"2d";if("2d"!==k)throw Error(`Context type ${h.contextType} is not supported by the CPU backend.`);let l=f.getContext(k,(null==h?void 0:h.contextAttributes)||{});if(null==l)throw Error(`Could not get the context with ${k} type.`);let[m,n]=e.shape.slice(0,2),o=2===e.shape.length?1:e.shape[2],p=c.data.get(e.dataId).values,q="float32"===e.dtype?255:1,r=new Uint8ClampedArray(n*m*4);for(let a=0;a<m*n;++a){let b=[0,0,0,255*j];for(let c=0;c<o;c++){let d=p[a*o+c];if("float32"===e.dtype){if(d<0||d>1)throw Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if("int32"===e.dtype&&(d<0||d>255))throw Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);1===o?(b[0]=d*q,b[1]=d*q,b[2]=d*q):b[c]=d*q}let c=4*a;r[c+0]=Math.round(b[0]),r[c+1]=Math.round(b[1]),r[c+2]=Math.round(b[2]),r[c+3]=Math.round(b[3])}f.width=n,f.height=m;let s=new ImageData(r,n,m);return l.putImageData(s,0,0),e}},{kernelName:bh,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{equation:e}=d,{allDims:f,summedDims:g,idDims:h}=hp.decodeEinsumEquation(e,b.length);hp.checkEinsumDimSizes(f.length,h,b);let{path:i,steps:j}=hp.getEinsumComputePath(g,h),k=j.length,l=null,m=f.length,n=[];for(let a=0;a<k;++a){for(let d of j[a]){let a,{permutationIndices:e,expandDims:f}=hp.getEinsumPermutation(m,h[d]);hp.isIdentityPermutation(e)?a=b[d]:(a=tE({inputs:{x:b[d]},backend:c,attrs:{perm:e}}),n.push(a));let g=a.shape.slice();for(let a=0;a<f.length;++a)g.splice(f[a],0,1);iV.arraysEqual(a.shape,g)||(a=uo({inputs:{x:a},backend:c,attrs:{shape:g}}),n.push(a)),null===l?l=a:(l=tz({inputs:{a:a,b:l},backend:c}),n.push(l))}a<k-1&&(i[a]>=0&&(l=uH({inputs:{x:l},backend:c,attrs:{axis:i[a]-(f.length-m),keepDims:!1}}),n.push(l)),m--)}for(let a of n)a!==l&&c.disposeIntermediateTensorInfo(a);return l}},{kernelName:"Elu",backendName:"cpu",kernelFunc:ug},{kernelName:bi,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c}=a,{dy:d,y:e}=b;sJ([d,e],"eluGrad");let f=new Float32Array(iV.sizeFromShape(e.shape)),g=c.data.get(e.dataId).values,h=c.data.get(d.dataId).values;for(let a=0;a<g.length;++a){let b=g[a];b>=0?f[a]=h[a]:f[a]=h[a]*(b+1)}return c.makeTensorInfo(e.shape,"float32",f)}},{kernelName:bj,backendName:"cpu",kernelFunc:s7},{kernelName:"Erf",backendName:"cpu",kernelFunc:uO},{kernelName:"Exp",backendName:"cpu",kernelFunc:s9},{kernelName:bk,backendName:"cpu",kernelFunc:uP},{kernelName:bl,backendName:"cpu",kernelFunc:tb},{kernelName:"FFT",backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c}=a,{input:d}=b,e=iV.sizeFromShape(d.shape),f=d.shape[d.shape.length-1],g=uo({inputs:{x:d},backend:c,attrs:{shape:[e/f,f]}}),h=uS(g,!1,c),i=uo({inputs:{x:h},backend:c,attrs:{shape:d.shape}});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(h),i}},{kernelName:bm,backendName:"cpu",kernelFunc:uT},{kernelName:bn,backendName:"cpu",kernelFunc:({inputs:a,attrs:b,backend:c})=>{let{image:d}=a,e=iV.getTypedArrayFromDType(d.dtype,iV.sizeFromShape(d.shape)),[f,g,h,i]=d.shape,j=c.data.get(d.dataId).values;for(let a=0;a<f;a++){let b=a*h*g*i;for(let a=0;a<g;a++){let c=h*i*a;for(let a=0;a<h;a++){let d=a*i;for(let f=0;f<i;f++){let g=Math.round(h-a-1),k=b+c+d+f,l=j[k];g>=0&&g<h&&(l=j[b+c+g*i+f]),e[k]=l}}}}return{dataId:c.write(e,d.shape,d.dtype),shape:d.shape,dtype:d.dtype}}},{kernelName:bo,backendName:"cpu",kernelFunc:td},{kernelName:bp,backendName:"cpu",kernelFunc:tf},{kernelName:cW,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,filter:f,bias:g,preluActivationWeights:h}=b,{strides:i,pad:j,dataFormat:k,dilations:l,dimRoundingMode:m,activation:n,leakyreluAlpha:o}=d,p=uD({inputs:{x:e,filter:f},backend:c,attrs:{strides:i,pad:j,dataFormat:k,dilations:l,dimRoundingMode:m}});if(g){let a=p;if("NCHW"===k&&1===g.shape.length&&1!==g.shape[0]){let a=uo({inputs:{x:g},backend:c,attrs:{shape:[g.shape[0],1,1]}});p=sX({inputs:{a:p,b:a},backend:c}),c.disposeIntermediateTensorInfo(a)}else p=sX({inputs:{a:p,b:g},backend:c});c.disposeIntermediateTensorInfo(a)}if(n){let a=p;if("NCHW"===k&&"prelu"===n&&1===h.shape.length&&1!==h.shape[0]){let a=uo({inputs:{x:h},backend:c,attrs:{shape:[h.shape[0],1,1]}});p=um(c,p,n,a,o),c.disposeIntermediateTensorInfo(a)}else p=um(c,p,n,h,o);c.disposeIntermediateTensorInfo(a)}return p}},{kernelName:cX,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,filter:f,bias:g,preluActivationWeights:h}=b,{strides:i,pad:j,dataFormat:k,dilations:l,dimRoundingMode:m,activation:n,leakyreluAlpha:o}=d,p=uG({inputs:{x:e,filter:f},backend:c,attrs:{strides:i,pad:j,dataFormat:k,dilations:l,dimRoundingMode:m}});if(g){let a=p;p=sX({inputs:{a:p,b:g},backend:c}),c.disposeIntermediateTensorInfo(a)}if(n){let a=p;p=um(c,p,n,h,o),c.disposeIntermediateTensorInfo(a)}return p}},{kernelName:bs,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c}=a,{params:d,indices:e}=b,f=iV.sizeFromShape(d.shape),g=e.shape,h=g[g.length-1],[i,j,k,l]=hp.prepareAndValidate(d,e);if(0===j)return c.makeTensorInfo(i,d.dtype,[]);let m=tg(c.data.get(e.dataId).values,c.bufferSync(d),d.dtype,j,h,k,l,d.shape,f);return c.makeTensorInfo(i,d.dtype,m.values)}},{kernelName:br,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,indices:f}=b,{axis:g,batchDims:h}=d;sJ([e,f],"gatherV2");let i=iV.parseAxisParam(g,e.shape)[0],j=c.data.get(f.dataId).values,k=e.shape[i];for(let a=0;a<j.length;++a){let b=j[a];iV.assert(b<=k-1&&b>=0,()=>`GatherV2: the index value ${b} is not in [0, ${k-1}]`)}let l=h;null==h&&(l=0);let m=iV.sizeFromShape(f.shape),n=hp.segment_util.collectGatherOpShapeInfo(e,f,i,l),o=uo({inputs:{x:e},backend:c,attrs:{shape:[n.batchSize,n.outerSize,n.dimSize,n.sliceSize]}}),p=uo({inputs:{x:f},backend:c,attrs:{shape:[n.batchSize,m/n.batchSize]}}),q=[n.batchSize,n.outerSize,m/n.batchSize,n.sliceSize],r=c.bufferSync(p),s=th(c.bufferSync(o),r,q);return c.disposeIntermediateTensorInfo(o),c.disposeIntermediateTensorInfo(p),c.makeTensorInfo(n.outputShape,s.dtype,s.values)}},{kernelName:bt,backendName:"cpu",kernelFunc:tj},{kernelName:bu,backendName:"cpu",kernelFunc:tl},{kernelName:bv,backendName:"cpu",kernelFunc:sQ},{kernelName:bw,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c}=a,{input:d}=b,e=iV.sizeFromShape(d.shape),f=d.shape[d.shape.length-1],g=uo({inputs:{x:d},backend:c,attrs:{shape:[e/f,f]}}),h=uS(g,!0,c),i=uo({inputs:{x:h},backend:c,attrs:{shape:d.shape}});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(h),i}},{kernelName:bx,backendName:"cpu",kernelFunc:uB},{kernelName:by,backendName:"cpu",kernelFunc:uU},{kernelName:bz,backendName:"cpu",kernelFunc:uV},{kernelName:bA,backendName:"cpu",kernelFunc:uW},{kernelName:bB,backendName:"cpu",kernelFunc:uh},{kernelName:bC,backendName:"cpu",kernelFunc:tn},{kernelName:bD,backendName:"cpu",kernelFunc:tp},{kernelName:bE,backendName:"cpu",kernelFunc:function(a){let{backend:b,attrs:c}=a,{start:d,stop:e,num:f}=c,g=tq(d,e,f);return b.makeTensorInfo([g.length],"float32",g)}},{kernelName:"Log",backendName:"cpu",kernelFunc:ts},{kernelName:bF,backendName:"cpu",kernelFunc:uX},{kernelName:bG,backendName:"cpu",kernelFunc:uY},{kernelName:bH,backendName:"cpu",kernelFunc:uZ},{kernelName:bI,backendName:"cpu",kernelFunc:u$},{kernelName:"LRN",backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{depthRadius:f,bias:g,alpha:h,beta:i}=d;sJ(e,"LRN");let j=e.shape[3],k=j-1,l=c.data.get(e.dataId).values,m=iV.sizeFromShape(e.shape),n=new Float32Array(m);for(let a=0;a<m;a++){let b=function(a){let b=a%j,c=a-b+Math.max(0,b-f),d=a-b+Math.min(b+f,k),e=0;for(;c<=d;c++){let a=l[c];e+=a*a}return e}(a),c=l[a]*Math.pow(g+h*b,-i);n[a]=c}return c.makeTensorInfo(e.shape,e.dtype,n)}},{kernelName:bJ,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,y:f,dy:g}=b,{depthRadius:h,bias:i,alpha:j,beta:k}=d;sJ(g,"LRNGrad");let l=iV.sizeFromShape(g.shape),m=g.shape[3],n=c.data.get(g.dataId).values,o=c.data.get(e.dataId).values,p=c.data.get(f.dataId).values,q=new Float32Array(l);for(let a=0;a<l;a++){let b=a%m,c=a-b+Math.max(0,b-h),d=a-b+Math.min(m,b+h+1),e=0;for(let a=c;a<d;a++)e+=Math.pow(o[a],2);e=j*e+i;for(let b=c;b<d;b++){let c=-2*j*k*o[b]*p[a]/e;a===b&&(c+=Math.pow(e,-k)),c*=n[a],q[b]+=c}}return c.makeTensorInfo(g.shape,e.dtype,q)}},{kernelName:"Max",backendName:"cpu",kernelFunc:u_},{kernelName:bK,backendName:"cpu",kernelFunc:tv},{kernelName:bL,backendName:"cpu",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f}=c;sJ(f,"maxPool");let{filterSize:g,strides:h,pad:i,dimRoundingMode:j}=e;iV.assert(hp.eitherStridesOrDilationsAreOne(h,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${h} and dilations '1'`);let k=hp.computePool2DInfo(f.shape,g,h,1,i,j);if(1===k.filterWidth&&1===k.filterHeight&&iV.arraysEqual(k.inShape,k.outShape))b=sQ({inputs:{x:f},backend:d});else{let a=d.data.get(f.dataId).values,c=iV.computeStrides(f.shape),e=ux(a,f.shape,f.dtype,c,k,"max");b=d.makeTensorInfo(k.outShape,f.dtype,e.values)}return b}},{kernelName:bN,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{filterSize:f,strides:g,pad:h,dimRoundingMode:i,dataFormat:j}=d;sJ(e,"maxPool3d");let k=hp.computePool3DInfo(e.shape,f,g,1,h,i,j),l=uz(c.data.get(e.dataId).values,e.shape,e.dtype,iV.computeStrides(e.shape),k,"max");return c.makeTensorInfo(l.shape,"float32",l.values)}},{kernelName:bO,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{dy:e,input:f}=b,{filterSize:g,strides:h,pad:i,dimRoundingMode:j}=d;sJ([e,f],"maxPool3DGrad");let k=hp.computePool3DInfo(f.shape,g,h,1,i,j),l=function(a,b){let c=eu(b.outShape,"int32"),d=b.strideDepth,e=b.strideHeight,f=b.strideWidth,g=b.dilationDepth,h=b.dilationHeight,i=b.dilationWidth,j=b.effectiveFilterDepth,k=b.effectiveFilterHeight,l=b.effectiveFilterWidth,m=b.padInfo.front,n=b.padInfo.top,o=b.padInfo.left;for(let p=0;p<b.batchSize;++p)for(let q=0;q<b.inChannels;++q)for(let r=0;r<b.outDepth;++r){let s=r*d-m,t=s;for(;t<0;)t+=g;let u=Math.min(b.inDepth,j+s);for(let d=0;d<b.outHeight;++d){let j=d*e-n,m=j;for(;m<0;)m+=h;let v=Math.min(b.inHeight,k+j);for(let e=0;e<b.outWidth;++e){let n=e*f-o,w=n;for(;w<0;)w+=i;let x=Math.min(b.inWidth,l+n),y=-1/0,z=-1;for(let b=t;b<u;b+=g){let c=b-s;for(let d=m;d<v;d+=h){let e=d-j;for(let f=w;f<x;f+=i){let g=f-n,h=a.get(p,b,d,f,q);h>=y&&(y=h,z=c*k*l+e*k+g)}}}c.set(z,p,r,d,e,q)}}}return c}(c.bufferSync(f),k),m=k.strideDepth,n=k.strideHeight,o=k.strideWidth,p=k.dilationDepth,q=k.dilationHeight,r=k.dilationWidth,s=k.effectiveFilterDepth,t=k.effectiveFilterHeight,u=k.effectiveFilterWidth,v=s-1-k.padInfo.front,w=u-1-k.padInfo.left,x=t-1-k.padInfo.top,y=eu(f.shape,"float32"),z=c.bufferSync(e);for(let a=0;a<k.batchSize;++a)for(let b=0;b<k.inChannels;++b)for(let c=0;c<k.inDepth;++c)for(let d=0;d<k.inHeight;++d)for(let e=0;e<k.inWidth;++e){let f=c-v,g=d-x,h=e-w,i=0;for(let c=0;c<s;c+=p){let d=(f+c)/m;if(!(d<0)&&!(d>=k.outDepth)&&Math.floor(d)===d)for(let e=0;e<t;e+=q){let f=(g+e)/n;if(!(f<0)&&!(f>=k.outHeight)&&Math.floor(f)===f)for(let g=0;g<u;g+=r){let j=(h+g)/o;if(j<0||j>=k.outWidth||Math.floor(j)!==j)continue;let m=+(s*t*u-1-l.get(a,d,f,j,b)===c*t*u+e*u+g);0!==m&&(i+=z.get(a,d,f,j,b)*m)}}}y.set(i,a,c,d,e,b)}return c.makeTensorInfo(y.shape,y.dtype,y.values)}},{kernelName:bM,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{dy:e,input:f,output:g}=b;sJ([f,g],"maxPoolGrad");let{filterSize:h,strides:i,pad:j,dimRoundingMode:k}=d,l=hp.computePool2DInfo(f.shape,h,i,1,j,k),m=c.data.get(f.dataId).values,n=eu(l.outShape,f.dtype,uy(m,f.shape,f.dtype,l).values),o=l.strideHeight,p=l.strideWidth,q=l.dilationHeight,r=l.dilationWidth,s=l.effectiveFilterHeight,t=l.effectiveFilterWidth,u=t-1-l.padInfo.left,v=s-1-l.padInfo.top,w=eu(f.shape,"float32"),x=c.data.get(e.dataId).values,y=eu(e.shape,"float32",x);for(let a=0;a<l.batchSize;++a)for(let b=0;b<l.inChannels;++b)for(let c=0;c<l.inHeight;++c)for(let d=0;d<l.inWidth;++d){let e=c-v,f=d-u,g=0;for(let c=0;c<s;c+=q){let d=(e+c)/o;if(!(d<0)&&!(d>=l.outHeight)&&Math.floor(d)===d)for(let e=0;e<t;e+=r){let h=(f+e)/p;if(h<0||h>=l.outWidth||Math.floor(h)!==h)continue;let i=+(s*t-1-n.get(a,d,h,b)===c*t+e);0!==i&&(g+=y.get(a,d,h,b)*i)}}w.set(g,a,c,d,b)}return c.makeTensorInfo(w.shape,w.dtype,w.values)}},{kernelName:bP,backendName:"cpu",kernelFunc:({inputs:a,attrs:b,backend:c})=>{var d,e;let f,g,h,{x:i}=a,{filterSize:j,strides:k,pad:l,includeBatchInIndex:m}=b;sJ(i,"MaxPoolWithArgmax");let n=c.data.get(i.dataId).values,o=hp.computePool2DInfo(i.shape,j,k,[1,1],l),[p,q]=(d=i.shape,e=i.dtype,f=iV.computeStrides(d),g=ux(n,d,e,f,o,"max"),h=uy(n,d,e,o,!0,m),[g.values,h.values]),r=c.write(p,o.outShape,i.dtype),s=c.write(q,o.outShape,i.dtype);return[{dataId:r,shape:o.outShape,dtype:i.dtype},{dataId:s,shape:o.outShape,dtype:"int32"}]}},{kernelName:bQ,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{axis:f,keepDims:g}=d,h=iV.parseAxisParam(f,e.shape),i=hp.computeOutAndReduceShapes(e.shape,h)[1],j=iV.sizeFromShape(i),k=[],l=c.makeTensorInfo([],"float32",new Float32Array([j]));k.push(l);let m=sT({inputs:{x:e},backend:c,attrs:{dtype:"float32"}});k.push(m);let n=uQ({inputs:{a:m,b:l},backend:c});k.push(n);let o=uH({inputs:{x:n},backend:c,attrs:{axis:f,keepDims:g}});return k.forEach(a=>c.disposeIntermediateTensorInfo(a)),o}},{kernelName:"Min",backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{axis:f,keepDims:g}=d;sJ(e,"min");let h=iV.parseAxisParam(f,e.shape),i=h,j=hp.getAxesPermutation(i,e.shape.length),k=e;null!=j&&(k=tE({inputs:{x:e},backend:c,attrs:{perm:j}}),i=hp.getInnerMostAxes(i.length,e.shape.length)),hp.assertAxesAreInnerMostDims("min",i,k.shape.length);let[l,m]=hp.computeOutAndReduceShapes(k.shape,i),n=iV.sizeFromShape(m),o=iV.makeZerosTypedArray(iV.sizeFromShape(l),k.dtype),p=c.data.get(k.dataId).values;for(let a=0;a<o.length;++a){let b=a*n,c=p[b];for(let a=0;a<n;++a){let d=p[b+a];(Number.isNaN(d)||d<c)&&(c=d)}o[a]=c}null!=j&&c.disposeIntermediateTensorInfo(k);let q=c.makeTensorInfo(l,k.dtype,o);if(g){let a=uo({inputs:{x:q},backend:c,attrs:{shape:hp.expandShapeToKeepDim(l,h)}});return c.disposeIntermediateTensorInfo(q),a}return q}},{kernelName:bR,backendName:"cpu",kernelFunc:tx},{kernelName:bS,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{paddings:f,mode:g}=d;sJ(e,"mirrorPad");let h=f.map((a,b)=>a[0]+e.shape[b]+a[1]),i=f.map(a=>a[0]),j=f.map((a,b)=>a[0]+e.shape[b]),k=+("reflect"!==g),l=c.data.get(e.dataId).values,m=e.shape.length,n=iV.computeStrides(e.shape),o=iV.sizeFromShape(h),p=h.length,q=iV.computeStrides(h),r=iV.getTypedArrayFromDType(e.dtype,o);for(let a=0;a<o;a++){let b=iV.indexToLoc(a,p,q);for(let a=0;a<p;a++)b[a]<i[a]?b[a]=2*i[a]-b[a]-k:b[a]>=j[a]&&(b[a]=(j[a]-1)*2-b[a]+k);b=b.map((a,b)=>a-i[b]);let c=iV.locToIndex(b,m,n);r[a]=l[c]}return{dataId:c.write(r,h,e.dtype),shape:h,dtype:e.dtype}}},{kernelName:"Mod",backendName:"cpu",kernelFunc:u0},{kernelName:bT,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{logits:e}=b,{numSamples:f,seed:g,normalized:h}=d;sJ(e,"multinomial");let i=h?e:u1({inputs:{logits:e},backend:c,attrs:{dim:-1}}),j=i.shape[0],k=i.shape[1],l=c.data.get(i.dataId).values,m=[j,f],n=iV.makeZerosTypedArray(iV.sizeFromShape(m),"int32");for(let a=0;a<j;++a){let b=a*k,c=new Float32Array(k-1);c[0]=l[b];for(let a=1;a<c.length;++a)c[a]=c[a-1]+l[b+a];let d=kz.alea(g.toString()),e=a*f;for(let a=0;a<f;++a){let b=d();n[e+a]=c.length;for(let d=0;d<c.length;d++)if(b<c[d]){n[e+a]=d;break}}}return h||c.disposeIntermediateTensorInfo(i),c.makeTensorInfo(m,"int32",n)}},{kernelName:bU,backendName:"cpu",kernelFunc:tz},{kernelName:"Neg",backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c}=a,{x:d}=b;sJ(d,"neg");let[e,f]=tA(c.data.get(d.dataId).values,d.shape,d.dtype);return c.makeTensorInfo(f,d.dtype,e)}},{kernelName:bW,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{boxes:e,scores:f}=b,{maxOutputSize:g,iouThreshold:h,scoreThreshold:i}=d;sJ(e,"NonMaxSuppression");let{selectedIndices:j}=u2(c.data.get(e.dataId).values,c.data.get(f.dataId).values,g,h,i);return c.makeTensorInfo([j.length],"int32",new Int32Array(j))}},{kernelName:bX,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{boxes:e,scores:f}=b,{maxOutputSize:g,iouThreshold:h,scoreThreshold:i,padToMaxOutputSize:j}=d;sJ(e,"NonMaxSuppressionPadded");let{selectedIndices:k,validOutputs:l}=u3(c.data.get(e.dataId).values,c.data.get(f.dataId).values,g,h,i,j);return[c.makeTensorInfo([k.length],"int32",new Int32Array(k)),c.makeTensorInfo([],"int32",new Int32Array([l]))]}},{kernelName:bY,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{boxes:e,scores:f}=b,{maxOutputSize:g,iouThreshold:h,scoreThreshold:i,softNmsSigma:j}=d;sJ(e,"NonMaxSuppressionWithScore");let{selectedIndices:k,selectedScores:l}=u4(c.data.get(e.dataId).values,c.data.get(f.dataId).values,g,h,i,j);return[c.makeTensorInfo([k.length],"int32",new Int32Array(k)),c.makeTensorInfo([l.length],"float32",new Float32Array(l))]}},{kernelName:bV,backendName:"cpu",kernelFunc:tC},{kernelName:b$,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{indices:e}=b,{dtype:f,depth:g,onValue:h,offValue:i}=d;sJ(e,"oneHot");let j=iV.sizeFromShape(e.shape),k=new Float32Array(j*g);k.fill(i);let l=c.data.get(e.dataId).values;for(let a=0;a<j;++a)l[a]>=0&&l[a]<g&&(k[a*g+l[a]]=h);return c.makeTensorInfo([...e.shape,g],f,k)}},{kernelName:bZ,backendName:"cpu",kernelFunc:function a(b){let{inputs:c,backend:d}=b,{x:e}=c;if("string"===e.dtype)throw Error("onesLike is not supported for string tensors");if("complex64"!==e.dtype)return uT({backend:d,attrs:{shape:e.shape,value:1,dtype:e.dtype}});{let b=sR({inputs:{input:e},backend:d}),c=a({inputs:{x:b},backend:d}),f=uB({inputs:{input:e},backend:d}),g=u5({inputs:{x:f},backend:d}),h=sO({inputs:{real:c,imag:g},backend:d});return d.disposeIntermediateTensorInfo(b),d.disposeIntermediateTensorInfo(c),d.disposeIntermediateTensorInfo(f),d.disposeIntermediateTensorInfo(g),h}}},{kernelName:b_,backendName:"cpu",kernelFunc:u6},u7,{kernelName:"Pow",backendName:"cpu",kernelFunc:u8},{kernelName:b1,backendName:"cpu",kernelFunc:uj},{kernelName:b2,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{axis:f,keepDims:g}=d;sJ(e,"prod");let h=e.shape.length,i=iV.parseAxisParam(f,e.shape),j=hp.getAxesPermutation(i,h),k=i,l=e,m=[];null!=j&&(m.push(l=tE({inputs:{x:e},backend:c,attrs:{perm:j}})),k=hp.getInnerMostAxes(k.length,h));let n=c.data.get(l.dataId).values,{outVals:o,outShape:p,outDtype:q}=tF(l.shape,l.dtype,n,k),r=p;return g&&(r=hp.expandShapeToKeepDim(p,i)),m.forEach(a=>c.disposeIntermediateTensorInfo(a)),c.makeTensorInfo(r,q,o)}},{kernelName:b3,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{paramsNestedSplits:e,paramsDenseValues:f,indices:g}=b,{outputRaggedRank:h}=d,i=e.map(a=>c.data.get(a.dataId).values),j=e.map(a=>a.shape),k=c.data.get(f.dataId).values,l=c.data.get(g.dataId).values,[m,n,o]=tH(i,j,k,f.shape,f.dtype,l,g.shape,h),p=m.map(a=>c.makeTensorInfo([a.length],"int32",a)),q=c.makeTensorInfo(o,f.dtype,n);return p.concat([q])}},{kernelName:b4,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c}=a,{starts:d,limits:e,deltas:f}=b,g=c.data.get(d.dataId).values,h=c.data.get(e.dataId).values,i=c.data.get(f.dataId).values,[j,k]=tI(g,d.shape,d.dtype,h,e.shape,i,f.shape);return[c.makeTensorInfo([j.length],"int32",j),c.makeTensorInfo([k.length],d.dtype,k)]}},{kernelName:b5,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{shape:e,values:f,defaultValue:g,rowPartitionTensors:h}=b,{rowPartitionTypes:i}=d,j=c.data.get(e.dataId).values,k=c.data.get(f.dataId).values,l=c.data.get(g.dataId).values,m=h.map(a=>c.data.get(a.dataId).values),n=h.map(a=>a.shape),[o,p]=tN(j,e.shape,k,f.shape,f.dtype,l,g.shape,m,n,i);return c.makeTensorInfo(o,f.dtype,p)}},{kernelName:b6,backendName:"cpu",kernelFunc:function(a){let{backend:b,attrs:c}=a,{start:d,stop:e,dtype:f,step:g}=c,h=tO(d,e,g,f);return b.makeTensorInfo([h.length],f,h)}},{kernelName:b7,backendName:"cpu",kernelFunc:sR},uR,{kernelName:b8,backendName:"cpu",kernelFunc:u9},{kernelName:b9,backendName:"cpu",kernelFunc:uk},{kernelName:cf,backendName:"cpu",kernelFunc:ul},{kernelName:ca,backendName:"cpu",kernelFunc:uo},{kernelName:cd,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{images:e}=b,{alignCorners:f,halfPixelCenters:g,size:h}=d;sJ(e,"resizeBilinear");let i=iV.computeStrides(e.shape),[j,k]=h,[l,m,n,o]=e.shape,p=c.data.get(e.dataId).values,q=new Float32Array(iV.sizeFromShape([l,j,k,o])),r=[f&&j>1?m-1:m,f&&k>1?n-1:n],s=[f&&j>1?j-1:j,f&&k>1?k-1:k],t=0,u=r[0]/s[0],v=r[1]/s[1];for(let a=0;a<l;a++)for(let b=0;b<j;b++){let c,d=Math.max(0,Math.floor(c=g?u*(b+.5)-.5:u*b)),e=c-d,f=Math.min(m-1,Math.ceil(c)),h=a*i[0]+d*i[1],j=a*i[0]+f*i[1];for(let a=0;a<k;a++){let b,c=Math.max(0,Math.floor(b=g?v*(a+.5)-.5:v*a)),d=b-c,f=Math.min(n-1,Math.ceil(b)),k=h+c*i[2],l=j+c*i[2],m=h+f*i[2],r=j+f*i[2];for(let a=0;a<o;a++){let b=p[k+a],c=p[l+a],f=p[m+a],g=p[r+a],h=b+(f-b)*d,i=h+(c+(g-c)*d-h)*e;q[t++]=i}}}return c.makeTensorInfo([l,j,k,o],"float32",q)}},{kernelName:ce,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{images:e,dy:f}=b,{alignCorners:g}=d;sJ([f,e],"resizeBilinearGrad");let h=iV.computeStrides(e.shape),[i,j,k,l]=e.shape,[,m,n]=f.shape,o=new Float32Array(i*j*k*l),p=[g&&m>1?j-1:j,g&&n>1?k-1:k],q=[g&&m>1?m-1:m,g&&n>1?n-1:n],r=p[0]/q[0],s=p[1]/q[1],t=c.data.get(f.dataId).values,u=0;for(let a=0;a<i;a++){let b=a*h[0];for(let a=0;a<m;a++){let c=a*r,d=Math.floor(c),e=Math.min(Math.ceil(c),j-1),f=b+d*h[1],g=b+e*h[1],i=c-d,m=1-i;for(let a=0;a<n;a++){let b=a*s,c=Math.floor(b),d=Math.min(Math.ceil(b),k-1),e=b-c,j=1-e,n=f+c*h[2],p=f+d*h[2],q=g+c*h[2],r=g+d*h[2],v=m*j,w=m*e,x=i*j,y=i*e;for(let a=0;a<l;a++){let b=t[u++];o[n+a]+=b*v,o[p+a]+=b*w,o[q+a]+=b*x,o[r+a]+=b*y}}}}return c.makeTensorInfo([i,k,j,l],"float32",o)}},{kernelName:cb,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{images:e}=b,{alignCorners:f,halfPixelCenters:g,size:h}=d;sJ(e,"resizeNearestNeighbor");let i=iV.computeStrides(e.shape),[j,k]=h,[l,m,n,o]=e.shape,p=c.data.get(e.dataId).values,q=new Float32Array(l*j*k*o),r=[f&&j>1?m-1:m,f&&k>1?n-1:n],s=[f&&j>1?j-1:j,f&&k>1?k-1:k],t=r[0]/s[0],u=r[1]/s[1],v=0;for(let a=0;a<l;a++){let b=a*i[0];for(let a=0;a<j;a++){let c=g?t*(a+.5):t*a,d=Math.min(m-1,f?Math.round(c):Math.floor(c));g&&(d=Math.max(0,d));let e=b+d*i[1];for(let a=0;a<k;a++){let b=g?u*(a+.5):u*a,c=Math.min(n-1,f?Math.round(b):Math.floor(b));g&&(c=Math.max(0,c));let d=e+c*i[2];for(let a=0;a<o;a++){let b=p[d+a];q[v++]=b}}}}return c.makeTensorInfo([l,j,k,o],e.dtype,q)}},{kernelName:cc,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{images:e,dy:f}=b,{alignCorners:g}=d;sJ([f,e],"resizeNearestNeighborGrad");let h=iV.computeStrides(e.shape),i=iV.computeStrides(f.shape),[j,k,l,m]=e.shape,[,n,o]=f.shape,p=new Float32Array(j*k*l*m),q=c.data.get(f.dataId).values,r=[g&&n>1?k-1:k,g&&o>1?l-1:l],s=[g&&n>1?n-1:n,g&&o>1?o-1:o],t=r[0]/s[0],u=r[1]/s[1],v=1/t,w=1/u,x=2*Math.ceil(v)+2,y=2*Math.ceil(w)+2;for(let a=0;a<j;a++){let b=a*h[0];for(let a=0;a<k;a++){let c=b+a*h[1],d=Math.floor(Math.floor(a*v)-x/2);for(let e=0;e<l;e++){let f=c+e*h[2],j=Math.floor(Math.floor(e*w)-y/2);for(let c=0;c<m;c++){let h=0;for(let f=0;f<x;f++){let m=f+d;if(m<0||m>=n)continue;let p=b+m*i[1],r=m*t;if(a===Math.min(k-1,g?Math.round(r):Math.floor(r)))for(let a=0;a<y;a++){let b=a+j;if(b<0||b>=o)continue;let d=p+b*i[2],f=b*u;e===Math.min(l-1,g?Math.round(f):Math.floor(f))&&(h+=q[d+c])}}p[f+c]=h}}}}return c.makeTensorInfo(e.shape,e.dtype,p)}},{kernelName:cg,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{dims:f}=d;sJ(e,"reverse");let g=e.shape.length,h=iV.parseAxisParam(f,e.shape);if(0===g)return sQ({inputs:{x:e},backend:c});let i=new dh(e.shape,e.dtype),j=c.bufferSync(e);for(let a=0;a<i.size;a++){let b=i.indexToLoc(a),c=b.slice();h.forEach(a=>c[a]=e.shape[a]-1-c[a]),i.set(j.get(...c),...b)}return c.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:cU,backendName:"cpu",kernelFunc:({inputs:a,attrs:b,backend:c})=>{let{image:d}=a,{radians:e,fillValue:f,center:g}=b,h=iV.getTypedArrayFromDType(d.dtype,iV.sizeFromShape(d.shape)),[i,j,k,l]=d.shape,[m,n]=hp.getImageCenter(g,j,k),o=Math.sin(e),p=Math.cos(e),q=c.data.get(d.dataId).values;for(let a=0;a<i;a++){let b=a*k*j*l;for(let a=0;a<j;a++){let c=k*l*a;for(let d=0;d<k;d++){let e=d*l;for(let g=0;g<l;g++){let r=[i,a,d,g],s=r[2],t=r[1],u=(s-m)*p-(t-n)*o,v=(s-m)*o+(t-n)*p;u=Math.round(u+m),v=Math.round(v+n);let w=f;"number"!=typeof f&&(w=3===g?255:f[g]),u>=0&&u<k&&v>=0&&v<j&&(w=q[b+k*l*v+u*l+g]),h[b+c+e+g]=w}}}}return{dataId:c.write(h,d.shape,d.dtype),shape:d.shape,dtype:d.dtype}}},{kernelName:ch,backendName:"cpu",kernelFunc:va},{kernelName:ci,backendName:"cpu",kernelFunc:tQ},{kernelName:cj,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{indices:e,updates:f}=b,{shape:g}=d,{sliceRank:h,numUpdates:i,sliceSize:j,strides:k,outputSize:l}=hp.calculateShapes(f,e,g),m=tR(c.bufferSync(e),c.bufferSync(f),g,l,j,i,h,k,0,!0);return c.makeTensorInfo(g,m.dtype,m.values)}},{kernelName:cl,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{sortedSequence:e,values:f}=b,{side:g}=d,h=function(a,b,c,d,e,f){let g=iV.getArrayFromDType("int32",c*e);for(let h=0;h<c;++h){let c=a.slice(h*d,(h+1)*d),i=h*e;for(let a=0;a<e;++a)g[i+a]="left"===f?function(a,b){let c=0,d=a.length,e=0;for(;c<d;)a[e=Math.floor((c+d)/2)]<b?c=e+1:d=e;return d}(c,b[a+i]):function(a,b){let c=0,d=a.length,e=0;for(;c<d;)a[e=Math.floor((c+d)/2)]<=b?c=e+1:d=e;return d}(c,b[a+i])}return g}(c.data.get(e.dataId).values,c.data.get(f.dataId).values,e.shape[0],e.shape[1],f.shape[1],g);return c.makeTensorInfo(f.shape,"int32",h)}},{kernelName:cm,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c}=a,{condition:d,t:e,e:f}=b;sJ([d,e,f],"select");let g=d.shape.length,h=c.data.get(d.dataId).values,i=c.data.get(e.dataId).values,j=c.data.get(f.dataId).values,k=dp(e.dtype,f.dtype),l=iV.makeZerosTypedArray(iV.sizeFromShape(e.shape),k),m=0,n=0===g||g>1||1===e.shape.length?1:iV.sizeFromShape(e.shape.slice(1));for(let a=0;a<h.length;a++)for(let b=0;b<n;b++)1===h[a]?l[m++]=i[a]:l[m++]=j[a];return c.makeTensorInfo(e.shape,k,l)}},{kernelName:cn,backendName:"cpu",kernelFunc:vd},{kernelName:cr,backendName:"cpu",kernelFunc:tT},{kernelName:cq,backendName:"cpu",kernelFunc:ve},{kernelName:"Sin",backendName:"cpu",kernelFunc:vf},{kernelName:cp,backendName:"cpu",kernelFunc:vg},{kernelName:co,backendName:"cpu",kernelFunc:tW},{kernelName:cw,backendName:"cpu",kernelFunc:u1},{kernelName:cs,backendName:"cpu",kernelFunc:vi},{kernelName:cu,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{blockShape:f,paddings:g}=d;sJ([e],"spaceToBatchND");let h=iV.sizeFromShape(f),i=[[0,0]];i.push(...g);for(let a=1+f.length;a<e.shape.length;++a)i.push([0,0]);let j=u7.kernelFunc({inputs:{x:e},backend:c,attrs:{paddings:i,constantValue:0}}),k=hp.getReshaped(j.shape,f,h,!1),l=hp.getPermuted(k.length,f.length,!1),m=hp.getReshapedPermuted(j.shape,f,h,!1),n=uo({inputs:{x:j},backend:c,attrs:{shape:k}}),o=tE({inputs:{x:n},backend:c,attrs:{perm:l}}),p=uo({inputs:{x:o},backend:c,attrs:{shape:m}});return c.disposeIntermediateTensorInfo(j),c.disposeIntermediateTensorInfo(n),c.disposeIntermediateTensorInfo(o),p}},{kernelName:cx,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c}=a,{indices:d,values:e,denseShape:f,defaultValue:g}=b;if(1!==f.shape.length)throw Error(`Dense shape must be a vector, saw:
        ${f.shape}`);if(2!==d.shape.length)throw Error(`Indices must be a matrix, saw:
        ${d.shape}`);if(1!==e.shape.length)throw Error(`Values must be a vector, saw:
        ${e.shape}`);if(0!==g.shape.length)throw Error(`Default value must be a scalar, saw:
        ${g.shape}`);let h=c.data.get(d.dataId).values,i=c.data.get(e.dataId).values,j=c.data.get(f.dataId).values,k=c.data.get(g.dataId).values[0],[l,m,n,o,p]=tX(h,d.shape,d.dtype,i,e.dtype,j,k);return[c.makeTensorInfo(m,d.dtype,l),c.makeTensorInfo([m[0]],e.dtype,n),c.makeTensorInfo([o.length],"bool",new Uint8Array(o.map(a=>Number(a)))),c.makeTensorInfo([p.length],d.dtype,new Int32Array(p))]}},{kernelName:cy,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c}=a,{inputIndices:d,inputShape:e,newShape:f}=b;if(2!==d.shape.length)throw Error(`Input indices should be a matrix but received shape
        ${d.shape}`);if(1!==e.shape.length)throw Error(`Input shape should be a vector but received shape
        ${e.shape}`);if(1!==f.shape.length)throw Error(`Target shape should be a vector but received shape ${f.shape}`);let g=Array.from(c.data.get(e.dataId).values),h=c.data.get(d.dataId).values,i=Array.from(c.data.get(f.dataId).values),[j,k,l]=tY(h,d.shape,d.dtype,g,i);return[c.makeTensorInfo(k,d.dtype,j),c.makeTensorInfo([l.length],f.dtype,new Int32Array(l))]}},{kernelName:cz,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c}=a,{data:d,indices:e,segmentIds:f}=b;if(d.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==e.shape.length)throw Error(`Indices should be a vector but received shape
          ${e.shape}`);if(1!==f.shape.length)throw Error(`Segment ids should be a vector but received shape
          ${f.shape}`);if(e.shape[0]!==f.shape[0])throw Error("segmentIds and indices should have same size.");let g=c.data.get(d.dataId).values,h=c.data.get(e.dataId).values,i=c.data.get(f.dataId).values,[j,k]=tZ(g,d.shape,d.dtype,h,i,!0);return c.makeTensorInfo(k,d.dtype,j)}},{kernelName:cA,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c}=a,{data:d,indices:e,segmentIds:f}=b;if(d.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==e.shape.length)throw Error(`Indices should be a vector but received shape
         ${e.shape}`);if(1!==f.shape.length)throw Error(`Segment ids should be a vector but received shape
         ${f.shape}`);if(e.shape[0]!==f.shape[0])throw Error("segmentIds and indices should have same size.");let g=c.data.get(d.dataId).values,h=c.data.get(e.dataId).values,i=c.data.get(f.dataId).values,[j,k]=tZ(g,d.shape,d.dtype,h,i);return c.makeTensorInfo(k,d.dtype,j)}},{kernelName:cB,backendName:"cpu",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{sparseIndices:f,sparseValues:g,defaultValue:h}=c,{outputShape:i}=e,{sliceRank:j,numUpdates:k,sliceSize:l,strides:m,outputSize:n}=hp.calculateShapes(g,f,i),o=d.bufferSync(f);switch(g.dtype){case"bool":b=tR(o,d.bufferSync(g),i,n,l,k,j,m,!!d.data.get(h.dataId).values[0],!1);break;case"float32":case"int32":b=tR(o,d.bufferSync(g),i,n,l,k,j,m,d.data.get(h.dataId).values[0],!1);break;case"string":b=tR(o,d.bufferSync(g),i,n,l,k,j,m,iV.decodeString(d.data.get(h.dataId).values[0]),!1);break;default:throw Error(`Unsupported type ${g.dtype}`)}return d.makeTensorInfo(i,b.dtype,b.values)}},{kernelName:cv,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{numOrSizeSplits:f,axis:g}=d,h=iV.parseAxisParam(g,e.shape)[0],i=hp.prepareSplitSize(e,f,h),j=Array(e.shape.length).fill(0),k=e.shape.slice();return i.map(a=>{let b=[...k];b[h]=a;let d=tW({inputs:{x:e},backend:c,attrs:{begin:j,size:b}});return j[h]+=a,d})}},{kernelName:ct,backendName:"cpu",kernelFunc:t_},{kernelName:cD,backendName:"cpu",kernelFunc:({inputs:a,backend:b})=>{let{x:c}=a;sJ(c,"square");let d=b.data.get(c.dataId).values,e=new Float32Array(d.length);for(let a=0;a<d.length;++a){let b=d[a];e[a]=b*b}return{dataId:b.write(e,c.shape,c.dtype),shape:c.shape,dtype:c.dtype}}},{kernelName:cC,backendName:"cpu",kernelFunc:t1},{kernelName:cE,backendName:"cpu",kernelFunc:t3},{kernelName:cS,backendName:"cpu",kernelFunc:vj},{kernelName:cF,backendName:"cpu",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f}=c,{begin:g,end:h,strides:i,beginMask:j,endMask:k,ellipsisMask:l,newAxisMask:m,shrinkAxisMask:n}=e;sJ(f,"stridedSlice");let{finalShapeSparse:o,finalShape:p,isIdentity:q,sliceDim0:r,isSimpleSlice:s,begin:t,end:u,strides:v}=tU.sliceInfo(f.shape,g,h,i,j,k,l,m,n);if(q)b=uo({inputs:{x:f},backend:d,attrs:{shape:p}});else if(r||s){iV.assert(f.shape.length>=1,()=>`Input must have rank at least 1, got: ${f.shape.length}`);let a=tU.computeOutShape(t,u,v),c=tW({inputs:{x:f},backend:d,attrs:{begin:t,size:a}});b=uo({inputs:{x:c},backend:d,attrs:{shape:p}}),d.disposeIntermediateTensorInfo(c)}else{let a=t4(o,d.bufferSync(f),v,t);b=d.makeTensorInfo(p,a.dtype,a.values)}return b}},{kernelName:cG,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{separator:e,nGramWidths:f,leftPad:g,rightPad:h,padWidth:i,preserveShortSequences:j}=d,{data:k,dataSplits:l}=b,[m,n]=t6(c.data.get(k.dataId).values,c.data.get(l.dataId).values,e,f,g,h,i,j);return[c.makeTensorInfo([m.length],"string",m),c.makeTensorInfo(l.shape,"int32",n)]}},{kernelName:cH,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{skipEmpty:e}=d,{input:f,delimiter:g}=b;if("string"!==f.dtype)throw Error("Input must be of datatype string");if(1!==f.shape.length)throw Error(`Input must be a vector, got shape: ${f.shape}`);if(0!==g.shape.length)throw Error(`Delimiter must be a scalar, got shape: ${g.shape}`);let[h,i,j]=t7(c.data.get(f.dataId).values,c.data.get(g.dataId).values[0],e),k=i.length;return[c.makeTensorInfo([k,2],"int32",h),c.makeTensorInfo([k],"string",i),c.makeTensorInfo([2],"int32",new Int32Array(j))]}},{kernelName:cI,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{numBuckets:e}=d,{input:f}=b;if("string"!==f.dtype)throw Error("Input must be of datatype string");if(e<=0)throw Error("Number of buckets must be at least 1");let g=t8(c.data.get(f.dataId).values,e);return c.makeTensorInfo(f.shape,"int32",g)}},{kernelName:"Sub",backendName:"cpu",kernelFunc:ua},{kernelName:"Sum",backendName:"cpu",kernelFunc:uH},{kernelName:"Tan",backendName:"cpu",kernelFunc:vk},{kernelName:cJ,backendName:"cpu",kernelFunc:vl},{kernelName:ck,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c}=a,{tensor:d,indices:e,updates:f}=b,{sliceRank:g,numUpdates:h,sliceSize:i,strides:j,outputSize:k}=hp.calculateShapes(f,e,d.shape),l=c.bufferSync(e),m=c.bufferSync(f),n=c.bufferSync(d),o=tR(l,m,d.shape,k,i,h,g,j,n,!1);return c.makeTensorInfo(d.shape,o.dtype,o.values)}},{kernelName:cK,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{reps:f}=d;sJ(e,"tile");let g=ub(c.bufferSync(e),f);return c.makeTensorInfo(g.shape,g.dtype,g.values)}},{kernelName:cL,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{k:f,sorted:g}=d;sJ(e,"topk");let[h,i]=ud(c.data.get(e.dataId).values,e.shape,e.dtype,f,g);return[c.makeTensorInfo(h.shape,h.dtype,h.values),c.makeTensorInfo(i.shape,i.dtype,i.values)]}},{kernelName:cM,backendName:"cpu",kernelFunc:function(a){let{inputs:b,attrs:c,backend:d}=a,{image:e,transforms:f}=b,{interpolation:g,fillMode:h,fillValue:i,outputShape:j}=c,[k,l,m,n]=e.shape,[o,p]=null!=j?j:[l,m],q=[k,o,p,n],r=iV.computeStrides(e.shape),s=r[0],t=r[1],u=r[2],v=iV.computeStrides(q),w=v[0],x=v[1],y=v[2],z=iV.getTypedArrayFromDType(e.dtype,iV.sizeFromShape(q));z.fill(i);let A=d.data.get(e.dataId).values,B=d.data.get(f.dataId).values;for(let a=0;a<k;++a){let b=1===f.shape[0]?B:B.subarray(8*a,8*a+8);for(let c=0;c<o;++c)for(let d=0;d<p;++d)for(let e=0;e<n;++e){let f,j=b[6]*d+b[7]*c+1;if(0===j)continue;let k=(b[0]*d+b[1]*c+b[2])/j,n=(b[3]*d+b[4]*c+b[5])/j,o=vm(k,m,h),p=vm(n,l,h);switch(g){case"nearest":f=vn(A,l,m,s,t,u,a,Math.round(p),Math.round(o),e,i);break;case"bilinear":f=function(a,b,c,d,e,f,g,h,i,j,k){let l=Math.floor(h),m=Math.floor(i),n=l+1,o=m+1,p=(o-i)*vn(a,b,c,d,e,f,g,l,m,j,k)+(i-m)*vn(a,b,c,d,e,f,g,l,o,j,k),q=(o-i)*vn(a,b,c,d,e,f,g,n,m,j,k)+(i-m)*vn(a,b,c,d,e,f,g,n,o,j,k);return(n-h)*p+(h-l)*q}(A,l,m,s,t,u,a,p,o,e,i);break;default:throw Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${g}`)}z[a*w+c*x+d*y+e]=f}return d.makeTensorInfo(q,e.dtype,z)}return{dataId:d.write(z,q,e.dtype),shape:e.shape,dtype:e.dtype}}},{kernelName:cN,backendName:"cpu",kernelFunc:tE},{kernelName:cO,backendName:"cpu",kernelFunc:function(a){let{inputs:b,attrs:c,backend:d}=a,{axis:e}=c,{x:f}=b;sJ(f,"unique");let{outputValues:g,outputShape:h,indices:i}=ue(d.data.get(f.dataId).values,e,f.shape,f.dtype);return[d.makeTensorInfo(h,f.dtype,g),d.makeTensorInfo([i.length],"int32",i)]}},{kernelName:cP,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{value:e}=b,{axis:f}=d;f<0&&(f+=e.shape.length);let g=e.shape.length,h=e.shape[f],i=Array(g-1),j=0;for(let a=0;a<g;a++)a!==f&&(i[j++]=e.shape[a]);let k=Array(g).fill(0),l=e.shape.slice();l[f]=1;let m=Array(h);for(let a=0;a<m.length;a++){k[f]=a;let b=tW({inputs:{x:e},backend:c,attrs:{begin:k,size:l}});m[a]=uo({inputs:{x:b},backend:c,attrs:{shape:i}}),c.disposeIntermediateTensorInfo(b)}return m}},{kernelName:cQ,backendName:"cpu",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,segmentIds:f}=b,{numSegments:g}=d;sJ(e,"unsortedSegmentSum");let h=e.shape.length,i=f.shape.length,j=[],k=[],l=h-i,m=f;for(let a=0;a<l;++a){let b=uP({inputs:{input:m},backend:c,attrs:{dim:a+1}});m=b,k.push(b)}for(let a=0;a<g;++a){let b=iV.createScalarValue(a,"int32"),d=c.makeTensorInfo([],"int32",b),f=s7({inputs:{a:d,b:m},backend:c}),g=sT({inputs:{x:f},backend:c,attrs:{dtype:"float32"}}),h=tz({inputs:{a:g,b:e},backend:c}),i=uH({inputs:{x:h},backend:c,attrs:{axis:0,keepDims:!1}});j.push(i),k.push(d),k.push(f),k.push(g),k.push(h),k.push(i)}let n=u6({inputs:j,backend:c,attrs:{axis:0}});return k.forEach(a=>c.disposeIntermediateTensorInfo(a)),n}},{kernelName:cR,backendName:"cpu",kernelFunc:u5}])c2(a);var vo=a.i(550695),vo=vo,vo=vo,iV=iV;let vp={},vq={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function vr(a,b){vp[a]=b}function vs(a,b){if(!(a in vp)||null!=b){let c=function(a,b){if(1!==a&&2!==a)throw Error("Cannot get WebGL rendering context, WebGL is disabled.");let c=null==b?function(a){if(!aw.getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===a)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw Error("Cannot create a canvas in this context")}(a):b;return(c.addEventListener("webglcontextlost",b=>{b.preventDefault(),delete vp[a]},!1),aw.getBool("SOFTWARE_WEBGL_ENABLED")&&(vq.failIfMajorPerformanceCaveat=!1),1===a)?c.getContext("webgl",vq)||c.getContext("experimental-webgl",vq):c.getContext("webgl2",vq)}(a,b);if(null===c)return console.log("Could not get context for WebGL version",a),null;vp[a]=c}let c=vp[a];return null==c||c.isContextLost()?(delete vp[a],vs(a)):(c.disable(c.DEPTH_TEST),c.disable(c.STENCIL_TEST),c.disable(c.BLEND),c.disable(c.DITHER),c.disable(c.POLYGON_OFFSET_FILL),c.disable(c.SAMPLE_COVERAGE),c.enable(c.SCISSOR_TEST),c.enable(c.CULL_FACE),c.cullFace(c.BACK),vp[a])}var iV=iV;function vt(a){let b=Math.ceil(iV.sizeFromShape(a)/4);return iV.sizeToSquarishShape(b)}function vu(a,b){return[Math.max(1,Math.ceil(b/2)),Math.max(1,Math.ceil(a/2))]}function vv(a,b){let c,d,e,f,g,h,i,j,k,l;return 2===aw.getNumber("WEBGL_VERSION")?(c=a.R32F,d=a.R16F,e=a.RGBA16F,f=a.RGBA32F,g=a.RED,i=4,j=1,k=a.HALF_FLOAT,l=a.FLOAT,h=a.RGBA8):(c=a.RGBA,d=a.RGBA,e=a.RGBA,f=a.RGBA,g=a.RGBA,i=4,j=4,k=null!=b?b.HALF_FLOAT_OES:null,l=a.FLOAT,h=a.RGBA),{internalFormatFloat:c,internalFormatHalfFloat:d,internalFormatPackedHalfFloat:e,internalFormatPackedFloat:f,textureFormatFloat:g,downloadTextureFormat:h,downloadUnpackNumChannels:i,defaultNumChannels:j,textureTypeHalfFloat:k,textureTypeFloat:l}}function vw(a,b){let c=b();return aw.getBool("DEBUG")&&function(a){let b=a.getError();if(b!==a.NO_ERROR)throw Error("WebGL Error: "+vy(a,b))}(a),c}function vx(a){return!!(aw.getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===a||596e-10<Math.abs(a)&&65504>Math.abs(a))}function vy(a,b){switch(b){case a.NO_ERROR:return"NO_ERROR";case a.INVALID_ENUM:return"INVALID_ENUM";case a.INVALID_VALUE:return"INVALID_VALUE";case a.INVALID_OPERATION:return"INVALID_OPERATION";case a.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case a.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case a.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${b}`}}function vz(a,b){return vY(a,()=>a.getExtension(b),'Extension "'+b+'" not supported on this browser.')}function vA(a,b){let c=vY(a,()=>a.createShader(a.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(vw(a,()=>a.shaderSource(c,b)),vw(a,()=>a.compileShader(c)),!1===a.getShaderParameter(c,a.COMPILE_STATUS))throw console.log(a.getShaderInfoLog(c)),Error("Failed to compile vertex shader.");return c}function vB(a,b){let c=vY(a,()=>a.createShader(a.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(vw(a,()=>a.shaderSource(c,b)),vw(a,()=>a.compileShader(c)),aw.get("ENGINE_COMPILE_ONLY"))return c;if(!1===a.getShaderParameter(c,a.COMPILE_STATUS))throw vD(b,a.getShaderInfoLog(c)),Error("Failed to compile fragment shader.");return c}(BD=BS||(BS={}))[BD.DENSE=0]="DENSE",BD[BD.SHARED_BATCH=1]="SHARED_BATCH",(BE=BT||(BT={}))[BE.RENDER=0]="RENDER",BE[BE.UPLOAD=1]="UPLOAD",BE[BE.PIXELS=2]="PIXELS",BE[BE.DOWNLOAD=3]="DOWNLOAD",(BF=BU||(BU={}))[BF.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",BF[BF.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",BF[BF.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",BF[BF.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",BF[BF.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16";let vC=/ERROR: [0-9]+:([0-9]+):/g;function vD(a,b){let c=vC.exec(b);if(null==c){console.log(`Couldn't parse line number in error: ${b}`),console.log(a);return}let d=+c[1],e=a.split("\n"),f=e.length.toString().length+2,g=e.map((a,b)=>iV.rightPad((b+1).toString(),f)+a),h=0;for(let a=0;a<g.length;a++)h=Math.max(g[a].length,h);let i=g.slice(0,d-1),j=g.slice(d-1,d),k=g.slice(d);console.log(i.join("\n")),console.log(b.split("\n")[0]),console.log(`%c ${iV.rightPad(j[0],h)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(k.join("\n"))}function vE(a){return vY(a,()=>a.createProgram(),"Unable to create WebGLProgram.")}function vF(a,b){if(vw(a,()=>a.linkProgram(b)),!aw.get("ENGINE_COMPILE_ONLY")&&!1===a.getProgramParameter(b,a.LINK_STATUS))throw console.log(a.getProgramInfoLog(b)),Error("Failed to link vertex and fragment shaders.")}function vG(a,b){if(vw(a,()=>a.validateProgram(b)),!1===a.getProgramParameter(b,a.VALIDATE_STATUS))throw console.log(a.getProgramInfoLog(b)),Error("Shader program validation failed.")}function vH(a,b){let c=vY(a,()=>a.createBuffer(),"Unable to create WebGLBuffer");return vw(a,()=>a.bindBuffer(a.ARRAY_BUFFER,c)),vw(a,()=>a.bufferData(a.ARRAY_BUFFER,b,a.STATIC_DRAW)),c}function vI(a,b){let c=vY(a,()=>a.createBuffer(),"Unable to create WebGLBuffer");return vw(a,()=>a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,c)),vw(a,()=>a.bufferData(a.ELEMENT_ARRAY_BUFFER,b,a.STATIC_DRAW)),c}function vJ(){return 2===aw.getNumber("WEBGL_VERSION")?1:4}function vK(a){return vY(a,()=>a.createTexture(),"Unable to create WebGLTexture.")}function vL(a,b){let c=aw.getNumber("WEBGL_MAX_TEXTURE_SIZE");if(a<=0||b<=0)throw Error(`Requested texture size [${a}x${b}] is invalid.`);if(a>c||b>c)throw Error(`Requested texture size [${a}x${b}] greater than WebGL maximum on this browser / GPU [${c}x${c}].`)}function vM(a){return vY(a,()=>a.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function vN(a,b,c,d,e,f,g){let h=a.getAttribLocation(b,c);return -1!==h&&(vw(a,()=>a.bindBuffer(a.ARRAY_BUFFER,d)),vw(a,()=>a.vertexAttribPointer(h,e,a.FLOAT,!1,f,g)),vw(a,()=>a.enableVertexAttribArray(h)),!0)}function vO(a,b,c){vZ(a,c),vw(a,()=>a.activeTexture(a.TEXTURE0+c)),vw(a,()=>a.bindTexture(a.TEXTURE_2D,b))}function vP(a,b){vZ(a,b),vw(a,()=>a.activeTexture(a.TEXTURE0+b)),vw(a,()=>a.bindTexture(a.TEXTURE_2D,null))}function vQ(a,b,c){return vY(a,()=>a.getUniformLocation(b,c),'uniform "'+c+'" not present in program.')}function vR(a,b,c){return a.getUniformLocation(b,c)}function vS(a,b,c,d){vw(a,()=>vO(a,b,d)),vw(a,()=>a.uniform1i(c,d))}function vT(a){vw(a,()=>a.bindFramebuffer(a.FRAMEBUFFER,null)),vw(a,()=>a.viewport(0,0,a.canvas.width,a.canvas.height)),vw(a,()=>a.scissor(0,0,a.canvas.width,a.canvas.height))}function vU(a,b,c){vw(a,()=>a.bindFramebuffer(a.FRAMEBUFFER,c)),vw(a,()=>a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,b,0))}function vV(a,b){vw(a,()=>a.bindFramebuffer(a.FRAMEBUFFER,b)),vw(a,()=>a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,null,0))}function vW(a){let b=a.checkFramebufferStatus(a.FRAMEBUFFER);if(b!==a.FRAMEBUFFER_COMPLETE)throw Error("Error binding framebuffer: "+vX(a,b))}function vX(a,b){switch(b){case a.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case a.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case a.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case a.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${b}`}}function vY(a,b,c){let d=vw(a,()=>b());if(null==d)throw Error(c);return d}function vZ(a,b){let c=a.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,d=b+a.TEXTURE0;if(d<a.TEXTURE0||d>c){let a=`[gl.TEXTURE0, gl.TEXTURE${c}]`;throw Error(`textureUnit must be in ${a}.`)}}function v$(a,b=2){return iV.sizeFromShape(a.slice(0,a.length-b))}function v_(a){if(0===a.length)throw Error("Cannot get rows and columns of an empty shape array.");return[a.length>1?a[a.length-2]:1,a[a.length-1]]}function v0(a){let b=[1,1,1];return 0!==a.length&&(1!==a.length||1!==a[0])&&(b=[v$(a),...v_(a)]),b}function v1(a,b=!1){let c=aw.getNumber("WEBGL_MAX_TEXTURE_SIZE"),d=aw.getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");d===1/0&&aw.getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(d=c/2),b&&(c*=2,d*=2,1===(a=a.map((b,c)=>c>=a.length-2?iV.nearestLargerEven(a[c]):a[c])).length&&(a=[2,a[0]])),2!==a.length&&(a=iV.squeezeShape(a).newShape);let e=iV.sizeFromShape(a),f=null;a.length<=1&&e<=c?f=[1,e]:2===a.length&&a[0]<=c&&a[1]<=c?f=a:3===a.length&&a[0]*a[1]<=c&&a[2]<=c?f=[a[0]*a[1],a[2]]:3===a.length&&a[0]<=c&&a[1]*a[2]<=c?f=[a[0],a[1]*a[2]]:4===a.length&&a[0]*a[1]*a[2]<=c&&a[3]<=c?f=[a[0]*a[1]*a[2],a[3]]:4===a.length&&a[0]<=c&&a[1]*a[2]*a[3]<=c&&(f=[a[0],a[1]*a[2]*a[3]]);let g=null!=f&&Math.max(...f)>d&&Math.min(...f)<=(b?2:1)&&Math.min(...f)>0;if(null==f||g)if(b){let b=v$(a),c=2,d=2;a.length&&([c,d]=v_(a)),e=c/2*b*(d/2),f=iV.sizeToSquarishShape(e).map(a=>2*a)}else f=iV.sizeToSquarishShape(e);return f}function v2(a,b){if(a=a.slice(-2),b=b.slice(-2),iV.arraysEqual(a,b)||!a.length||!b.length||0===a[0]||0===a[1]||0===b[0]||0===b[1])return!0;if(a.length!==b.length){let c=a[a.length-1],d=b[b.length-1];if(c===d||c%2==0&&d%2==0&&(1===a[0]||1===b[0]))return!0}return a[1]===b[1]&&a[0]%2==0&&b[0]%2==0}function v3(a){if(null==g){let b=vs(a);g=b.getParameter(b.MAX_TEXTURE_SIZE)}return g}function v4(){g=null}function v5(){h=null}function v6(a){if(null==h){let b=vs(a);h=b.getParameter(b.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,h)}function v7(a){if(0===a)return 0;let b=vs(a);return v8(b,"EXT_disjoint_timer_query_webgl2")&&2===a?2:+!!v8(b,"EXT_disjoint_timer_query")}function v8(a,b){return null!=a.getExtension(b)}function v9(a){try{let b=vs(a);if(null!=b)return!0}catch(a){console.log("Error when getting WebGL context: ",a)}return!1}function wa(a){if(0===a)return!1;let b=vs(a);if(1===a){if(!v8(b,"OES_texture_float"))return!1}else if(!v8(b,"EXT_color_buffer_float"))return!1;return wc(b)}function wb(a){if(0===a)return!1;let b=vs(a);if(1===a){if(!v8(b,"OES_texture_float")||!v8(b,"WEBGL_color_buffer_float"))return!1}else{if(v8(b,"EXT_color_buffer_float"))return wc(b);let a="EXT_color_buffer_half_float";if(v8(b,a)){var c;let d,e,f,g,h=b.getExtension(a);return d=vv(c=b,h),e=c.createTexture(),c.bindTexture(c.TEXTURE_2D,e),c.texImage2D(c.TEXTURE_2D,0,d.internalFormatHalfFloat,1,1,0,d.textureFormatFloat,d.textureTypeHalfFloat,null),f=c.createFramebuffer(),c.bindFramebuffer(c.FRAMEBUFFER,f),c.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_2D,e,0),g=c.checkFramebufferStatus(c.FRAMEBUFFER)===c.FRAMEBUFFER_COMPLETE,c.bindTexture(c.TEXTURE_2D,null),c.bindFramebuffer(c.FRAMEBUFFER,null),c.deleteTexture(e),c.deleteFramebuffer(f),g}return!1}return wc(b)}function wc(a){let b=vv(a),c=a.createTexture();a.bindTexture(a.TEXTURE_2D,c),a.texImage2D(a.TEXTURE_2D,0,b.internalFormatFloat,1,1,0,b.textureFormatFloat,b.textureTypeFloat,null);let d=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,d),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,c,0);let e=a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE;return a.bindTexture(a.TEXTURE_2D,null),a.bindFramebuffer(a.FRAMEBUFFER,null),a.deleteTexture(c),a.deleteFramebuffer(d),e}function wd(a){return 2===a&&null!=vs(a).fenceSync}function we(a,b){Array.isArray(a)||(a=[a]),a.forEach(a=>{null!=a&&iV.assert("complex64"!==a.dtype,()=>`${b} does not support complex64 tensors in the WebGL backend.`)})}a.s(["assertNotComplex",()=>we,"bindCanvasToFramebuffer",()=>vT,"bindColorTextureToFramebuffer",()=>vU,"bindTextureToProgramUniformSampler",()=>vS,"bindTextureUnit",()=>vO,"bindVertexBufferToProgramAttribute",()=>vN,"callAndCheck",()=>vw,"canBeRepresented",()=>vx,"createFragmentShader",()=>vB,"createFramebuffer",()=>vM,"createProgram",()=>vE,"createStaticIndexBuffer",()=>vI,"createStaticVertexBuffer",()=>vH,"createTexture",()=>vK,"createVertexShader",()=>vA,"getBatchDim",()=>v$,"getExtensionOrThrow",()=>vz,"getFramebufferErrorMessage",()=>vX,"getMaxTexturesInShader",()=>v6,"getNumChannels",()=>vJ,"getProgramUniformLocation",()=>vR,"getProgramUniformLocationOrThrow",()=>vQ,"getRowsCols",()=>v_,"getShapeAs3D",()=>v0,"getTextureShapeFromLogicalShape",()=>v1,"getWebGLDisjointQueryTimerVersion",()=>v7,"getWebGLErrorMessage",()=>vy,"getWebGLMaxTextureSize",()=>v3,"hasExtension",()=>v8,"isCapableOfRenderingToFloatTexture",()=>wa,"isDownloadFloatTextureEnabled",()=>wb,"isReshapeFree",()=>v2,"isWebGLFenceEnabled",()=>wd,"isWebGLVersionEnabled",()=>v9,"linkProgram",()=>vF,"logShaderSourceAndInfoLog",()=>vD,"resetMaxTextureSize",()=>v4,"resetMaxTexturesInShader",()=>v5,"unbindColorTextureFromFramebuffer",()=>vV,"unbindTextureUnit",()=>vP,"validateFramebuffer",()=>vW,"validateProgram",()=>vG,"validateTextureSize",()=>vL],982212);let wf=aw;wf.registerFlag("HAS_WEBGL",()=>wf.getNumber("WEBGL_VERSION")>0),wf.registerFlag("WEBGL_VERSION",()=>v9(2)?2:+!!v9(1)),wf.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),wf.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===wf.get("WEBGL_VERSION")),wf.registerFlag("WEBGL_CPU_FORWARD",()=>!0),wf.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),wf.registerFlag("WEBGL_PACK",()=>wf.getBool("HAS_WEBGL")),wf.registerFlag("WEBGL_PACK_NORMALIZATION",()=>wf.getBool("WEBGL_PACK")),wf.registerFlag("WEBGL_PACK_CLIP",()=>wf.getBool("WEBGL_PACK")),wf.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>wf.getBool("WEBGL_PACK")),wf.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>wf.getBool("WEBGL_PACK")),wf.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>wf.getBool("WEBGL_PACK")),wf.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>wf.getBool("WEBGL_PACK")),wf.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>wf.getBool("WEBGL_PACK")),wf.registerFlag("WEBGL_PACK_REDUCE",()=>wf.getBool("WEBGL_PACK")),wf.registerFlag("WEBGL_LAZILY_UNPACK",()=>wf.getBool("WEBGL_PACK")),wf.registerFlag("WEBGL_CONV_IM2COL",()=>wf.getBool("WEBGL_PACK")),wf.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>wf.getBool("WEBGL_PACK")),wf.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>v3(wf.getNumber("WEBGL_VERSION"))),wf.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>v6(wf.getNumber("WEBGL_VERSION"))),wf.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let a=wf.getNumber("WEBGL_VERSION");return 0===a?0:v7(a)}),wf.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>wf.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!vo.isMobile()),wf.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>wa(wf.getNumber("WEBGL_VERSION"))),wf.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!wf.getBool("WEBGL_FORCE_F16_TEXTURES")&&wf.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),wf.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>wb(wf.getNumber("WEBGL_VERSION"))),wf.registerFlag("WEBGL_FENCE_API_ENABLED",()=>wd(wf.getNumber("WEBGL_VERSION"))),wf.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>4*!!wf.getBool("WEBGL_RENDER_FLOAT32_ENABLED")),wf.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,a=>{if("number"!=typeof a)throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${a}.`);if(a<0&&-1!==a)throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${a}.`)}),wf.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>vo.isMobile()?1:-1,a=>{if("number"!=typeof a)throw Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${a}.`);if(a<0&&-1!==a)throw Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${a}.`)}),wf.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),wf.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),wf.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),wf.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),wf.registerFlag("WEBGL_EXP_CONV",()=>!1),wf.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>wf.getBool("IS_TEST")),wf.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),wf.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),wf.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),wf.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);var hp=hp,sI=sI,iV=iV;function wg(){let a,b,c,d,e,f,g,h,i,j;return 2===aw.getNumber("WEBGL_VERSION")?(a="#version 300 es",b="in",c="out",d="in",e="texture",f="outputColor",g="out vec4 outputColor;",h=aw.getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",i="",j=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(a="",b="attribute",c="varying",d="varying",e="texture2D",f="gl_FragColor",g="",h=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,i=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,j=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:a,attribute:b,varyingVs:c,varyingFs:d,texture2D:e,output:f,defineOutput:g,defineSpecialNaN:h,defineSpecialInf:i,defineRound:j}}var hp=hp,iV=iV,hp=hp,iV=iV,iV=iV;function wh(a,b,c="index"){let d=iV.computeStrides(b);return d.map((b,e)=>{let f=`int ${a[e]} = ${c} / ${b}`,g=e===d.length-1?`int ${a[e+1]} = ${c} - ${a[e]} * ${b}`:`index -= ${a[e]} * ${b}`;return`${f}; ${g};`}).join("")}function wi(a,b,c="index"){let d=iV.computeStrides(b);return d.map((b,e)=>{let f=`int ${a[e]} = ${c} / outShapeStrides[${e}]`,g=e===d.length-1?`int ${a[e+1]} = ${c} - ${a[e]} * outShapeStrides[${e}]`:`index -= ${a[e]} * outShapeStrides[${e}]`;return`${f}; ${g};`}).join("")}function wj(a){let b=iV.computeStrides(a).map(a=>a.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${b[0]} + coords.y * ${b[1]} + coords.z;
  }
`}function wk(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}let wl=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:wm}=hp,wn=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,wo=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,wp=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,wq=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function wr(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function ws(a){return`offset${a}`}function wt(a){let b=a.name,c=iV.sizeFromShape(a.shapeInfo.logicalShape);return c<2?`return ${b};`:`
    for (int i = 0; i < ${c}; i++) {
      if (i == index) {
        return ${b}[i];
      }
    }
  `}function wu(a){if(a<=1)return"int";if(2===a)return"ivec2";if(3===a)return"ivec3";if(4===a)return"ivec4";if(5===a)return"ivec5";else if(6===a)return"ivec6";else throw Error(`GPU for rank ${a} is not yet supported`)}function wv(a,b,c){let{newShape:d,keptDims:e}=iV.squeezeShape(b),f=b.length,g=a&&3===f&&1===b[0],h=g?b.slice(1):d,i=!a&&f>1&&!iV.arraysEqual(b,c)&&d.length<f||g,j=i?h:b;return{useSqueezeShape:i,uniformShape:j,keptDims:e}}function ww(a,b){let c=JSON.parse(JSON.stringify(a));return c.shapeInfo.logicalShape=b,c}function wx(a,b){return b.map(b=>a[b]).join(", ")}function wy(a,b,c){let d,e,f,g=[],h=[],i=null,j=null;for(let d of(j=a.getUniformLocation(c,"NAN",!1),1===aw.getNumber("WEBGL_VERSION")&&(i=a.getUniformLocation(c,"INFINITY",!1)),b.variableNames)){let e={name:d,uniform:a.getUniformLocation(c,d,!1),offset:a.getUniformLocation(c,`offset${d}`,!1)};b.enableShapeUniforms&&(e.shape=a.getUniformLocation(c,`${d}Shape`,!1),e.texShape=a.getUniformLocation(c,`${d}TexShape`,!1)),g.push(e)}if(b.enableShapeUniforms&&(d=a.getUniformLocation(c,"outShape",!1),f=a.getUniformLocation(c,"outShapeStrides",!1),e=a.getUniformLocation(c,"outTexShape",!1)),b.customUniforms)for(let d of b.customUniforms)h.push(a.getUniformLocation(c,d.name,!1));return{variablesLocations:g,customUniformLocations:h,infLoc:i,nanLoc:j,outShapeLocation:d,outShapeStridesLocation:f,outTexShapeLocation:e}}function wz(a,b){if(a.length!==b.length)throw Error(`Binary was compiled with ${a.length} inputs, but was executed with ${b.length} inputs`);a.forEach((a,c)=>{let d=a.logicalShape,e=b[c],f=e.shape;if(!iV.arraysEqual(d,f))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${d} and ${f} must match`);if(a.isUniform&&e.isUniform)return;let g=a.texShape,h=e.isUniform?null:e.texData.texShape;if(!iV.arraysEqual(g,h))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${g} and ${h} must match`)})}function wA(a){return aw.getBool("WEBGL_USE_SHAPES_UNIFORMS")&&a<=4}class wB{constructor(a){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=BS.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const b=wg();this.outputShape=a,this.enableShapeUniforms=wA(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?wi(["r","c","d"],a):wh(["r","c","d"],a)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${b.output} = result;
      }
    `}}class wC{constructor(a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=BS.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const b=wg();this.outputShape=a,this.enableShapeUniforms=wA(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?wi(["r","c","d"],a):wh(["r","c","d"],a)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${b.output} = result;
      }
    `}}class wD{constructor(a){this.variableNames=["A"],this.outTexUsage=BT.DOWNLOAD;const b=wg();this.outputShape=a,this.userCode=`
      ${wl}

      void main() {
        float x = getAAtOutCoords();
        ${b.output} = encode_float(x);
      }
    `}}class wE{constructor(a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=BT.DOWNLOAD;const b=wg();this.outputShape=a,this.userCode=`
      ${wl}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${b.output} = encode_float(x);
      }
    `}}let wF={R:0,G:1,B:2,A:3};class wG{constructor(a,b=!1,c="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const d=wg();this.outputShape=a,this.enableShapeUniforms=wA(this.outputShape.length);let e="result";b&&(e="floor(result * 255. + 0.5)");let f="";for(let a=0;a<c.length;a++){const b=c[a];f+=`
          if(offset == ${a}) {
            result = values[${wF[b]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?wk():wj(a)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${c.length});

        flatIndex = idiv(flatIndex, ${c.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${d.texture2D}(A, uv);
          ${f}
        }
        ${d.output} = vec4(${e}, 0., 0., 0.);
      }
    `}}class wH{constructor(a,b=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const c=wg();this.outputShape=a,this.enableShapeUniforms=wA(this.outputShape.length);let d="",e="result";b&&(e="floor(result * 255. + 0.5)");for(let b=0;b<=1;b++)for(let e=0;e<=1;e++){const f=2*b+e;d+=`
          localCoords = coords;
          if(localCoords[2] + ${e} < ${this.enableShapeUniforms?"outShape[2]":`${a[2]}`}) {
          localCoords[2] += ${e};
          if (localCoords[1] + ${b} < ${this.enableShapeUniforms?"outShape[1]":`${a[1]}`}) {
            localCoords[1] += ${b};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${c.texture2D}(A, uv);

            if (offset == 0) {
              result[${f}] = values[0];
            } else if (offset == 1) {
              result[${f}] = values[1];
            } else if (offset == 2) {
              result[${f}] = values[2];
            } else {
              result[${f}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?wk():wj(a)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${d}

          ${c.output} = ${e};
        }
    `}}var iV=iV;function wI(a){let b=wg();return vA(a,`${b.version}
    precision highp float;
    ${b.attribute} vec3 clipSpacePos;
    ${b.attribute} vec2 uv;
    ${b.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`)}function wJ(a){return vH(a,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function wK(a){return vI(a,new Uint16Array([0,1,2,2,1,3]))}function wL(a,b,c,d,e,f){vL(b,c);let g=vK(a),h=a.TEXTURE_2D;return vw(a,()=>a.bindTexture(h,g)),vw(a,()=>a.texParameteri(h,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE)),vw(a,()=>a.texParameteri(h,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE)),vw(a,()=>a.texParameteri(h,a.TEXTURE_MIN_FILTER,a.NEAREST)),vw(a,()=>a.texParameteri(h,a.TEXTURE_MAG_FILTER,a.NEAREST)),1===aw.getNumber("WEBGL_VERSION")?vw(a,()=>a.texImage2D(h,0,d,b,c,0,e,f,null)):vw(a,()=>a.texStorage2D(h,1,d,b,c)),vw(a,()=>a.bindTexture(a.TEXTURE_2D,null)),{texture:g,texShape:[c,b]}}function wM(a){return a.internalFormatFloat}function wN(a,b,c,d){let[e,f]=[c,b];return wL(a,e,f,wM(d),d.textureFormatFloat,a.FLOAT)}function wO(a){return a.internalFormatHalfFloat}function wP(a,b,c,d){let[e,f]=[c,b];return wL(a,e,f,wO(d),d.textureFormatFloat,d.textureTypeHalfFloat)}function wQ(a){return a.downloadTextureFormat}function wR(a,b,c,d){let[e,f]=[c,b];return wL(a,e,f,wQ(d),a.RGBA,a.UNSIGNED_BYTE)}function wS(a){return a.internalFormatPackedFloat}function wT(a,b,c,d){let[e,f]=vu(b,c);return wL(a,e,f,wS(d),a.RGBA,a.FLOAT)}function wU(a){return a.internalFormatPackedHalfFloat}function wV(a,b,c,d){let[e,f]=vu(b,c);return wL(a,e,f,wU(d),a.RGBA,d.textureTypeHalfFloat)}function wW(a,b,c){return vw(a,()=>a.bindBuffer(a.ARRAY_BUFFER,c)),vN(a,b,"clipSpacePos",c,3,20,0)&&vN(a,b,"uv",c,2,20,12)}function wX(a,b,c,d,e,f){let g,h,i;vw(a,()=>a.bindTexture(a.TEXTURE_2D,b)),e instanceof Uint8Array?(g=new Uint8Array(c*d*4),h=a.UNSIGNED_BYTE,i=a.RGBA):(g=new Float32Array(c*d*4),h=a.FLOAT,i=f.internalFormatPackedFloat),g.set(e),2===aw.getNumber("WEBGL_VERSION")?vw(a,()=>a.texSubImage2D(a.TEXTURE_2D,0,0,0,c,d,a.RGBA,h,g)):vw(a,()=>a.texImage2D(a.TEXTURE_2D,0,i,c,d,0,a.RGBA,h,g)),vw(a,()=>a.bindTexture(a.TEXTURE_2D,null))}function wY(a,b,c){vw(a,()=>a.bindTexture(a.TEXTURE_2D,b)),c.data instanceof Uint8Array?2===aw.getNumber("WEBGL_VERSION")?vw(a,()=>a.texSubImage2D(a.TEXTURE_2D,0,0,0,c.width,c.height,a.RGBA,a.UNSIGNED_BYTE,c.data)):vw(a,()=>a.texImage2D(a.TEXTURE_2D,0,a.RGBA,c.width,c.height,0,a.RGBA,a.UNSIGNED_BYTE,c.data)):2===aw.getNumber("WEBGL_VERSION")?vw(a,()=>a.texSubImage2D(a.TEXTURE_2D,0,0,0,a.RGBA,a.UNSIGNED_BYTE,c)):vw(a,()=>a.texImage2D(a.TEXTURE_2D,0,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,c)),vw(a,()=>a.bindTexture(a.TEXTURE_2D,null))}function wZ(a,b,c,d){let e=a.createBuffer();vw(a,()=>a.bindBuffer(a.PIXEL_PACK_BUFFER,e));let f=16*b*c;return vw(a,()=>a.bufferData(a.PIXEL_PACK_BUFFER,f,a.STREAM_READ)),vw(a,()=>a.readPixels(0,0,c,b,a.RGBA,a.FLOAT,0)),vw(a,()=>a.bindBuffer(a.PIXEL_PACK_BUFFER,null)),e}function w$(a,b,c){let d=new Float32Array(c);return a.bindBuffer(a.PIXEL_PACK_BUFFER,b),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,d),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),d}function w_(a,b,c,d){let[e,f]=[c,b],g=new Uint8Array(b*c*4);return vw(a,()=>a.readPixels(0,0,e,f,d.downloadTextureFormat,a.UNSIGNED_BYTE,g)),new Float32Array(g.buffer)}function w0(a,b,c,d,e,f,g,h){let i=new Float32Array(function(a,b){let[c,d]=vu(a,b);return c*d*4}(f,g));return a.bindBuffer(a.PIXEL_PACK_BUFFER,b),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,i),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),i}function w1(a,b,c){let d=new Float32Array(b*c*4);return vw(a,()=>a.readPixels(0,0,c,b,a.RGBA,a.FLOAT,d)),d}a.s(["bindVertexProgramAttributeStreams",()=>wW,"createBufferFromOutputTexture",()=>wZ,"createFloat16MatrixTexture",()=>wP,"createFloat16PackedMatrixTexture",()=>wV,"createFloat32MatrixTexture",()=>wN,"createIndexBuffer",()=>wK,"createPackedMatrixTexture",()=>wT,"createUnsignedBytesMatrixTexture",()=>wR,"createVertexBuffer",()=>wJ,"createVertexShader",()=>wI,"downloadByteEncodedFloatMatrixFromOutputTexture",()=>w_,"downloadFloat32MatrixFromBuffer",()=>w$,"downloadMatrixFromPackedOutputTexture",()=>w1,"downloadPackedMatrixFromBuffer",()=>w0,"getInternalFormatForFloat16MatrixTexture",()=>wO,"getInternalFormatForFloat16PackedMatrixTexture",()=>wU,"getInternalFormatForFloat32MatrixTexture",()=>wM,"getInternalFormatForPackedMatrixTexture",()=>wS,"getInternalFormatForUnsignedBytesMatrixTexture",()=>wQ,"uploadDenseMatrixToTexture",()=>wX,"uploadPixelDataToTexture",()=>wY],438096);class w2{constructor(a){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const b=aw.getNumber("WEBGL_VERSION");if(null!=a){var c;this.gl=a,c=a,vp[b]=c}else this.gl=vs(b);if(a=this.gl,2===aw.getNumber("WEBGL_VERSION")){const b=a;this.createVertexArray=()=>vw(b,()=>b.createVertexArray()),this.bindVertexArray=a=>vw(b,()=>b.bindVertexArray(a)),this.deleteVertexArray=a=>vw(b,()=>b.deleteVertexArray(a)),this.getVertexArray=()=>vw(b,()=>b.getParameter(b.VERTEX_ARRAY_BINDING))}else if(null!=a){const b=a.getExtension("OES_vertex_array_object");if(null==b)throw Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>vw(a,()=>b.createVertexArrayOES()),this.bindVertexArray=c=>vw(a,()=>b.bindVertexArrayOES(c)),this.deleteVertexArray=c=>vw(a,()=>b.deleteVertexArrayOES(c)),this.getVertexArray=()=>vw(a,()=>a.getParameter(b.VERTEX_ARRAY_BINDING_OES))}let d="WEBGL_color_buffer_float";const e="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===aw.getNumber("WEBGL_VERSION")){const a="OES_texture_half_float";if(this.textureFloatExtension=vz(this.gl,"OES_texture_float"),v8(this.gl,a))this.textureHalfFloatExtension=vz(this.gl,a);else if(aw.get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(d),v8(this.gl,e))this.colorBufferHalfFloatExtension=vz(this.gl,e);else if(aw.get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(d="EXT_color_buffer_float",v8(this.gl,d))this.colorBufferFloatExtension=this.gl.getExtension(d);else if(v8(this.gl,e))this.colorBufferHalfFloatExtension=this.gl.getExtension(e);else throw Error("GL context does not support color renderable floats");this.vertexBuffer=wJ(this.gl),this.indexBuffer=wK(this.gl),this.framebuffer=vM(this.gl),this.textureConfig=vv(this.gl,this.textureHalfFloatExtension)}get debug(){return aw.getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let a=this.gl;vw(a,()=>a.finish()),vw(a,()=>a.bindFramebuffer(a.FRAMEBUFFER,null)),vw(a,()=>a.deleteFramebuffer(this.framebuffer)),vw(a,()=>a.bindBuffer(a.ARRAY_BUFFER,null)),vw(a,()=>a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,null)),vw(a,()=>a.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(a,b){return this.throwIfDisposed(),wN(this.gl,a,b,this.textureConfig)}createFloat16MatrixTexture(a,b){return this.throwIfDisposed(),wP(this.gl,a,b,this.textureConfig)}createUnsignedBytesMatrixTexture(a,b){return this.throwIfDisposed(),wR(this.gl,a,b,this.textureConfig)}uploadPixelDataToTexture(a,b){this.throwIfDisposed(),wY(this.gl,a,b)}uploadDenseMatrixToTexture(a,b,c,d){this.throwIfDisposed(),wX(this.gl,a,b,c,d,this.textureConfig)}createFloat16PackedMatrixTexture(a,b){return this.throwIfDisposed(),wV(this.gl,a,b,this.textureConfig)}createPackedMatrixTexture(a,b){return this.throwIfDisposed(),wT(this.gl,a,b,this.textureConfig)}deleteMatrixTexture(a){this.throwIfDisposed(),this.outputTexture===a&&(vV(this.gl,this.framebuffer),this.outputTexture=null),vw(this.gl,()=>this.gl.deleteTexture(a))}downloadByteEncodedFloatMatrixFromOutputTexture(a,b,c){return this.downloadMatrixDriver(a,()=>w_(this.gl,b,c,this.textureConfig))}downloadPackedMatrixFromBuffer(a,b,c,d,e,f){return w0(this.gl,a,b,c,d,e,f,this.textureConfig)}downloadFloat32MatrixFromBuffer(a,b){return w$(this.gl,a,b)}createBufferFromTexture(a,b,c){this.bindTextureToFrameBuffer(a);let d=wZ(this.gl,b,c,this.textureConfig);return this.unbindTextureToFrameBuffer(),d}createAndWaitForFence(){let a=this.createFence(this.gl);return this.pollFence(a)}createFence(a){let b,c;if(aw.getBool("WEBGL_FENCE_API_ENABLED")){let d=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);a.flush(),c=()=>{let b=a.clientWaitSync(d,0,0);return b===a.ALREADY_SIGNALED||b===a.CONDITION_SATISFIED},b=d}else aw.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(b=this.beginQuery(),this.endQuery(),c=()=>this.isQueryAvailable(b,aw.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):c=()=>!0;return{query:b,isFencePassed:c}}downloadMatrixFromPackedTexture(a,b,c){return this.downloadMatrixDriver(a,()=>w1(this.gl,b,c))}createProgram(a){this.throwIfDisposed();let b=this.gl;null==this.vertexShader&&(this.vertexShader=wI(b));let c=vE(b);vw(b,()=>b.attachShader(c,this.vertexShader)),vw(b,()=>b.attachShader(c,a)),vF(b,c);let d=Object.assign(c,{vao:this.createVertexArray()});return this.debug&&vG(b,d),d}buildVao(a){this.setProgram(a),this.bindVertexArray(a.vao);let b=this.gl;vw(b,()=>b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),wW(b,a,this.vertexBuffer)}deleteProgram(a){this.throwIfDisposed(),a===this.program&&(this.program=null),null!=a&&(vw(this.gl,()=>this.gl.deleteProgram(a)),this.deleteVertexArray(a.vao))}setProgram(a){this.throwIfDisposed(),this.program=a,null!=this.program&&this.debug&&vG(this.gl,this.program),vw(this.gl,()=>this.gl.useProgram(a))}getUniformLocation(a,b,c=!0){return(this.throwIfDisposed(),c)?vQ(this.gl,a,b):vR(this.gl,a,b)}getAttributeLocation(a,b){return this.throwIfDisposed(),vw(this.gl,()=>this.gl.getAttribLocation(a,b))}getUniformLocationNoThrow(a,b){return this.throwIfDisposed(),this.gl.getUniformLocation(a,b)}setInputMatrixTexture(a,b,c){this.throwIfDisposed(),this.throwIfNoProgram(),vS(this.gl,a,b,c)}setOutputMatrixTexture(a,b,c){this.setOutputMatrixTextureDriver(a,c,b)}setOutputPackedMatrixTexture(a,b,c){this.throwIfDisposed();let[d,e]=vu(b,c);this.setOutputMatrixTextureDriver(a,d,e)}setOutputMatrixWriteRegion(a,b,c,d){this.setOutputMatrixWriteRegionDriver(c,a,d,b)}setOutputPackedMatrixWriteRegion(a,b,c,d){throw Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&vG(this.gl,this.program),vW(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let a=this.gl;this.debug&&(console.assert(this.getVertexArray()===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()),vw(a,()=>a.drawElements(a.TRIANGLES,6,a.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),vw(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=vz(this.gl,2===aw.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===aw.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let a=this.gl,b=this.getQueryTimerExtensionWebGL2(),c=a.createQuery();return a.beginQuery(b.TIME_ELAPSED_EXT,c),c}let a=this.getQueryTimerExtensionWebGL1(),b=a.createQueryEXT();return a.beginQueryEXT(a.TIME_ELAPSED_EXT,b),b}endQuery(){if(2===aw.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let a=this.gl,b=this.getQueryTimerExtensionWebGL2();a.endQuery(b.TIME_ELAPSED_EXT);return}let a=this.getQueryTimerExtensionWebGL1();a.endQueryEXT(a.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(a){return await iV.repeatedTry(()=>this.disposed||this.isQueryAvailable(a,aw.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(a,aw.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(a,b){if(0===b)return null;if(2===b){let b=this.gl;return b.getQueryParameter(a,b.QUERY_RESULT)/1e6}{let b=this.getQueryTimerExtensionWebGL1();return b.getQueryObjectEXT(a,b.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(a,b){if(0===b)return!0;if(2===b){let b=this.gl,c=this.getQueryTimerExtensionWebGL2(),d=b.getQueryParameter(a,b.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(c.GPU_DISJOINT_EXT)),d&&!this.disjoint}{let b=this.getQueryTimerExtensionWebGL1(),c=b.getQueryObjectEXT(a,b.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(b.GPU_DISJOINT_EXT)),c&&!this.disjoint}}pollFence(a){return new Promise(b=>{this.addItemToPoll(()=>a.isFencePassed(),()=>b())})}pollItems(){let a=function(a){let b=0;for(;b<a.length&&a[b]();++b);return b-1}(this.itemsToPoll.map(a=>a.isDoneFn));for(let b=0;b<=a;++b){let{resolveFn:a}=this.itemsToPoll[b];a()}this.itemsToPoll=this.itemsToPoll.slice(a+1)}addItemToPoll(a,b){let c;this.itemsToPoll.push({isDoneFn:a,resolveFn:b}),this.itemsToPoll.length>1||("setTimeoutCustom"in aw.platform&&(c=aw.platform.setTimeoutCustom.bind(aw.platform)),iV.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,c))}bindTextureToFrameBuffer(a){this.throwIfDisposed(),vU(this.gl,a,this.framebuffer),this.debug&&vW(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(vU(this.gl,this.outputTexture,this.framebuffer),this.debug&&vW(this.gl)):vV(this.gl,this.framebuffer)}downloadMatrixDriver(a,b){this.bindTextureToFrameBuffer(a);let c=b();return this.unbindTextureToFrameBuffer(),c}setOutputMatrixTextureDriver(a,b,c){this.throwIfDisposed();let d=this.gl;vU(d,a,this.framebuffer),this.debug&&vW(d),this.outputTexture=a,vw(d,()=>d.viewport(0,0,b,c)),vw(d,()=>d.scissor(0,0,b,c))}setOutputMatrixWriteRegionDriver(a,b,c,d){this.throwIfDisposed(),vw(this.gl,()=>this.gl.scissor(a,b,c,d))}throwIfDisposed(){if(this.disposed)throw Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw Error("No GPU program is currently set.")}}let{addImpl:w3,bincountImpl:w4,bincountReduceImpl:w5,bitwiseAndImpl:w6,castImpl:w7,ceilImpl:w8,concatImpl:w9,equalImpl:xa,expImpl:xb,expm1Impl:xc,floorImpl:xd,gatherNdImpl:xe,gatherV2Impl:xf,greaterImpl:xg,greaterEqualImpl:xh,lessImpl:xi,lessEqualImpl:xj,linSpaceImpl:xk,logImpl:xl,maxImpl:xm,maximumImpl:xn,minimumImpl:xo,multiplyImpl:xp,negImpl:xq,notEqualImpl:xr,prodImpl:xs,raggedGatherImpl:xt,raggedRangeImpl:xu,raggedTensorToTensorImpl:xv,rangeImpl:xw,rsqrtImpl:xx,scatterImpl:xy,sigmoidImpl:xz,simpleAbsImpl:xA,sliceImpl:xB,sparseFillEmptyRowsImpl:xC,sparseReshapeImpl:xD,sparseSegmentReductionImpl:xE,sqrtImpl:xF,staticRegexReplaceImpl:xG,stridedSliceImpl:xH,stringNGramsImpl:xI,stringSplitImpl:xJ,stringToHashBucketFastImpl:xK,subImpl:xL,tileImpl:xM,topKImpl:xN,transposeImpl:xO,uniqueImpl:xP}=uf;function xQ(a,b){return["x","y","z","w","u","v"].slice(0,b).map(b=>`${a}.${b}`)}function xR(a,b){return 1===b?[a]:xQ(a,b)}class xS{constructor(a){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=a,this.rank=a.length,this.enableShapeUniforms=wA(this.outputShape.length),0===this.rank)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const a=xR("rc",this.rank),b=wu(this.rank),c=this.getOutOfBoundsCondition(a),d=this.getSetup(a),e=this.getOutput(a);this.userCode=`
        void main() {
          ${b} rc = getOutputCoords();

          if(${c}) {
            setOutput(vec4(0));
          } else {
            ${d}

            setOutput(vec4(${e}));
          }
        }
      `}}getSourceCoordsArr(a){let b=[];for(let c=0;c<=1;c++)for(let d=0;d<=1;d++){let e=`${0===c?"r":"rp1"}, ${0===d?"c":"cp1"}`;for(let b=2;b<this.rank;b++)e=`${a[a.length-1-b]},`+e;b.push(e)}return b}getOutOfBoundsCondition(a){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let b="";for(let c=this.rank-2;c<this.rank;c++)b+=`${a[c]} >= ${this.enableShapeUniforms?`outShape[${c}]`:this.outputShape[c]}`,c<this.rank-1&&(b+="||");return b}getSetup(a){if(1===this.rank)return"";let b=a.slice(-2),c=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],d=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${b[0]};
      int c = ${b[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${c};
      bool rEdge = rp1 >= ${d};
    `}getOutput(a){let b=this.getSourceCoordsArr(a);if(1===this.rank){let a=this.enableShapeUniforms?"outShape":this.outputShape[0];return`getA(rc), (rc + 1 >= ${a} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${b[0]}),
            cEdge ? 0. : getA(${b[1]}),
            rEdge ? 0. : getA(${b[2]}),
            rEdge || cEdge ? 0. : getA(${b[3]})`}}class xT{constructor(a,b){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=a,this.enableShapeUniforms=wA(this.outputShape.length);let c="";for(let a=0;a<4;a++){let b="thisRC = rc;";a%2==1&&(b+="thisRC.z += 1;"),a>1&&(b+="thisRC.y += 1;"),c+=`
        ${b}
        ${a>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${a}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${a>0?"}":""}
      `}this.userCode=`
      ${function(a,b){let c=b?function(a,b,c="index"){let d=function(a,b){let c=a.length,d=a.map(a=>`${b}[${a}]`),e=Array(c-1);e[c-2]=d[c-1];for(let a=c-3;a>=0;--a)e[a]=`(${e[a+1]} * ${d[a+1]})`;return e}(a.map((a,b)=>b),b);return d.map((b,e)=>{let f=`int ${a[e]} = ${c} / ${d[e]}`,g=e===d.length-1?`int ${a[e+1]} = ${c} - ${a[e]} * ${d[e]}`:`index -= ${a[e]} * ${d[e]}`;return`${f}; ${g};`}).join("")}(["r","c","d"],"inputShape"):wh(["r","c","d"],a);return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${c}
      return ivec3(r, c, d);
    }
  `}(b,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?wk():wj(a)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":a[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":a[2]};

        ${c}

        setOutput(result);
      }
    `}}class xU{constructor(a){this.gpgpu=a,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(a,b,c){let d,e=xW(b,c),f=xX(a,e,c);f in this.freeTextures||(this.freeTextures[f]=[]),f in this.usedTextures||(this.usedTextures[f]=[]);let g=xV(a,e,this.gpgpu.gl,this.gpgpu.textureConfig,c);if(this.freeTextures[f].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=g,this.log();let a=this.freeTextures[f].pop();return this.usedTextures[f].push(a),a}return e===BU.PACKED_2X2_FLOAT32?d=this.gpgpu.createPackedMatrixTexture(a[0],a[1]):e===BU.PACKED_2X2_FLOAT16?d=this.gpgpu.createFloat16PackedMatrixTexture(a[0],a[1]):e===BU.UNPACKED_FLOAT32?d=this.gpgpu.createFloat32MatrixTexture(a[0],a[1]):e===BU.UNPACKED_FLOAT16?d=this.gpgpu.createFloat16MatrixTexture(a[0],a[1]):e===BU.PACKED_4X1_UNSIGNED_BYTE&&(d=this.gpgpu.createUnsignedBytesMatrixTexture(a[0],a[1])),this.usedTextures[f].push(d),this.numUsedTextures++,this._numBytesAllocated+=g,this.log(),d}releaseTexture(a,b,c,d){if(null==this.freeTextures)return;let e=xW(c,d),f=xX(b,e,d);f in this.freeTextures||(this.freeTextures[f]=[]);let g=xV(b,e,this.gpgpu.gl,this.gpgpu.textureConfig,d),h=aw.getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==h&&this._numBytesAllocated>h?(this.gpgpu.deleteMatrixTexture(a.texture),this._numBytesAllocated-=g):(this.freeTextures[f].push(a),this.numFreeTextures++,this._numBytesFree+=g),this.numUsedTextures--;let i=this.usedTextures[f],j=i&&i.indexOf(a);if(null==j||j<0)throw Error("Cannot release a texture that was never provided by this texture manager");i[j]=i[i.length-1],i.pop(),this.log()}log(){if(!this.logEnabled)return;let a=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${a})`);let b=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*b)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let a in this.freeTextures)this.freeTextures[a].forEach(a=>{this.gpgpu.deleteMatrixTexture(a.texture)});for(let a in this.usedTextures)this.usedTextures[a].forEach(a=>{this.gpgpu.deleteMatrixTexture(a.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function xV(a,b,c,d,e){let f,g=function(a,b){switch(a){case BU.PACKED_2X2_FLOAT32:return wS(b);case BU.PACKED_2X2_FLOAT16:return wU(b);case BU.UNPACKED_FLOAT32:return wM(b);case BU.UNPACKED_FLOAT16:return wO(b);case BU.PACKED_4X1_UNSIGNED_BYTE:return wQ(b);default:throw Error(`Unknown physical texture type ${a}`)}}(b,d);if(e){let[b,c]=vu(a[0],a[1]);f=b*c}else{var h;let[b,c]=(h=a[0],[a[1],h]);f=b*c}return f*function(a,b){if(b===a.R32F)return 4;if(b===a.R16F)return 2;if(b===a.RGBA32F)return 16;if(b===a.RGBA)return 16;if(b===a.RGBA16F)return 8;else if(b===a.RGBA8)return 4;throw Error(`Unknown internal format ${b}`)}(c,g)}function xW(a,b){if(a===BT.UPLOAD)return BU.PACKED_2X2_FLOAT32;if(a===BT.RENDER||null==a)return aw.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?b?BU.PACKED_2X2_FLOAT32:BU.UNPACKED_FLOAT32:b?BU.PACKED_2X2_FLOAT16:BU.UNPACKED_FLOAT16;if(a===BT.DOWNLOAD||a===BT.PIXELS)return BU.PACKED_4X1_UNSIGNED_BYTE;throw Error(`Unknown logical texture type ${a}`)}function xX(a,b,c){return`${a[0]}_${a[1]}_${b}_${c}`}class xY{constructor(a,b){this.variableNames=["A"],this.outputShape=a,this.enableShapeUniforms=wA(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${b}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}let xZ="if (isnan(x)) return x;",x$="return abs(x);",x_=xZ+`
  return (x < 0.0) ? 0.0 : x;
`,x0=xZ+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,x1="return x;",x2=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,x3=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,x4=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;class x5{constructor(a,b){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a,this.enableShapeUniforms=wA(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${b}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class x6{constructor(a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=a,this.enableShapeUniforms=wA(this.outputShape.length);const b=a.length,c=xR("rc",b),d=wu(b),e=function(a,b){if(1===a)return"rc";let c="";for(let d=0;d<a;d++)c+=b[d],d<a-1&&(c+=",");return c}(b,c),f=c.slice(-2),g=b<=1?"rc":`vec2(${f.join(",")})`;this.userCode=`
      void main() {
        ${d} rc = getOutputCoords();
        vec4 packedInput = getA(${e});

        setOutput(getChannel(packedInput, ${g}));
      }
    `}}let x7=sI.whereImpl,x8={},x9=aw.getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class ya extends y{nextDataId(){return ya.nextDataId++}constructor(a){let b;if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!aw.getBool("HAS_WEBGL"))throw Error("WebGL is not supported on this device");null!=a?(b=a instanceof w2?a:new w2(vs(aw.getNumber("WEBGL_VERSION"),a)),this.binaryCache={},this.gpgpuCreatedLocally=!1):(b=new w2(vs(aw.getNumber("WEBGL_VERSION"))),this.binaryCache=function(a){return a in x8||(x8[a]={}),x8[a]}(aw.getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0),this.gpgpu=b,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new xU(this.gpgpu),this.numMBBeforeWarning=null==aw.global.screen?1024:aw.global.screen.height*aw.global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new x(this,dB)}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(a,b,c,d,e,f){let g=this.makeTensorInfo(b,c),h=this.texData.get(g.dataId);h.isPacked=!1,h.texture={texture:a,texShape:[d,e]},h.texShape=[d,e];let i=new wG(v0(b),!1,f),j=this.runWebGLProgram(i,[g],c,[[d,e]]);return j.shape=b,h.texture=null,this.disposeIntermediateTensorInfo(g),j.dataId}write(a,b,c){if((aw.getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||aw.getBool("DEBUG"))&&this.checkNumericalProblems(a),"complex64"===c&&null!=a)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let d={id:this.nextDataId()};return this.texData.set(d,{shape:b,dtype:c,values:a,usage:BT.UPLOAD,refCount:1}),d}refCount(a){return this.texData.has(a)?this.texData.get(a).refCount:0}incRef(a){let b=this.texData.get(a);b.refCount++}decRef(a){if(this.texData.has(a)){let b=this.texData.get(a);b.refCount--}}move(a,b,c,d,e){if(aw.getBool("DEBUG")&&this.checkNumericalProblems(b),"complex64"===d)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(a,{shape:c,dtype:d,values:b,usage:BT.UPLOAD,refCount:e})}disposeIntermediateTensorInfo(a){this.disposeData(a.dataId)}readSync(a){let b,c,{values:d,dtype:e,complexTensorInfos:f,slice:g,shape:h,isPacked:i}=this.texData.get(a);if(null!=g){let b;b=i?new x5(h,x1):new xY(h,x1);let c=this.runWebGLProgram(b,[{dataId:a,shape:h,dtype:e}],e),d=this.readSync(c.dataId);return this.disposeIntermediateTensorInfo(c),d}if(null!=d)return this.convertAndCacheOnCPU(a);if("string"===e)return d;let j=null!=this.activeTimers;if(j&&(b=iV.now()),"complex64"===e){let a=this.readSync(f.real.dataId),b=this.readSync(f.imag.dataId);c=hp.mergeRealAndImagArrays(a,b)}else c=this.getValuesFromTexture(a);return j&&(this.downloadWaitMs+=iV.now()-b),this.convertAndCacheOnCPU(a,c)}async read(a){let b,c;if(this.pendingRead.has(a)){let b=this.pendingRead.get(a);return new Promise(a=>b.push(a))}let{values:d,shape:e,slice:f,dtype:g,complexTensorInfos:h,isPacked:i}=this.texData.get(a);if(null!=f){let b;b=i?new x5(e,x1):new xY(e,x1);let c=this.runWebGLProgram(b,[{dataId:a,shape:e,dtype:g}],g),d=this.read(c.dataId);return this.disposeIntermediateTensorInfo(c),d}if(null!=d)return this.convertAndCacheOnCPU(a);if(aw.getBool("DEBUG")&&!aw.getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===aw.getNumber("WEBGL_VERSION"))throw Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let j=null;if("complex64"!==g&&aw.get("WEBGL_BUFFER_SUPPORTED")){b=this.decode(a);let c=this.texData.get(b.dataId);j=this.gpgpu.createBufferFromTexture(c.texture.texture,...vt(e))}if(this.pendingRead.set(a,[]),"complex64"!==g&&await this.gpgpu.createAndWaitForFence(),"complex64"===g){let a=await Promise.all([this.read(h.real.dataId),this.read(h.imag.dataId)]),b=a[0],d=a[1];c=hp.mergeRealAndImagArrays(b,d)}else if(null==j)c=this.getValuesFromTexture(a);else{let a=iV.sizeFromShape(e);c=this.gpgpu.downloadFloat32MatrixFromBuffer(j,a)}if(null!=b&&this.disposeIntermediateTensorInfo(b),null!=j){let a=this.gpgpu.gl;vw(a,()=>a.deleteBuffer(j))}let k=this.convertAndCacheOnCPU(a,c),l=this.pendingRead.get(a);return this.pendingRead.delete(a),l.forEach(a=>a(k)),this.pendingDisposal.has(a)&&(this.pendingDisposal.delete(a),this.disposeData(a)&&dB.removeDataId(a,this),this.pendingDeletes--),k}readToGPU(a,b={}){let{values:c,shape:d,slice:e,dtype:f,isPacked:g,texture:h}=this.texData.get(a);if("complex64"===f)throw Error("Does not support reading texture for complex64 dtype.");if(null!=e){let c;c=g?new x5(d,x1):new xY(d,x1);let e=this.runWebGLProgram(c,[{dataId:a,shape:d,dtype:f}],f),h=this.readToGPU(e,b);return this.disposeIntermediateTensorInfo(e),h}if(null==h)if(null!=c)throw Error("Data is not on GPU but on CPU.");else throw Error("There is no data on GPU or CPU.");let i=this.decode(a,b.customTexShape);return Object.assign({tensorRef:dB.makeTensorFromTensorInfo(i)},this.texData.get(i.dataId).texture)}bufferSync(a){let b=this.readSync(a.dataId);if("string"===a.dtype)try{let c=b.map(a=>iV.decodeString(a));return eu(a.shape,a.dtype,c)}catch(a){throw Error("Failed to decode encoded string bytes into utf-8")}return eu(a.shape,a.dtype,b)}checkNumericalProblems(a){if(null!=a)for(let b=0;b<a.length;b++){let c=a[b];if(!vx(c)){if(aw.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${c} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${c} cannot be represented on this device.`)}}}getValuesFromTexture(a){let{shape:b,dtype:c,isPacked:d}=this.texData.get(a),e=iV.sizeFromShape(b);if(aw.getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let c=this.decode(a),d=this.texData.get(c.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(d.texture.texture,...vt(b)).subarray(0,e);return this.disposeIntermediateTensorInfo(c),f}let f=aw.getBool("WEBGL_PACK")&&!0===d,g=f?v0(b):b,h=f?new wE(g):new wD(g),i=this.runWebGLProgram(h,[{shape:g,dtype:c,dataId:a}],"float32"),j=this.texData.get(i.dataId),k=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(j.texture.texture,j.texShape[0],j.texShape[1]).subarray(0,e);return this.disposeIntermediateTensorInfo(i),k}timerAvailable(){return aw.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(a){let b=this.activeTimers,c=[],d=!1;null==this.programTimersStack?(this.programTimersStack=c,d=!0):this.activeTimers.push(c),this.activeTimers=c,a();let e=iV.flatten(this.activeTimers.map(a=>a.query)).filter(a=>null!=a),f=iV.flatten(this.activeTimers.map(a=>a.name)).filter(a=>null!=a);this.activeTimers=b,d&&(this.programTimersStack=null);let g={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(aw.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let a=await Promise.all(e);g.kernelMs=iV.sum(a),g.getExtraProfileInfo=()=>a.map((a,b)=>({name:f[b],ms:a})).map(a=>`${a.name}: ${a.ms}`).join(", ")}else g.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,g})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return aw.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:iV.now(),endMs:null}}endTimer(a){return aw.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.endQuery():a.endMs=iV.now(),a}async getQueryTime(a){return aw.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.waitForQueryAndGetTime(a):a.endMs-a.startMs}disposeData(a,b=!1){if(this.pendingDisposal.has(a))return!1;if(!this.texData.has(a))return!0;if(b?this.texData.get(a).refCount=0:this.texData.get(a).refCount--,!b&&this.texData.get(a).refCount>0)return!1;if(this.pendingRead.has(a))return this.pendingDisposal.add(a),this.pendingDeletes++,!1;this.releaseGPUData(a);let{complexTensorInfos:c}=this.texData.get(a);return null!=c&&(this.disposeData(c.real.dataId,b),this.disposeData(c.imag.dataId,b)),this.texData.delete(a),!0}releaseGPUData(a){let{texture:b,dtype:c,texShape:d,usage:e,isPacked:f,slice:g}=this.texData.get(a),h=g&&g.origDataId||a,i=this.dataRefCount.get(h);i>1?this.dataRefCount.set(h,i-1):(this.dataRefCount.delete(h),null!=b&&(this.numBytesInGPU-=this.computeBytes(d,c),this.textureManager.releaseTexture(b,d,e,f)));let j=this.texData.get(a);j.texture=null,j.texShape=null,j.isPacked=!1,j.slice=null}getTexture(a){return this.uploadToGPU(a),this.texData.get(a).texture.texture}getDataInfo(a){return this.texData.get(a)}shouldExecuteOnCPU(a,b=x9){return aw.getBool("WEBGL_CPU_FORWARD")&&a.every(a=>null==this.texData.get(a.dataId).texture&&iV.sizeFromShape(a.shape)<b)}getGPGPUContext(){return this.gpgpu}where(a){hp.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let b=a.dataSync();return x7(a.shape,b)}packedUnaryOp(a,b,c){let d=new x5(a.shape,b),e=this.compileAndRun(d,[a],c);return dB.makeTensorFromTensorInfo(e)}abs(a){if(this.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){let b=xA(this.texData.get(a.dataId).values);return this.makeOutput(a.shape,a.dtype,b)}if(aw.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(a,x$,a.dtype);let b=new xY(a.shape,x$),c=this.compileAndRun(b,[a]);return dB.makeTensorFromTensorInfo(c)}makeTensorInfo(a,b,c){let d;if("string"===b&&null!=c&&c.length>0&&iV.isString(c[0])){let e=c.map(a=>iV.encodeString(a));d=this.write(e,a,b)}else d=this.write(c,a,b);return this.texData.get(d).usage=null,{dataId:d,shape:a,dtype:b}}makeOutput(a,b,c){return dB.makeTensorFromTensorInfo(this.makeTensorInfo(a,b,c),this)}unpackTensor(a){let b=new x6(a.shape);return this.runWebGLProgram(b,[a],a.dtype)}packTensor(a){let b=new xS(a.shape);return this.runWebGLProgram(b,[a],a.dtype,null,!0)}packedReshape(a,b){let c=[v$(a.shape),...v_(a.shape)],d={dtype:a.dtype,shape:c,dataId:a.dataId},e=new xT([v$(b),...v_(b)],c),f=this.runWebGLProgram(e,[d],a.dtype,[c],!0);return{dataId:f.dataId,shape:b,dtype:f.dtype}}decode(a,b){let c,{isPacked:d,shape:e,dtype:f}=this.texData.get(a);if(null!=b){let a=iV.sizeFromShape(e),c=b[0]*b[1]*4;iV.assert(a<=c,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let g=v0(e);c=d?new wC(g):new wB(g);let h=[null!=b?b:vt(g)],i=this.runWebGLProgram(c,[{shape:g,dtype:f,dataId:a}],f,h,!0,b);return{dtype:f,shape:e,dataId:i.dataId}}runWebGLProgram(a,b,c,d,e=!1,f){let g,h,i,j=this.makeTensorInfo(a.outputShape,c),k=this.texData.get(j.dataId);if(a.packedOutput&&(k.isPacked=!0),a.outPackingScheme===BS.DENSE&&(k.texShape=(null!=f?f:vt(a.outputShape)).map(a=>2*a)),null!=a.outTexUsage&&(k.usage=a.outTexUsage),0===iV.sizeFromShape(j.shape))return k.values=iV.getTypedArrayFromDType(j.dtype,0),j;let l=[],m=b.map(b=>{if("complex64"===b.dtype)throw Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let c=this.texData.get(b.dataId);if(null==c.texture){if(!a.packedInputs&&iV.sizeFromShape(b.shape)<=aw.getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:c.values};a.packedInputs&&(c.isPacked=!0,c.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!c.isPacked!=!!a.packedInputs)b=c.isPacked?this.unpackTensor(b):this.packTensor(b),l.push(b),c=this.texData.get(b.dataId);else if(c.isPacked&&!v2(c.shape,b.shape)){let a=b,d=b.shape;b.shape=c.shape,b=this.packedReshape(b,d),l.push(b),c=this.texData.get(b.dataId),a.shape=d}return{shape:b.shape,texData:c,isUniform:!1}});this.uploadToGPU(j.dataId);let n={shape:j.shape,texData:k,isUniform:!1},o=(h="",m.concat(n).forEach(b=>{let c=null!=b.texData&&null!=b.texData.slice&&b.texData.slice.flatOffset>0;if(a.enableShapeUniforms&&!b.isUniform){let d=b.texData.texShape,{useSqueezeShape:e,uniformShape:f,keptDims:g}=wv(a.packedInputs,b.shape,d),i="",j="",k="";if(1===f.length&&a.packedInputs){let a=[Math.ceil(d[0]/2),Math.ceil(d[1]/2)];i=`${a[0]>1}_${a[1]>1}`}else if(2!==f.length||a.packedInputs){if(f.length>2&&!a.packedInputs){let a=iV.computeStrides(f);k=`${a[0]===d[1]}_${a[a.length-1]===d[1]}`}}else j=`${f[0]>1}_${f[1]>1}`;let l=b.shape.length,m=2===f.length&&iV.arraysEqual(b.shape,d),o=1===iV.sizeFromShape(b.shape),p=hp.getBroadcastDims(b.shape,n.shape),q=!a.packedInputs&&l===n.shape.length&&iV.arraysEqual(d,n.texData.texShape),r=a.packedInputs||f.length>2?"":`${d[0]>1}_${d[1]>1}`;h+=`${l}_${q}_${e?g:""}_${f.length}_${o}_${p}_${m}_${i}_${j}_${k}_${r}_${c}`}else{let a=b.isUniform?"uniform":b.texData.texShape;h+=`${b.shape}_${a}_${c}`}}),i=a.userCode,a.constructor.name+("_"+h+"_"+i)+`${aw.getNumber("WEBGL_VERSION")}`),p=this.getAndSaveBinary(o,()=>{var b;let c,d,e,f,g,h;return b=this.gpgpu,d=(c=m.map((b,c)=>{let d={logicalShape:b.shape,texShape:b.isUniform?null:b.texData.texShape,isUniform:b.isUniform,isPacked:!b.isUniform&&b.texData.isPacked,flatOffset:null};return null!=b.texData&&null!=b.texData.slice&&b.texData.slice.flatOffset>0&&(d.flatOffset=b.texData.slice.flatOffset),{name:a.variableNames[c],shapeInfo:d}})).map(a=>a.shapeInfo),f=function(a,b,c){var d,e,f,g;let h,i,j=[];if(a.forEach(a=>{let b=iV.sizeFromShape(a.shapeInfo.logicalShape);if(a.shapeInfo.isUniform?j.push(`uniform float ${a.name}${b>1?`[${b}]`:""};`):(j.push(`uniform sampler2D ${a.name};`),j.push(`uniform int offset${a.name};`)),c.enableShapeUniforms){let{uniformShape:b}=wv(c.packedInputs,a.shapeInfo.logicalShape,a.shapeInfo.texShape);switch(b.length){case 1:j.push(`uniform int ${a.name}Shape;`);break;case 2:j.push(`uniform ivec2 ${a.name}Shape;`);break;case 3:j.push(`uniform ivec3 ${a.name}Shape;`);break;case 4:j.push(`uniform ivec4 ${a.name}Shape;`)}j.push(`uniform ivec2 ${a.name}TexShape;`)}}),c.enableShapeUniforms){switch(b.logicalShape.length){case 1:j.push("uniform int outShape;");break;case 2:j.push("uniform ivec2 outShape;"),j.push("uniform int outShapeStrides;");break;case 3:j.push("uniform ivec3 outShape;"),j.push("uniform ivec2 outShapeStrides;");break;case 4:j.push("uniform ivec4 outShape;"),j.push("uniform ivec3 outShapeStrides;")}j.push("uniform ivec2 outTexShape;")}c.customUniforms&&c.customUniforms.forEach(a=>{j.push(`uniform ${a.type} ${a.name}${a.arrayIndex?`[${a.arrayIndex}]`:""};`)});let k=j.join("\n"),l=a.map(a=>(function(a,b,c=!1,d){let e="";c?e+=function a(b,c){switch(b.shapeInfo.logicalShape.length){case 0:let d,e,f;return e="get"+(d=b.name).charAt(0).toUpperCase()+d.slice(1),f=wg(),`
    vec4 ${e}() {
      return ${f.texture2D}(${d}, halfCR);
    }
  `;case 1:return function(a,b){let c=a.name,d="get"+c.charAt(0).toUpperCase()+c.slice(1),e=a.shapeInfo.texShape,f=wg();if(b)return`
    vec4 ${d}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${c}TexShape[0]) / 2.0), ceil(float(${c}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${f.texture2D}(${c}, uv);
    }
  `;let g=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return`
    vec4 ${d}(int index) {
      vec2 uv = packedUVfrom1D(
        ${g[0]}, ${g[1]}, index);
      return ${f.texture2D}(${c}, uv);
    }
  `}(b,c);case 2:return function(a,b){let c=a.shapeInfo.logicalShape,d=a.name,e="get"+d.charAt(0).toUpperCase()+d.slice(1),f=a.shapeInfo.texShape,g=f[0],h=f[1],i=wg();if(null!=f&&iV.arraysEqual(c,f))return b?`
      vec4 ${e}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}TexShape[1], ${d}TexShape[0]);

        return ${i.texture2D}(${d}, uv);
      }
    `:`
      vec4 ${e}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${g}.0);

        return ${i.texture2D}(${d}, uv);
      }
    `;if(b)return`
    vec4 ${e}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${d}TexShape[0]) / 2.0), ceil(float(${d}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${d}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${i.texture2D}(${d}, uv);
    }
  `;let j=[Math.ceil(f[0]/2),Math.ceil(f[1]/2)],k=Math.ceil(c[1]/2);return`
    vec4 ${e}(int row, int col) {
      vec2 uv = packedUVfrom2D(${k}, ${j[0]}, ${j[1]}, row, col);
      return ${i.texture2D}(${d}, uv);
    }
  `}(b,c);case 3:return function(b,c){let d=b.shapeInfo.logicalShape,e=b.name,f="get"+e.charAt(0).toUpperCase()+e.slice(1),g=b.shapeInfo.texShape,h=[Math.ceil(g[0]/2),Math.ceil(g[1]/2)];if(1===d[0]){let e=ww(b,d.slice(1));return`
        ${a(e,c)}
        vec4 ${f}(int b, int row, int col) {
          return ${f}(${wx(["b","row","col"],[1,2])});
        }
      `}let i=wg();if(c)return`
    vec4 ${f}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${e}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${e}, uv);
    }
  `;let j=h[0],k=h[1],l=Math.ceil(d[2]/2),m=l*Math.ceil(d[1]/2);return`
    vec4 ${f}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${j}, ${k}, ${m}, ${l}, b, row, col);
      return ${i.texture2D}(${e}, uv);
    }
  `}(b,c);default:return function(a,b){let c=a.name,d="get"+c.charAt(0).toUpperCase()+c.slice(1),e=wg();if(b)return`
    vec4 ${d}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${c}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${c}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${c}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${c}TexShape[0]) / 2.0), ceil(float(${c}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${e.texture2D}(${c}, uv);
    }
  `;let f=a.shapeInfo.logicalShape,g=f.length,h=a.shapeInfo.texShape,i=[Math.ceil(h[0]/2),Math.ceil(h[1]/2)],j=i[0],k=i[1],l=Math.ceil(f[g-1]/2),m=l*Math.ceil(f[g-2]/2),n="int b, int row, int col",o=`b * ${m} + (row / 2) * ${l} + (col / 2)`;for(let a=2;a<g-1;a++)n=`int b${a}, `+n,m*=f[g-a-1],o=`b${a} * ${m} + `+o;return`
    vec4 ${d}(${n}) {
      int index = ${o};
      int texR = index / ${k};
      int texC = index - texR * ${k};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${k}, ${j});
      return ${e.texture2D}(${c}, uv);
    }
  `}(b,c)}}(a,d):e+=function a(b,c=!1){let d=b.shapeInfo.logicalShape;switch(d.length){case 0:return function(a,b){let c=a.name,d="get"+c.charAt(0).toUpperCase()+c.slice(1);if(a.shapeInfo.isUniform)return`float ${d}() {return ${c};}`;let[e,f]=a.shapeInfo.texShape;if(1===e&&1===f)return`
      float ${d}() {
        return sampleTexture(${c}, halfCR);
      }
    `;let g=ws(c);if(b)return`
    float ${d}() {
      vec2 uv = uvFromFlat(${c}TexShape[0], ${c}TexShape[1], ${g});
      return sampleTexture(${c}, uv);
    }
  `;let[h,i]=a.shapeInfo.texShape;return`
    float ${d}() {
      vec2 uv = uvFromFlat(${h}, ${i}, ${g});
      return sampleTexture(${c}, uv);
    }
  `}(b,c);case 1:return function(a,b){let c=a.name,d="get"+c.charAt(0).toUpperCase()+c.slice(1);if(a.shapeInfo.isUniform)return`
      float ${d}(int index) {
        ${wt(a)}
      }
    `;let e=a.shapeInfo.texShape,f=e[0],g=e[1];if(1===g&&1===f)return`
      float ${d}(int index) {
        return sampleTexture(${c}, halfCR);
      }
    `;let h=ws(c);return 1===g?b?`
      float ${d}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${h}) + 0.5) / float(${c}TexShape[0]));
        return sampleTexture(${c}, uv);
      }
    `:`
      float ${d}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${h}) + 0.5) / ${f}.0);
        return sampleTexture(${c}, uv);
      }
    `:1===f?b?`
      float ${d}(int index) {
        vec2 uv = vec2((float(index + ${h}) + 0.5) / float(${c}TexShape[1]), 0.5);
        return sampleTexture(${c}, uv);
      }
    `:`
      float ${d}(int index) {
        vec2 uv = vec2((float(index + ${h}) + 0.5) / ${g}.0, 0.5);
        return sampleTexture(${c}, uv);
      }
    `:b?`
    float ${d}(int index) {
      vec2 uv = uvFromFlat(${c}TexShape[0], ${c}TexShape[1], index + ${h});
      return sampleTexture(${c}, uv);
    }
  `:`
    float ${d}(int index) {
      vec2 uv = uvFromFlat(${f}, ${g}, index + ${h});
      return sampleTexture(${c}, uv);
    }
  `}(b,c);case 2:return function(b,c){let d=b.shapeInfo.logicalShape,e=b.name,f="get"+e.charAt(0).toUpperCase()+e.slice(1),g=b.shapeInfo.texShape;if(null!=g&&iV.arraysEqual(d,g)){if(c)return`
      float ${f}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${e}TexShape[1], ${e}TexShape[0]);
        return sampleTexture(${e}, uv);
      }
    `;let a=g[0],b=g[1];return`
    float ${f}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${b}.0, ${a}.0);
      return sampleTexture(${e}, uv);
    }
  `}let{newShape:h,keptDims:i}=iV.squeezeShape(d);if(h.length<d.length){let d=ww(b,h);return`
      ${a(d,c)}
      float ${f}(int row, int col) {
        return ${f}(${wx(["row","col"],i)});
      }
    `}if(b.shapeInfo.isUniform)return`
      float ${f}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${d[1]}, 1)));
        ${wt(b)}
      }
    `;let j=g[0],k=g[1],l=ws(e);return 1===k?c?`
      float ${f}(int row, int col) {
        float index = dot(vec3(row, col, ${l}), vec3(${e}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
    float ${f}(int row, int col) {
      float index = dot(vec3(row, col, ${l}), vec3(${d[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${j}.0);
      return sampleTexture(${e}, uv);
    }
  `:1===j?c?`
      float ${f}(int row, int col) {
        float index = dot(vec3(row, col, ${l}), vec3(${e}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
    float ${f}(int row, int col) {
      float index = dot(vec3(row, col, ${l}), vec3(${d[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${k}.0, 0.5);
      return sampleTexture(${e}, uv);
    }
  `:c?`
      float ${f}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${e}Shape[1] + col + ${l};
        vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index);
        return sampleTexture(${e}, uv);
      }
    `:`
  float ${f}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${d[1]} + col + ${l};
    vec2 uv = uvFromFlat(${j}, ${k}, index);
    return sampleTexture(${e}, uv);
  }
`}(b,c);case 3:return function(b,c){let d=b.shapeInfo.logicalShape,e=b.name,f="get"+e.charAt(0).toUpperCase()+e.slice(1),g=d[1]*d[2],h=d[2],{newShape:i,keptDims:j}=iV.squeezeShape(d);if(i.length<d.length){let d=ww(b,i);return`
        ${a(d,c)}
        float ${f}(int row, int col, int depth) {
          return ${f}(${wx(["row","col","depth"],j)});
        }
      `}if(b.shapeInfo.isUniform)return`
      float ${f}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${g}, ${h}, 1)));
        ${wt(b)}
      }
    `;let k=b.shapeInfo.texShape,l=k[0],m=k[1],n=b.shapeInfo.flatOffset;if(m===g&&null==n)return c?`
      float ${f}(int row, int col, int depth) {
        int stride1 = ${e}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${e}TexShape[1], ${e}TexShape[0]);
        return sampleTexture(${e}, uv);
      }
    `:`
        float ${f}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${h}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${l}.0);
          return sampleTexture(${e}, uv);
        }
      `;if(m===h&&null==n)return c?`
      float ${f}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${e}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${e}TexShape[1], ${e}TexShape[0]);
        return sampleTexture(${e}, uv);
      }
    `:`
    float ${f}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${d[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${l}.0);
      return sampleTexture(${e}, uv);
    }
  `;let o=ws(e);return c?`
    float ${f}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${e}Shape[1] * ${e}Shape[2];
      int stride1 = ${e}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${o};
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index);
      return sampleTexture(${e}, uv);
    }
    `:`
      float ${f}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${g} + col * ${h} + depth + ${o};
        vec2 uv = uvFromFlat(${l}, ${m}, index);
        return sampleTexture(${e}, uv);
      }
  `}(b,c);case 4:return function(b,c){let d=b.shapeInfo.logicalShape,e=b.name,f="get"+e.charAt(0).toUpperCase()+e.slice(1),g=d[3],h=d[2]*g,i=d[1]*h,{newShape:j,keptDims:k}=iV.squeezeShape(d);if(j.length<d.length){let d=ww(b,j);return`
      ${a(d,c)}
      float ${f}(int row, int col, int depth, int depth2) {
        return ${f}(${wx(["row","col","depth","depth2"],k)});
      }
    `}if(b.shapeInfo.isUniform)return`
      float ${f}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${h}, ${g}, 1)));
        ${wt(b)}
      }
    `;let l=b.shapeInfo.flatOffset,m=b.shapeInfo.texShape,n=m[0],o=m[1],p=`int stride2 = ${e}Shape[3];`,q=`int stride1 = ${e}Shape[2] * stride2;`,r=`int stride0 = ${e}Shape[1] * stride1;`;if(o===i&&null==l)return c?`
      float ${f}(int row, int col, int depth, int depth2) {
        ${p}
        ${q}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${e}TexShape[1], ${e}TexShape[0]);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${f}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${h}, ${g}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${o}.0, ${n}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(o===g&&null==l)return c?`
      float ${f}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e}Shape[1] * ${e}Shape[2], ${e}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${e}TexShape[1], ${e}TexShape[0]);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${f}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${d[1]*d[2]}, ${d[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${o}.0, ${n}.0);
        return sampleTexture(${e}, uv);
      }
    `;let s=ws(e);return c?`
    float ${f}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${p}
      ${q}
      ${r}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${s});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${f}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${h} +
          depth * ${g} + depth2;
      vec2 uv = uvFromFlat(${n}, ${o}, index + ${s});
      return sampleTexture(${e}, uv);
    }
  `}(b,c);case 5:return function(b){let c=b.shapeInfo.logicalShape,d=b.name,e="get"+d.charAt(0).toUpperCase()+d.slice(1),f=c[4],g=c[3]*f,h=c[2]*g,i=c[1]*h,{newShape:j,keptDims:k}=iV.squeezeShape(c);if(j.length<c.length){let c=ww(b,j);return`
      ${a(c)}
      float ${e}(int row, int col, int depth, int depth2, int depth3) {
        return ${e}(${wx(["row","col","depth","depth2","depth3"],k)});
      }
    `}if(b.shapeInfo.isUniform)return`
      float ${e}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${h}, ${g}, ${f})) +
          depth3;
        ${wt(b)}
      }
    `;let l=b.shapeInfo.flatOffset,m=b.shapeInfo.texShape,n=m[0],o=m[1];if(o===i&&null==l)return`
      float ${e}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${h}, ${g}, ${f}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${o}.0, ${n}.0);
        return sampleTexture(${d}, uv);
      }
    `;if(o===f&&null==l)return`
      float ${e}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${c[1]*c[2]*c[3]},
               ${c[2]*c[3]}, ${c[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${o}.0, ${n}.0);
        return sampleTexture(${d}, uv);
      }
    `;let p=ws(d);return`
    float ${e}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${h} + depth * ${g} +
          depth2 * ${f} + depth3 + ${p};
      vec2 uv = uvFromFlat(${n}, ${o}, index);
      return sampleTexture(${d}, uv);
    }
  `}(b);case 6:return function(b){let c=b.shapeInfo.logicalShape,d=b.name,e="get"+d.charAt(0).toUpperCase()+d.slice(1),{newShape:f,keptDims:g}=iV.squeezeShape(c);if(f.length<c.length){let c=ww(b,f);return`
      ${a(c)}
      float ${e}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${e}(${wx(["row","col","depth","depth2","depth3","depth4"],g)});
      }
    `}let h=c[5],i=c[4]*h,j=c[3]*i,k=c[2]*j,l=c[1]*k;if(b.shapeInfo.isUniform)return`
      float ${e}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${k}, ${j}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${h}, 1)));
        ${wt(b)}
      }
    `;let m=b.shapeInfo.flatOffset,n=b.shapeInfo.texShape,o=n[0],p=n[1];if(p===l&&null==m)return`
      float ${e}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${k}, ${j}, ${i}, ${h})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${o}.0);
        return sampleTexture(${d}, uv);
      }
    `;if(p===h&&null==m)return`
      float ${e}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${c[1]*c[2]*c[3]*c[4]},
               ${c[2]*c[3]*c[4]},
               ${c[3]*c[4]},
               ${c[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${o}.0);
        return sampleTexture(${d}, uv);
      }
    `;let q=ws(d);return`
    float ${e}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${k} + depth * ${j} +
          depth2 * ${i} + depth3 * ${h} + depth4 + ${q};
      vec2 uv = uvFromFlat(${o}, ${p}, index);
      return sampleTexture(${d}, uv);
    }
  `}(b);default:throw Error(`${d.length}-D input sampling is not yet supported`)}}(a,d);let f=a.shapeInfo.logicalShape,g=b.logicalShape;return f.length<=g.length&&(c?e+=function(a,b){let c,d=a.name,e=d.charAt(0).toUpperCase()+d.slice(1),f=a.shapeInfo.logicalShape.length,g=b.logicalShape.length,h=wm(a.shapeInfo.logicalShape,b.logicalShape),i=wu(g),j=g-f,k=["x","y","z","w","u","v"];c=0===f?"":g<2&&h.length>=1?"coords = 0;":h.map(a=>`coords.${k[a+j]} = 0;`).join("\n");let l="";l=g<2&&f>0?"coords":a.shapeInfo.logicalShape.map((a,b)=>`coords.${k[b+j]}`).join(", ");let m="return outputValue;",n=1===iV.sizeFromShape(a.shapeInfo.logicalShape),o=1===iV.sizeFromShape(b.logicalShape);if(1!==f||n||o){if(n&&!o)m=1===g?`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:`
        return vec4(outputValue.x);
      `;else if(h.length){let a=f-2,b=f-1;h.indexOf(a)>-1&&h.indexOf(b)>-1?m="return vec4(outputValue.x);":h.indexOf(a)>-1?m="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":h.indexOf(b)>-1&&(m="return vec4(outputValue.xx, outputValue.zz);")}}else m=`
      return vec4(outputValue.xy, outputValue.xy);
    `;return`
    vec4 ${"get"+e+"AtOutCoords"}() {
      ${i} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${e}(${l});
      ${m}
    }
  `}(a,b):e+=function(a,b){let c,d=a.name,e=d.charAt(0).toUpperCase()+d.slice(1),f="get"+e+"AtOutCoords",g=b.texShape,h=a.shapeInfo.texShape,i=a.shapeInfo.logicalShape.length,j=b.logicalShape.length;if(!a.shapeInfo.isUniform&&i===j&&null==a.shapeInfo.flatOffset&&iV.arraysEqual(h,g))return`
      float ${f}() {
        return sampleTexture(${d}, resultUV);
      }
    `;let k=wu(j),l=wm(a.shapeInfo.logicalShape,b.logicalShape),m=j-i,n=["x","y","z","w","u","v"];c=0===i?"":j<2&&l.length>=1?"coords = 0;":l.map(a=>`coords.${n[a+m]} = 0;`).join("\n");let o="";return o=j<2&&i>0?"coords":a.shapeInfo.logicalShape.map((a,b)=>`coords.${n[b+m]}`).join(", "),`
    float ${f}() {
      ${k} coords = getOutputCoords();
      ${c}
      return get${e}(${o});
    }
  `}(a,b)),e})(a,b,c.packedInputs,c.enableShapeUniforms)).join("\n"),m=b.texShape,n=wg(),o=(d=n,`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${d.texture2D}(textureSampler, uv).r;
    }
  `),p=(e=n,`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${wn}
    ${wo}
    ${wp}
  `);return b.isPacked?(h=function(a,b,c){switch(a.length){case 0:return wr();case 1:var d,e;let f;return d=b,e=c,1===(f=[Math.ceil(d[0]/2),Math.ceil(d[1]/2)])[0]?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${f[1]}.0);
      }
    `:1===f[1]?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${f[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${f[0]}, ${f[1]}));
      return 2 * (resTexRC.x * ${f[1]} + resTexRC.y);
    }
  `;case 2:var g=a,h=b,i=c;let j=[Math.ceil(h[0]/2),Math.ceil(h[1]/2)];if(iV.arraysEqual(g,h))return i?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${j[0]}, ${j[1]}));
      }
    `;let k=Math.ceil(g[1]/2);return i?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${j[0]}, ${j[1]}));

      int index = resTexRC.x * ${j[1]} + resTexRC.y;
      int r = 2 * (index / ${k});
      int c = imod(index, ${k}) * 2;

      return ivec2(r, c);
    }
  `;case 3:var l=a,m=b,n=c;if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let o=[Math.ceil(m[0]/2),Math.ceil(m[1]/2)],p=Math.ceil(l[2]/2),q=p*Math.ceil(l[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o[0]}, ${o[1]}));
      int index = resTexRC.x * ${o[1]} + resTexRC.y;

      int b = index / ${q};
      index -= b * ${q};

      int r = 2 * (index / ${p});
      int c = imod(index, ${p}) * 2;

      return ivec3(b, r, c);
    }
  `;default:return function(a,b,c){if(c)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let d=[Math.ceil(b[0]/2),Math.ceil(b[1]/2)],e=Math.ceil(a[a.length-1]/2),f=e*Math.ceil(a[a.length-2]/2),g=f,h="",i="b, r, c";for(let b=2;b<a.length-1;b++)g*=a[a.length-b-1],h=`
      int b${b} = index / ${g};
      index -= b${b} * ${g};
    `+h,i=`b${b}, `+i;return`
    ivec${a.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${d[0]}, ${d[1]}));
      int index = resTexRC.x * ${d[1]} + resTexRC.y;

      ${h}

      int b = index / ${f};
      index -= b * ${f};

      int r = 2 * (index / ${e});
      int c = imod(index, ${e}) * 2;

      return ivec${a.length}(${i});
    }
  `}(a,b,c)}}(b.logicalShape,m,c.enableShapeUniforms),f=n,i=`
    void setOutput(vec4 val) {
      ${f.output} = val;
    }
  `):(h=function(a,b,c){switch(a.length){case 0:return wr();case 1:return d=b,e=c,1===d[0]?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${d[1]}.0);
      }
    `:1===d[1]?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${d[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${d[0]}, ${d[1]}));
      return resTexRC.x * ${d[1]} + resTexRC.y;
    }
  `;case 2:return f=a,g=b,h=c,iV.arraysEqual(f,g)?h?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${g[0]}, ${g[1]}));
      }
    `:1===f[1]?h?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${g[0]}, ${g[1]}));
        int index = resTexRC.x * ${g[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:1===f[0]?h?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${g[0]}, ${g[1]}));
        int index = resTexRC.x * ${g[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:h?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${g[0]}, ${g[1]}));
      int index = resTexRC.x * ${g[1]} + resTexRC.y;
      int r = index / ${f[1]};
      int c = index - r * ${f[1]};
      return ivec2(r, c);
    }
  `;case 3:var d,e,f,g,h,i,j,k,l,m=a,n=b,o=c;if(o){let a=wi(["r","c","d"],m);return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${a}
    return ivec3(r, c, d);
  }
`}let p=wh(["r","c","d"],m);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      ${p}
      return ivec3(r, c, d);
    }
  `;case 4:var q=a,r=b,s=c;if(s){let a=wi(["r","c","d","d2"],q);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${a}
      return ivec4(r, c, d, d2);
    }
  `}let t=wh(["r","c","d","d2"],q);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      ${t}
      return ivec4(r, c, d, d2);
    }
  `;case 5:let u;return i=a,j=b,u=wh(["r","c","d","d2","d3"],i),`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${j[0]},
                             ${j[1]}));

      int index = resTexRC.x * ${j[1]} + resTexRC.y;

      ${u}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;case 6:let v;return k=a,l=b,v=wh(["r","c","d","d2","d3","d4"],k),`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${l[0]}, ${l[1]}));
      int index = resTexRC.x * ${l[1]} + resTexRC.y;

      ${v}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;default:throw Error(`${a.length}-D output sampling is not yet supported`)}}(b.logicalShape,m,c.enableShapeUniforms),g=n,i=`
    void setOutput(float val) {
      ${g.output} = vec4(val, 0, 0, 0);
    }
  `),c.packedInputs&&(p+=wq),[p,o,i,k,h,l,c.userCode].join("\n")}(c,e={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},a),g=vB(b.gl,f),h=b.createProgram(g),aw.get("ENGINE_COMPILE_ONLY")?{program:a,fragmentShader:g,source:f,webGLProgram:h,inShapeInfos:d,outShapeInfo:e,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(b.buildVao(h),Object.assign({program:a,fragmentShader:g,source:f,webGLProgram:h,inShapeInfos:d,outShapeInfo:e},wy(b,a,h)))}),q=null!=this.activeTimers;q&&(g=this.startTimer()),aw.get("ENGINE_COMPILE_ONLY")||function(a,b,c,d,e){b.program.enableShapeUniforms||(wz(b.inShapeInfos,c),wz([b.outShapeInfo],[d]));let f=d.texData.texture,g=d.texData.texShape;d.texData.isPacked?a.setOutputPackedMatrixTexture(f.texture,g[0],g[1]):a.setOutputMatrixTexture(f.texture,g[0],g[1]),a.setProgram(b.webGLProgram),a.bindVertexArray(b.webGLProgram.vao),1===aw.getNumber("WEBGL_VERSION")&&null!==b.infLoc&&a.gl.uniform1f(b.infLoc,1/0),null!==b.nanLoc&&a.gl.uniform1f(b.nanLoc,NaN);for(let d=0;d<c.length;++d){let e=c[d],{uniform:f,offset:g,shape:h,texShape:i}=b.variablesLocations[d];if(h){let{uniformShape:c}=wv(b.program.packedInputs,e.shape,e.texData.texShape);switch(c.length){case 1:a.gl.uniform1iv(h,new Int32Array(c));break;case 2:a.gl.uniform2iv(h,new Int32Array(c));break;case 3:a.gl.uniform3iv(h,new Int32Array(c));break;case 4:a.gl.uniform4iv(h,new Int32Array(c))}}if(i&&a.gl.uniform2i(i,e.texData.texShape[0],e.texData.texShape[1]),null!=f){if(e.isUniform){if(2>iV.sizeFromShape(e.shape))a.gl.uniform1f(f,e.uniformValues[0]);else{let b=e.uniformValues;b instanceof Float32Array||(b=new Float32Array(b)),a.gl.uniform1fv(f,b)}continue}null!=e.texData.slice&&null!=g&&a.gl.uniform1i(g,e.texData.slice.flatOffset),a.setInputMatrixTexture(e.texData.texture.texture,f,d)}}let h=b.outShapeLocation;if(h)switch(d.shape.length){case 1:a.gl.uniform1iv(h,new Int32Array(d.shape));break;case 2:a.gl.uniform2iv(h,new Int32Array(d.shape));break;case 3:a.gl.uniform3iv(h,new Int32Array(d.shape));break;case 4:a.gl.uniform4iv(h,new Int32Array(d.shape))}if(b.outShapeStridesLocation){let c=iV.computeStrides(d.shape);switch(d.shape.length){case 2:a.gl.uniform1iv(b.outShapeStridesLocation,new Int32Array(c));break;case 3:a.gl.uniform2iv(b.outShapeStridesLocation,new Int32Array(c));break;case 4:a.gl.uniform3iv(b.outShapeStridesLocation,new Int32Array(c))}}if(b.outTexShapeLocation&&a.gl.uniform2i(b.outTexShapeLocation,d.texData.texShape[0],d.texData.texShape[1]),b.program.customUniforms&&e)for(let c=0;c<b.program.customUniforms.length;++c){let d=b.program.customUniforms[c],f=b.customUniformLocations[c],g=e[c];if("float"===d.type)a.gl.uniform1fv(f,g);else if("vec2"===d.type)a.gl.uniform2fv(f,g);else if("vec3"===d.type)a.gl.uniform3fv(f,g);else if("vec4"===d.type)a.gl.uniform4fv(f,g);else if("int"===d.type)a.gl.uniform1iv(f,g);else if("ivec2"===d.type)a.gl.uniform2iv(f,g);else if("ivec3"===d.type)a.gl.uniform3iv(f,g);else if("ivec4"===d.type)a.gl.uniform4iv(f,g);else throw Error(`uniform type ${d.type} is not supported yet.`)}a.executeProgram()}(this.gpgpu,p,m,n,d),l.forEach(a=>this.disposeIntermediateTensorInfo(a)),q&&(g=this.endTimer(g),this.activeTimers.push({name:a.constructor.name,query:this.getQueryTime(g)}));let r=aw.getNumber("WEBGL_FLUSH_THRESHOLD");if(r>0){let a=iV.now();a-this.lastGlFlushTime>r&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=a)}if(!aw.getBool("WEBGL_LAZILY_UNPACK")&&k.isPacked&&!1===e){let a=this.unpackTensor(j);return this.disposeIntermediateTensorInfo(j),a}return j}compileAndRun(a,b,c,d,e=!1){return c=c||b[0].dtype,this.runWebGLProgram(a,b,c,d,e)}getAndSaveBinary(a,b){return a in this.binaryCache||(this.binaryCache[a]=b()),this.binaryCache[a]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(aw.getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(a=>{this.gpgpu.deleteProgram(this.binaryCache[a].webGLProgram),delete this.binaryCache[a]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=dT(()=>{if(!aw.get("WEBGL_RENDER_FLOAT32_ENABLED")){let a=aw.getBool("DEBUG");aw.set("DEBUG",!1);let b=this.abs(eG(1e-8)).dataSync()[0];if(aw.set("DEBUG",a),b>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(a){let b,c=this.texData.get(a),{shape:d,dtype:e,values:f,texture:g,usage:h,isPacked:i}=c;if(null!=g)return;let j=null!=this.activeTimers;j&&(b=iV.now());let k=c.texShape;if(null==k&&(c.texShape=k=v1(d,i)),null!=f){let a,g=v0(d),h=k[1],l=k[0],m=f instanceof Uint8Array||f instanceof Uint8ClampedArray;(i||!m)&&([h,l]=vu(k[0],k[1])),a=i?new wH(g,m):new wG(g,m);let n=m?[l,h]:k,o=this.makeTensorInfo(n,e),p=this.texData.get(o.dataId);m?p.usage=BT.PIXELS:p.usage=BT.UPLOAD,p.texShape=n,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(o.dataId),h,l,f);let q=[[l,h]],r=this.runWebGLProgram(a,[o],e,q,!0),s=this.texData.get(r.dataId);c.texShape=s.texShape,c.isPacked=s.isPacked,c.usage=s.usage,aw.get("ENGINE_COMPILE_ONLY")?this.disposeData(r.dataId):(c.texture=s.texture,c.values=null,this.texData.delete(r.dataId)),this.disposeIntermediateTensorInfo(o),j&&(this.uploadWaitMs+=iV.now()-b)}else c.texture=this.acquireTexture(k,h,e,i)}convertAndCacheOnCPU(a,b){let c=this.texData.get(a),{dtype:d}=c;return null!=b&&(c.values=function(a,b){if("float32"===b||"complex64"===b)return a;if("int32"===b||"bool"===b){let c="int32"===b?new Int32Array(a.length):new Uint8Array(a.length);for(let b=0;b<c.length;++b)c[b]=Math.round(a[b]);return c}throw Error(`Unknown dtype ${b}`)}(b,d)),c.values}acquireTexture(a,b,c,d){if(this.numBytesInGPU+=this.computeBytes(a,c),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){let a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(a,b,d)}computeBytes(a,b){return a[0]*a[1]*iV.bytesPerElement(b)}checkCompileCompletion(){for(let[,a]of Object.entries(this.binaryCache))this.checkCompletion_(a)}async checkCompileCompletionAsync(){let a=[];if(this.gpgpu.parallelCompilationExtension){for(let[,b]of Object.entries(this.binaryCache))a.push(this.checkCompletionAsync_(b));return Promise.all(a)}for(let[,b]of Object.entries(this.binaryCache)){let c=new Promise(a=>{try{this.checkCompletion_(b),a(!0)}catch(a){throw a}});a.push(c)}return Promise.all(a)}async checkCompletionAsync_(a){return this.gpgpu.gl.getProgramParameter(a.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(a):(await mg(),this.checkCompletionAsync_(a))}checkCompletion_(a){if(!1===this.gpgpu.gl.getProgramParameter(a.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(a.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(a.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw vD(a.source,this.gpgpu.gl.getShaderInfoLog(a.fragmentShader)),Error("Failed to compile fragment shader.");throw Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(let a of Object.values(this.binaryCache)){this.gpgpu.buildVao(a.webGLProgram);let{variablesLocations:b,customUniformLocations:c,infLoc:d,nanLoc:e,outShapeLocation:f,outShapeStridesLocation:g,outTexShapeLocation:h}=wy(this.gpgpu,a.program,a.webGLProgram);a.variablesLocations=b,a.customUniformLocations=c,a.infLoc=d,a.nanLoc=e,a.outShapeLocation=f,a.outShapeStridesLocation=g,a.outTexShapeLocation=h}}createTensorFromGPUData(a,b,c){a.channels=a.channels||"RGBA";let{texture:d,height:e,width:f,channels:g}=a,h=dB.backend;if(!h.gpgpu.gl.isTexture(d))throw Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let i=h.writeTexture(d,b,c,e,f,g);return dB.makeTensorFromDataId(i,b,c,h)}}ya.nextDataId=0;var yb=a.i(438096),yc=a.i(982212);function yd(){aw.set("WEBGL_FORCE_F16_TEXTURES",!0)}a.s(["forceHalfFloat",()=>yd],649679),vo.isBrowser()&&dW("webgl",()=>new ya,2),a.s(["webgl",0,{forceHalfFloat:yd}],662536);var un=gz,iV=iV,hp=hp,hp=hp;let ye=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class yf{constructor(a,b,c){this.variableNames=["A","B"],this.outputShape=hp.assertAndGetBroadcastShape(b,c),this.enableShapeUniforms=wA(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${a}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}var hp=hp,iV=iV;let yg=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class yh{constructor(a,b,c,d=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=hp.assertAndGetBroadcastShape(b,c);const e=this.outputShape.length;this.enableShapeUniforms=wA(e);let f="";if(d)if(0===e||1===iV.sizeFromShape(this.outputShape))f=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else{const a=wu(e);if(f=`
          ${a} coords = getOutputCoords();
        `,1===e)this.enableShapeUniforms?f+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:f+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const a=xR("coords",e);this.enableShapeUniforms?f+=`
            bool nextRowOutOfBounds =
              (${a[e-2]} + 1) >= outShape[${e} - 2];
            bool nextColOutOfBounds =
              (${a[e-1]} + 1) >= outShape[${e} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:f+=`
            bool nextRowOutOfBounds =
              (${a[e-2]} + 1) >= ${this.outputShape[e-2]};
            bool nextColOutOfBounds =
              (${a[e-1]} + 1) >= ${this.outputShape[e-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${a}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${f}

        setOutput(result);
      }
    `}}function yi(a){let{inputs:b,backend:c}=a,{x:d}=b;return c.incRef(d.dataId),{dataId:d.dataId,shape:d.shape,dtype:d.dtype}}function yj(a){let{inputs:b,backend:c}=a,{real:d,imag:e}=b,f=c.makeTensorInfo(d.shape,"complex64");return c.texData.get(f.dataId).complexTensorInfos={real:yi({inputs:{x:d},backend:c}),imag:yi({inputs:{x:e},backend:c})},f}var iV=iV;let yk="return (a < 0.) ? b * a : a;",yl=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,ym="return (a < 0.) ? b * a : a;",yn=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,yo="if (isnan(x)) return x;";function yp({opSnippet:a,packedOpSnippet:b,cpuKernelImpl:c,dtype:d}){return({inputs:e,backend:f})=>{let g,{x:h}=e,i=d||h.dtype;if(f.shouldExecuteOnCPU([h])&&null!=c){let a=c(f.texData.get(h.dataId).values,i);return f.makeTensorInfo(h.shape,i,a)}return g=aw.getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=b?new x5(h.shape,b):new xY(h.shape,a),f.runWebGLProgram(g,[h],i)}}function yq({opSnippet:a,packedOpSnippet:b,checkOutOfBounds:c=!1,supportsComplex:d=!1,cpuKernelImpl:e,dtype:f}){return({inputs:g,backend:h})=>{let i,{a:j,b:k}=g;if(d&&"complex64"===j.dtype){let b=h.texData.get(j.dataId),c=h.texData.get(k.dataId),[d,e]=[[b.complexTensorInfos.real,c.complexTensorInfos.real],[b.complexTensorInfos.imag,c.complexTensorInfos.imag]].map(b=>{let[c,d]=b,e={dataId:c.dataId,dtype:c.dtype,shape:j.shape},f={dataId:d.dataId,dtype:d.dtype,shape:k.shape},g=new yf(a,j.shape,k.shape);return h.runWebGLProgram(g,[e,f],dp(c.dtype,d.dtype))}),f=yj({inputs:{real:d,imag:e},backend:h});return h.disposeIntermediateTensorInfo(d),h.disposeIntermediateTensorInfo(e),f}let l=f||dp(j.dtype,k.dtype);if(("string"===j.dtype||"string"===k.dtype||h.shouldExecuteOnCPU([j,k]))&&null!=e){let a=h.texData.get(j.dataId).values,b=h.texData.get(k.dataId).values,c="string"===j.dtype?hp.fromUint8ToStringArray(a):a,d="string"===j.dtype?hp.fromUint8ToStringArray(b):b,[f,g]=e(j.shape,k.shape,c,d,l),i=h.makeTensorInfo(g,l);return h.texData.get(i.dataId).values=f,i}return i=aw.getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=b?new yh(b,j.shape,k.shape,c):new yf(a,j.shape,k.shape),h.runWebGLProgram(i,[j,k],l)}}function yr(a,b=!1){if("linear"===a)return"return x;";if("relu"===a)return b?x3:x_;if("elu"===a)return b?x2:"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===a)return b?x4:x0;if("prelu"===a)return b?yn:ym;else if("leakyrelu"===a)return b?yl:yk;else if("sigmoid"===a)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw Error(`Activation ${a} has not been implemented for the WebGL backend.`)}class ys{constructor(a,b,c,d=!1,e=!1,f=!1,g=null,h=!1,i=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=c,this.enableShapeUniforms=wA(this.outputShape.length);const j=Math.ceil((d?a[1]:a[2])/2),k=d?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],l=e?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",n="";g&&(m=h?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${g}
        }`:i?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${g}
        }`:`vec4 activation(vec4 x) {
          ${g}
        }`,n="result = activation(result);"),f&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha");let o="rc.x",p="rc.x";a[0]<b[0]?o=`imod(rc.x, ${a[0]})`:b[0]<a[0]&&(p=`imod(rc.x, ${b[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${j}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${o};
        int batchB = ${p};
        for (int i = 0; i < ${j}; i++) {
          vec4 a = getMatrixA(batchA, ${d?"i * 2, rc.y":"rc.y, i * 2"});
          vec4 b = getMatrixB(batchB, ${e?"rc.z, i * 2":"i * 2, rc.z"});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${k[0]} * ${l[0]});
          result += (${k[1]} * ${l[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${f?"result += getBiasAtOutCoords();":""}

        ${n}

        setOutput(result);
      }
    `}}var hp=hp,hp=hp;class yt{constructor(a,b,c){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=hp.assertAndGetBroadcastShape(b,c),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${a}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}let yu="return a * b;";function yv(a){let b,{inputs:c,backend:d}=a,{a:e,b:f}=c,g=hp.upcastType(e.dtype,f.dtype);if("complex64"===e.dtype){let a=d.texData.get(e.dataId),b=d.texData.get(f.dataId),c=new yt("return areal * breal - aimag * bimag;",e.shape,f.shape),g=new yt("return areal * bimag + aimag * breal;",e.shape,f.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:e.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:e.shape},{dataId:b.complexTensorInfos.real.dataId,dtype:b.complexTensorInfos.real.dtype,shape:f.shape},{dataId:b.complexTensorInfos.imag.dataId,dtype:b.complexTensorInfos.imag.dtype,shape:f.shape}],i=d.runWebGLProgram(c,h,"float32"),j=d.runWebGLProgram(g,h,"float32"),k=yj({inputs:{real:i,imag:j},backend:d});return d.disposeIntermediateTensorInfo(i),d.disposeIntermediateTensorInfo(j),k}if(d.shouldExecuteOnCPU([e,f])){let a=d.texData.get(e.dataId),b=d.texData.get(f.dataId),[c,h]=xp(e.shape,f.shape,a.values,b.values,g),i=d.makeTensorInfo(h,g);return d.texData.get(i.dataId).values=c,i}return b=aw.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new yh(yu,e.shape,f.shape):new yf(yu,e.shape,f.shape),d.runWebGLProgram(b,[e,f],g)}var iV=iV;function yw(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{shape:f}=d,g=iV.sizeFromShape(e.shape),h=iV.inferFromImplicitShape(f,g),i=iV.sizeFromShape(h);iV.assert(g===i,()=>`The new shape (${h}) has ${i} elements and the old shape (${e.shape}) has ${g} elements. The new shape and old shape must have the same number of elements.`);let j=c.texData.get(e.dataId);if(j.isPacked&&!v2(e.shape,h)&&!(null!==j.texture&&v2(j.shape,h))){let a,b,d,f,g;return a=[v$(e.shape),...v_(e.shape)],b={dtype:e.dtype,shape:a,dataId:e.dataId},d=new xT([v$(h),...v_(h)],a),f=[a],{dataId:(g=c.runWebGLProgram(d,[b],e.dtype,f,!0)).dataId,shape:h,dtype:g.dtype}}return c.incRef(e.dataId),{dataId:e.dataId,shape:h,dtype:e.dtype}}var hp=hp,iV=iV,hp=hp,iV=iV;class yx{constructor(a,b){this.variableNames=["x"];const{windowSize:c,batchSize:d,inSize:e,outSize:f}=a;this.outputShape=[d,f];const g=4*Math.floor(c/4),h=c%4;let i="sumValue += dot(values, ones);";if(null!=b){const a=1/b;i=`sumValue += dot(values * ${iV.isInt(a)?a.toPrecision(2):a}, ones);`}let j="";e%c>0&&(j=`
        if (inIdx < 0 || inIdx >= ${e}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${j}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${c};

        float sumValue = 0.0;

        for (int i = 0; i < ${g}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${i}
        }

        int inIdx = inOffset + ${g};
        if (${1===h}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${i}
        } else if (${2===h}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${i}
        } else if (${3===h}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${i}
        }
        setOutput(sumValue);
      }
    `}}class yy{constructor(a,b){this.variableNames=["x"];const{windowSize:c,batchSize:d,inSize:e,outSize:f}=a;this.outputShape=[d,f];let g="0.0",h="";"prod"===b?g="1.0":"min"===b?(g="1.0 / 1e-20",h="min"):"max"===b&&(g="-1.0 / 1e-20",h="max");let i=`${b}(${b}(${b}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===b?i="sumValue":"prod"===b?i="prodValue":"all"===b?i="allValue":"any"===b&&(i="anyValue");const j=4*Math.floor(c/4),k=c%4;let l=`
      if (${"sum"===b}) {
        sumValue += dot(values, ones);
      } else if (${"prod"===b}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${h}(values, minMaxValue);
        if (${"min"===b} || ${"max"===b}) {
          minMaxValue = ${h}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,m="vec4";"all"===b?(g="1.0",l=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,m="bvec4"):"any"===b&&(g="0.0",l=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,m="bvec4");let n="";e%c>0&&(n=`
        if (inIdx < 0 || inIdx >= ${e}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${g};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${n}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${c};

        vec4 minMaxValue = vec4(${g});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${j}; i += 4) {
          int inIdx = inOffset + i;
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${j};
        if (${1===k}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${l}
        } else if (${2===k}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${l}
        } else if (${3===k}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${l}
        }
        setOutput(${i});
      }
    `}}function yz(a,b,c,d){let e=function(a){let b=[];for(;0===b.length||1!==b[b.length-1].outSize;){let c=b.length?b[b.length-1].outSize:a[1],d=hp.computeOptimalWindowSize(c);b.push({inSize:c,windowSize:d,outSize:Math.ceil(c/d)})}return b}(a.shape),f=a;for(let g=0;g<e.length;g++){let h,i,{inSize:j,windowSize:k,outSize:l}=e[g];h="mean"===c?0===g?new yx({windowSize:k,inSize:j,batchSize:a.shape[0],outSize:l},j):new yx({windowSize:k,inSize:j,batchSize:a.shape[0],outSize:l}):new yy({windowSize:k,inSize:j,batchSize:a.shape[0],outSize:l},c),i=f,f=d.runWebGLProgram(h,[f],b),i.dataId!==a.dataId&&d.disposeIntermediateTensorInfo(i)}return f}class yA{constructor(a,b){this.variableNames=["A"];const c=Array(a.length);for(let d=0;d<c.length;d++)c[d]=a[b[d]];this.outputShape=c,this.rank=c.length;const d=wu(this.rank),e=function(a){let b=a.length;if(b>6)throw Error(`Transpose for rank ${b} is not yet supported`);let c=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],d=Array(b);for(let b=0;b<a.length;b++)d[a[b]]=c[b];return d.join()}(b);this.userCode=`
    void main() {
      ${d} resRC = getOutputCoords();
      setOutput(getA(${e}));
    }
    `}}class yB{constructor(a,b){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const c=Array(a.length);for(let d=0;d<c.length;d++)c[d]=a[b[d]];if(this.outputShape=c,this.rank=c.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const d=wu(this.rank),e=xQ("rc",this.rank),f=Array(this.rank);for(let a=0;a<b.length;a++)f[b[a]]=e[a];const g=`vec2(${f.slice(-2).join()})`,h=`++${e[this.rank-1]} < ${c[this.rank-1]}`,i=`getChannel(getA(${f.join()}), ${g})`;this.userCode=`
    void main() {
      ${d} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${i};
      if(${h}) {
        result[1] = ${i};
      }
      --${e[this.rank-1]};
      if(++${e[this.rank-2]} < ${c[this.rank-2]}) {
        result[2] = ${i};
        if(${h}) {
          result[3] = ${i};
        }
      }
      setOutput(result);
    }
    `}}function yC(a,b,c){let d=aw.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new yB(a.shape,b):new yA(a.shape,b);return c.runWebGLProgram(d,[a],a.dtype)}function yD(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{axis:f,keepDims:g}=d;return function(a,b,c,d){let e=a.shape.length,f=iV.parseAxisParam(b,a.shape),g=f,h=hp.getAxesPermutation(g,e),i=null!=h,j=a;i&&(j=yC(a,h,d),g=hp.getInnerMostAxes(g.length,e)),hp.assertAxesAreInnerMostDims("sum",g,e);let[k,l]=hp.computeOutAndReduceShapes(j.shape,g),m=k;c&&(m=hp.expandShapeToKeepDim(k,f));let n=iV.sizeFromShape(l),o=yw({inputs:{x:j},attrs:{shape:[iV.sizeFromShape(a.shape)/n,n]},backend:d}),p=yz(o,dq(a.dtype),"sum",d),q=yw({inputs:{x:p},attrs:{shape:m},backend:d});return d.disposeIntermediateTensorInfo(o),d.disposeIntermediateTensorInfo(p),i&&d.disposeIntermediateTensorInfo(j),q}(e,f,g,c)}function yE(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f}=c,{perm:g}=e,h=Array(f.shape.length);for(let a=0;a<h.length;a++)h[a]=f.shape[g[a]];if(d.shouldExecuteOnCPU([f])){let a=xO(d.texData.get(f.dataId).values,f.shape,f.dtype,g,h);b=d.makeTensorInfo(h,f.dtype),d.texData.get(b.dataId).values=a}else b=yC(f,g,d);return b}function yF({a,b,transposeA:c,transposeB:d,backend:e,bias:f=null,preluActivationWeights:g=null,leakyreluAlpha:h=0,activation:i=null}){let j,k=a.shape.length,l=b.shape.length,m=c?a.shape[k-2]:a.shape[k-1],n=d?b.shape[l-1]:b.shape[l-2],o=c?a.shape[k-1]:a.shape[k-2],p=d?b.shape[l-2]:b.shape[l-1],q=a.shape.slice(0,-2),r=b.shape.slice(0,-2),s=iV.sizeFromShape(q),t=iV.sizeFromShape(r),u=un.assertAndGetBroadcastShape(a.shape.slice(0,-2),b.shape.slice(0,-2)).concat([o,p]);iV.assert(m===n,()=>`Error in matMul: inner shapes (${m}) and (${n}) of Tensors with shapes ${a.shape} and ${b.shape} and transposeA=${c} and transposeB=${d} must match.`);let v=c?[s,m,o]:[s,o,m],w=d?[t,p,n]:[t,n,p],x=yw({inputs:{x:a},backend:e,attrs:{shape:v}}),y=yw({inputs:{x:b},backend:e,attrs:{shape:w}}),z=[x,y],A=Math.max(s,t),B=c?x.shape[1]:x.shape[2],C=null!=f,D=null!=g,E="leakyrelu"===i,F=null!=i?yr(i,!0):null,G=C||D||E||null!=F;if((1===o||1===p)&&B>1e3&&!1===G){let a=x,b=y;c&&(a=yE({inputs:{x:x},backend:e,attrs:{perm:[0,2,1]}}),z.push(a)),d&&(b=yE({inputs:{x:y},backend:e,attrs:{perm:[0,2,1]}}),z.push(b));let f=1!==p,g=1===p,h=a;f&&(h=yw({inputs:{x:a},backend:e,attrs:{shape:[A,B,1]}}),z.push(h));let i=b;g&&(i=yw({inputs:{x:b},backend:e,attrs:{shape:[A,1,B]}}),z.push(i));let k=yv({inputs:{a:h,b:i},backend:e});j=yD({inputs:{x:k},backend:e,attrs:{axis:1===p?2:1,keepDims:!0}}),z.push(k)}else{let i=dp(a.dtype,b.dtype),k=new ys(v,w,[A,o,p],c,d,C,F,D,E),l=[x,y];if(null!=f&&l.push(f),D&&l.push(g),E){let a=e.makeTensorInfo([],"float32",iV.createScalarValue(h,"float32"));l.push(a),z.push(a)}j=e.runWebGLProgram(k,l,i)}let H=yw({inputs:{x:j},backend:e,attrs:{shape:u}});for(let a of(z.push(j),z))e.disposeIntermediateTensorInfo(a);return H}let yG="return abs(x);",yH=yp({opSnippet:xZ+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`}),yI=yp({opSnippet:xZ+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`}),yJ="return a + b;",yK=yq({opSnippet:yJ,packedOpSnippet:yJ,supportsComplex:!0,cpuKernelImpl:w3});class yL{constructor(a,b){this.outputShape=[],this.outputShape=a,this.variableNames=b.map((a,b)=>`T${b}`);const c=[];this.variableNames.forEach(a=>{c.push(`float v${a} = get${a}AtOutCoords();`)});const d=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${c.join("\n        ")}

        float result = ${d};
        setOutput(result);
      }
    `}}class yM{constructor(a,b){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a,this.variableNames=b.map((a,b)=>`T${b}`);const c=[];this.variableNames.forEach(a=>{c.push(`vec4 v${a} = get${a}AtOutCoords();`)});const d=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${c.join("\n        ")}

        vec4 result = ${d};
        setOutput(result);
      }
    `}}var hp=hp,iV=iV,hp=hp,iV=iV,hp=hp,iV=iV,hp=hp,iV=iV;class yN{constructor(a,b,c){this.variableNames=["A"];const{windowSize:d,batchSize:e,outSize:f}=a;c||this.variableNames.push("bestIndicesA"),this.outputShape=[e,f],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${d};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${d}; i++) {
          int inIdx = ${c?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};
          float candidate = getA(batch, inIdx);
          if (candidate ${"max"===b?">":"<"} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}var iV=iV;class yO{constructor(a,b,c,d){let e,f;this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,iV.assert(a.length>2,()=>`Packed arg${c.charAt(0).toUpperCase()+c.slice(1)} supports only inputs with rank above 2.`);const g=Math.ceil(a[a.length-1]/b);this.outputShape=a.slice(0,-1),g>1&&this.outputShape.push(g),d||this.variableNames.push("bestIndicesA");const h=this.outputShape,i=h.length,j=wu(i),k=xR("coords",i);if(1===g){const a=wu(f=i+1);e=`
        ${a} sourceLocR = ${a}(${k.join()}, 0);
        ++${k[i-1]};
        ${a} sourceLocG = ${a}(${k.join()}, 0);
        ++${k[i-2]};
        ${a} sourceLocA = ${a}(${k.join()}, 0);
        --${k[i-1]};
        ${a} sourceLocB = ${a}(${k.join()}, 0);
        --${k[i-2]};`}else f=i,e=`
        ${j} sourceLocR = coords;
        ++${k[i-1]};
        ${j} sourceLocG = coords;
        ++${k[i-2]};
        ${j} sourceLocA = coords;
        --${k[i-1]};
        ${j} sourceLocB = coords;
        --${k[i-2]};`;const l=["x","y","z","w","u","v"].slice(0,f),m="."+l[f-1],n=l.map(a=>"int "+a),o=xR("sourceLocR",f-1).concat("inIdx.r"),p=xR("sourceLocG",f-1).concat("inIdx.g"),q=xR("sourceLocB",f-1).concat("inIdx.b"),r=xR("sourceLocA",f-1).concat("inIdx.a"),s="max"===c?"greaterThan":"lessThan",t=d?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${o.join()}),
                             getBestIndicesAChannel(${p.join()}),
                             getBestIndicesAChannel(${q.join()}),
                             getBestIndicesAChannel(${r.join()})));`,u=`vec4(
            getAChannel(${o.join()}),
            hasNextCol ? getAChannel(${p.join()}) : 0.,
            hasNextRow ? getAChannel(${q.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${r.join()}) : 0.)`,v=d?"":`
      float getBestIndicesAChannel(${n.join()}) {
        return getChannel(getBestIndicesA(${l.join()}),
                                          vec2(${l.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${n.join()}) {
        return getChannel(getA(${l.join()}),
                               vec2(${l.slice(-2).join()}));
      }
      ${v}
      void main() {
        ${j} coords = getOutputCoords();
        bool hasNextCol = ${k[i-1]} < ${h[i-1]-1};
        bool hasNextRow = ${k[i-2]} < ${h[i-2]-1};
        ${e}
        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},
          sourceLocB${m}, sourceLocA${m}) * ${b};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${u};

        for (int i = 0; i < ${b}; i++) {
          inIdx = srcIdx;
          ${t}
          vec4 candidate = ${u};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${s}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function yP(a,b,c,d){let e=[c];if(hp.assertAxesAreInnerMostDims("arg"+d.charAt(0).toUpperCase()+d.slice(1),e,b.shape.length),!aw.getBool("WEBGL_PACK_REDUCE")||b.shape.length<=2){let c=[],f=a.texData.get(b.dataId),g=null!==f&&f.isPacked,h=b;g&&c.push(h=a.unpackTensor(b));let[i,j]=hp.computeOutAndReduceShapes(h.shape,e),k=yw({inputs:{x:h},backend:a,attrs:{shape:[-1,iV.sizeFromShape(j)]}});c.push(k);let l=function a(b,c,d,e=null){let f=c.shape[0],g=c.shape[1];null!=e&&(f=e.shape[0],g=e.shape[1]);let h=hp.computeOptimalWindowSize(g),i=new yN({windowSize:h,inSize:g,batchSize:f,outSize:Math.ceil(g/h)},d,null==e),j=[c];null!=e&&j.push(e);let k=b.runWebGLProgram(i,j,"int32");if(1===k.shape[1])return k;let l=a(b,c,d,k);return b.disposeIntermediateTensorInfo(k),l}(a,k,d);c.push(l);let m=yw({inputs:{x:l},backend:a,attrs:{shape:i}});return c.forEach(b=>a.disposeIntermediateTensorInfo(b)),m}return function a(b,c,d,e=null){let f=null!=e?e.shape:c.shape,g=f[f.length-1],h=new yO(f,hp.computeOptimalWindowSize(g),d,null==e),i=null==e?[c]:[c,e],j=b.runWebGLProgram(h,i,"int32");if(j.shape.length===c.shape.length){let e=a(b,c,d,j);return b.disposeIntermediateTensorInfo(j),e}return j}(a,b,d)}var hp=hp,iV=iV;let yQ=yp({opSnippet:xZ+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`}),yR=yp({opSnippet:xZ+"return log(x + sqrt(x * x + 1.0));"}),yS=yp({opSnippet:xZ+`
  return atan(x);
`}),yT=yq({opSnippet:ye+`
  return atan(a, b);
`,packedOpSnippet:`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+yg+`
  return result;
`}),yU=yp({opSnippet:xZ+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`});var hp=hp,iV=iV;class yV{constructor(a,b,c,d=!1,e=!1){if(this.variableNames=["x"],"avg"===b&&c)throw Error("Cannot compute positions for average pool.");const f=a.filterWidth,g=a.strideHeight,h=a.strideWidth,i=a.dilationHeight,j=a.dilationWidth,k=a.effectiveFilterHeight,l=a.effectiveFilterWidth,m=a.padInfo.top,n=a.padInfo.left;this.outputShape=a.outShape;const o="avg"===b,p=`((batch  * ${a.inHeight} + xR) * ${a.inWidth} + xC) * ${a.inChannels} + d`,q=`(xR * ${a.inWidth} + xC) * ${a.inChannels} + d`;let r="0.0";if(o||(r="-1.0 / 1e-20"),c){this.userCode=`
        const ivec2 strides = ivec2(${g}, ${h});
        const ivec2 pads = ivec2(${m}, ${n});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${k};
              wR += ${i}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${a.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${l};
                wC += ${j}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${a.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${d?e?p:q:`wR * ${l} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let s=`${b}(${b}(${b}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===b&&(s="avgValue / max(count, 1.0)");const t=4*Math.floor(f/4),u=f%4,v=`
      if (${o}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${g}, ${h});
      const ivec2 pads = ivec2(${m}, ${n});
      const float initializationValue = ${r};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${a.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${r});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${k};
            wR += ${i}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${a.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${t}; wC += 4) {
            int xC = xCCorner + wC * ${j};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${j}, d),
              getValue(batch, xR, xC + 2 * ${j}, d),
              getValue(batch, xR, xC + 3 * ${j}, d)
            );

            ${v}
          }

          int xC = xCCorner + ${t};
          if (${1===u}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${v}
          } else if (${2===u}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${j}, d),
              initializationValue,
              initializationValue
            );

            ${v}
          } else if (${3===u}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${j}, d),
              getValue(batch, xR, xC + 2 * ${j}, d),
              initializationValue
            );

            ${v}
          }
        }
        setOutput(${s});
      }
    `}}class yW{constructor(a,b,c,d=!1,e=!1){if(this.variableNames=["x"],"avg"===b&&c)throw Error("Cannot compute positions for average pool.");const f=a.filterWidth,g=a.strideDepth,h=a.strideHeight,i=a.strideWidth,j=a.dilationDepth,k=a.dilationHeight,l=a.dilationWidth,m=a.effectiveFilterDepth,n=a.effectiveFilterHeight,o=a.effectiveFilterWidth,p=a.padInfo.front,q=a.padInfo.top,r=a.padInfo.left;this.outputShape=a.outShape;const s="avg"===b;let t="0.0";if(s||(t="-1.0 / 1e-20"),c){this.userCode=`
        const ivec3 strides =
            ivec3(${g}, ${h}, ${i});
        const ivec3 pads = ivec3(${p}, ${q}, ${r});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${m};
              wD += ${j}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${a.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${n};
                wR += ${k}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${a.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${o};
                  wC += ${l}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${a.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${d?e?`(((batch * ${a.inDepth} + xD) * ${a.inHeight} + xR) * ${a.inWidth} + xC) * ${a.inChannels} + ch`:`((xD * ${a.inHeight} + xR) * ${a.inWidth} + xC) * ${a.inChannels} + ch`:`wD * ${n} * ${o} +
                      wR * ${o} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let u=`${b}(${b}(${b}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===b&&(u="avgValue / max(count, 1.0)");const v=4*Math.floor(f/4),w=f%4,x=`
      if (${s}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${g}, ${h}, ${i});
      const ivec3 pads = ivec3(${p}, ${q}, ${r});
      const float initializationValue = ${t};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${a.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${t});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${m};
            wD += ${j}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${a.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${n};
            wR += ${k}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${a.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${v}; wC += 4) {
              int xC = xCCorner + wC * ${l};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${l}, ch),
                getValue(batch, xD, xR, xC + 2 * ${l}, ch),
                getValue(batch, xD, xR, xC + 3 * ${l}, ch)
              );

              ${x}
            }

            int xC = xCCorner + ${v};
            if (${1===w}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${x}
            } else if (${2===w}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${l}, ch),
                initializationValue,
                initializationValue
              );

              ${x}
            } else if (${3===w}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${l}, ch),
                getValue(batch, xD, xR, xC + 2 * ${l}, ch),
                initializationValue
              );

              ${x}
            }
          }
        }
        setOutput(${u});
      }
    `}}var hp=hp,hp=hp;class yX{constructor(a){this.variableNames=["dy"],this.outputShape=a.inShape;const b=a.filterHeight,c=a.filterWidth,d=a.strideHeight,e=a.strideWidth,f=a.dilationHeight,g=a.dilationWidth,h=a.effectiveFilterHeight,i=a.effectiveFilterWidth,j=h-1-a.padInfo.top,k=i-1-a.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${j}, ${k});
      const float avgMultiplier = float(${1/(b*c)});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h};
            wR += ${f}) {
          float dyR = float(dyRCorner + wR) / ${d}.0;

          if (dyR < 0.0 || dyR >= ${a.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i};
            wC+= ${g}) {
            float dyC = float(dyCCorner + wC) / ${e}.0;

            if (dyC < 0.0 || dyC >= ${a.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class yY{constructor(a){this.variableNames=["dy"],this.outputShape=a.inShape;const b=a.filterDepth,c=a.filterHeight,d=a.filterWidth,e=a.strideDepth,f=a.strideHeight,g=a.strideWidth,h=a.dilationDepth,i=a.dilationHeight,j=a.dilationWidth,k=a.effectiveFilterDepth,l=a.effectiveFilterHeight,m=a.effectiveFilterWidth,n=k-1-a.padInfo.front,o=l-1-a.padInfo.top,p=m-1-a.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${n}, ${o}, ${p});
      const float avgMultiplier = float(${1/(b*c*d)});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${k};
            wD += ${h}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${a.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${f}.0;

            if (dyR < 0.0 || dyR >= ${a.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${m};
                wC += ${j}) {
              float dyC = float(dyCCorner + wC) / ${g}.0;

              if (dyC < 0.0 || dyC >= ${a.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}var hp=hp,iV=iV,hp=hp;class yZ{constructor(a,b,c,d,e,f){this.outputShape=[],this.variableNames=["x","mean","variance"],hp.assertAndGetBroadcastShape(a,b),hp.assertAndGetBroadcastShape(a,c);let g="0.0";null!=d&&(hp.assertAndGetBroadcastShape(a,d),this.variableNames.push("offset"),g="getOffsetAtOutCoords()");let h="1.0";null!=e&&(hp.assertAndGetBroadcastShape(a,e),this.variableNames.push("scale"),h="getScaleAtOutCoords()"),this.outputShape=a,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${g};
        float scale = ${h};
        float inv = scale * inversesqrt(variance + float(${f}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}var hp=hp;class y${constructor(a,b,c,d,e,f){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],hp.assertAndGetBroadcastShape(a,b),hp.assertAndGetBroadcastShape(a,c);let g="vec4(0.0)";null!=d&&(hp.assertAndGetBroadcastShape(a,d),this.variableNames.push("offset"),g="getOffsetAtOutCoords()");let h="vec4(1.0)";null!=e&&(hp.assertAndGetBroadcastShape(a,e),this.variableNames.push("scale"),h="getScaleAtOutCoords()"),this.outputShape=a,this.userCode=`
      void main() {
        vec4 offset = ${g};
        vec4 scale = ${h};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${f}));

        setOutput((x - mean) * inv + offset);
      }
    `}}var hp=hp,iV=iV,tU=gr,iV=iV;class y_{constructor(a){let b;this.variableNames=["source"],this.outputShape=a,this.rank=a.length;const c=wu(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const d=function(a){if(1===a)return"sourceLoc";if(a<=6)return y0.slice(0,a).map(a=>"sourceLoc."+a).join(",");throw Error(`Slicing for rank ${a} is not yet supported`)}(this.rank),e=a.map((a,b)=>`sourceLoc.${y0[b]} = start[${b}] + coords.${y0[b]};`);b=`
        ${c} sourceLoc;
        ${c} coords = getOutputCoords();
        ${e.join("\n")}
      `,this.userCode=`
      void main() {
        ${b}
        setOutput(getSource(${d}));
      }
    `}}let y0=["x","y","z","w","u","v"];class y1{constructor(a){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a,this.rank=a.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const b=wu(this.rank),c=xR("coords",this.rank),d=xR("sourceLoc",this.rank),e=1===this.rank?"sourceLoc":`vec2(${d.slice(-2).join()})`,f=`getChannel(getSource(${d.join()}), ${e})`,g=`
      result.x = ${f};
      if (++${c[this.rank-1]} < ${a[this.rank-1]}) {
        ++${d[this.rank-1]};
        result.y = ${f};
        --${d[this.rank-1]};
      }
    `,h=1===this.rank?"":`
      --${c[this.rank-1]};
      if (++${c[this.rank-2]} < ${a[this.rank-2]}) {
        ++${d[this.rank-2]};
        result.z = ${f};
        if (++${c[this.rank-1]} < ${a[this.rank-1]}) {
          ++${d[this.rank-1]};
          result.w = ${f};
        }
      }
    `,i=this.rank<=4?`sourceLoc = coords +
            ${b}(${a.map((a,b)=>`start[${b}]`).join()});`:a.map((a,b)=>`${d[b]} = ${c[b]} + start[${b}];`).join("\n");this.userCode=`
      void main() {
        ${b} coords = getOutputCoords();
        ${b} sourceLoc;
        ${i}
        vec4 result = vec4(0.);
        ${g}
        ${h}
        setOutput(result);
      }
    `}}function y2(a){let b,c,d,e,f,{inputs:g,backend:h,attrs:i}=a,{x:j}=g,{begin:k,size:l}=i,[m,n]=tU.parseSliceParams(j,k,l);if(tU.assertParamsValid(j,m,n),0===iV.sizeFromShape(n))return h.makeTensorInfo(n,j.dtype,[]);if(h.shouldExecuteOnCPU([j])||"string"===j.dtype){let a=xB(h.texData.get(j.dataId).values,m,n,j.shape,j.dtype);return h.makeTensorInfo(n,j.dtype,a)}let{isPacked:o}=h.texData.get(j.dataId),p=tU.isSliceContinous(j.shape,m,n);if(o||!p){let a=aw.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new y1(n):new y_(n),b=[m];return h.runWebGLProgram(a,[j],j.dtype,b)}return h.uploadToGPU(j.dataId),b=h.texData.get(j.dataId),c=h.makeTensorInfo(n,j.dtype),Object.assign(d=h.texData.get(c.dataId),b),d.refCount=1,d.shape=n,d.dtype=j.dtype,e=tU.computeFlatOffset(m,iV.computeStrides(j.shape)),b.slice&&(e+=b.slice.flatOffset),d.slice={flatOffset:e,origDataId:b.slice&&b.slice.origDataId||j.dataId},f=h.dataRefCount.get(d.slice.origDataId)||1,h.dataRefCount.set(d.slice.origDataId,f+1),c}let y3=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,y4=`
  return float(int(a.r) & int(b.r));
`;var hp=hp,iV=iV;let y5=yq({opSnippet:"return float(a != b);",cpuKernelImpl:xr,dtype:"bool"});function y6(a){let{inputs:b,backend:c}=a,{input:d}=b;return yi({inputs:{x:c.texData.get(d.dataId).complexTensorInfos.real},backend:c})}let y7="return ceil(x);",y8=yp({opSnippet:y7,packedOpSnippet:y7,cpuKernelImpl:w8});class y9{constructor(a){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=a,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class za{constructor(a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=a,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}class zb{constructor(a){this.variableNames=["real","imag"],this.outputShape=a,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function zc(a,b){return{dataId:b.dataId,dtype:b.dtype,shape:a.shape}}var hp=hp,iV=iV,hp=hp,iV=iV,hp=hp;class zd{constructor(a){this.outputShape=[],this.outputShape=hp.computeOutShape(a,1),this.variableNames=a.map((a,b)=>`T${b}`);const b=Array(a.length-1);b[0]=a[0][1];for(let c=1;c<b.length;c++)b[c]=b[c-1]+a[c][1];const c=[`if (yC < ${b[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<b.length;a++){const d=b[a-1];c.push(`else if (yC < ${b[a]}) setOutput(getT${a}(yR, yC-${d}));`)}const d=b.length,e=b[b.length-1];c.push(`else setOutput(getT${d}(yR, yC-${e}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${c.join("\n        ")}
      }
    `}}var hp=hp;class ze{constructor(a,b){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=hp.computeOutShape(a,b);const c=this.outputShape,d=c.length,e=wu(d),f=xR("coords",d),g=["x","y","z","w","u","v"].slice(0,d);this.variableNames=a.map((a,b)=>`T${b}`);const h=Array(a.length-1);h[0]=a[0][b];for(let c=1;c<h.length;c++)h[c]=h[c-1]+a[c][b];const i=g[b],j=g.slice(-2),k=g.join();let l=`if (${i} < ${h[0]}) {
        return getChannel(
            getT0(${k}), vec2(${j.join()}));
        }`;for(let a=1;a<h.length;a++){const b=h[a-1];l+=`
        if (${i} < ${h[a]}  && ${i} >= ${h[a-1]}) {
          return getChannel(
            getT${a}(${zf(g,i,b)}),
            vec2(${zf(j,i,b)}));
        }`}const m=h.length,n=h[h.length-1];l+=`
        return getChannel(
          getT${m}(${zf(g,i,n)}),
          vec2(${zf(j,i,n)}));`,this.userCode=`
      float getValue(${g.map(a=>"int "+a)}) {
        ${l}
      }

      void main() {
        ${e} coords = getOutputCoords();
        vec4 result = vec4(getValue(${f}), 0., 0., 0.);

        ${f[d-1]} = ${f[d-1]} + 1;
        if (${f[d-1]} < ${c[d-1]}) {
          result.g = getValue(${f});
        }

        ${f[d-2]} = ${f[d-2]} + 1;
        if (${f[d-2]} < ${c[d-2]}) {
          result.a = getValue(${f});
        }

        ${f[d-1]} = ${f[d-1]} - 1;
        if (${f[d-2]} < ${c[d-2]} &&
            ${f[d-1]} < ${c[d-1]}) {
          result.b = getValue(${f});
        }
        setOutput(result);
      }
    `}}function zf(a,b,c){let d=a.indexOf(b);return a.map((a,b)=>b===d?`${a} - ${c}`:a).join()}function zg(a){let{inputs:b,backend:c}=a,{input:d}=b;return yi({inputs:{x:c.texData.get(d.dataId).complexTensorInfos.imag},backend:c})}function zh(a){let{inputs:b,backend:c,attrs:d}=a,{axis:e}=d,f=iV.parseAxisParam(e,b[0].shape)[0],g=b.map(a=>a.shape);hp.assertParamsConsistent(g,f);let h=hp.computeOutShape(b.map(a=>a.shape),f);if(0===iV.sizeFromShape(h))return c.makeTensorInfo(h,b[0].dtype,[]);let i=b.filter(a=>iV.sizeFromShape(a.shape)>0);return 1===i.length?yi({inputs:{x:i[0]},backend:c}):function a(b,c,d){var e,f,g;let h,i=b[0].dtype;if("complex64"===i){let e=b.map(a=>y6({inputs:{input:a},backend:d})),f=b.map(a=>zg({inputs:{input:a},backend:d})),g=a(e,c,d),h=a(f,c,d),i=yj({inputs:{real:g,imag:h},backend:d});return e.forEach(a=>d.disposeIntermediateTensorInfo(a)),f.forEach(a=>d.disposeIntermediateTensorInfo(a)),d.disposeIntermediateTensorInfo(g),d.disposeIntermediateTensorInfo(h),i}let j=d.shouldExecuteOnCPU(b);if("string"===i&&(j=!0),j){let a=b.map(a=>{let b=iV.sizeFromShape(a.shape.slice(c));return yw({inputs:{x:a},backend:d,attrs:{shape:[-1,b]}})}),e=w9(a.map(a=>({vals:d.readSync(a.dataId),shape:a.shape})),hp.computeOutShape(a.map(a=>a.shape),1),i,1===a[0].shape[0]),f=hp.computeOutShape(b.map(a=>a.shape),c),g=d.makeTensorInfo(f,i,e);return a.forEach(a=>d.disposeIntermediateTensorInfo(a)),g}let k=b.filter(a=>iV.sizeFromShape(a.shape)>0),l=aw.getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&k[0].shape.length>1;if(1===k.length){let a=l?new xY(b[0].shape,x1):new x5(b[0].shape,x1);return d.runWebGLProgram(a,b,i)}let m=aw.getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(k.length>m){let b=[];for(let e=0;e<k.length;e+=m){let f=k.slice(e,e+m);b.push(a(f,c,d))}let e=a(b,c,d);for(let a of b)d.disposeIntermediateTensorInfo(a);return e}if(l){let a=new ze(k.map(a=>a.shape),c);return d.runWebGLProgram(a,k,i)}let{tensors2D:n,outShape:o}=(e=k,f=c,g=d,h=hp.computeOutShape(e.map(a=>a.shape),f),{tensors2D:e.map(a=>yw({inputs:{x:a},attrs:{shape:[-1,iV.sizeFromShape(a.shape.slice(f))]},backend:g})),outShape:h}),p=new zd(n.map(a=>a.shape)),q=d.runWebGLProgram(p,n,i);n.forEach(a=>d.disposeIntermediateTensorInfo(a));let r=yw({inputs:{x:q},attrs:{shape:o},backend:d});return d.disposeIntermediateTensorInfo(q),r}(i,f,c)}var hp=hp;class zi{constructor(a,b=!1,c=null,d=!1,e=!1){this.variableNames=["x","W"],this.outputShape=a.outShape;const f=a.padInfo.top,g=a.padInfo.left,h=a.strideHeight,i=a.strideWidth,j=a.dilationHeight,k=a.dilationWidth,l=a.filterHeight,m=a.filterWidth,n=4*Math.floor(a.inChannels/4),o=a.inChannels%4,p="channelsLast"===a.dataFormat;let q="",r="";c&&(q=d?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${c}
        }`:e?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${c}
        }`:`
          float activation(float x) {
            ${c}
          }
        `,r="result = activation(result);"),b&&this.variableNames.push("bias"),d&&this.variableNames.push("preluActivationWeights"),e&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${q}

      const ivec2 strides = ivec2(${h}, ${i});
      const ivec2 pads = ivec2(${f}, ${g});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${p?3:1}];

        ivec2 xRCCorner =
            ivec2(coords[${p?1:2}], coords[${p?2:3}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l}; wR++) {
          int xR = xRCorner + wR * ${j};

          if (xR < 0 || xR >= ${a.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${m}; wC++) {
            int xC = xCCorner + wC * ${k};

            if (xC < 0 || xC >= ${a.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${n}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${p}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${1===o}) {

              if (${p}) {
                dotProd +=
                    getX(batch, xR, xC, ${n}) *
                    getW(wR, wC, ${n}, d2);
              } else {
                dotProd +=
                    getX(batch, ${n}, xR, xC) *
                    getW(wR, wC, ${n}, d2);
              }

            } else if (${2===o}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${n}, d2),
                getW(wR, wC, ${n} + 1, d2)
              );

              if (${p}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${n}),
                  getX(batch, xR, xC, ${n} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${n}, xR, xC),
                  getX(batch, ${n} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${3===o}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${n}, d2),
                getW(wR, wC, ${n} + 1, d2),
                getW(wR, wC, ${n} + 2, d2)
              );

              if (${p}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${n}),
                  getX(batch, xR, xC, ${n} + 1),
                  getX(batch, xR, xC, ${n} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${n}, xR, xC),
                  getX(batch, ${n} + 1, xR, xC),
                  getX(batch, ${n} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${b?"result += getBiasAtOutCoords();":""}
        ${r}
        setOutput(result);
      }
    `}}class zj{constructor(a){this.variableNames=["x","W"],this.outputShape=a.outShape;const b=a.padInfo.front,c=a.padInfo.top,d=a.padInfo.left,e=a.strideDepth,f=a.strideHeight,g=a.strideWidth,h=a.dilationDepth,i=a.dilationHeight,j=a.dilationWidth,k=a.filterDepth,l=a.filterHeight,m=a.filterWidth,n=4*Math.floor(a.inChannels/4),o=a.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${e}, ${f}, ${g});
      const ivec3 pads = ivec3(${b}, ${c}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${k}; wF++) {
          int xF = xFCorner + wF * ${h};

          if (xF < 0 || xF >= ${a.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${l}; wR++) {
            int xR = xRCorner + wR * ${i};

            if (xR < 0 || xR >= ${a.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m}; wC++) {
              int xC = xCCorner + wC * ${j};

              if (xC < 0 || xC >= ${a.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${n}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${1===o}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${n}) *
                  getW(wF, wR, wC, ${n}, d2);
              } else if (${2===o}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${n}),
                  getX(batch, xF, xR, xC, ${n} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${n}, d2),
                  getW(wF, wR, wC, ${n} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${3===o}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${n}),
                  getX(batch, xF, xR, xC, ${n} + 1),
                  getX(batch, xF, xR, xC, ${n} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${n}, d2),
                  getW(wF, wR, wC, ${n} + 1, d2),
                  getW(wF, wR, wC, ${n} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}var iV=iV;class zk{constructor(a,b=!1,c=null,d=!1,e=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=a.outShape,this.enableShapeUniforms=wA(this.outputShape.length);const f=a.padInfo.left,g=a.strideWidth,h=a.dilationWidth,i=a.filterHeight,j=a.filterWidth;let k=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let a=0;a<j;a++)k+=`
           vec4 xTexelC${2*a};
           int xTexelC${2*a}Ready;
           vec4 xTexelC${2*a+1};
           int xTexelC${2*a+1}Ready;
           vec4 xC${a};`;k+=`
     for (int r = 0; r < ${i}; r++) {
      for (int d1 = 0; d1 < ${a.inChannels}; d1 += 2) {
       `;for(let a=0;a<j;a++)k+=`
           xTexelC${2*a} = vec4(0.0);
           xTexelC${2*a}Ready = 0;
           xTexelC${2*a+1} = vec4(0.0);
           xTexelC${2*a+1}Ready = 0;
           xC${a} = vec4(0.0);`;k+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let b=0;b<(j+1)/2;b++){const c=2*b;if(k+=`
           xC = xCCorner + ${c*h};
           `,1===g){if(c<j&&(f%2==1?(k+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${c}Ready == 0) {
                   xTexelC${c} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${c}.zw = vec2(0.0);
                   }
                   xTexelC${c}Ready = 1;
                 }
               `,1===h&&c>0?k+=`
                 xC${c} = vec4(xTexelC${c-2}.zw, xTexelC${c}.xy);
                 `:k+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${c} = vec4(previous.zw, xTexelC${c}.xy);
                   } else {
                     xC${c} = vec4(0.0, 0.0, xTexelC${c}.xy);
                   }
                   `):k+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${c}Ready == 0) {
                   xTexelC${c} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${c}.zw = vec2(0.0);
                   }
                   xTexelC${c}Ready = 1;
                 }

                 xC${c} = xTexelC${c};
                 `,c+1<j)){const a=f%2==0?iV.nearestLargerEven(h):h;h%2==0&&f%2==1||h%2!=0&&f%2!=1?(k+=`
                   xCOffset = xC + imod(pads[1], 2) + ${a};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${c+1}Ready == 0) {
                     xTexelC${c+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${c+1}.zw = vec2(0.0);
                     }
                     xTexelC${c+1}Ready = 1;
                   }
                   `,h>1?k+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${c+1} = vec4(previous.zw, xTexelC${c+1}.xy);
                     } else {
                      xC${c+1} = vec4(0.0, 0.0, xTexelC${c+1}.xy);
                     }
                     `:k+=`
                     xC${c+1} = vec4(xTexelC${c}.zw, xTexelC${c+1}.xy);
                     `):1===a?k+=`
                     xC${c+1} = xTexelC${c};
                     `:k+=`
                     xCOffset = xC + ${a};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${c+1}Ready == 0) {
                       xTexelC${c+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${c+1}.zw = vec2(0.0);
                       }
                       xTexelC${c+1}Ready = 1;
                     }

                     xC${c+1} = xTexelC${c+1};
                     `}}else c<j&&(f%2==1?(k+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${c}Ready == 0) {
                   xTexelC${c} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${c}.zw = vec2(0.0);
                   }
                   xTexelC${c}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${c+1}Ready == 0) {
                   xTexelC${c+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${c+1}.zw = vec2(0.0);
                   }
                   xTexelC${c+1}Ready = 1;
                 }

                 xC${c} = vec4(xTexelC${c}.zw, xTexelC${c+1}.zw);
               `,c+1<j&&(k+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${c+1} = vec4(xTexelC${c+1}.xy, final.xy);
                 `)):(k+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${c}Ready == 0) {
                   xTexelC${c} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${c}.zw = vec2(0.0);
                   }
                   xTexelC${c}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${c+1}Ready == 0) {
                   xTexelC${c+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${c+1}.zw = vec2(0.);
                   }
                   xTexelC${c+1}Ready = 1;
                 }

                 xC${c} = vec4(
                   xTexelC${c}.xy, xTexelC${c+1}.xy);
               `,c+1<j&&(k+=`
                   xC${c+1} = vec4(xTexelC${c}.zw, xTexelC${c+1}.zw);
                 `)));c<j&&(k+=`
             wTexel = getW(r, ${c}, d1, d2);
             dotProd += xC${c}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${a.inChannels}) {
               dotProd += xC${c}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,c+1<j&&(k+=`
               wTexel = getW(r, ${c+1}, d1, d2);
               dotProd += xC${c+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${a.inChannels}) {
                 dotProd += xC${c+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}k+=`
     }
   
     }
   
     }
   `;let l="",m="";c&&(l=d?`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${c}
         }`:e?`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${c}
         }`:`vec4 activation(vec4 x) {
           ${c}
         }`,m="result = activation(result);"),b&&this.variableNames.push("bias"),d&&this.variableNames.push("preluActivationWeights"),e&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${l}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${k}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${b?"result += getBiasAtOutCoords();":""}
         ${m}
         setOutput(result);
       }
     `}}var iV=iV;class zl{constructor(a,b){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=a,this.enableShapeUniforms=wA(this.outputShape.length);const{dataFormat:c}=b,d=wg(),e="channelsLast"===c,f=e?1:2,g=e?2:3,h=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${a[2]} && pos < ${a[1]}) {`;let i="";for(let a=0;a<=1;a++)for(let b=0;b<=1;b++)i+=`
          blockIndex = rc.z + ${b};
          pos = rc.y + ${a};

          ${h}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${f}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${g}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${e}) {
                  innerDims = vec2(d1, ch);
                  result[${2*a+b}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${2*a+b}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${i}

        ${d.output} = result;
      }
    `}}function zm(a,b){let c=a.length;return c>=3?b?[...a.slice(0,-3),a[c-3]*a[c-2],a[c-1]]:[...a.slice(0,-3),a[c-3],a[c-2]*a[c-1]]:!b&&1===c&&a[0]>1?[a[0],1]:null}function zn({x:a,filter:b,convInfo:c,backend:d,bias:e=null,preluActivationWeights:f=null,leakyreluAlpha:g=0,activation:h=null}){let i,j=a.shape,k=d.texData.get(a.dataId),l=c.inChannels,m=j[0]*j[1]*j[2],n=c.outChannels,o="channelsLast"===c.dataFormat,p=[];if(null!=f){let a=zm(f.shape,o);null!=a&&(f=yw({inputs:{x:f},backend:d,attrs:{shape:a}}),p.push(f))}if(null!=e){let a=zm(e.shape,o);null!=a&&(e=yw({inputs:{x:e},backend:d,attrs:{shape:a}}),p.push(e))}if(!((1===m||1===n)&&l>1e3)&&k.isPacked&&o&&null!=k.texture&&j[2]%2!=0&&iV.arraysEqual(k.shape.slice(-3),j.slice(-3))){let l=j[0]*j[1]*(j[2]+1),m={dataId:a.dataId,shape:[1,l,c.inChannels],dtype:a.dtype},n=k.shape;k.shape=k.shape.slice(),k.shape[k.shape.length-2]++,iV.assert(v2(k.shape,m.shape),()=>`packed reshape ${k.shape} to ${m.shape} isn't free`);let o=yw({inputs:{x:b},backend:d,attrs:{shape:[1,c.inChannels,c.outChannels]}});p.push(o);let q=yF({a:m,b:o,backend:d,transposeA:!1,transposeB:!1,bias:e,activation:h,preluActivationWeights:f,leakyreluAlpha:g}),r=d.texData.get(q.dataId);iV.assert(r.isPacked,()=>"batchMatMul result is expected to be packed"),k.shape=n,r.shape=c.outShape,(i=yi({inputs:{x:q},backend:d})).shape=c.outShape,p.push(q)}else{let j=c.outHeight*c.outWidth,k=yw({inputs:{x:a},backend:d,attrs:{shape:o?[c.batchSize,j,c.inChannels]:[c.batchSize,c.inChannels,j]}}),l=yw({inputs:{x:b},backend:d,attrs:{shape:[1,c.inChannels,c.outChannels]}}),m=yF({a:o?k:l,b:o?l:k,transposeA:!o,transposeB:!1,backend:d,bias:e,activation:h,preluActivationWeights:f,leakyreluAlpha:g});i=yw({inputs:{x:m},backend:d,attrs:{shape:c.outShape}}),p.push(k),p.push(l),p.push(m)}for(let a of p)d.disposeIntermediateTensorInfo(a);return i}function zo({x:a,filter:b,convInfo:c,backend:d,bias:e=null,preluActivationWeights:f=null,leakyreluAlpha:g=0,activation:h=null}){let{filterWidth:i,filterHeight:j,inChannels:k,outWidth:l,outHeight:m,dataFormat:n}=c,o="channelsLast"===n,p=i*j*k,q=m*l,r=[c.batchSize,p,q],s=[];if(null!=f){let a=zm(f.shape,o);null!=a&&(f=yw({inputs:{x:f},backend:d,attrs:{shape:a}}),s.push(f))}if(null!=e){let a=zm(e.shape,o);null!=a&&(e=yw({inputs:{x:e},backend:d,attrs:{shape:a}}),s.push(e))}let t=yw({inputs:{x:b},backend:d,attrs:{shape:[1,p,iV.sizeFromShape(b.shape)/p]}});s.push(t);let u=new zl(r,c),v=[a.shape,[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inChannels],[c.filterWidth*c.inChannels],[c.outWidth]],w=d.runWebGLProgram(u,[a],"float32",v),x=yw({inputs:{x:w},backend:d,attrs:{shape:r}});s.push(w),s.push(x);let y=null!=e,z=null!=f,A="leakyrelu"===h,B=h?yr(h,!0):null,C=new ys(o?x.shape:t.shape,o?t.shape:x.shape,o?[c.batchSize,q,c.outChannels]:[c.batchSize,c.outChannels,q],!0,!1,y,B,z,A),D=o?[x,t]:[t,x];if(e&&D.push(e),z&&D.push(f),A){let a=d.makeTensorInfo([],"float32",iV.createScalarValue(g,"float32"));D.push(a),s.push(a)}let E=d.runWebGLProgram(C,D,"float32"),F=yw({inputs:{x:E},backend:d,attrs:{shape:c.outShape}});for(let a of(s.push(E),s))d.disposeIntermediateTensorInfo(a);return F}var hp=hp;class zp{constructor(a){this.variableNames=["x","dy"],this.outputShape=a.filterShape;const b=a.strideHeight,c=a.strideWidth,d=a.padInfo.top,e=a.padInfo.left,f="channelsLast"===a.dataFormat;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${a.batchSize}; b++) {
          for (int yR = 0; yR < ${a.outHeight}; yR++) {
            int xR = wR + yR * ${b} - ${d};

            if (xR < 0 || xR >= ${a.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${a.outWidth}; yC++) {
              int xC = wC + yC * ${c} - ${e};

              if (xC < 0 || xC >= ${a.inWidth}) {
                continue;
              }

              ${f?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class zq{constructor(a){this.variableNames=["dy","W"],this.outputShape=a.inShape;const b=a.filterHeight,c=a.filterWidth,d=a.strideHeight,e=a.strideWidth,f="channelsLast"===a.dataFormat,g=b-1-a.padInfo.top,h=c-1-a.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${g}, ${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${f?3:1}];

        ivec2 dyCorner = ivec2(coords[${f?1:2}], coords[${f?2:3}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${b}; wR++) {
          float dyR = float(dyRCorner + wR) / ${d}.0;

          if (dyR < 0.0 || dyR >= ${a.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${b} - 1 - wR;

          for (int wC = 0; wC < ${c}; wC++) {
            float dyC = float(dyCCorner + wC) / ${e}.0;

            if (dyC < 0.0 || dyC >= ${a.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${c} - 1 - wC;

            for (int d2 = 0; d2 < ${a.outChannels}; d2++) {

              if (${f}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class zr{constructor(a){this.variableNames=["x","dy"],this.outputShape=a.filterShape;const b=a.strideDepth,c=a.strideHeight,d=a.strideWidth,e=a.padInfo.front,f=a.padInfo.top,g=a.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${a.batchSize}; b++) {
          for (int yF = 0; yF < ${a.outDepth}; yF++) {
            int xF = wF + yF * ${b} - ${e};

            if (xF < 0 || xF >= ${a.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${a.outHeight}; yR++) {
              int xR = wR + yR * ${c} - ${f};

              if (xR < 0 || xR >= ${a.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${a.outWidth}; yC++) {
                int xC = wC + yC * ${d} - ${g};

                if (xC < 0 || xC >= ${a.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class zs{constructor(a){this.variableNames=["dy","W"],this.outputShape=a.inShape;const b=a.filterDepth,c=a.filterHeight,d=a.filterWidth,e=a.strideDepth,f=a.strideHeight,g=a.strideWidth,h=b-1-a.padInfo.front,i=c-1-a.padInfo.top,j=d-1-a.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${i}, ${j});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${b}; wF++) {
          float dyF = float(dyFCorner + wF) / ${e}.0;

          if (dyF < 0.0 || dyF >= ${a.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${b} - 1 - wF;

          for (int wR = 0; wR < ${c}; wR++) {
            float dyR = float(dyRCorner + wR) / ${f}.0;

            if (dyR < 0.0 || dyR >= ${a.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${c} - 1 - wR;

            for (int wC = 0; wC < ${d}; wC++) {
              float dyC = float(dyCCorner + wC) / ${g}.0;

              if (dyC < 0.0 || dyC >= ${a.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${d} - 1 - wC;

              for (int d2 = 0; d2 < ${a.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}var hp=hp;class zt{constructor(a){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=a.inShape,this.enableShapeUniforms=wA(this.outputShape.length);const b=a.filterHeight,c=a.filterWidth,d=b-1-a.padInfo.top,e=c-1-a.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${d}, ${e});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${b}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${a.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${b} - 1 - wR;

          for (int wC = 0; wC < ${c}; wC++) {
            int wCPerm = ${c} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${a.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${a.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${a.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${a.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${a.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}var hp=hp,hp=hp,hp=hp;let zu=yp({opSnippet:yo+`
  return cos(x);
`,packedOpSnippet:`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${yg}
  return result;
`}),zv=yp({opSnippet:`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`});class zw{constructor(a,b,c,d,e){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[f,g,h,i]=a,[j]=b,[k,l]=c;this.outputShape=[j,k,l,i];const[m,n]=[`${g-1}.0`,`${h-1}.0`],[o,p,q]=k>1?[`${(g-1)/(k-1)}`,"(y2-y1) * height_ratio",`y1*${m} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${m}`],[r,s,t]=l>1?[`${(h-1)/(l-1)}`,"(x2-x1) * width_ratio",`x1*${n} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${n}`];this.userCode=`
      const float height_ratio = float(${o});
      const float width_ratio = float(${r});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${f}) {
          return;
        }

        float height_scale = ${p};
        float width_scale = ${s};

        float in_y = ${q};
        if( in_y < 0.0 || in_y > ${m} ) {
          setOutput(float(${e}));
          return;
        }
        float in_x = ${t};
        if( in_x < 0.0 || in_x > ${n} ) {
          setOutput(float(${e}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${+("bilinear"===d)} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}(BG=BV||(BV={})).Prod="*",BG.Sum="+";class zx{constructor(a,b,c,d){this.op=a,this.outputShape=b,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const e=this.outputShape.length,f=this.op===BV.Prod?"1.0":"0.0",g=c?f:`getX(${zy(e,"coords",this.op)})`,h=this.outputShape[this.outputShape.length-1];let i="",j="";c?(i=d?`end != ${h-1}`:"end != 0",j=d?"end + 1":"end - 1"):(i=d?`end + pow2 < ${h}`:"end >= pow2",j=d?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${wu(e)} coords = getOutputCoords();
        int end = ${zz(e,"coords",this.op)};
        float val = ${g};
        int pow2 = int(pow(2.0, index));
        if (${i}) {
          int idx = ${j};
          ${zz(e,"coords",this.op)} = idx;
          val ${this.op}= getX(${zy(e,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function zy(a,b,c){if(1===a)return`${b}`;if(2===a)return`${b}.x, ${b}.y`;if(3===a)return`${b}.x, ${b}.y, ${b}.z`;if(4===a)return`${b}.x, ${b}.y, ${b}.z, ${b}.w`;throw Error(`Cumulative ${c} for rank ${a} is not yet supported`)}function zz(a,b,c){if(1===a)return`${b}`;if(2===a)return`${b}.y`;if(3===a)return`${b}.z`;if(4===a)return`${b}.w`;throw Error(`Cumulative ${c} for rank ${a} is not yet supported`)}var hp=hp;function zA(a,b,c,d,e,f){let g=b.shape.length,h=hp.getAxesPermutation([d],g),i=b;null!=h&&(i=yE({inputs:{x:b},backend:c,attrs:{perm:h}}));let j=hp.getInnerMostAxes(1,g)[0];if(j!==g-1)throw Error(`WebGL cumprod shader expects an inner-most axis=${b.shape.length-1} but got axis=${d}`);let k=i.shape[j],l=yi({inputs:{x:i},backend:c});for(let b=0;b<=Math.ceil(Math.log2(k))-1;b++){let d=new zx(a,i.shape,!1,f),e=[[b]],g=l;l=c.runWebGLProgram(d,[l],l.dtype,e),c.disposeIntermediateTensorInfo(g)}if(e){let b=new zx(a,i.shape,e,f),d=l;l=c.runWebGLProgram(b,[l],l.dtype),c.disposeIntermediateTensorInfo(d)}if(null!=h){let a=yE({inputs:{x:l},backend:c,attrs:{perm:hp.getUndoAxesPermutation(h)}});return c.disposeIntermediateTensorInfo(l),c.disposeIntermediateTensorInfo(i),a}return l}class zB{constructor(a,b,c){this.variableNames=["x"],this.outputShape=[],this.outputShape=a,this.blockSize=b,this.dataFormat=c,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${b};
      int offset_h = imod(h, ${b});
      int in_w = w / ${b};
      int offset_w = imod(w, ${b});
      int offset_d = (offset_h * ${b} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}var hp=hp,iV=iV;class zC{constructor(a,b=!1,c=null,d=!1,e=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=a.outShape,this.enableShapeUniforms=wA(this.outputShape.length);const f=a.filterHeight,g=a.filterWidth,h=a.outChannels/a.inChannels;let i="",j="";c&&(i=d?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${c}
        }`:e?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${c}
        }`:`
          float activation(float x) {
            ${c}
          }
        `,j="result = activation(result);"),b&&this.variableNames.push("bias"),d&&this.variableNames.push("preluActivationWeights"),e&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${i}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${h};
        int q = d2 - d1 * ${h};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${g}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${b?"result += getBiasAtOutCoords();":""}
        ${j}
        setOutput(result);
      }
    `}}var iV=iV;class zD{constructor(a,b=!1,c=null,d=!1,e=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=a.outShape,this.enableShapeUniforms=wA(this.outputShape.length);const f=a.outChannels/a.inChannels,g=a.padInfo.left,h=a.strideWidth,i=a.dilationWidth,j=a.filterHeight,k=a.filterWidth;let l=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let a=0;a<k;a++)l+=`
          vec4 xTexelC${2*a};
          int xTexelC${2*a}Ready;
          vec4 xTexelC${2*a+1};
          int xTexelC${2*a+1}Ready;
          vec4 xC${a};`;l+=`
    for (int r = 0; r < ${j}; r++) {
      `;for(let a=0;a<k;a++)l+=`
          xTexelC${2*a} = vec4(0.0);
          xTexelC${2*a}Ready = 0;
          xTexelC${2*a+1} = vec4(0.0);
          xTexelC${2*a+1}Ready = 0;
          xC${a} = vec4(0.0);`;l+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let a=0;a<(k+1)/2;a++){const b=2*a;if(l+=`
          xC = xCCorner + ${b*i};
          `,1===h){if(b<k&&(g%2==1?(l+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,1===i&&b>0?l+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:l+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):l+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<k)){const a=g%2==0?iV.nearestLargerEven(i):i;i%2==0&&g%2==1||i%2!=0&&g%2!=1?(l+=`
                  xCOffset = xC + imod(pads[1], 2) + ${a};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,i>1?l+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:l+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):1===a?l+=`
                    xC${b+1} = xTexelC${b};
                    `:l+=`
                    xCOffset = xC + ${a};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<k&&(g%2==1?(l+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<k&&(l+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(l+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<k&&(l+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<k&&(l+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<k&&(l+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}l+=`
    }
  
      }
    `;let m="",n="";c&&(m=d?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${c}
        }`:e?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${c}
        }`:`vec4 activation(vec4 x) {
          ${c}
        }`,n="result = activation(result);"),b&&this.variableNames.push("bias"),d&&this.variableNames.push("preluActivationWeights"),e&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${m}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${f};
        int q = d2 - d1 * ${f};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${l}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${b?"result += getBiasAtOutCoords();":""}
        ${n}
        setOutput(result);
      }
    `}}var hp=hp;class zE{constructor(a){this.variableNames=["x","dy"],this.outputShape=a.filterShape;const b=a.strideHeight,c=a.strideWidth,d=a.padInfo.top,e=a.padInfo.left,f=a.outChannels/a.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${f} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${a.batchSize}; b++) {
          for (int yR = 0; yR < ${a.outHeight}; yR++) {
            int xR = wR + yR * ${b} - ${d};

            if (xR < 0 || xR >= ${a.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${a.outWidth}; yC++) {
              int xC = wC + yC * ${c} - ${e};

              if (xC < 0 || xC >= ${a.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class zF{constructor(a){this.variableNames=["dy","W"],this.outputShape=a.inShape;const b=a.filterHeight,c=a.filterWidth,d=a.strideHeight,e=a.strideWidth,f=b-1-a.padInfo.top,g=c-1-a.padInfo.left,h=a.outChannels/a.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${f}, ${g});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${b}; wR++) {
          float dyR = float(dyRCorner + wR) / ${d}.0;

          if (dyR < 0.0 || dyR >= ${a.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${b} - 1 - wR;

          for (int wC = 0; wC < ${c}; wC++) {
            float dyC = float(dyCCorner + wC) / ${e}.0;

            if (dyC < 0.0 || dyC >= ${a.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${c} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${h}; dm++) {
              int d2 = d1 * ${h} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}var hp=hp,iV=iV;class zG{constructor(a){this.variableNames=["X"],this.outputShape=[a,a],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}var hp=hp;class zH{constructor(a){this.variableNames=["x","W"],this.outputShape=a.outShape;const{inHeight:b,inWidth:c,padInfo:d,strideHeight:e,strideWidth:f,filterHeight:g,filterWidth:h,dilationHeight:i,dilationWidth:j}=a,{top:k,left:l}=d;this.userCode=`
      const ivec2 strides = ivec2(${e}, ${f});
      const ivec2 pads = ivec2(${k}, ${l});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${g}; h++) {
          int hIn = hBeg + h * ${i};

          if (hIn >= 0 && hIn < ${b}) {
            for (int w = 0; w < ${h}; w++) {
              int wIn = wBeg + w * ${j};

              if (wIn >= 0 && wIn < ${c}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}var hp=hp,iV=iV;let zI=yp({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`}),zJ=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,zK=yq({opSnippet:"return float(a == b);",packedOpSnippet:`
  return vec4(equal(a, b));
`,dtype:"bool",cpuKernelImpl:xa});var hp=hp;let zL=yp({opSnippet:`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${hp.ERF_P};
  float a1 = ${hp.ERF_A1};
  float a2 = ${hp.ERF_A2};
  float a3 = ${hp.ERF_A3};
  float a4 = ${hp.ERF_A4};
  float a5 = ${hp.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`}),zM=yp({opSnippet:yo+`
  return exp(x);
`,packedOpSnippet:`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:xb,dtype:"float32"});var iV=iV;function zN(a){let{inputs:b,attrs:c,backend:d}=a,{dim:e}=c,{input:f}=b,g=f.shape.length,h=f.shape.slice(),i=e;return e<0&&(iV.assert(-(g+1)<=e,()=>`Axis must be in the interval [${-(g+1)}, ${g}]`),i=g+e+1),h.splice(i,0,1),yw({inputs:{x:f},backend:d,attrs:{shape:h}})}let zO="return exp(x) - 1.0;",zP=yp({opSnippet:zO,packedOpSnippet:zO,cpuKernelImpl:xc});var iV=iV;class zQ{constructor(a,b,c){let d;this.variableNames=["real","imag"];const e=b[1];this.outputShape=b;const f=c?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,g=c?`${e}.0`:"1.0";if("real"===a)d="return real * expR - imag * expI;";else if("imag"===a)d="return real * expI + imag * expR;";else throw Error(`FFT component must be either "real" or "imag", got ${a}.`);this.userCode=`
      const float exponentMultiplier = ${f};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${d}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${e});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${e}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${g};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function zR(a,b,c){let d=c.texData.get(a.dataId),e=iV.sizeFromShape(a.shape),f=a.shape[a.shape.length-1],g=yw({inputs:{x:a},backend:c,attrs:{shape:[e/f,f]}}),h=g.shape,i=new zQ("real",h,b),j=new zQ("imag",h,b),k=[{dataId:d.complexTensorInfos.real.dataId,dtype:d.complexTensorInfos.real.dtype,shape:h},{dataId:d.complexTensorInfos.imag.dataId,dtype:d.complexTensorInfos.imag.dtype,shape:h}],l=c.runWebGLProgram(i,k,"float32"),m=c.runWebGLProgram(j,k,"float32"),n=yj({inputs:{real:l,imag:m},backend:c});c.disposeIntermediateTensorInfo(l),c.disposeIntermediateTensorInfo(m);let o=yw({inputs:{x:n},backend:c,attrs:{shape:a.shape}});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(n),o}var iV=iV;class zS{constructor(a,b){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=a,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function zT(a){let{backend:b,attrs:c}=a,{shape:d,value:e}=c,{dtype:f}=c;if("string"===(f=f||iV.inferDtype(e))){let a=iV.getArrayFromDType(f,iV.sizeFromShape(d));return a.fill(e),b.makeTensorInfo(d,f,a)}{let a=new zS(d,e),c=[[e]];return b.runWebGLProgram(a,[],f,c)}}class zU{constructor(a){this.variableNames=["Image"],this.outputShape=[];const b=a[2];this.outputShape=a,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${b} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${b}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}let zV="return floor(x);",zW=yp({opSnippet:zV,packedOpSnippet:zV,cpuKernelImpl:xd}),zX=yq({opSnippet:`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,packedOpSnippet:`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,dtype:"int32"});class zY{constructor(a){this.variableNames=["A"];const b=wg(),[c,d]=a;this.outputShape=a,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${c}.0);

        vec4 values = ${b.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class zZ{constructor(a){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const b=wg(),[c,d]=a;this.outputShape=a,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${d}.0, ${c}.0);
            vec4 values = ${b.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${b.output} = result;
      }
    `}}let z$=aw.getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");var hp=hp,iV=iV,hp=hp,iV=iV,hp=hp,iV=iV;class z_{constructor(a,b,c,d){this.sliceDim=a,this.strides=b,this.paramsShape=d,this.variableNames=["x","indices"],this.outputShape=c;const e=wu(c.length);let f=`
    int index;`;for(let a=0;a<this.sliceDim;a++)f+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${e} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${f}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}var hp=hp,iV=iV;class z0{constructor(a,b){this.variableNames=["A","indices"],this.outputShape=b,this.rank=b.length;const c=wu(this.rank),d=function(a,b){let c=["resRC.x","resRC.y","resRC.z","resRC.w"],d=[];for(let b=0;b<a.length;b++)2===b?d.push("index"):d.push(`${c[b]}`);return d.join()}(a,0);this.userCode=`
      void main() {
        ${c} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${a[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${d}));
      }
    `}}function z1(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,indices:f}=b,{axis:g,batchDims:h}=d,i=iV.parseAxisParam(g,e.shape)[0];if(aw.get("DEBUG")){let a=c.readSync(f.dataId),b=e.shape[i];for(let c=0;c<a.length;++c){let d=a[c];iV.assert(d<=b-1&&d>=0,()=>`GatherV2: the index value ${d} is not in [0, ${b-1}]`)}}let j=hp.segment_util.collectGatherOpShapeInfo(e,f,i,h),k=iV.sizeFromShape(f.shape),l=[],m=yw({inputs:{x:e},backend:c,attrs:{shape:[j.batchSize,j.outerSize,j.dimSize,j.sliceSize]}}),n=yw({inputs:{x:f},backend:c,attrs:{shape:[j.batchSize,k/j.batchSize]}});l.push(m),l.push(n);let o=[j.batchSize,j.outerSize,k/j.batchSize,j.sliceSize];if(c.shouldExecuteOnCPU([e,f])||"string"===e.dtype){let a=c.bufferSync(n),b=xf(c.bufferSync(m),a,o);return l.forEach(a=>c.disposeIntermediateTensorInfo(a)),c.makeTensorInfo(j.outputShape,b.dtype,b.values)}let p=new z0(m.shape,o),q=c.runWebGLProgram(p,[m,n],m.dtype);l.push(q);let r=yw({inputs:{x:q},backend:c,attrs:{shape:j.outputShape}});return l.forEach(a=>c.disposeIntermediateTensorInfo(a)),r}let z2=yq({opSnippet:"return float(a > b);",packedOpSnippet:`
  return vec4(greaterThan(a, b));
`,cpuKernelImpl:xg,dtype:"bool"}),z3=yq({opSnippet:"return float(a >= b);",packedOpSnippet:`
  return vec4(greaterThanEqual(a, b));
`,dtype:"bool",cpuKernelImpl:xh}),z4=yp({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),z5=yp({opSnippet:"return float(isinf(x));",dtype:"bool"}),z6=yp({opSnippet:"return float(isnan(x));",dtype:"bool"}),z7=yq({opSnippet:"return float(a < b);",packedOpSnippet:`
  return vec4(lessThan(a, b));
`,cpuKernelImpl:xi,dtype:"bool"}),z8=yq({opSnippet:"return float(a <= b);",packedOpSnippet:`
  return vec4(lessThanEqual(a, b));
`,cpuKernelImpl:xj,dtype:"bool"}),z9=yp({opSnippet:yo+`
  return x < 0.0 ? 0./0. : log(x);
`,packedOpSnippet:`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,cpuKernelImpl:xl}),Aa=yp({opSnippet:yo+`
  return log(1.0 + x);
`}),Ab=yq({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,dtype:"bool"}),Ac=yp({opSnippet:"return float(!(x >= 1.0));"}),Ad=yq({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,dtype:"bool"});class Ae{constructor(a,b,c,d,e){let f;this.variableNames=["x"],this.outputShape=[];const g=a[3]-1;this.outputShape=a;const h=`float(${c}) + float(${d}) * sum`;f=.5===e?`inversesqrt(${h})`:1===e?`1.0/(${h})`:`exp(log(${h}) * float(-${e}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${b}; j <= ${b}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${g}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${f};
        setOutput(val);
      }
    `}}class Af{constructor(a,b,c,d,e){let f;this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const g=a[3]-1;this.outputShape=a;const h=`float(${c}) + float(${d}) * sum`;f=.5===e?`inversesqrt(${h})`:1===e?`1.0/(${h})`:`exp(log(${h}) * float(-${e}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${b};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${b}; j <= ${b}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${g}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${f};
        setOutput(result);
      }
    `}}class Ag{constructor(a,b,c,d,e){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=a,this.depth=a[3],this.depthRadius=b,this.bias=c,this.alpha=d,this.beta=e,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${b})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${b} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${d}) * norm + float(${c});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${d})
                * float(${e})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${e});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}var hp=hp,iV=iV,iV=iV;function Ah(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f}=c,{reductionIndices:g,keepDims:h}=e,i=f.shape.length,j=iV.parseAxisParam(g,f.shape),k=j,l=hp.getAxesPermutation(k,i),m=null!=l,n=d.shouldExecuteOnCPU([f]),o=f;if(m){if(n){let a=d.texData.get(o.dataId).values,b=Array(i);for(let a=0;a<b.length;a++)b[a]=f.shape[l[a]];let c=xO(a,f.shape,f.dtype,l,b);o=d.makeTensorInfo(b,f.dtype),d.texData.get(o.dataId).values=c}else o=yC(f,l,d);k=hp.getInnerMostAxes(k.length,i)}hp.assertAxesAreInnerMostDims("max",k,i);let[p,q]=hp.computeOutAndReduceShapes(o.shape,k),r=p;if(h&&(r=hp.expandShapeToKeepDim(p,j)),n){let a=xm(d.texData.get(o.dataId).values,iV.sizeFromShape(q),r,f.dtype);b=d.makeTensorInfo(r,f.dtype),d.texData.get(b.dataId).values=a}else{var s,t;let a,c,e,f,g;s=o,t=r,a=iV.sizeFromShape(q),c=iV.sizeFromShape(s.shape),f=yz(e=yw({inputs:{x:s},attrs:{shape:[c/a,a]},backend:d}),s.dtype,"max",d),g=yw({inputs:{x:f},attrs:{shape:t},backend:d}),d.disposeIntermediateTensorInfo(e),d.disposeIntermediateTensorInfo(f),b=g}return m&&d.disposeIntermediateTensorInfo(o),b}let Ai=yq({opSnippet:ye+`
  return max(a, b);
`,packedOpSnippet:`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+yg+`
  return result;
`,cpuKernelImpl:xn});var hp=hp,iV=iV,hp=hp,hp=hp;class Aj{constructor(a){this.variableNames=["dy","maxPos"],this.outputShape=a.inShape;const b=a.strideHeight,c=a.strideWidth,d=a.dilationHeight,e=a.effectiveFilterHeight,f=a.effectiveFilterWidth,g=e-1-a.padInfo.top,h=f-1-a.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${g}, ${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e};
          wR += ${d}) {
          float dyR = float(dyRCorner + wR) / ${b}.0;

          if (dyR < 0.0 || dyR >= ${a.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${f}; wC++) {
            float dyC = float(dyCCorner + wC) / ${c}.0;

            if (dyC < 0.0 || dyC >= ${a.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${e*f-1} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${f} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class Ak{constructor(a){this.variableNames=["dy","maxPos"],this.outputShape=a.inShape;const b=a.strideDepth,c=a.strideHeight,d=a.strideWidth,e=a.dilationDepth,f=a.dilationHeight,g=a.dilationWidth,h=a.effectiveFilterDepth,i=a.effectiveFilterHeight,j=a.effectiveFilterWidth,k=h-1-a.padInfo.front,l=i-1-a.padInfo.top,m=j-1-a.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${k}, ${l}, ${m});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
           wD += ${e}) {
          float dyD = float(dyDCorner + wD) / ${b}.0;

          if (dyD < 0.0 || dyD >= ${a.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${i};
              wR += ${f}) {
            float dyR = float(dyRCorner + wR) / ${c}.0;

            if (dyR < 0.0 || dyR >= ${a.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${j};
                wC += ${g}) {
              float dyC = float(dyCCorner + wC) / ${d}.0;

              if (dyC < 0.0 || dyC >= ${a.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${h*i*j-1} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${i} * ${j} +
                  wR * ${j} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}var hp=hp,hp=hp,iV=iV,hp=hp,iV=iV,iV=iV,hp=hp,iV=iV;let Al=yq({opSnippet:ye+`
  return min(a, b);
`,packedOpSnippet:`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+yg+`
  return result;
`,cpuKernelImpl:xo});class Am{constructor(a,b,c){this.variableNames=["x"],this.outputShape=b.map((b,c)=>b[0]+a[c]+b[1]);const d=a.length,e=wu(d),f=b.map(a=>a[0]).join(","),g=b.map((b,c)=>b[0]+a[c]).join(","),h=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,d),i=+("reflect"!==c);if(1===d){this.userCode=`
        int start = ${f};
        int end = ${g};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${i};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${i};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${e} start = ${e}(${f});
      ${e} end = ${e}(${g});

      void main() {
        ${e} outC = getOutputCoords();
        for (int i = 0; i < ${d}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${i};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${i};
          }
        }
        ${e} coords = outC - start;
        setOutput(getX(${h}));
      }
    `}}class An{constructor(a,b,c){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=b.map((b,c)=>b[0]+a[c]+b[1]);const d=a.length,e=wu(d),f=b.map(a=>a[0]).join(","),g=b.map((b,c)=>b[0]+a[c]).join(","),h=xR("rc",d),i=xR("source",d),j=`${h[d-1]} < ${this.outputShape[d-1]}`,k=1===d?"source":`vec2(${i.slice(-2).join()})`,l=+("reflect"!==c);let m="";if(1===d){const a=`
        ${e} source = rc;
        if (source < start) {
          source = start * 2 - source - ${l};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${l};
        }
        source -= start;
      `;m=`
        ${e} rc = outputLoc;
        ${a}
        result[0] = getChannel(getX(${i.join()}), ${k});
        ${h[d-1]} += 1;
        if(${j}) {
          ${a}
          result[1] = getChannel(getX(${i.join()}), ${k});
        }
      `}else{const a=`
        ${e} source = rc;
        ${e} lt = ${e}(lessThan(source, start));
        ${e} gte = ${e}(greaterThanEqual(source, end));
        ${e} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${l}) +
                gte * ((end - 1) * 2 - source + ${l});
        source -= start;
      `;m=`
        ${e} rc = outputLoc;
        ${a}
        result[0] = getChannel(getX(${i.join()}), ${k});
        ${h[d-1]} += 1;
        if(${j}) {
          ${a}
          result[1] = getChannel(getX(${i.join()}), ${k});
        }
        rc = outputLoc;
        ${h[d-2]} += 1;
        if(${h[d-2]} < ${this.outputShape[d-2]}) {
          ${a}
          result[2] = getChannel(getX(${i.join()}), ${k});
          ${h[d-1]} += 1;
          if(${j}) {
            ${a}
            result[3] = getChannel(getX(${i.join()}), ${k});
          }
        }
      `}this.userCode=`
      const ${e} start = ${e}(${f});
      const ${e} end = ${e}(${g});

      void main() {
        ${e} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}}let Ao=yq({opSnippet:`if (b == 0.0) return NAN;
  return mod(a, b);`,packedOpSnippet:`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+yg+`
  return result;
`});class Ap{constructor(a,b,c){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[a,c],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${b-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${b-1}));
      }
    `}}var hp=hp,iV=iV;let Aq=yq({opSnippet:`
if (a == b) {
  return 1.0;
};
return a / b;`,packedOpSnippet:`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,checkOutOfBounds:!0}),Ar="return a - b;",As=yq({opSnippet:Ar,packedOpSnippet:Ar,supportsComplex:!0,cpuKernelImpl:xL});function At(a){let{inputs:b,backend:c,attrs:d}=a,{logits:e}=b,{dim:f}=d,g=iV.parseAxisParam([f],e.shape),h=Ah({inputs:{x:e},backend:c,attrs:{reductionIndices:g,keepDims:!1}}),i=hp.expandShapeToKeepDim(h.shape,g),j=yw({inputs:{x:h},backend:c,attrs:{shape:i}}),k=As({inputs:{a:e,b:j},backend:c}),l=zM({inputs:{x:k},backend:c}),m=yD({inputs:{x:l},backend:c,attrs:{axis:g,keepDims:!1}}),n=yw({inputs:{x:m},backend:c,attrs:{shape:i}}),o=Aq({inputs:{a:l,b:n},backend:c});return c.disposeIntermediateTensorInfo(h),c.disposeIntermediateTensorInfo(j),c.disposeIntermediateTensorInfo(k),c.disposeIntermediateTensorInfo(l),c.disposeIntermediateTensorInfo(m),c.disposeIntermediateTensorInfo(n),o}let Au=xZ+`
  return -x;
`,Av=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;var hp=hp,sI=sI;let Aw=sI.nonMaxSuppressionV3Impl;var hp=hp,sI=sI;let Ax=sI.nonMaxSuppressionV4Impl;var hp=hp,sI=sI;let Ay=sI.nonMaxSuppressionV5Impl;var iV=iV;class Az{constructor(a,b,c,d){this.variableNames=["indices"],this.outputShape=[a,b],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${d}), float(${c}),
                      float(index == coords.y)));
      }
    `}}function AA(a){let{inputs:b,backend:c}=a,{x:d}=b;if("complex64"!==d.dtype)return zT({attrs:{shape:d.shape,dtype:d.dtype,value:"string"===d.dtype?"":0},backend:c});{let a=y6({inputs:{input:d},backend:c}),b=AA({inputs:{x:a},backend:c}),e=zg({inputs:{input:d},backend:c}),f=AA({inputs:{x:e},backend:c}),g=yj({inputs:{real:b,imag:f},backend:c});return c.disposeIntermediateTensorInfo(a),c.disposeIntermediateTensorInfo(b),c.disposeIntermediateTensorInfo(e),c.disposeIntermediateTensorInfo(f),g}}var iV=iV,iV=iV;class AB{constructor(a,b,c){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=b.map((b,c)=>b[0]+a[c]+b[1]);const d=a.length,e=wu(d),f=b.map(a=>a[0]).join(","),g=b.map((b,c)=>b[0]+a[c]).join(","),h=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,d);if(1===d){this.userCode=`
        int start = ${f};
        int end = ${g};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${e} start = ${e}(${f});
      ${e} end = ${e}(${g});

      void main() {
        ${e} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${e} coords = outC - start;
          setOutput(getX(${h}));
        }
      }
    `}}class AC{constructor(a,b,c){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=b.map((b,c)=>b[0]+a[c]+b[1]);const d=a.length,e=wu(d),f=b.map(a=>a[0]).join(","),g=b.map((b,c)=>b[0]+a[c]).join(","),h=xR("rc",d),i=xR("source",d),j=`${h[d-1]} < ${this.outputShape[d-1]}`,k=1===d?"source":`vec2(${i.slice(-2).join()})`,l=[`${e} rc = outputLoc;`,`${h[d-1]} += 1;
       if(${j}) {
      `,1===d?"":`}
       rc = outputLoc;
       ${h[d-2]} += 1;
       if(${h[d-2]} < ${this.outputShape[d-2]}) {`,1===d?"":`  ${h[d-1]} += 1;
         if(${j}) {`],m=1===d?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let n="";for(let a=0,b=1===d?2:4;a<b;a++)n+=`
        ${l[a]}
        if (${m}) {
          result[${a}] = float(value);
        } else {
          ${e} source = rc - start;
          result[${a}] = getChannel(getX(${i.join()}), ${k});
        }
      `;n+=1===d?"} ":"}}",this.userCode=`
      const ${e} start = ${e}(${f});
      const ${e} end = ${e}(${g});

      void main() {
        ${e} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${n}
        setOutput(result);
      }
    `}}let AD=a=>{let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{paddings:f,constantValue:g}=d;if(0===iV.sizeFromShape(e.shape))return zT({backend:c,attrs:{shape:f.map((a,b)=>a[0]+e.shape[b]+a[1]),value:g,dtype:e.dtype}});let h=aw.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new AC(e.shape,f,g):new AB(e.shape,f,g),i=[[g]];return c.runWebGLProgram(h,[e],e.dtype,i)},AE=yq({opSnippet:`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,packedOpSnippet:`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+yg+`
  return result;
`});var hp=hp,iV=iV;let AF=a=>{let{backend:b,attrs:c}=a,{start:d,stop:e,step:f,dtype:g}=c,h=xw(d,e,f,g);return b.makeTensorInfo([h.length],g,h)},AG=yp({opSnippet:"return 1.0 / x;"}),AH=yp({opSnippet:xZ+`
  return (x < 0.0) ? 0.0 : x;
`,packedOpSnippet:`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),AI=yp({opSnippet:xZ+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,packedOpSnippet:`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`});class AJ{constructor(a,b,c,d,e){this.variableNames=["A"],this.outputShape=[];const[f,g,h,i]=a;this.outputShape=[f,b,c,i];const j=[d&&b>1?g-1:g,d&&c>1?h-1:h],k=[d&&b>1?b-1:b,d&&c>1?c-1:c];this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${j[0]/k[0]},
          ${j[1]/k[1]});
      const vec2 inputShapeRC = vec2(${g}.0, ${h}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${e?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class AK{constructor(a,b,c,d,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[f,g,h,i]=a;this.outputShape=[f,b,c,i];const j=[d&&b>1?g-1:g,d&&c>1?h-1:h],k=[d&&b>1?b-1:b,d&&c>1?c-1:c];this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${j[0]/k[0]},
          ${j[1]/k[1]},
          ${j[1]/k[1]});
      const vec3 inputShapeRC = vec3(${g}.0, ${h}.0,
                                     ${h}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${e?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${i-1};
        bool hasNextRow = coords.z < ${c-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}class AL{constructor(a,b,c){this.variableNames=["dy"],this.outputShape=[],this.outputShape=b;const[,d,e]=b,[,f,g]=a,h=[c&&f>1?d-1:d,c&&g>1?e-1:e],i=[c&&f>1?f-1:f,c&&g>1?g-1:g],j=h[0]/i[0],k=h[1]/i[1],l=1/j,m=1/k,n=2*Math.ceil(l)+2,o=2*Math.ceil(m)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${j});
        const float widthScale = float(${k});

        const float invHeightScale = float(${l});
        const float invWidthScale = float(${m});

        const int winHeight = int(${n});
        const int winWidth = int(${o});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${f}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${g}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${d-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${e-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}class AM{constructor(a,b,c,d,e){this.variableNames=["A"],this.outputShape=[];const[f,g,h,i]=a;this.outputShape=[f,b,c,i];const j=[d&&b>1?g-1:g,d&&c>1?h-1:h],k=[d&&b>1?b-1:b,d&&c>1?c-1:c];this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${j[0]/k[0]},
          ${j[1]/k[1]});
      const vec2 inputShapeRC = vec2(${g}.0, ${h}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${e?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d?"0.5":"0.0"})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class AN{constructor(a,b,c,d,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[f,g,h,i]=a;this.outputShape=[f,b,c,i];const j=[d&&b>1?g-1:g,d&&c>1?h-1:h],k=[d&&b>1?b-1:b,d&&c>1?c-1:c];this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${j[0]/k[0]},
          ${j[1]/k[1]},
          ${j[1]/k[1]});
      const vec3 inputShapeRC = vec3(${g}.0, ${h}.0,
                                     ${h}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${e?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d?"0.5":"0.0"})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${i-1};
        bool hasNextRow = coords.z < ${c-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}class AO{constructor(a,b,c){this.variableNames=["dy"],this.outputShape=[],this.outputShape=b;const[,d,e]=b,[,f,g]=a,h=[c&&f>1?d-1:d,c&&g>1?e-1:e],i=[c&&f>1?f-1:f,c&&g>1?g-1:g],j=h[0]/i[0],k=h[1]/i[1],l=1/j,m=1/k,n=2*Math.ceil(l)+2,o=2*Math.ceil(m)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${j});
        const float widthScale = float(${k});

        const float invHeightScale = float(${l});
        const float invWidthScale = float(${m});

        const int winHeight = int(${n});
        const int winWidth = int(${o});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${f}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${g}) {
              continue;
            }

            float sourceFracRow =
              float(${h[0]}) *
                (float(dyR) / float(${i[0]}));

            float sourceFracCol =
                float(${h[1]}) *
                  (float(dyC) / float(${i[1]}));

            int sourceNearestRow = int(min(
                float(int(${d}) - 1),
                ${c} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${e}) - 1),
                ${c} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}var iV=iV;class AP{constructor(a,b){this.variableNames=["x"];const c=a.length;if(c>4)throw Error(`WebGL backend: Reverse of rank-${c} tensor is not yet supported`);if(this.outputShape=a,1===c){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${a[0]} - coord - 1));
        }
      `;return}const d=a.map((c,d)=>-1!==b.indexOf(d)&&1!==a[d]?`${a[d]} - coords[${d}] - 1`:`coords[${d}]`).join(","),e=wu(c);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        setOutput(getX(${d}));
      }
    `}}class AQ{constructor(a,b){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const c=a.length;if(c>4)throw Error(`WebGL backend: Reverse of rank-${c} tensor is not yet supported`);this.outputShape=a;const d=xR("rc",c),e=`${d[c-1]} + 1 < ${this.outputShape[c-1]}`,f=`${d[c-2]} + 1 < ${this.outputShape[c-2]}`,g=wu(c);function h(c){let d=a.map((d,e)=>{var f,g;return f=e,g=c,-1!==b.indexOf(f)&&1!==a[f]?`${a[f]} - ${g[f]} - 1`:`${g[f]}`}),e=d.join(","),f=d.slice(-2).join(",");return`getChannel(getX(${e}), vec2(${f}))`}1===c?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${a[0]} - rc - 1),
            ${a[0]} - rc - 1);
          if(${e}){
              result.g = getChannel(getX(${a[0]} - (rc  + 1) - 1),
                ${a[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${g} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${h(d.slice())};
          if(${e}){
            result.g = ${function(a){return a[c-1]="("+a[c-1]+" + 1)",h(a)}(d.slice())};
          }
          if(${f}) {
            result.b = ${function(a){return a[c-2]="("+a[c-2]+" + 1)",h(a)}(d.slice())};
            if(${e}) {
              result.a = ${function(a){return a[c-1]="("+a[c-1]+" + 1)",a[c-2]="("+a[c-2]+" + 1)",h(a)}(d.slice())};
            }
          }
          setOutput(result);
        }
    `}}var hp=hp;class AR{constructor(a,b){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const c=a[1],d=a[2];this.outputShape=a;let e="";e="number"==typeof b?`float outputValue = ${b.toFixed(2)};`:`
        vec3 fill = vec3(${b.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${e}
          if(coordX >= 0 && coordX < ${d} && coordY >= 0 && coordY < ${c}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}let AS=yp({opSnippet:`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`}),AT=yp({opSnippet:"return inversesqrt(x);",cpuKernelImpl:xx});var hp=hp;class AU{constructor(a,b,c,d,e,f,g=!0,h=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=f;const i=wu(e.length),j=wu(f.length);let k="";1===c?k="i":2===c&&(k="i, j");const l=`getIndices(${k})`;let m="";1===d?m="i":2===d&&(m="i, coords[1]");const n=`getUpdates(${m})`;let o="";h&&(o="coords[0], coords[1]");const p=`getDefaultValue(${o})`;this.userCode=`
        ${i} strides = ${i}(${e});

        void main() {
          ${j} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${a}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${b}; j++) {
              int index = round(${l});
              flattenedIndex += index * ${b>1?"strides[j]":"strides"};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${n};
              found = true;
            }
          }
          setOutput(mix(${p}, sum, float(found)));
        }
      `}}class AV{constructor(a,b,c,d,e,f,g=!0,h=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=f;const i=wu(e.length),j=wu(f.length);let k="";1===c?k="i":2===c&&(k="i, j");const l=`getIndices(${k})`;let m="";1===d?m="i":2===d&&(m="i, coords[1]");const n=`getUpdates(${m})`;let o="";h&&(o="coords[0], coords[1]");const p=`getDefaultValue(${o})`;this.userCode=`
        ${i} strides = ${i}(${e});

        void main() {
          ${j} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${a}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${b}; j+=2) {
              ivec4 index = round(${l});
              flattenedIndex += index.xz * ${b>1?"strides[j]":"strides"};
              if (j + 1 < ${b}) {
                flattenedIndex += index.yw * ${b>1?"strides[j + 1]":"strides"};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${n};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${p}, sum, found));
        }
      `}}class AW{constructor(a,b,c,d){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[a,c];const e=`for (int i = 0; i < ${Math.ceil(Math.log2(b+1))}; ++i) { if (left >= right) break;`,f=2===aw.getNumber("WEBGL_VERSION")?"while (left < right) {":e;this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${f}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${"left"===d?"<":"<="} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}class AX{constructor(a,b,c){let d,e;if(this.variableNames=["c","a","b"],this.outputShape=b,c>4)throw Error(`Where for rank ${c} is not yet supported`);if(1===c)e="resRC",d="resRC";else{const c=["resRC.x","resRC.y","resRC.z","resRC.w"],f=[],g=[];for(let d=0;d<b.length;d++)g.push(`${c[d]}`),d<a&&f.push(`${c[d]}`);d=f.join(),e=g.join()}const f=wu(c);this.userCode=`
      void main() {
        ${f} resRC = getOutputCoords();
        float cVal = getC(${d});
        if (cVal >= 1.0) {
          setOutput(getA(${e}));
        } else {
          setOutput(getB(${e}));
        }
      }
    `}}var hp=hp;let AY=yp({opSnippet:`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${hp.SELU_SCALEALPHA};
  float scale = ${hp.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`}),AZ=yp({opSnippet:yo+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,packedOpSnippet:`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:xz}),A$=yp({opSnippet:`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`}),A_=yp({opSnippet:yo+`
  return sin(x);
`,packedOpSnippet:`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${yg}
  return result;
`}),A0=yp({opSnippet:`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`}),A1=yp({opSnippet:`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`});var hp=hp,iV=iV,hp=hp,iV=iV,hp=hp,iV=iV;let A2="return sqrt(x);",A3=yp({opSnippet:A2,packedOpSnippet:A2,cpuKernelImpl:xF}),A4=yp({opSnippet:"return x * x;"}),A5="return (a - b) * (a - b);",A6=yq({opSnippet:A5,packedOpSnippet:A5});var hp=hp,tU=gr,iV=iV;class A7{constructor(a,b,c){this.variableNames=["x"],this.outputShape=c;const d=c.length,e=wu(c.length),f=wu(c.length);let g="";if(1===d)g="coords * strides + begin";else{let a=0;g=c.map((b,d)=>(a++,1===c.length?`coords * strides[${d}] + begin[${d}]`:`coords[${a-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${e} begin = ${e}(${a});
      ${e} strides = ${e}(${b});

      void main() {
        ${f} coords = getOutputCoords();
        setOutput(getX(${g}));
      }
    `}}let A8=yp({opSnippet:"return tan(x);"}),A9=yp({opSnippet:`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`});var hp=hp,iV=iV;class Ba{constructor(a,b){this.variableNames=["A"];const c=Array(a.length);for(let d=0;d<c.length;d++)c[d]=a[d]*b[d];this.outputShape=c,this.rank=c.length;const d=wu(this.rank),e=function(a){let b=a.length;if(b>5)throw Error(`Tile for rank ${b} is not yet supported`);if(1===b)return`imod(resRC, ${a[0]})`;let c=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],d=[];for(let b=0;b<a.length;b++)d.push(`imod(${c[b]}, ${a[b]})`);return d.join()}(a);this.userCode=`
      void main() {
        ${d} resRC = getOutputCoords();
        setOutput(getA(${e}));
      }
    `}}function Bb(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{reps:f}=d;if("string"===e.dtype||e.shape.length>5){let a=c.readSync(e.dataId),b="string"===e.dtype?a.map(a=>iV.decodeString(a)):a,d=xM(eu(e.shape,e.dtype,b),f);return c.makeTensorInfo(d.shape,d.dtype,d.values)}let g=new Ba(e.shape,f);return c.runWebGLProgram(g,[e],e.dtype)}var iV=iV;class Bc{constructor(a){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=a,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class Bd{constructor(a){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=a,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function Be(a,b){null!==b&&a.disposeIntermediateTensorInfo(b)}function Bf(a){let b=1;for(;b<a;)b*=2;return b}class Bg{constructor(a,b,c,d,e,f){let g;switch(this.variableNames=["Image","Transforms"],this.outputShape=f,d){case"constant":default:g=1;break;case"reflect":g=2;break;case"wrap":g=3;break;case"nearest":g=4}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${g} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${g} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${g} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${a} && 0 <= coordX && coordX < ${b}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${e});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${e});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${b}));
                float mapY = mapCoord(inY, float(${a}));

                if (${"nearest"===c?1:2} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}var hp=hp,iV=iV;class Bh{constructor(a,b){this.variableNames=["x","segmentIds"];const c=a.windowSize,d=a.batchSize,e=a.inSize,f=a.numSegments,g=f*Math.ceil(e/c);this.outputShape=[d,g];const h=4*Math.floor(c/4),i=c%4,j=`
        sumValue += dot(values, segFilter);
    `;let k="";e%c>0&&(k=`
        if (inIdx < 0 || inIdx >= ${e}) {
          return initializationValue;
        }
      `);let l="";e%c>0&&(l=`
        if (inIdx < 0 || inIdx >= ${e}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = 0.0;

      float getValue(int batch, int inIdx) {
        ${k}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${l}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${f})) * float(${c}));
        int currentSeg = int(mod(float(outIdx), float(${f})));

        float sumValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${j}
        }

        int inIdx = inOffset + ${h};
        if (${1===i}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${j}
        } else if (${2===i}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${j}
        } else if (${3===i}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${j}
        }
        setOutput(sumValue);
      }
    `}}for(let a of[{kernelName:cV,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{a:e,b:f,bias:g,preluActivationWeights:h}=b,{transposeA:i,transposeB:j,activation:k,leakyreluAlpha:l}=d;return yF({a:e,b:f,transposeA:i,transposeB:j,backend:c,bias:g,preluActivationWeights:h,leakyreluAlpha:l,activation:k})}},{kernelName:"Abs",backendName:"webgl",kernelFunc:function(a){let b,{inputs:c,backend:d}=a,{x:e}=c;if(d.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){let a=xA(d.texData.get(e.dataId).values);return d.makeTensorInfo(e.shape,e.dtype,a)}return b=aw.getBool("WEBGL_PACK_UNARY_OPERATIONS")?new x5(e.shape,yG):new xY(e.shape,yG),d.runWebGLProgram(b,[e],e.dtype)}},{kernelName:az,backendName:"webgl",kernelFunc:yH},{kernelName:aA,backendName:"webgl",kernelFunc:yI},{kernelName:"Add",backendName:"webgl",kernelFunc:yK},{kernelName:aB,backendName:"webgl",kernelFunc:function a(b){let{inputs:c,backend:d}=b;if(1===c.length)return yi({inputs:{x:c[0]},backend:d});if(c.length>aw.getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let b=Math.floor(c.length/2),e=a({inputs:c.slice(0,b),backend:d}),f=a({inputs:c.slice(b),backend:d});return a({inputs:[e,f],backend:d})}let e=c.map(a=>a.dtype).reduce((a,b)=>dp(a,b)),f=c.map(a=>a.shape),g=aw.getBool("WEBGL_PACK")?new yM(c[0].shape,f):new yL(c[0].shape,f);return d.runWebGLProgram(g,c,e)}},{kernelName:"All",backendName:"webgl",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f}=c,{axis:g,keepDims:h}=e,i=f.shape.length,j=iV.parseAxisParam(g,f.shape),k=j,l=hp.getAxesPermutation(k,i),m=f;null!=l&&(m=yE({inputs:{x:f},backend:d,attrs:{perm:l}}),k=hp.getInnerMostAxes(k.length,i)),hp.assertAxesAreInnerMostDims("all",k,i);let[n,o]=hp.computeOutAndReduceShapes(m.shape,k),p=yw({inputs:{x:m},backend:d,attrs:{shape:[-1,iV.sizeFromShape(o)]}}),q=yz(p,p.dtype,"all",d);return b=h?yw({inputs:{x:q},backend:d,attrs:{shape:hp.expandShapeToKeepDim(n,j)}}):yw({inputs:{x:q},backend:d,attrs:{shape:n}}),d.disposeIntermediateTensorInfo(p),d.disposeIntermediateTensorInfo(q),null!=l&&d.disposeIntermediateTensorInfo(m),b}},{kernelName:"Any",backendName:"webgl",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f}=c,{axis:g,keepDims:h}=e,i=f.shape.length,j=iV.parseAxisParam(g,f.shape),k=j,l=hp.getAxesPermutation(k,i),m=f;null!=l&&(m=yE({inputs:{x:f},backend:d,attrs:{perm:l}}),k=hp.getInnerMostAxes(k.length,i)),hp.assertAxesAreInnerMostDims("any",k,i);let[n,o]=hp.computeOutAndReduceShapes(m.shape,k),p=yw({inputs:{x:m},backend:d,attrs:{shape:[-1,iV.sizeFromShape(o)]}}),q=yz(p,p.dtype,"any",d);return b=h?yw({inputs:{x:q},backend:d,attrs:{shape:hp.expandShapeToKeepDim(n,j)}}):yw({inputs:{x:q},backend:d,attrs:{shape:n}}),d.disposeIntermediateTensorInfo(p),d.disposeIntermediateTensorInfo(q),null!=l&&d.disposeIntermediateTensorInfo(m),b}},{kernelName:aC,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{axis:f}=d,g=iV.parseAxisParam(f,e.shape),h=hp.getAxesPermutation(g,e.shape.length),i=e,j=[];null!=h&&(j.push(i=yE({inputs:{x:e},backend:c,attrs:{perm:h}})),g=hp.getInnerMostAxes(g.length,i.shape.length)),hp.assertAxesAreInnerMostDims("argMax",[g[0]],i.shape.length);let k=yP(c,i,g[0],"max");return j.forEach(a=>c.disposeIntermediateTensorInfo(a)),k}},{kernelName:aD,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{axis:f}=d,g=iV.parseAxisParam(f,e.shape),h=hp.getAxesPermutation(g,e.shape.length),i=e,j=[];null!=h&&(j.push(i=yE({inputs:{x:e},backend:c,attrs:{perm:h}})),g=hp.getInnerMostAxes(g.length,i.shape.length)),hp.assertAxesAreInnerMostDims("argMin",[g[0]],i.shape.length);let k=yP(c,i,g[0],"min");return j.forEach(a=>c.disposeIntermediateTensorInfo(a)),k}},{kernelName:aE,backendName:"webgl",kernelFunc:yQ},{kernelName:aF,backendName:"webgl",kernelFunc:yR},{kernelName:aG,backendName:"webgl",kernelFunc:yS},{kernelName:aI,backendName:"webgl",kernelFunc:yT},{kernelName:aH,backendName:"webgl",kernelFunc:yU},{kernelName:aJ,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b;we(e,"avgPool");let{filterSize:f,strides:g,pad:h,dimRoundingMode:i}=d;iV.assert(hp.eitherStridesOrDilationsAreOne(g,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${g} and dilations '1'`);let j=hp.computePool2DInfo(e.shape,f,g,1,h,i);if(1===j.filterWidth&&1===j.filterHeight&&iV.arraysEqual(j.inShape,j.outShape))return yi({inputs:{x:e},backend:c});let k=new yV(j,"avg",!1);return c.runWebGLProgram(k,[e],"float32")}},{kernelName:aL,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{filterSize:f,strides:g,pad:h,dimRoundingMode:i,dataFormat:j}=d,k=new yW(hp.computePool3DInfo(e.shape,f,g,[1,1,1],h,i,j),"avg",!1);return c.runWebGLProgram(k,[e],"float32")}},{kernelName:aM,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{dy:e,input:f}=b,{filterSize:g,strides:h,pad:i,dimRoundingMode:j}=d,k=new yY(hp.computePool3DInfo(f.shape,g,h,[1,1,1],i,j));return c.runWebGLProgram(k,[e],f.dtype)}},{kernelName:aK,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{dy:e,input:f}=b;we([e,f],"avgPoolGrad");let{filterSize:g,strides:h,pad:i}=d,j=new yX(hp.computePool2DInfo(f.shape,g,h,1,i));return c.runWebGLProgram(j,[e],f.dtype)}},{kernelName:aN,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{a:e,b:f}=b,{transposeA:g,transposeB:h}=d;return yF({a:e,b:f,transposeA:g,transposeB:h,backend:c})}},{kernelName:bq,backendName:"webgl",kernelFunc:({inputs:a,backend:b,attrs:c})=>{let{x:d,mean:e,variance:f,offset:g,scale:h}=a;iV.assert(e.shape.length===f.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),iV.assert(null==g||e.shape.length===g.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),iV.assert(null==h||e.shape.length===h.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:i}=c;null==i&&(i=.001);let j=[d,e,f],k=null;null!=g&&(k=g.shape,j.push(g));let l=null;null!=h&&(l=h.shape,j.push(h));let m=aw.getBool("WEBGL_PACK_NORMALIZATION")?new y$(d.shape,e.shape,f.shape,k,l,i):new yZ(d.shape,e.shape,f.shape,k,l,i);return b.runWebGLProgram(m,j,j[0].dtype)}},{kernelName:aO,backendName:"webgl",kernelFunc:a=>{let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{blockShape:f,crops:g}=d;iV.assert(e.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let h=f.reduce((a,b)=>a*b),i=hp.getReshaped(e.shape,f,h),j=hp.getPermuted(i.length,f.length),k=hp.getReshapedPermuted(e.shape,f,h),l=hp.getSliceBeginCoords(g,f.length),m=hp.getSliceSize(k,g,f.length),n=[],o=yw({inputs:{x:e},backend:c,attrs:{shape:i}}),p=yE({inputs:{x:o},backend:c,attrs:{perm:j}}),q=yw({inputs:{x:p},backend:c,attrs:{shape:k}}),r=y2({inputs:{x:q},backend:c,attrs:{begin:l,size:m}});return n.push(o),n.push(p),n.push(q),n.forEach(a=>c.disposeIntermediateTensorInfo(a)),r}},{kernelName:aP,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,weights:f}=b,{size:g}=d,h=w4(c.readSync(e.dataId),c.readSync(f.dataId),f.dtype,f.shape,g);return c.makeTensorInfo([g],f.dtype,h)}},{kernelName:aQ,backendName:"webgl",kernelFunc:function(a){let b,{inputs:c,backend:d}=a,{a:e,b:f}=c,g=aw.getBool("WEBGL_PACK_BINARY_OPERATIONS"),h=aw.getNumber("WEBGL_VERSION");if(d.shouldExecuteOnCPU([e,f])||1===h){let a=d.texData.get(e.dataId).values,b=d.texData.get(f.dataId).values,[c,g]=w6(e.shape,f.shape,a,b,e.dtype),h=d.makeTensorInfo(g,e.dtype);return d.texData.get(h.dataId).values=c,h}return b=g?new yh(y3,e.shape,f.shape,!1):new yf(y4,e.shape,f.shape),d.runWebGLProgram(b,[e,f],e.dtype)}},{kernelName:aR,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c}=a,{s0:d,s1:e}=b,f=c.readSync(d.dataId),g=c.readSync(e.dataId),h=hp.assertAndGetBroadcastShape(Array.from(f),Array.from(g));return c.makeTensorInfo([h.length],"int32",Int32Array.from(h))}},{kernelName:aS,backendName:"webgl",kernelFunc:function a(b){let{inputs:c,backend:d,attrs:e}=b,{x:f}=c,{dtype:g}=e;if("complex64"===g){if("complex64"===f.dtype)return yi({inputs:{x:f},backend:d});let b=f4(f.shape),c=a({inputs:{x:f},backend:d,attrs:{dtype:"float32"}}),e=yj({inputs:{real:c,imag:b},backend:d});return b.dispose(),d.disposeIntermediateTensorInfo(c),e}if("complex64"===f.dtype){let b=y6({inputs:{input:f},backend:d}),c=a({inputs:{x:b},backend:d,attrs:{dtype:g}});return d.disposeIntermediateTensorInfo(b),c}if(!iV.hasEncodingLoss(f.dtype,g)){let a=yi({inputs:{x:f},backend:d});return{dataId:a.dataId,shape:a.shape,dtype:g}}if(d.shouldExecuteOnCPU([f])){let[a,b,c]=w7(d.texData.get(f.dataId).values,f.shape,f.dtype,g);return d.makeTensorInfo(a,b,c)}if("int32"===g){let a,b;return a=new xY(f.shape,"return float(int(x));"),{dataId:(b=d.runWebGLProgram(a,[f],"int32")).dataId,shape:b.shape,dtype:b.dtype}}if("bool"===g){let a=d.makeTensorInfo([],"bool",iV.getTypedArrayFromDType("bool",1)),b=y5({inputs:{a:f,b:a},backend:d});return d.disposeIntermediateTensorInfo(a),b}throw Error(`Error in Cast: failed to cast ${f.dtype} to ${g}`)}},{kernelName:aT,backendName:"webgl",kernelFunc:y8},{kernelName:aU,backendName:"webgl",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f}=c,{clipValueMin:g,clipValueMax:h}=e;return b=aw.getBool("WEBGL_PACK_CLIP")?new za(f.shape):new y9(f.shape),d.runWebGLProgram(b,[f],f.dtype,[[g],[h]])}},{kernelName:aV,backendName:"webgl",kernelFunc:yj},{kernelName:aW,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c}=a,{x:d}=b,e=c.texData.get(d.dataId),f=new zb(d.shape),g=[zc(d,e.complexTensorInfos.real),zc(d,e.complexTensorInfos.imag)];return c.runWebGLProgram(f,g,g[0].dtype)}},{kernelName:aX,backendName:"webgl",kernelFunc:zh},{kernelName:aY,backendName:"webgl",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f,filter:g}=c,{strides:h,pad:i,dataFormat:j,dilations:k,dimRoundingMode:l}=e,m=hp.convertConv2DDataFormat(j),n=hp.computeConv2DInfo(f.shape,g.shape,h,k,i,l,!1,m);if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))b=zn({x:f,filter:g,convInfo:n,backend:d});else if(n.strideWidth<=2&&"channelsLast"===m&&aw.getBool("WEBGL_EXP_CONV")){let a=new zk(n),c=[[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inHeight,n.inWidth]];b=d.runWebGLProgram(a,[f,g],"float32",c)}else if(aw.getBool("WEBGL_CONV_IM2COL"))b=zo({x:f,filter:g,convInfo:n,backend:d});else{let a=new zi(n);b=d.runWebGLProgram(a,[f,g],"float32")}let o=yw({inputs:{x:b},backend:d,attrs:{shape:n.outShape}});return d.disposeIntermediateTensorInfo(b),o}},{kernelName:aZ,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,dy:f}=b,{strides:g,pad:h,dataFormat:i,dimRoundingMode:j,filterShape:k}=d,l=hp.convertConv2DDataFormat(i),m=new zp(hp.computeConv2DInfo(e.shape,k,g,1,h,j,!1,l));return c.runWebGLProgram(m,[e,f],"float32")}},{kernelName:a$,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{dy:e,filter:f}=b,{inputShape:g,strides:h,pad:i,dataFormat:j,dimRoundingMode:k}=d,l=hp.convertConv2DDataFormat(j),m=hp.computeConv2DInfo(g,f.shape,h,1,i,k,!1,l);if(aw.getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===l){let a=[[m.strideHeight,m.strideWidth]],b=new zt(m);return c.runWebGLProgram(b,[e,f],"float32",a)}{let a=new zq(m);return c.runWebGLProgram(a,[e,f],"float32")}}},{kernelName:a_,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,filter:f}=b,{strides:g,pad:h,dilations:i}=d,j=new zj(hp.computeConv3DInfo(e.shape,f.shape,g,i,h));return c.runWebGLProgram(j,[e,f],"float32")}},{kernelName:a0,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,dy:f}=b,{strides:g,pad:h,filterShape:i}=d,j=new zr(hp.computeConv3DInfo(e.shape,i,g,1,h));return c.runWebGLProgram(j,[e,f],"float32")}},{kernelName:a1,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{dy:e,filter:f}=b,{pad:g,strides:h,inputShape:i}=d,j=new zs(hp.computeConv3DInfo(i,f.shape,h,1,g));return c.runWebGLProgram(j,[e,f],"float32")}},{kernelName:"Cos",backendName:"webgl",kernelFunc:zu},{kernelName:a2,backendName:"webgl",kernelFunc:zv},{kernelName:a5,backendName:"webgl",kernelFunc:a=>{let{inputs:b,backend:c,attrs:d}=a,{image:e,boxes:f,boxInd:g}=b,{cropSize:h,method:i,extrapolationValue:j}=d,k=new zw(e.shape,f.shape,h,i,j);return c.runWebGLProgram(k,[e,f,g],"float32")}},{kernelName:a3,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{axis:f,exclusive:g,reverse:h}=d;return zA(BV.Prod,e,c,f,g,h)}},{kernelName:a4,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{axis:f,exclusive:g,reverse:h}=d;return zA(BV.Sum,e,c,f,g,h)}},{kernelName:a6,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,weights:f}=b,{size:g,binaryOutput:h}=d;if(1===e.shape.length){let a=w4(c.readSync(e.dataId),c.readSync(f.dataId),f.dtype,f.shape,g);return c.makeTensorInfo([g],f.dtype,a)}if(2===e.shape.length){let a=w5(c.bufferSync(e),c.bufferSync(f),g,h);return c.makeTensorInfo(a.shape,f.dtype,a.values)}throw Error(`Error in denseBincount: input must be at most rank 2, but got rank${e.shape.length}.`)}},{kernelName:a7,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{blockSize:f,dataFormat:g}=d,h=e.shape[0],i="NHWC"===g?e.shape[1]:e.shape[2],j="NHWC"===g?e.shape[2]:e.shape[3],k="NHWC"===g?e.shape[3]:e.shape[1],l=i*f,m=j*f,n=k/(f*f),o=new zB("NHWC"===g?[h,l,m,n]:[h,n,l,m],f,g);return c.runWebGLProgram(o,[e],e.dtype)}},{kernelName:a8,backendName:"webgl",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f,filter:g}=c,{strides:h,pad:i,dilations:j,dimRoundingMode:k}=e,l=j;null==l&&(l=[1,1]),iV.assert(hp.eitherStridesOrDilationsAreOne(h,l),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${h} and dilations '${l}'`);let m=hp.computeConv2DInfo(f.shape,g.shape,h,l,i,k,!0);b=aw.getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels==1?new zD(m):new zC(m);let n=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];return d.runWebGLProgram(b,[f,g],"float32",n)}},{kernelName:a9,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,dy:f}=b,{strides:g,dilations:h,pad:i,dimRoundingMode:j,filterShape:k}=d,l=new zE(hp.computeConv2DInfo(e.shape,k,g,h,i,j,!0));return c.runWebGLProgram(l,[e,f],"float32")}},{kernelName:ba,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{dy:e,filter:f}=b,{strides:g,dilations:h,pad:i,dimRoundingMode:j,inputShape:k}=d,l=new zF(hp.computeConv2DInfo(k,f.shape,g,h,i,j,!0));return c.runWebGLProgram(l,[e,f],"float32")}},{kernelName:bb,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c}=a,{x:d}=b,e=[...d.shape,...d.shape],f=iV.sizeFromShape(d.shape),g=yw({inputs:{x:d},backend:c,attrs:{shape:[f]}}),h=new zG(f),i=c.runWebGLProgram(h,[g],g.dtype),j=yw({inputs:{x:i},backend:c,attrs:{shape:e}});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(i),j}},{kernelName:bc,backendName:"webgl",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f,filter:g}=c,{strides:h,pad:i,dilations:j}=e,k=hp.computeDilation2DInfo(f.shape,g.shape,h,i,"NHWC",j),l=new zH(k),m=yw({inputs:{x:b=d.runWebGLProgram(l,[f,g],"float32")},backend:d,attrs:{shape:k.outShape}});return d.disposeIntermediateTensorInfo(b),m}},{kernelName:bh,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{equation:e}=d,{allDims:f,summedDims:g,idDims:h}=hp.decodeEinsumEquation(e,b.length);hp.checkEinsumDimSizes(f.length,h,b);let{path:i,steps:j}=hp.getEinsumComputePath(g,h),k=j.length,l=null,m=f.length,n=[];for(let a=0;a<k;++a){for(let d of j[a]){let a,{permutationIndices:e,expandDims:f}=hp.getEinsumPermutation(m,h[d]);hp.isIdentityPermutation(e)?a=b[d]:(a=yE({inputs:{x:b[d]},backend:c,attrs:{perm:e}}),n.push(a));let g=a.shape.slice();for(let a=0;a<f.length;++a)g.splice(f[a],0,1);iV.arraysEqual(a.shape,g)||(a=yw({inputs:{x:a},backend:c,attrs:{shape:g}}),n.push(a)),null===l?l=a:(l=yv({inputs:{a:a,b:l},backend:c}),n.push(l))}a<k-1&&(i[a]>=0&&(l=yD({inputs:{x:l},backend:c,attrs:{axis:i[a]-(f.length-m),keepDims:!1}}),n.push(l)),m--)}for(let a of n)a!==l&&c.disposeIntermediateTensorInfo(a);return l}},{kernelName:"Elu",backendName:"webgl",kernelFunc:zI},{kernelName:bi,backendName:"webgl",kernelFunc:a=>{let{inputs:b,backend:c}=a,{dy:d,y:e}=b,f=aw.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new yh(zJ,d.shape,e.shape):new yf("return (b >= 0.0) ? a : a * (b + 1.0);",d.shape,e.shape);return c.runWebGLProgram(f,[d,e],d.dtype)}},{kernelName:bj,backendName:"webgl",kernelFunc:zK},{kernelName:"Erf",backendName:"webgl",kernelFunc:zL},{kernelName:"Exp",backendName:"webgl",kernelFunc:zM},{kernelName:bk,backendName:"webgl",kernelFunc:zN},{kernelName:bl,backendName:"webgl",kernelFunc:zP},{kernelName:"FFT",backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c}=a,{input:d}=b;return zR(d,!1,c)}},{kernelName:bm,backendName:"webgl",kernelFunc:zT},{kernelName:bn,backendName:"webgl",kernelFunc:({inputs:a,backend:b})=>{let{image:c}=a,d=new zU(c.shape);return b.runWebGLProgram(d,[c],c.dtype)}},{kernelName:bo,backendName:"webgl",kernelFunc:zW},{kernelName:bp,backendName:"webgl",kernelFunc:zX},{kernelName:cT,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{pixels:e}=b,{numChannels:f}=d,g="undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement,h="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,[j,k]=g?[e.videoWidth,e.videoHeight]:[e.width,e.height],l=[k,j],m=[k,j,f];if(h||g){let a=aw.getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==i||a!==z$)&&(z$=a,i=document.createElement("canvas").getContext("2d",{willReadFrequently:z$})),i.canvas.width=j,i.canvas.height=k,i.drawImage(e,0,0,j,k),e=i.canvas}let n=c.makeTensorInfo(l,"int32");c.texData.get(n.dataId).usage=BT.PIXELS,c.gpgpu.uploadPixelDataToTexture(c.getTexture(n.dataId),e);let o=aw.getBool("WEBGL_PACK")?new zZ(m):new zY(m),p=c.runWebGLProgram(o,[n],"int32");return c.disposeData(n.dataId),p}},{kernelName:cW,backendName:"webgl",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f,filter:g,bias:h,preluActivationWeights:i}=c,{strides:j,pad:k,dataFormat:l,dilations:m,dimRoundingMode:n,activation:o,leakyreluAlpha:p}=e,q=hp.convertConv2DDataFormat(l),r=hp.computeConv2DInfo(f.shape,g.shape,j,m,k,n,!1,q),s=[],t=null!=h,u=null!=i,v="leakyrelu"===o,w=()=>{let a=[f,g],b=(a,b)=>{if("NCHW"===b&&1===a.shape.length&&1!==a.shape[0]){let b=yw({inputs:{x:a},backend:d,attrs:{shape:[a.shape[0],1,1]}});return s.push(b),b}return a};if(t&&a.push(b(h,l)),u&&a.push(b(i,l)),v){let b=d.makeTensorInfo([],"float32",iV.createScalarValue(p,"float32"));a.push(b),s.push(b)}return a};if(1===r.filterHeight&&1===r.filterWidth&&1===r.dilationHeight&&1===r.dilationWidth&&1===r.strideHeight&&1===r.strideWidth&&("SAME"===r.padInfo.type||"VALID"===r.padInfo.type))b=zn({x:f,filter:g,convInfo:r,backend:d,bias:h,activation:o,preluActivationWeights:i,leakyreluAlpha:p});else if(r.strideWidth<=2&&"channelsLast"===q&&aw.getBool("WEBGL_EXP_CONV")){let a=new zk(r,t,o?yr(o,!0):null,u,v),c=[[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inHeight,r.inWidth]],e=w();b=d.runWebGLProgram(a,e,"float32",c)}else if(aw.getBool("WEBGL_CONV_IM2COL"))b=zo({x:f,filter:g,convInfo:r,backend:d,bias:h,activation:o,preluActivationWeights:i,leakyreluAlpha:p});else{let a=new zi(r,t,o?yr(o,!1):null,u,v),c=w();b=d.runWebGLProgram(a,c,"float32")}let x=yw({inputs:{x:b},backend:d,attrs:{shape:r.outShape}});return s.push(b),s.forEach(a=>d.disposeIntermediateTensorInfo(a)),x}},{kernelName:cX,backendName:"webgl",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f,filter:g,bias:h,preluActivationWeights:i}=c,{strides:j,pad:k,dilations:l,dimRoundingMode:m,activation:n,leakyreluAlpha:o}=e,p=[],q=l;null==q&&(q=[1,1]),iV.assert(hp.eitherStridesOrDilationsAreOne(j,q),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${j} and dilations '${q}'`);let r=hp.computeConv2DInfo(f.shape,g.shape,j,q,k,m,!0),s=aw.getBool("WEBGL_PACK_DEPTHWISECONV")&&r.strideWidth<=2&&r.outChannels/r.inChannels==1,t=n?yr(n,s):null,u=[f,g],v=null!=h,w=null!=i,x="leakyrelu"===n;if(v&&u.push(h),w&&u.push(i),x){let a=d.makeTensorInfo([],"float32",iV.createScalarValue(o,"float32"));u.push(a),p.push(a)}b=s?new zD(r,v,t,w,x):new zC(r,v,t,w,x);let y=[[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inHeight,r.inWidth]],z=d.runWebGLProgram(b,u,"float32",y);return p.forEach(a=>d.disposeIntermediateTensorInfo(a)),z}},{kernelName:bs,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c}=a,{params:d,indices:e}=b,f=e.shape,g=f[f.length-1],h=iV.sizeFromShape(d.shape),[i,j,k,l]=hp.prepareAndValidate(d,e),m=yw({inputs:{x:e},backend:c,attrs:{shape:[j,g]}}),n=yw({inputs:{x:d},backend:c,attrs:{shape:[iV.sizeFromShape(d.shape)/k,k]}});if(c.shouldExecuteOnCPU([d,e])||"string"===d.dtype){let a=xe(c.readSync(e.dataId),c.bufferSync(d),d.dtype,j,g,k,l,d.shape,h);return c.makeTensorInfo(i,d.dtype,a.values)}let o=new z_(g,l,[j,k],d.shape),p=c.runWebGLProgram(o,[n,m],n.dtype),q=yw({inputs:{x:p},backend:c,attrs:{shape:i}});return c.disposeIntermediateTensorInfo(m),c.disposeIntermediateTensorInfo(n),c.disposeIntermediateTensorInfo(p),q}},{kernelName:br,backendName:"webgl",kernelFunc:z1},{kernelName:bt,backendName:"webgl",kernelFunc:z2},{kernelName:bu,backendName:"webgl",kernelFunc:z3},{kernelName:bv,backendName:"webgl",kernelFunc:yi},{kernelName:bw,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c}=a,{input:d}=b;return zR(d,!0,c)}},{kernelName:bx,backendName:"webgl",kernelFunc:zg},{kernelName:by,backendName:"webgl",kernelFunc:z4},{kernelName:bz,backendName:"webgl",kernelFunc:z5},{kernelName:bA,backendName:"webgl",kernelFunc:z6},{kernelName:bB,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{alpha:f}=d,g=c.makeTensorInfo([],"float32",iV.createScalarValue(f,"float32")),h=aw.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new yh(yl,e.shape,g.shape):new yf(yk,e.shape,g.shape),i=c.runWebGLProgram(h,[e,g],"float32");return c.disposeIntermediateTensorInfo(g),i}},{kernelName:bC,backendName:"webgl",kernelFunc:z7},{kernelName:bD,backendName:"webgl",kernelFunc:z8},{kernelName:bE,backendName:"webgl",kernelFunc:function(a){let{backend:b,attrs:c}=a,{start:d,stop:e,num:f}=c,g=xk(d,e,f);return b.makeTensorInfo([g.length],"float32",g)}},{kernelName:"Log",backendName:"webgl",kernelFunc:z9},{kernelName:bF,backendName:"webgl",kernelFunc:Aa},{kernelName:bG,backendName:"webgl",kernelFunc:Ab},{kernelName:bH,backendName:"webgl",kernelFunc:Ac},{kernelName:bI,backendName:"webgl",kernelFunc:Ad},{kernelName:"LRN",backendName:"webgl",kernelFunc:a=>{let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{depthRadius:f,bias:g,alpha:h,beta:i}=d,j=aw.getBool("WEBGL_PACK_NORMALIZATION")?new Af(e.shape,f,g,h,i):new Ae(e.shape,f,g,h,i);return c.runWebGLProgram(j,[e],e.dtype)}},{kernelName:bJ,backendName:"webgl",kernelFunc:a=>{let{inputs:b,backend:c,attrs:d}=a,{x:e,y:f,dy:g}=b,{depthRadius:h,bias:i,alpha:j,beta:k}=d,l=new Ag(e.shape,h,i,j,k);return c.runWebGLProgram(l,[e,f,g],e.dtype)}},{kernelName:"Max",backendName:"webgl",kernelFunc:Ah},{kernelName:bK,backendName:"webgl",kernelFunc:Ai},{kernelName:bL,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b;we(e,"maxPool");let{filterSize:f,strides:g,pad:h,dimRoundingMode:i}=d;iV.assert(hp.eitherStridesOrDilationsAreOne(g,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${g} and dilations '1'`);let j=hp.computePool2DInfo(e.shape,f,g,1,h,i);if(1===j.filterWidth&&1===j.filterHeight&&iV.arraysEqual(j.inShape,j.outShape))return yi({inputs:{x:e},backend:c});let k=new yV(j,"max",!1);return c.runWebGLProgram(k,[e],e.dtype)}},{kernelName:bN,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{filterSize:f,strides:g,pad:h,dataFormat:i,dimRoundingMode:j}=d,k=new yW(hp.computePool3DInfo(e.shape,f,g,[1,1,1],h,j,i),"max",!1);return c.runWebGLProgram(k,[e],e.dtype)}},{kernelName:bO,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{dy:e,input:f}=b,{filterSize:g,strides:h,pad:i,dimRoundingMode:j}=d,k=hp.computePool3DInfo(f.shape,g,h,[1,1,1],i,j),l=new yW(k,"max",!0),m=c.runWebGLProgram(l,[f],f.dtype),n=new Ak(k),o=c.runWebGLProgram(n,[e,m],f.dtype);return c.disposeIntermediateTensorInfo(m),o}},{kernelName:bM,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{dy:e,input:f,output:g}=b;we([f,g],"maxPoolGrad");let{filterSize:h,strides:i,pad:j,dimRoundingMode:k}=d,l=hp.computePool2DInfo(f.shape,h,i,1,j,k),m=new yV(l,"max",!0),n=c.runWebGLProgram(m,[f],f.dtype),o=new Aj(l),p=c.runWebGLProgram(o,[e,n],f.dtype);return c.disposeIntermediateTensorInfo(n),p}},{kernelName:bP,backendName:"webgl",kernelFunc:({inputs:a,attrs:b,backend:c})=>{let d,e,{x:f}=a,{filterSize:g,strides:h,pad:i,includeBatchInIndex:j}=b;iV.assert(4===f.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${f.shape.length}.`);let k=[1,1];iV.assert(hp.eitherStridesOrDilationsAreOne(h,k),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${h} and dilations '${k}'`);let l=hp.computePool2DInfo(f.shape,g,h,k,i),[m,n]=(d=new yV(l,"max",!1),e=c.runWebGLProgram(d,[f],"float32"),d=new yV(l,"max",!0,!0,j),[e,c.runWebGLProgram(d,[f],"float32")]);return[m,n]}},{kernelName:bQ,backendName:"webgl",kernelFunc:({inputs:a,attrs:b,backend:c})=>{var d,e;let f,g,h,i,j,{x:k}=a,{keepDims:l,axis:m}=b,n=k.shape.length,o=iV.parseAxisParam(m,k.shape),p=o,q=hp.getAxesPermutation(p,n),r=null!=q,s=c.shouldExecuteOnCPU([k]),t=[],u=k;if(r){if(s){let a=c.texData.get(u.dataId).values,b=Array(n);for(let a=0;a<b.length;a++)b[a]=k.shape[q[a]];let d=xO(a,k.shape,k.dtype,q,b);u=c.makeTensorInfo(b,k.dtype),c.texData.get(u.dataId).values=d}else u=yC(k,q,c);t.push(u),p=hp.getInnerMostAxes(p.length,n)}hp.assertAxesAreInnerMostDims("sum",p,n);let[v,w]=hp.computeOutAndReduceShapes(u.shape,p),x=v;l&&(x=hp.expandShapeToKeepDim(v,o));let y=(d=u,e=x,f=iV.sizeFromShape(w),g=iV.sizeFromShape(d.shape),i=yz(h=yw({inputs:{x:d},attrs:{shape:[g/f,f]},backend:c}),"float32","mean",c),j=yw({inputs:{x:i},attrs:{shape:e},backend:c}),c.disposeIntermediateTensorInfo(h),c.disposeIntermediateTensorInfo(i),j);for(let a of t)c.disposeIntermediateTensorInfo(a);return y}},{kernelName:"Min",backendName:"webgl",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f}=c,{axis:g,keepDims:h}=e,i=f.shape.length,j=iV.parseAxisParam(g,f.shape),k=j,l=hp.getAxesPermutation(k,i),m=f;null!=l&&(m=yE({inputs:{x:f},backend:d,attrs:{perm:l}}),k=hp.getInnerMostAxes(k.length,f.shape.length)),hp.assertAxesAreInnerMostDims("min",k,i);let[n,o]=hp.computeOutAndReduceShapes(m.shape,k),p=yw({inputs:{x:m},backend:d,attrs:{shape:[-1,iV.sizeFromShape(o)]}}),q=yz(p,p.dtype,"min",d);return b=h?yw({inputs:{x:q},backend:d,attrs:{shape:hp.expandShapeToKeepDim(n,j)}}):yw({inputs:{x:q},backend:d,attrs:{shape:n}}),d.disposeIntermediateTensorInfo(p),d.disposeIntermediateTensorInfo(q),null!=l&&d.disposeIntermediateTensorInfo(m),b}},{kernelName:bR,backendName:"webgl",kernelFunc:Al},{kernelName:bS,backendName:"webgl",kernelFunc:({inputs:a,backend:b,attrs:c})=>{let{x:d}=a,{paddings:e,mode:f}=c,g=aw.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new An(d.shape,e,f):new Am(d.shape,e,f);return b.runWebGLProgram(g,[d],d.dtype)}},{kernelName:"Mod",backendName:"webgl",kernelFunc:Ao},{kernelName:bT,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{logits:e}=b,{numSamples:f,seed:g,normalized:h}=d,i=h?e:At({inputs:{logits:e},backend:c,attrs:{dim:e.shape.length-1}}),j=new Ap(i.shape[0],i.shape[1],f),k=c.runWebGLProgram(j,[i],"int32",[[g]]);return h||c.disposeIntermediateTensorInfo(i),k}},{kernelName:bU,backendName:"webgl",kernelFunc:yv},{kernelName:"Neg",backendName:"webgl",kernelFunc:function(a){let b,{inputs:c,backend:d}=a,{x:e}=c;if(d.shouldExecuteOnCPU([e])){let[a,b]=xq(d.texData.get(e.dataId).values,e.shape,e.dtype);return d.makeTensorInfo(b,e.dtype,a)}return b=aw.getBool("WEBGL_PACK_UNARY_OPERATIONS")?new x5(e.shape,Av):new xY(e.shape,Au),d.runWebGLProgram(b,[e],e.dtype)}},{kernelName:bW,backendName:"webgl",kernelFunc:function(a){hp.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:b,backend:c,attrs:d}=a,{boxes:e,scores:f}=b,{maxOutputSize:g,iouThreshold:h,scoreThreshold:i}=d,{selectedIndices:j}=Aw(c.readSync(e.dataId),c.readSync(f.dataId),g,h,i);return c.makeTensorInfo([j.length],"int32",new Int32Array(j))}},{kernelName:bX,backendName:"webgl",kernelFunc:function(a){hp.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:b,backend:c,attrs:d}=a,{boxes:e,scores:f}=b,{maxOutputSize:g,iouThreshold:h,scoreThreshold:i,padToMaxOutputSize:j}=d,{selectedIndices:k,validOutputs:l}=Ax(c.readSync(e.dataId),c.readSync(f.dataId),g,h,i,j);return[c.makeTensorInfo([k.length],"int32",new Int32Array(k)),c.makeTensorInfo([],"int32",new Int32Array([l]))]}},{kernelName:bY,backendName:"webgl",kernelFunc:function(a){hp.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:b,backend:c,attrs:d}=a,{boxes:e,scores:f}=b,{maxOutputSize:g,iouThreshold:h,scoreThreshold:i,softNmsSigma:j}=d,{selectedIndices:k,selectedScores:l}=Ay(c.readSync(e.dataId),c.readSync(f.dataId),g,h,i,j);return[c.makeTensorInfo([k.length],"int32",new Int32Array(k)),c.makeTensorInfo([l.length],"float32",new Float32Array(l))]}},{kernelName:bV,backendName:"webgl",kernelFunc:y5},{kernelName:b$,backendName:"webgl",kernelFunc:a=>{let{inputs:b,backend:c,attrs:d}=a,{indices:e}=b,{dtype:f,depth:g,onValue:h,offValue:i}=d,j=iV.sizeFromShape(e.shape),k=new Az(j,g,h,i),l=yw({inputs:{x:e},backend:c,attrs:{shape:[j]}}),m=c.runWebGLProgram(k,[l],f);c.disposeIntermediateTensorInfo(l);let n=yw({inputs:{x:m},backend:c,attrs:{shape:[...e.shape,g]}});return c.disposeIntermediateTensorInfo(m),n}},{kernelName:bZ,backendName:"webgl",kernelFunc:function a(b){let{inputs:c,backend:d}=b,{x:e}=c;if("string"===e.dtype)throw Error("onesLike is not supported under string dtype");if("complex64"!==e.dtype)return zT({attrs:{shape:e.shape,dtype:e.dtype,value:1},backend:d});{let b=y6({inputs:{input:e},backend:d}),c=a({inputs:{x:b},backend:d}),f=zg({inputs:{input:e},backend:d}),g=AA({inputs:{x:f},backend:d}),h=yj({inputs:{real:c,imag:g},backend:d});return d.disposeIntermediateTensorInfo(b),d.disposeIntermediateTensorInfo(c),d.disposeIntermediateTensorInfo(f),d.disposeIntermediateTensorInfo(g),h}}},{kernelName:b_,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{axis:e}=d;if(1===b.length)return zN({inputs:{input:b[0]},backend:c,attrs:{dim:e}});let f=b[0].shape,g=b[0].dtype;b.forEach(a=>{iV.assertShapesMatch(f,a.shape,"All tensors passed to stack must have matching shapes"),iV.assert(g===a.dtype,()=>"All tensors passed to stack must have matching dtypes")});let h=[],i=zh({inputs:b.map(a=>{let b=zN({inputs:{input:a},backend:c,attrs:{dim:e}});return h.push(b),b}),backend:c,attrs:{axis:e}});return h.forEach(a=>c.disposeIntermediateTensorInfo(a)),i}},{kernelName:b0,backendName:"webgl",kernelFunc:AD},{kernelName:"Pow",backendName:"webgl",kernelFunc:AE},{kernelName:b1,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c}=a,{x:d,alpha:e}=b,f=aw.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new yh(yn,d.shape,e.shape):new yf(ym,d.shape,e.shape);return c.runWebGLProgram(f,[d,e],"float32")}},{kernelName:b2,backendName:"webgl",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f}=c,{axis:g,keepDims:h}=e,i=f.shape.length,j=[],k=iV.parseAxisParam(g,f.shape),l=k,m=hp.getAxesPermutation(l,i),n=f;if(null!=m&&(n=yE({inputs:{x:f},backend:d,attrs:{perm:m}}),l=hp.getInnerMostAxes(l.length,i),j.push(n)),hp.assertAxesAreInnerMostDims("prod",l,i),d.shouldExecuteOnCPU([n])){let a=d.texData.get(n.dataId).values,{outVals:c,outShape:e,outDtype:f}=xs(n.shape,n.dtype,a,l);b=d.makeTensorInfo(e,f,c)}else{let[a,c]=hp.computeOutAndReduceShapes(n.shape,l),e=yw({inputs:{x:n},backend:d,attrs:{shape:[-1,iV.sizeFromShape(c)]}}),g=yz(e,dq(f.dtype),"prod",d);b=yw({inputs:{x:g},backend:d,attrs:{shape:a}}),j.push(e),j.push(g)}if(h){j.push(b);let a=hp.expandShapeToKeepDim(b.shape,k);b=yw({inputs:{x:b},backend:d,attrs:{shape:a}})}return j.forEach(a=>d.disposeIntermediateTensorInfo(a)),b}},{kernelName:b3,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{paramsNestedSplits:e,paramsDenseValues:f,indices:g}=b,{outputRaggedRank:h}=d,i=e.map(a=>c.readSync(a.dataId)),j=e.map(a=>a.shape),k=c.readSync(f.dataId),l=c.readSync(g.dataId),[m,n,o]=xt(i,j,k,f.shape,f.dtype,l,g.shape,h),p=m.map(a=>c.makeTensorInfo([a.length],"int32",a)),q=c.makeTensorInfo(o,f.dtype,n);return p.concat([q])}},{kernelName:b4,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c}=a,{starts:d,limits:e,deltas:f}=b,g=c.readSync(d.dataId),h=c.readSync(e.dataId),i=c.readSync(f.dataId),[j,k]=xu(g,d.shape,d.dtype,h,e.shape,i,f.shape);return[c.makeTensorInfo([j.length],"int32",j),c.makeTensorInfo([k.length],d.dtype,k)]}},{kernelName:b5,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{shape:e,values:f,defaultValue:g,rowPartitionTensors:h}=b,{rowPartitionTypes:i}=d,j=c.readSync(e.dataId),k=c.readSync(f.dataId),l=c.readSync(g.dataId),m=h.map(a=>c.readSync(a.dataId)),n=h.map(a=>a.shape),[o,p]=xv(j,e.shape,k,f.shape,f.dtype,l,g.shape,m,n,i);return c.makeTensorInfo(o,f.dtype,p)}},{kernelName:b6,backendName:"webgl",kernelFunc:AF},{kernelName:b7,backendName:"webgl",kernelFunc:y6},{kernelName:bg,backendName:"webgl",kernelFunc:Aq},{kernelName:b8,backendName:"webgl",kernelFunc:AG},{kernelName:b9,backendName:"webgl",kernelFunc:AH},{kernelName:cf,backendName:"webgl",kernelFunc:AI},{kernelName:ca,backendName:"webgl",kernelFunc:yw},{kernelName:cd,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{images:e}=b,{alignCorners:f,halfPixelCenters:g,size:h}=d,[i,j]=h,k=aw.getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new AK(e.shape,i,j,f,g):new AJ(e.shape,i,j,f,g);return c.runWebGLProgram(k,[e],"float32")}},{kernelName:ce,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{images:e,dy:f}=b,{alignCorners:g}=d,h=new AL(f.shape,e.shape,g);return c.runWebGLProgram(h,[f],f.dtype)}},{kernelName:cb,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{images:e}=b,{alignCorners:f,halfPixelCenters:g,size:h}=d,[i,j]=h,k=aw.getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new AN(e.shape,i,j,f,g):new AM(e.shape,i,j,f,g);return c.runWebGLProgram(k,[e],e.dtype)}},{kernelName:cc,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{images:e,dy:f}=b,{alignCorners:g}=d,h=new AO(f.shape,e.shape,g);return c.runWebGLProgram(h,[f],f.dtype)}},{kernelName:cg,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{dims:f}=d,g=e.shape.length,h=iV.parseAxisParam(f,e.shape);if(0===g)return yi({inputs:{x:e},backend:c});let i=aw.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new AQ(e.shape,h):new AP(e.shape,h);return c.runWebGLProgram(i,[e],e.dtype)}},{kernelName:cU,backendName:"webgl",kernelFunc:({inputs:a,attrs:b,backend:c})=>{let{image:d}=a,{radians:e,fillValue:f,center:g}=b,h=new AR(d.shape,f),[i,j]=hp.getImageCenter(g,d.shape[1],d.shape[2]),k=[[i,j,Math.sin(e),Math.cos(e)]];return c.runWebGLProgram(h,[d],d.dtype,k)}},{kernelName:ch,backendName:"webgl",kernelFunc:AS},{kernelName:ci,backendName:"webgl",kernelFunc:AT},{kernelName:cj,backendName:"webgl",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{indices:f,updates:g}=c,{shape:h}=e,{sliceRank:i,numUpdates:j,sliceSize:k,strides:l,outputSize:m}=hp.calculateShapes(g,f,h),n=[m/k,k];if(0===m)return d.makeTensorInfo(h,f.dtype);let o=yw({inputs:{x:f},backend:d,attrs:{shape:[j,i]}}),p=yw({inputs:{x:g},backend:d,attrs:{shape:[j,k]}}),q=d.makeTensorInfo([],"float32",new Float32Array([0]));b=aw.getBool("WEBGL_PACK")?new AV(j,i,o.shape.length,p.shape.length,l,n):new AU(j,i,o.shape.length,p.shape.length,l,n);let r=d.runWebGLProgram(b,[p,o,q],p.dtype),s=yw({inputs:{x:r},backend:d,attrs:{shape:h}});return d.disposeIntermediateTensorInfo(o),d.disposeIntermediateTensorInfo(p),d.disposeIntermediateTensorInfo(r),d.disposeIntermediateTensorInfo(q),s}},{kernelName:cl,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{sortedSequence:e,values:f}=b,{side:g}=d,h=new AW(e.shape[0],e.shape[1],f.shape[1],g),i=[[e.shape[1]]];return c.runWebGLProgram(h,[e,f],"int32",i)}},{kernelName:cm,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c}=a,{condition:d,t:e,e:f}=b,g=new AX(d.shape.length,e.shape,e.shape.length);return c.runWebGLProgram(g,[d,e,f],dp(e.dtype,f.dtype))}},{kernelName:cn,backendName:"webgl",kernelFunc:AY},{kernelName:cr,backendName:"webgl",kernelFunc:AZ},{kernelName:cq,backendName:"webgl",kernelFunc:A$},{kernelName:"Sin",backendName:"webgl",kernelFunc:A_},{kernelName:cp,backendName:"webgl",kernelFunc:A0},{kernelName:co,backendName:"webgl",kernelFunc:y2},{kernelName:cw,backendName:"webgl",kernelFunc:At},{kernelName:cs,backendName:"webgl",kernelFunc:A1},{kernelName:cu,backendName:"webgl",kernelFunc:a=>{let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{blockShape:f,paddings:g}=d;iV.assert(e.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let h=f.reduce((a,b)=>a*b),i=[[0,0]];i.push(...g);for(let a=1+f.length;a<e.shape.length;++a)i.push([0,0]);let j=[],k=AD({inputs:{x:e},backend:c,attrs:{paddings:i,constantValue:0}}),l=hp.getReshaped(k.shape,f,h,!1),m=hp.getPermuted(l.length,f.length,!1),n=hp.getReshapedPermuted(k.shape,f,h,!1),o=yw({inputs:{x:k},backend:c,attrs:{shape:l}}),p=yE({inputs:{x:o},backend:c,attrs:{perm:m}}),q=yw({inputs:{x:p},backend:c,attrs:{shape:n}});return j.push(k),j.push(o),j.push(p),j.forEach(a=>c.disposeIntermediateTensorInfo(a)),q}},{kernelName:cx,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c}=a,{indices:d,values:e,denseShape:f,defaultValue:g}=b;if(1!==f.shape.length)throw Error(`Dense shape must be a vector, saw:
         ${f.shape}`);if(2!==d.shape.length)throw Error(`Indices must be a matrix, saw:
         ${d.shape}`);if(1!==e.shape.length)throw Error(`Values must be a vector, saw:
         ${e.shape}`);if(0!==g.shape.length)throw Error(`Default value must be a scalar, saw:
        ${g.shape}`);let h=c.readSync(d.dataId),i=c.readSync(e.dataId),j=c.readSync(f.dataId),k=c.readSync(g.dataId)[0],[l,m,n,o,p]=xC(h,d.shape,d.dtype,i,e.dtype,j,k);return[c.makeTensorInfo(m,d.dtype,l),c.makeTensorInfo([m[0]],e.dtype,n),c.makeTensorInfo([o.length],"bool",new Uint8Array(o.map(a=>Number(a)))),c.makeTensorInfo([p.length],d.dtype,new Int32Array(p))]}},{kernelName:cy,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c}=a,{inputIndices:d,inputShape:e,newShape:f}=b;if(2!==d.shape.length)throw Error(`Input indices should be a matrix but received shape ${d.shape}`);if(1!==e.shape.length)throw Error(`Input shape should be a vector but received shape ${e.shape}`);if(1!==f.shape.length)throw Error(`Target shape should be a vector but received shape ${f.shape}`);let g=Array.from(c.readSync(e.dataId)),h=c.readSync(d.dataId),i=Array.from(c.readSync(f.dataId)),[j,k,l]=xD(h,d.shape,d.dtype,g,i);return[c.makeTensorInfo(k,d.dtype,j),c.makeTensorInfo([l.length],f.dtype,new Int32Array(l))]}},{kernelName:cz,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c}=a,{data:d,indices:e,segmentIds:f}=b;if(d.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==e.shape.length)throw Error(`Indices should be a vector but received shape
              ${e.shape}`);if(1!==f.shape.length)throw Error(`Segment ids should be a vector but received shape
              ${f.shape}`);let g=c.readSync(d.dataId),h=c.readSync(e.dataId),i=c.readSync(f.dataId),[j,k]=xE(g,d.shape,d.dtype,h,i,!0);return c.makeTensorInfo(k,d.dtype,j)}},{kernelName:cA,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c}=a,{data:d,indices:e,segmentIds:f}=b;if(d.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==e.shape.length)throw Error(`Indices should be a vector but received shape
             ${e.shape}`);if(1!==f.shape.length)throw Error(`Segment ids should be a vector but received shape
             ${f.shape}`);let g=c.readSync(d.dataId),h=c.readSync(e.dataId),i=c.readSync(f.dataId),[j,k]=xE(g,d.shape,d.dtype,h,i);return c.makeTensorInfo(k,d.dtype,j)}},{kernelName:cB,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{sparseIndices:e,sparseValues:f,defaultValue:g}=b,{outputShape:h}=d,{sliceRank:i,numUpdates:j,sliceSize:k,strides:l,outputSize:m}=hp.calculateShapes(f,e,h);if("string"===f.dtype){let a=xy(c.bufferSync(e),c.bufferSync(f),h,m,k,j,i,l,iV.decodeString(c.readSync(g.dataId)[0]),!1);return c.makeTensorInfo(h,a.dtype,a.values)}let n=new AU(j,i,e.shape.length,f.shape.length,l,[m,1],!1),o=c.runWebGLProgram(n,[f,e,g],f.dtype),p=yw({inputs:{x:o},backend:c,attrs:{shape:h}});return c.disposeIntermediateTensorInfo(o),p}},{kernelName:cv,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{numOrSizeSplits:f,axis:g}=d,h=iV.parseAxisParam(g,e.shape)[0],i=hp.prepareSplitSize(e,f,h),j=Array(e.shape.length).fill(0),k=e.shape.slice();return i.map(a=>{let b=[...k];b[h]=a;let d=y2({inputs:{x:e},backend:c,attrs:{begin:j,size:b}});return j[h]+=a,d})}},{kernelName:ct,backendName:"webgl",kernelFunc:A3},{kernelName:cD,backendName:"webgl",kernelFunc:A4},{kernelName:cC,backendName:"webgl",kernelFunc:A6},{kernelName:cE,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b;if("string"!==e.dtype)throw Error("Input must be of datatype string");let f=c.readSync(e.dataId),g=xG(hp.fromUint8ToStringArray(f),"string",d);return c.makeTensorInfo(e.shape,"string",g)}},{kernelName:cS,backendName:"webgl",kernelFunc:function({inputs:a,attrs:b,backend:c}){let{x:d}=a,e=xZ+`
    return x > 0.0 ? 1.0 : float(${b.alpha});
  `,f=new xY(d.shape,e);return c.runWebGLProgram(f,[d],d.dtype)}},{kernelName:cF,backendName:"webgl",kernelFunc:function(a){let b,{inputs:c,backend:d,attrs:e}=a,{x:f}=c,{begin:g,end:h,strides:i,beginMask:j,endMask:k,ellipsisMask:l,newAxisMask:m,shrinkAxisMask:n}=e,{finalShapeSparse:o,finalShape:p,isIdentity:q,sliceDim0:r,isSimpleSlice:s,begin:t,end:u,strides:v}=tU.sliceInfo(f.shape,g,h,i,j,k,l,m,n);if(q)b=yw({inputs:{x:f},backend:d,attrs:{shape:p}});else if(r||s){iV.assert(f.shape.length>=1,()=>`Input must have rank at least 1, got: ${f.shape.length}`);let a=tU.computeOutShape(t,u,v),c=y2({inputs:{x:f},backend:d,attrs:{begin:t,size:a}});b=yw({inputs:{x:c},backend:d,attrs:{shape:p}}),d.disposeIntermediateTensorInfo(c)}else if(d.shouldExecuteOnCPU([f])){let a=d.readSync(f.dataId),c=xH(o,eu(f.shape,f.dtype,a),v,t);b=d.makeTensorInfo(p,f.dtype,c.values)}else{let a=new A7(t,v,o);b=d.runWebGLProgram(a,[f],f.dtype)}let w=yw({inputs:{x:b},backend:d,attrs:{shape:p}});return d.disposeIntermediateTensorInfo(b),w}},{kernelName:cG,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{separator:e,nGramWidths:f,leftPad:g,rightPad:h,padWidth:i,preserveShortSequences:j}=d,{data:k,dataSplits:l}=b,[m,n]=xI(c.readSync(k.dataId),c.readSync(l.dataId),e,f,g,h,i,j);return[c.makeTensorInfo([m.length],"string",m),c.makeTensorInfo(l.shape,"int32",n)]}},{kernelName:cH,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{skipEmpty:e}=d,{input:f,delimiter:g}=b;if("string"!==f.dtype)throw Error("Input must be of datatype string");if(1!==f.shape.length)throw Error(`Input must be a vector, got shape: ${f.shape}`);if(0!==g.shape.length)throw Error(`Delimiter must be a scalar, got shape: ${g.shape}`);let[h,i,j]=xJ(c.readSync(f.dataId),c.readSync(g.dataId)[0],e),k=i.length;return[c.makeTensorInfo([k,2],"int32",h),c.makeTensorInfo([k],"string",i),c.makeTensorInfo([2],"int32",new Int32Array(j))]}},{kernelName:cI,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{numBuckets:e}=d,{input:f}=b;if("string"!==f.dtype)throw Error("Input must be of datatype string");if(e<=0)throw Error("Number of buckets must be at least 1");let g=xK(c.readSync(f.dataId),e);return c.makeTensorInfo(f.shape,"int32",g)}},{kernelName:"Sub",backendName:"webgl",kernelFunc:As},{kernelName:"Sum",backendName:"webgl",kernelFunc:yD},{kernelName:"Tan",backendName:"webgl",kernelFunc:A8},{kernelName:cJ,backendName:"webgl",kernelFunc:A9},{kernelName:ck,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{tensor:e,indices:f,updates:g}=b,{}=d,{sliceRank:h,numUpdates:i,sliceSize:j,strides:k,outputSize:l}=hp.calculateShapes(g,f,e.shape),m=[l/j,j];if(0===l)return c.makeTensorInfo(e.shape,f.dtype);let n=yw({inputs:{x:f},backend:c,attrs:{shape:[i,h]}}),o=yw({inputs:{x:g},backend:c,attrs:{shape:[i,j]}}),p=yw({inputs:{x:e},backend:c,attrs:{shape:m}}),q=new AU(i,h,n.shape.length,o.shape.length,k,m,!1,!0),r=c.runWebGLProgram(q,[o,n,p],p.dtype),s=yw({inputs:{x:r},backend:c,attrs:{shape:e.shape}});return c.disposeIntermediateTensorInfo(n),c.disposeIntermediateTensorInfo(o),c.disposeIntermediateTensorInfo(p),c.disposeIntermediateTensorInfo(r),s}},{kernelName:cK,backendName:"webgl",kernelFunc:Bb},{kernelName:cL,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e}=b,{k:f,sorted:g}=d,h=aw.getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),i=aw.getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),j=e.shape,k=j[j.length-1];if(c.shouldExecuteOnCPU([e])||k<h||f>i){let[a,b]=xN(c.readSync(e.dataId),j,e.dtype,f,g);return[c.makeTensorInfo(a.shape,a.dtype,a.values),c.makeTensorInfo(b.shape,b.dtype,b.values)]}if(0===f)return j[j.length-1]=0,[c.makeTensorInfo(j,e.dtype,[]),c.makeTensorInfo(j,"int32",[])];if(1===k)return[e,zT({attrs:{shape:j,dtype:"int32",value:0},backend:c})];let l=c.texData.get(e.dataId),m=null!==l&&l.isPacked,n=m?c.unpackTensor(e):e,o=iV.sizeFromShape(j)/k,p=yw({inputs:{x:n},attrs:{shape:[o,k]},backend:c});m&&Be(c,n);let q=Bf(f),r=Bf(k),s=null,t=()=>null===s?[p,p]:[p,s],u=(a,b,d)=>{let e=t(),f=new Bc(d),g=[[k],[+(null===s)],[-1/0],[a],[b]],h=s;s=c.runWebGLProgram(f,e,"int32",g),Be(c,h)};for(let a=1;a<q;a*=2){let b=2*a;for(let c=a;c>=1;c/=2)u(b,c,[o,r])}for(let a=r;a>q;a/=2){let b=t(),d=new Bd([o,a/2]),e=[[k],[+(null===s)],[q]],f=s;s=c.runWebGLProgram(d,b,"int32",e),Be(c,f);let g=q/2,h=2*g;for(let a=g;a>=1;a/=2)u(h,a,s.shape)}let v=s;s=y2({inputs:{x:s},backend:c,attrs:{begin:0,size:[o,f]}}),Be(c,v);let w=z1({inputs:{x:p,indices:s},backend:c,attrs:{axis:1,batchDims:1}});Be(c,p);let x=j.slice(0,-1);x.push(f),v=s,s=yw({inputs:{x:s},attrs:{shape:x},backend:c}),Be(c,v);let y=w;return w=yw({inputs:{x:w},attrs:{shape:x},backend:c}),Be(c,y),[w,s]}},{kernelName:cM,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{image:e,transforms:f}=b,{interpolation:g,fillMode:h,fillValue:i,outputShape:j}=d,[k,l,m,n]=e.shape,[o,p]=null!=j?j:[l,m],q=new Bg(l,m,g,h,i,[k,o,p,n]);return c.runWebGLProgram(q,[e,f],"float32")}},{kernelName:cN,backendName:"webgl",kernelFunc:yE},{kernelName:cO,backendName:"webgl",kernelFunc:function(a){let{inputs:b,attrs:c,backend:d}=a,{axis:e}=c,{x:f}=b;we(f,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let{outputValues:g,outputShape:h,indices:i}=xP(d.readSync(f.dataId),e,f.shape,f.dtype);return[d.makeTensorInfo(h,f.dtype,g),d.makeTensorInfo([i.length],"int32",i)]}},{kernelName:cP,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{value:e}=b,{axis:f}=d;f<0&&(f+=e.shape.length);let g=e.shape.length,h=e.shape[f],i=Array(g-1),j=0;for(let a=0;a<g;a++)a!==f&&(i[j++]=e.shape[a]);let k=[],l=Array(g).fill(0),m=e.shape.slice();m[f]=1;let n=Array(h);for(let a=0;a<n.length;a++){l[f]=a;let b=y2({inputs:{x:e},backend:c,attrs:{begin:l,size:m}}),d=yw({inputs:{x:b},backend:c,attrs:{shape:i}});n[a]=d,k.push(b)}return k.forEach(a=>c.disposeIntermediateTensorInfo(a)),n}},{kernelName:cQ,backendName:"webgl",kernelFunc:function(a){let{inputs:b,backend:c,attrs:d}=a,{x:e,segmentIds:f}=b,{numSegments:g}=d,h=e.shape.length,i=[],j=0,k=hp.getAxesPermutation([j],h),l=e;null!=k&&(l=yE({inputs:{x:e},backend:c,attrs:{perm:k}}),i.push(l),j=hp.getInnerMostAxes(1,h)[0]);let m=hp.segment_util.computeOutShape(l.shape,j,g),n=iV.sizeFromShape([l.shape[j]]),o=yw({inputs:{x:l},backend:c,attrs:{shape:[-1,n]}});i.push(o);let p=dq(e.dtype),q=(a,b,d,e,f)=>{let g=a.shape[0],h=a.shape[1],j=hp.segment_util.segOpComputeOptimalWindowSize(h,f),k=new Bh({windowSize:j,inSize:h,batchSize:g,numSegments:f},b),l=c.compileAndRun(k,[a,d],e);if(i.push(l),l.shape[1]===f)return l;let m=AF({backend:c,attrs:{start:0,stop:f,step:1,dtype:"float32"}}),n=Bb({inputs:{x:m},backend:c,attrs:{reps:[h/j]}});return i.push(m),i.push(n),q(l,b,n,e,f)},r=yw({inputs:{x:q(o,"unsortedSegmentSum",f,p,g)},backend:c,attrs:{shape:m}}),s=r;return null!=k&&(i.push(r),s=yE({inputs:{x:s},backend:c,attrs:{perm:hp.getUndoAxesPermutation(k)}})),i.forEach(a=>c.disposeIntermediateTensorInfo(a)),s}},{kernelName:cR,backendName:"webgl",kernelFunc:AA}])c2(a);a.i(28496),a.i(662536),a.i(649679),a.s(["GPGPUContext",()=>w2,"MathBackendWebGL",()=>ya,"forceHalfFloat",()=>yd,"gpgpu_util",0,yb,"setWebGLContext",()=>vr,"webgl_util",0,yc],20577),a.i(20577);var so=so,Bi="undefined"!=typeof self?self:{};function Bj(){throw Error("Invalid UTF8")}function Bk(a,b){return b=String.fromCharCode.apply(null,b),null==a?b:a+b}let Bl="undefined"!=typeof TextDecoder,Bm="undefined"!=typeof TextEncoder;function Bn(a){if(Bm)a=(l||=new TextEncoder).encode(a);else{let c=0,d=new Uint8Array(3*a.length);for(let e=0;e<a.length;e++){var b=a.charCodeAt(e);if(b<128)d[c++]=b;else{if(b<2048)d[c++]=b>>6|192;else{if(b>=55296&&b<=57343){if(b<=56319&&e<a.length){let f=a.charCodeAt(++e);if(f>=56320&&f<=57343){b=1024*(b-55296)+f-56320+65536,d[c++]=b>>18|240,d[c++]=b>>12&63|128,d[c++]=b>>6&63|128,d[c++]=63&b|128;continue}e--}b=65533}d[c++]=b>>12|224,d[c++]=b>>6&63|128}d[c++]=63&b|128}}a=c===d.length?d:d.subarray(0,c)}return a}a:{for(var Bo=["CLOSURE_FLAGS"],Bp=Bi,Bq=0;Bq<Bo.length;Bq++)if(null==(Bp=Bp[Bo[Bq]])){BX=null;break a}BX=Bp}var Br,Bs,Bt,Bu,Bv,Bw,Bx,By,Bz,BA,BB,BC,BD,BE,BF,BG,BH,BI,BJ,BK,BL,BM,BN,BO,BP,BQ,BR,BS,BT,BU,BV,BW,BX,BY,BZ=BX&&BX[0x2461fc15];BW=null!=BZ&&BZ;let B$=Bi.navigator;function B_(a){return!!BW&&!!BY&&BY.brands.some(({brand:b})=>b&&-1!=b.indexOf(a))}function B0(a){var b;return(b=Bi.navigator)&&(b=b.userAgent)||(b=""),-1!=b.indexOf(a)}function B1(){return!!BW&&!!BY&&BY.brands.length>0}function B2(){return B1()?B_("Chromium"):(B0("Chrome")||B0("CriOS"))&&!(!B1()&&B0("Edge"))||B0("Silk")}function B3(a){return B3[" "](a),a}BY=B$&&B$.userAgentData||null,B3[" "]=function(){};var B4=!B1()&&(B0("Trident")||B0("MSIE"));B0("Android")&&B2(),B2(),B0("Safari")&&(B2()||!B1()&&B0("Coast")||!B1()&&B0("Opera")||!B1()&&B0("Edge")||(B1()?B_("Microsoft Edge"):B0("Edg/"))||B1()&&B_("Opera"));var B5={},B6=null;function B7(){if(!B6){B6={};var a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),b=["+/=","+/","-_=","-_.","-_"];for(let c=0;c<5;c++){let d=a.concat(b[c].split(""));B5[c]=d;for(let a=0;a<d.length;a++){let b=d[a];void 0===B6[b]&&(B6[b]=a)}}}}var B8="undefined"!=typeof Uint8Array,B9=!B4&&"function"==typeof btoa;function Ca(a){if(!B9){void 0===b&&(b=0),B7(),b=B5[b];var b,c=Array(Math.floor(a.length/3)),d=b[64]||"";let i=0,j=0;for(;i<a.length-2;i+=3){var e=a[i],f=a[i+1],g=a[i+2],h=b[e>>2];e=b[(3&e)<<4|f>>4],f=b[(15&f)<<2|g>>6],g=b[63&g],c[j++]=h+e+f+g}switch(h=0,g=d,a.length-i){case 2:g=b[(15&(h=a[i+1]))<<2]||d;case 1:a=a[i],c[j]=b[a>>2]+b[(3&a)<<4|h>>4]+g+d}return c.join("")}for(b="",c=0,d=a.length-10240;c<d;)b+=String.fromCharCode.apply(null,a.subarray(c,c+=10240));return btoa(b+=String.fromCharCode.apply(null,c?a.subarray(c):a))}let Cb=/[-_.]/g,Cc={"-":"+",_:"/",".":"="};function Cd(a){return Cc[a]||""}function Ce(a){if(!B9){var b;let c,d,e,f;return(d=3*(c=(b=a).length)/4)%3?d=Math.floor(d):-1!="=.".indexOf(b[c-1])&&(d=-1!="=.".indexOf(b[c-2])?d-2:d-1),e=new Uint8Array(d),f=0,function(a,b){function c(b){for(;d<a.length;){let b=a.charAt(d++),c=B6[b];if(null!=c)return c;if(!/^[\s\xa0]*$/.test(b))throw Error("Unknown base64 encoding at char: "+b)}return b}B7();let d=0;for(;;){let a=c(-1),d=c(0),e=c(64),f=c(64);if(64===f&&-1===a)break;b(a<<2|d>>4),64!=e&&(b(d<<4&240|e>>2),64!=f&&b(e<<6&192|f))}}(b,function(a){e[f++]=a}),f!==d?e.subarray(0,f):e}Cb.test(a)&&(a=a.replace(Cb,Cd));let c=new Uint8Array((a=atob(a)).length);for(let b=0;b<a.length;b++)c[b]=a.charCodeAt(b);return c}function Cf(a){return B8&&null!=a&&a instanceof Uint8Array}var Cg={};function Ch(){return m||=new Cj(null,Cg)}function Ci(a){Ck(Cg);var b=a.g;return null==(b=null==b||Cf(b)?b:"string"==typeof b?Ce(b):null)?b:a.g=b}var Cj=class{h(){return new Uint8Array(Ci(this)||0)}constructor(a,b){if(Ck(b),this.g=a,null!=a&&0===a.length)throw Error("ByteString should be constructed with non-empty values")}};function Ck(a){if(a!==Cg)throw Error("illegal external caller")}function Cl(a,b){a.__closure__error__context__984382||(a.__closure__error__context__984382={}),a.__closure__error__context__984382.severity=b}function Cm(a){return Cl(a=Error(a),"warning"),a}function Cn(a){if(null!=a){var b,c=n??={},d=c[a]||0;d>=5||(c[a]=d+1,Cl(a=Error(),"incident"),b=a,Bi.setTimeout(()=>{throw b},0))}}var Co="function"==typeof Symbol&&"symbol"==typeof Symbol();function Cp(a,b,c=!1){return"function"==typeof Symbol&&"symbol"==typeof Symbol()?c&&Symbol.for&&a?Symbol.for(a):null!=a?Symbol(a):Symbol():b}var Cq=Cp("jas",void 0,!0),Cr=Cp(void 0,"0di"),Cs=Cp(void 0,"1oa"),Ct=Cp(void 0,Symbol()),Cu=Cp(void 0,"0actk"),Cv=Cp(void 0,"8utk");let Cw=Co?Cq:"Ea",Cx={Ea:{value:0,configurable:!0,writable:!0,enumerable:!1}},Cy=Object.defineProperties;function Cz(a,b){Co||Cw in a||Cy(a,Cx),a[Cw]|=b}function CA(a,b){Co||Cw in a||Cy(a,Cx),a[Cw]=b}function CB(a){return Cz(a,34),a}function CC(a,b){CA(b,-15615&a)}function CD(a,b){CA(b,-15581&(34|a))}function CE(){return"function"==typeof BigInt}function CF(a){return Array.prototype.slice.call(a)}var CG,CH={};function CI(a){return null!==a&&"object"==typeof a&&!Array.isArray(a)&&a.constructor===Object}function CJ(a,b){if(null!=a){if("string"==typeof a)a=a?new Cj(a,Cg):Ch();else if(a.constructor!==Cj)if(Cf(a))a=a.length?new Cj(new Uint8Array(a),Cg):Ch();else{if(!b)throw Error();a=void 0}}return a}let CK=[];function CL(a){if(2&a)throw Error()}CA(CK,55),CG=Object.freeze(CK);class CM{constructor(a,b,c){this.g=a,this.h=b,this.l=c}next(){let a=this.g.next();return a.done||(a.value=this.h.call(this.l,a.value)),a}[Symbol.iterator](){return this}}function CN(a){return Ct?a[Ct]:void 0}var CO=Object.freeze({});function CP(a){return a.Na=!0,a}var CQ=CP(a=>"number"==typeof a),CR=CP(a=>"string"==typeof a),CS=CP(a=>"boolean"==typeof a),CT="function"==typeof Bi.BigInt&&"bigint"==typeof Bi.BigInt(0);function CU(a){var b=a;if(CR(b)){if(!/^\s*(?:-?[1-9]\d*|0)?\s*$/.test(b))throw Error(String(b))}else if(CQ(b)&&!Number.isSafeInteger(b))throw Error(String(b));return CT?BigInt(a):a=CS(a)?a?"1":"0":CR(a)?a.trim()||"0":String(a)}var CV=CP(a=>CT?a>=CX&&a<=CZ:"-"===a[0]?C$(a,CW):C$(a,CY));let CW=Number.MIN_SAFE_INTEGER.toString(),CX=CT?BigInt(Number.MIN_SAFE_INTEGER):void 0,CY=Number.MAX_SAFE_INTEGER.toString(),CZ=CT?BigInt(Number.MAX_SAFE_INTEGER):void 0;function C$(a,b){if(a.length>b.length)return!1;if(a.length<b.length||a===b)return!0;for(let c=0;c<a.length;c++){let d=a[c],e=b[c];if(d>e)return!1;if(d<e)return!0}}let C_="function"==typeof Uint8Array.prototype.slice,C0,C1=0,C2=0;function C3(a){let b=a>>>0;C1=b,C2=(a-b)/0x100000000>>>0}function C4(a){if(a<0){C3(-a);let[b,c]=Dc(C1,C2);C1=b>>>0,C2=c>>>0}else C3(a)}function C5(a){let b=C0||=new DataView(new ArrayBuffer(8));b.setFloat32(0,+a,!0),C2=0,C1=b.getUint32(0,!0)}function C6(a,b){let c=0x100000000*b+(a>>>0);return Number.isSafeInteger(c)?c:C8(a,b)}function C7(a,b){let c=0x80000000&b;return c&&(b=~b>>>0,0==(a=1+~a>>>0)&&(b=b+1>>>0)),"number"==typeof(a=C6(a,b))?c?-a:a:c?"-"+a:a}function C8(a,b){if(a>>>=0,(b>>>=0)<=2097151)var c=""+(0x100000000*b+a);else CE()?c=""+(BigInt(b)<<BigInt(32)|BigInt(a)):(a=(0xffffff&a)+6777216*(c=0xffffff&(a>>>24|b<<8))+6710656*(b=b>>16&65535),c+=8147497*b,b*=2,a>=1e7&&(c+=a/1e7>>>0,a%=1e7),c>=1e7&&(b+=c/1e7>>>0,c%=1e7),c=b+C9(c)+C9(a));return c}function C9(a){return a=String(a),"0000000".slice(a.length)+a}function Da(){var a=C1,b=C2;if(0x80000000&b)if(CE())a=""+(BigInt(0|b)<<BigInt(32)|BigInt(a>>>0));else{let[c,d]=Dc(a,b);a="-"+C8(c,d)}else a=C8(a,b);return a}function Db(a){if(a.length<16)C4(Number(a));else if(CE())C1=Number((a=BigInt(a))&BigInt(0xffffffff))>>>0,C2=Number(a>>BigInt(32)&BigInt(0xffffffff));else{let b=+("-"===a[0]);C2=C1=0;let c=a.length;for(let d=b,e=(c-b)%6+b;e<=c;d=e,e+=6){let b=Number(a.slice(d,e));C2*=1e6,(C1=1e6*C1+b)>=0x100000000&&(C2+=Math.trunc(C1/0x100000000),C2>>>=0,C1>>>=0)}if(b){let[a,b]=Dc(C1,C2);C1=a,C2=b}}}function Dc(a,b){return b=~b,a?a=1+~a:b+=1,[a,b]}let Dd="function"==typeof BigInt?BigInt.asIntN:void 0,De="function"==typeof BigInt?BigInt.asUintN:void 0,Df=Number.isSafeInteger,Dg=Number.isFinite,Dh=Math.trunc,Di=CU(0);function Dj(a){return null==a||"number"==typeof a?a:"NaN"===a||"Infinity"===a||"-Infinity"===a?Number(a):void 0}function Dk(a){return null==a||"boolean"==typeof a?a:"number"==typeof a?!!a:void 0}let Dl=/^-?([1-9][0-9]*|0)(\.[0-9]+)?$/;function Dm(a){switch(typeof a){case"bigint":return!0;case"number":return Dg(a);case"string":return Dl.test(a);default:return!1}}function Dn(a){if(null==a)return a;if("string"==typeof a&&a)a*=1;else if("number"!=typeof a)return;return Dg(a)?0|a:void 0}function Do(a){if(null==a)return a;if("string"==typeof a&&a)a*=1;else if("number"!=typeof a)return;return Dg(a)?a>>>0:void 0}function Dp(a){if("-"===a[0])return!1;let b=a.length;return b<20||20===b&&184467>Number(a.substring(0,6))}function Dq(a){let b=a.length;return"-"===a[0]?b<20||20===b&&Number(a.substring(0,7))>-922337:b<19||19===b&&922337>Number(a.substring(0,6))}function Dr(a){return Dq(a)?a:(Db(a),Da())}function Ds(a){return Df(a=Dh(a))||(C4(a),a=C7(C1,C2)),a}function Dt(a){var b=Dh(Number(a));return Df(b)?String(b):(-1!==(b=a.indexOf("."))&&(a=a.substring(0,b)),Dr(a))}function Du(a){var b=Dh(Number(a));return Df(b)?CU(b):(-1!==(b=a.indexOf("."))&&(a=a.substring(0,b)),CE()?CU(Dd(64,BigInt(a))):CU(Dr(a)))}function Dv(a){if(Df(a))a=CU(Ds(a));else{if(Df(a=Dh(a)))a=String(a);else{let b=String(a);Dq(b)?a=b:(C4(a),a=Da())}a=CU(a)}return a}function Dw(a){return null==a?a:"bigint"==typeof a?a=CV(a)||CV(a=Dd(64,a))?Number(a):String(a):Dm(a)?"number"==typeof a?Ds(a):Dt(a):void 0}function Dx(a){if("string"!=typeof a)throw Error();return a}function Dy(a){if(null!=a&&"string"!=typeof a)throw Error();return a}function Dz(a){return null==a||"string"==typeof a?a:void 0}function DA(a,b,c,d){if(null!=a&&"object"==typeof a&&a.W===CH)return a;if(!Array.isArray(a))return c?2&d?((a=b[Cr])||(CB((a=new b).u),a=b[Cr]=a),b=a):b=new b:b=void 0,b;let e=c=0|a[Cw];return 0===e&&(e|=32&d),(e|=2&d)!==c&&CA(a,e),new b(a)}function DB(a,b,c){if(b)a:{if(!Dm(b=a))throw Cm("int64");switch(typeof b){case"string":b=Du(b);break a;case"bigint":b=CU(Dd(64,b));break a;default:b=Dv(b)}}else a=typeof(b=a),b=null==b?b:"bigint"===a?CU(Dd(64,b)):Dm(b)?"string"===a?Du(b):Dv(b):void 0;return null==(a=b)?c?Di:void 0:a}let DC={},DD=function(){try{return B3(new class extends Map{constructor(){super()}}),!1}catch{return!0}}();class DE{constructor(){this.g=new Map}get(a){return this.g.get(a)}set(a,b){return this.g.set(a,b),this.size=this.g.size,this}delete(a){return a=this.g.delete(a),this.size=this.g.size,a}clear(){this.g.clear(),this.size=this.g.size}has(a){return this.g.has(a)}entries(){return this.g.entries()}keys(){return this.g.keys()}values(){return this.g.values()}forEach(a,b){return this.g.forEach(a,b)}[Symbol.iterator](){return this.entries()}}let DF=DD?(Object.setPrototypeOf(DE.prototype,Map.prototype),Object.defineProperties(DE.prototype,{size:{value:0,configurable:!0,enumerable:!0,writable:!0}}),DE):class extends Map{constructor(){super()}};function DG(a){return a}function DH(a){if(2&a.M)throw Error("Cannot mutate an immutable Map")}var DI=class extends DF{constructor(a,b,c=DG,d=DG){super();let e=0|a[Cw];CA(a,e|=64),this.M=e,this.I=b,this.S=c,this.X=this.I?DJ:d;for(let f=0;f<a.length;f++){const g=a[f],h=c(g[0],!1,!0);let i=g[1];b?void 0===i&&(i=null):i=d(g[1],!1,!0,void 0,void 0,e),super.set(h,i)}}La(){var a=DP;if(0!==this.size)return Array.from(super.entries(),b=>(b[0]=a(b[0]),b[1]=a(b[1]),b))}da(a=DK){let b=[],c=super.entries();for(var d;!(d=c.next()).done;)(d=d.value)[0]=a(d[0]),d[1]=a(d[1]),b.push(d);return b}clear(){DH(this),super.clear()}delete(a){return DH(this),super.delete(this.S(a,!0,!1))}entries(){if(this.I){var a=super.keys();a=new CM(a,DL,this)}else a=super.entries();return a}values(){if(this.I){var a=super.keys();a=new CM(a,DI.prototype.get,this)}else a=super.values();return a}forEach(a,b){this.I?super.forEach((c,d,e)=>{a.call(b,e.get(d),d,e)}):super.forEach(a,b)}set(a,b){return DH(this),null==(a=this.S(a,!0,!1))?this:null==b?(super.delete(a),this):super.set(a,this.X(b,!0,!0,this.I,!1,this.M))}Ja(a){let b=this.S(a[0],!1,!0);a=a[1],a=this.I?void 0===a?null:a:this.X(a,!1,!0,void 0,!1,this.M),super.set(b,a)}has(a){return super.has(this.S(a,!1,!1))}get(a){a=this.S(a,!1,!1);let b=super.get(a);if(void 0!==b){var c=this.I;return c?((c=this.X(b,!1,!0,c,this.pa,this.M))!==b&&super.set(a,c),c):b}}[Symbol.iterator](){return this.entries()}};function DJ(a,b,c,d,e,f){return a=DA(a,d,c,f),e&&(a=DV(a)),a}function DK(a){return a}function DL(a){return[a,this.get(a)]}function DM(){return o||=new DI(CB([]),void 0,void 0,void 0,DC)}function DN(a,b,c,d,e){if(null!=a){if(Array.isArray(a)){let f=0|a[Cw];return 0===a.length&&1&f?void 0:e&&2&f?a:DO(a,b,c,void 0!==d,e)}return b(a,d)}}function DO(a,b,c,d,e){let f=d||c?0|a[Cw]:0,g=d?!!(32&f):void 0,h=0,i=(d=CF(a)).length;for(let a=0;a<i;a++){var j=d[a];if(a===i-1&&CI(j)){let a;for(let d in j){let f=DN(j[d],b,c,g,e);null!=f&&((a??={})[d]=f)}j=a}else j=DN(d[a],b,c,g,e);d[a]=j,null!=j&&(h=a+1)}return h<i&&(d.length=h),c&&((a=CN(a))&&(d[Ct]=CF(a)),c(f,d)),d}function DP(a){return DN(a,DQ,void 0,void 0,!1)}function DQ(a){switch(typeof a){case"number":return Number.isFinite(a)?a:""+a;case"bigint":return CV(a)?Number(a):""+a;case"boolean":return+!!a;case"object":if(Cf(a))return Cf(a)&&Cn(Cv),Ca(a);if(a.W===CH)return DR(a);if(a instanceof Cj){let b=a.g;return null==b?"":"string"==typeof b?b:a.g=Ca(b)}return a instanceof DI?a.La():void 0}return a}function DR(a){var b=a.u;a=DO(b,DQ,void 0,void 0,!1);var c=0|b[Cw];if((b=a.length)&&!(512&c)){var d=a[b-1],e=!1;CI(d)?(b--,e=!0):d=void 0;var f=b-(c=512&c?0:-1),g=(p??function(a){return a})(f,c,a,d);if(d&&(a[b]=void 0),f<g&&d){for(var h in f=!0,d){let i=+h;i<=g?(a[e=i+c]=d[h],b=Math.max(e+1,b),e=!1,delete d[h]):f=!1}f&&(d=void 0)}for(f=b-1;b>0;f=b-1)if(null==(h=a[f]))b--,e=!0;else{if(!((f-=c)>=g))break;(d??={})[f]=h,b--,e=!0}e&&(a.length=b),d&&a.push(d)}return a}function DS(a,b,c){return a=DT(a,b[0],b[1],c?1:2),b!==q&&c&&Cz(a,8192),a}function DT(a,b,c,d){if(null==a){var e=96;c?(a=[c],e|=512):a=[],b&&(e=-0xffc001&e|(1023&b)<<14)}else{if(!Array.isArray(a))throw Error("narr");if(8192&(e=0|a[Cw])||!(64&e)||2&e||Cn(Cu),1024&e)throw Error("farr");if(64&e)return a;if(1===d||2===d||(e|=64),c&&(e|=512,c!==a[0]))throw Error("mid");a:{var f=(c=a).length;if(f){var g=f-1;if(CI(d=c[g])){if((g-=b=512&(e|=256)?0:-1)>=1024)throw Error("pvtlmt");for(var h in d)(f=+h)<g&&(c[f+b]=d[h],delete d[h]);e=-0xffc001&e|(1023&g)<<14;break a}}if(b){if((h=Math.max(b,f-(512&e?0:-1)))>1024)throw Error("spvt");e=-0xffc001&e|(1023&h)<<14}}}return CA(a,e),a}function DU(a,b,c){let d=c||2&b?CD:CC,e=!!(32&b);return Cz(a=function(a,b,c){let d=CF(a);var e=d.length;let f=256&b?d[e-1]:void 0;for(e+=f?-1:0,b=512&b?1:0;b<e;b++)d[b]=c(d[b]);if(f)for(let a in b=d[b]={},f)b[a]=c(f[a]);return(a=CN(a))&&(d[Ct]=CF(a)),d}(a,b,a=>(function a(b,c,d=CD){if(null!=b){if(B8&&b instanceof Uint8Array)return c?b:new Uint8Array(b);if(Array.isArray(b)){var e=0|b[Cw];return 2&e?b:(c&&=0===e||!!(32&e)&&!(64&e||!(16&e)))?(CA(b,34|e),4&e&&Object.freeze(b),b):DO(b,a,4&e?CD:d,!0,!0)}return b.W===CH?b=2&(e=0|(d=b.u)[Cw])?b:new b.constructor(DU(d,e,!0)):b instanceof DI&&!(2&b.M)&&(b=new DI(d=CB(b.da(a)),b.I,b.S,b.X)),b}})(a,e,d)),32|2*!!c),a}function DV(a){let b=a.u,c=0|b[Cw];return 2&c?new a.constructor(DU(b,c,!1)):a}function DW(a,b){return DX(a=a.u,0|a[Cw],b)}function DX(a,b,c){if(-1===c)return null;let d=c+(512&b?0:-1),e=a.length-1;return d>=e&&256&b?a[e][c]:d<=e?a[d]:void 0}function DY(a,b,c){let d=a.u,e=0|d[Cw];return CL(e),DZ(d,e,b,c),a}function DZ(a,b,c,d){let e=512&b?0:-1,f=c+e;var g=a.length-1;return f>=g&&256&b?a[g][c]=d:f<=g?a[f]=d:void 0!==d&&(c>=(g=b>>14&1023||0x20000000)?null!=d&&(a[g+e]={[c]:d},CA(a,b|=256)):a[f]=d),b}function D$(a,b){let c=0|(a=a.u)[Cw],d=DX(a,c,b),e=Dj(d);return null!=e&&e!==d&&DZ(a,c,b,e),e}function D_(a){let b=0|(a=a.u)[Cw],c=DX(a,b,1),d=CJ(c,!0);return null!=d&&d!==c&&DZ(a,b,1,d),d}function D0(){return void 0===CO?2:4}function D1(a,b,c,d,e){let f=a.u,g=2&(a=0|f[Cw])?1:d;e=!!e;let h=0|(d=D2(f,a,b))[Cw];if(!(4&h)){4&h&&(d=CF(d),h=Ej(h,a),a=DZ(f,a,b,d));let e=0,g=0;for(;e<d.length;e++){let a=c(d[e]);null!=a&&(d[g++]=a)}g<e&&(d.length=g),CA(d,h=c=-2049&(20|(h=D3(h,a)))&-4097),2&h&&Object.freeze(d)}return 1===g||4===g&&32&h?D4(h)||(e=h,(h|=2)!==e&&CA(d,h),Object.freeze(d)):(2===g&&D4(h)&&(CA(d=CF(d),h=Ek(h=Ej(h,a),a,e)),a=DZ(f,a,b,d)),D4(h)||(b=h,(h=Ek(h,a,e))!==b&&CA(d,h))),d}function D2(a,b,c){return Array.isArray(a=DX(a,b,c))?a:CG}function D3(a,b){return 0===a&&(a=Ej(a,b)),1|a}function D4(a){return!!(2&a)&&!!(4&a)||!!(1024&a)}function D5(a){a=CF(a);for(let b=0;b<a.length;b++){let c=a[b]=CF(a[b]);Array.isArray(c[1])&&(c[1]=CB(c[1]))}return a}function D6(a,b,c,d){let e=0|(a=a.u)[Cw];CL(e),DZ(a,e,b,("0"===d?0===Number(c):c===d)?void 0:c)}function D7(a,b,c,d){CL(b);let e=D2(a,b,c),f=e!==CG;if(64&b||!(8192&b)||!f){let g=f?0|e[Cw]:0,h=g;(!f||2&h||D4(h)||4&h&&!(32&h))&&(e=CF(e),h=Ej(h,b),b=DZ(a,b,c,e)),h=-13&D3(h,b),(h=Ek(d?-17&h:16|h,b,!0))!==g&&CA(e,h)}return e}function D8(a,b){return Eb(D9(a=a.u),a,0|a[Cw],GT)===b?b:-1}function D9(a){if(Co)return a[Cs]??(a[Cs]=new Map);if(Cs in a)return a[Cs];let b=new Map;return Object.defineProperty(a,Cs,{value:b}),b}function Ea(a,b,c,d){let e=D9(a),f=Eb(e,a,b,c);return f!==d&&(f&&(b=DZ(a,b,f)),e.set(c,d)),b}function Eb(a,b,c,d){let e=a.get(d);if(null!=e)return e;e=0;for(let a=0;a<d.length;a++){let f=d[a];null!=DX(b,c,f)&&(0!==e&&(c=DZ(b,c,e)),e=f)}return a.set(d,e),e}function Ec(a,b,c){let d,e=0|a[Cw],f=DX(a,e,c);if(null!=f&&f.W===CH)return(b=DV(f))!==f&&DZ(a,e,c,b),b.u;if(Array.isArray(f)){let a=0|f[Cw];d=2&a?DS(DU(f,a,!1),b,!0):64&a?f:DS(d,b,!0)}else d=DS(void 0,b,!0);return d!==f&&DZ(a,e,c,d),d}function Ed(a,b,c){let d=0|(a=a.u)[Cw],e=DX(a,d,c);return(b=DA(e,b,!1,d))!==e&&null!=b&&DZ(a,d,c,b),b}function Ee(a,b,c){if(null==(b=Ed(a,b,c)))return b;let d=0|(a=a.u)[Cw];if(!(2&d)){let e=DV(b);e!==b&&DZ(a,d,c,b=e)}return b}function Ef(a,b,c,d,e,f,g){a=a.u;var h=!!(2&b);let i=h?1:e;f=!!f,g&&=!h;var j=0|(e=D2(a,b,d))[Cw];if(!(h=!!(4&j))){var k=e,l=b;let a=!!(2&(j=D3(j,b)));a&&(l|=2);let d=!a,f=!0,g=0,h=0;for(;g<k.length;g++){let b=DA(k[g],c,!1,l);if(b instanceof c){if(!a){let a=!!(2&b.u[Cw]);d&&=!a,f&&=a}k[h++]=b}}h<g&&(k.length=h),j|=4,j=f?16|j:-17&j,CA(k,j=d?8|j:-9&j),a&&Object.freeze(k)}if(g&&!(8&j||!e.length&&(1===i||4===i&&32&j))){for(D4(j)&&(e=CF(e),j=Ej(j,b),b=DZ(a,b,d,e)),c=e,g=j,k=0;k<c.length;k++)(j=c[k])!==(l=DV(j))&&(c[k]=l);g|=8,CA(c,g=c.length?-17&g:16|g),j=g}return 1===i||4===i&&32&j?D4(j)||(b=j,(j|=!e.length||16&j&&(!h||32&j)?2:1024)!==b&&CA(e,j),Object.freeze(e)):(2===i&&D4(j)&&(CA(e=CF(e),j=Ek(j=Ej(j,b),b,f)),b=DZ(a,b,d,e)),D4(j)||(d=j,(j=Ek(j,b,f))!==d&&CA(e,j))),e}function Eg(a,b,c){let d=0|a.u[Cw];return Ef(a,d,b,c,D0(),!1,!(2&d))}function Eh(a,b,c,d){return null==d&&(d=void 0),DY(a,c,d)}function Ei(a,b,c,d){null==d&&(d=void 0);a:{let e=0|(a=a.u)[Cw];if(CL(e),null==d){let d=D9(a);if(Eb(d,a,e,c)!==b)break a;d.set(c,0)}else e=Ea(a,e,c,b);DZ(a,e,b,d)}}function Ej(a,b){return -1025&(a=32|(2&b?2|a:-3&a))}function Ek(a,b,c){return 32&b&&c||(a&=-33),a}function El(a,b,c){CL(0|a.u[Cw]),D1(a,b,Dz,2,!0).push(Dx(c))}function Em(a,b,c,d){let e=0|a.u[Cw];CL(e),a=Ef(a,e,c,b,2,!0),d=null!=d?d:new c,a.push(d),a[Cw]=2&d.u[Cw]?-9&a[Cw]:-17&a[Cw]}function En(a,b){return Dn(DW(a,b))}function Eo(a,b){return Dz(DW(a,b))}function Ep(a,b){return D$(a,b)??0}function Eq(a,b,c){if(null!=c&&"boolean"!=typeof c)throw a=typeof c,Error(`Expected boolean but got ${"object"!=a?a:c?Array.isArray(c)?"array":a:"null"}: ${c}`);DY(a,b,c)}function Er(a,b,c){if(null!=c){if("number"!=typeof c||!Dg(c))throw Cm("int32");c|=0}DY(a,b,c)}function Es(a,b,c){if(null!=c&&"number"!=typeof c)throw Error(`Value of float/double field must be a number, found ${typeof c}: ${c}`);DY(a,b,c)}function Et(a,b,c){{let g=a.u,h=0|g[Cw];if(CL(h),null==c)DZ(g,h,b);else{var d=a=0|c[Cw],e=D4(a),f=e||Object.isFrozen(c);for(e||(a=0),f||(c=CF(c),d=0,a=Ek(a=Ej(a,h),h,!0),f=!1),a|=21,e=0;e<c.length;e++){let b=c[e],g=Dx(b);Object.is(b,g)||(f&&(c=CF(c),d=0,a=Ek(a=Ej(a,h),h,!0),f=!1),c[e]=g)}a!==d&&(f&&(c=CF(c),a=Ek(a=Ej(a,h),h,!0)),CA(c,a)),DZ(g,h,b,c)}}}function Eu(a,b){return Error(`Invalid wire type: ${a} (at position ${b})`)}function Ev(){return Error("Failed to read varint, encoding is invalid.")}function Ew(a,b){return Error(`Tried to read past the end of the data ${b} > ${a}`)}function Ex(a){if("string"==typeof a)return{buffer:Ce(a),O:!1};if(Array.isArray(a))return{buffer:new Uint8Array(a),O:!1};if(a.constructor===Uint8Array)return{buffer:a,O:!1};if(a.constructor===ArrayBuffer)return{buffer:new Uint8Array(a),O:!1};if(a.constructor===Cj)return{buffer:Ci(a)||new Uint8Array(0),O:!0};if(a instanceof Uint8Array)return{buffer:new Uint8Array(a.buffer,a.byteOffset,a.byteLength),O:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function Ey(a,b){let c,d=0,e=0,f=0,g=a.h,h=a.g;do d|=(127&(c=g[h++]))<<f,f+=7;while(f<32&&128&c)for(f>32&&(e|=(127&c)>>4),f=3;f<32&&128&c;f+=7)e|=(127&(c=g[h++]))<<f;if(EG(a,h),c<128)return b(d>>>0,e>>>0);throw Ev()}function Ez(a){let b=0,c=a.g,d=c+10,e=a.h;for(;c<d;){let d=e[c++];if(b|=d,0==(128&d))return EG(a,c),!!(127&b)}throw Ev()}function EA(a){let b=a.h,c=a.g,d=b[c++],e=127&d;if(128&d&&(e|=(127&(d=b[c++]))<<7,128&d&&(e|=(127&(d=b[c++]))<<14,128&d&&(e|=(127&(d=b[c++]))<<21,128&d&&(e|=(d=b[c++])<<28,128&d&&128&b[c++]&&128&b[c++]&&128&b[c++]&&128&b[c++]&&128&b[c++])))))throw Ev();return EG(a,c),e}function EB(a){return EA(a)>>>0}function EC(a){var b=a.h;let c=a.g,d=b[c],e=b[c+1],f=b[c+2];return b=b[c+3],EG(a,a.g+4),(d|e<<8|f<<16|b<<24)>>>0}function ED(a){var b=EC(a);a=2*(b>>31)+1;let c=b>>>23&255;return b&=8388607,255==c?b?NaN:1/0*a:0==c?1401298464324817e-60*a*b:a*Math.pow(2,c-150)*(b+8388608)}function EE(a){return EA(a)}function EF(a,b,{aa:c=!1}={}){a.aa=c,b&&(a.h=(b=Ex(b)).buffer,a.m=b.O,a.j=0,a.l=a.h.length,a.g=a.j)}function EG(a,b){if(a.g=b,b>a.l)throw Ew(a.l,b)}function EH(a,b){if(b<0)throw Error(`Tried to read a negative byte length: ${b}`);let c=a.g,d=c+b;if(d>a.l)throw Ew(b,a.l-c);return a.g=d,c}function EI(a,b){if(0==b)return Ch();var c=EH(a,b);return a.aa&&a.m?c=a.h.subarray(c,c+b):(a=a.h,c=c===(b=c+b)?new Uint8Array(0):C_?a.slice(c,b):new Uint8Array(a.subarray(c,b))),0==c.length?Ch():new Cj(c,Cg)}DI.prototype.toJSON=void 0;var EJ=[];function EK(a){var b=a.g;if(b.g==b.l)return!1;a.l=a.g.g;var c=EB(a.g);if(b=c>>>3,!((c&=7)>=0&&c<=5))throw Eu(c,a.l);if(b<1)throw Error(`Invalid field number: ${b} (at position ${a.l})`);return a.m=b,a.h=c,!0}function EL(a,b,c){let d=a.g.l,e=EB(a.g),f=a.g.g+e,g=f-d;if(g<=0&&(a.g.l=f,c(b,a,void 0,void 0,void 0),g=f-a.g.g),g)throw Error(`Message parsing ended unexpectedly. Expected to read ${e} bytes, instead read ${e-g} bytes, either the data ended unexpectedly or the message misreported its own length`);return a.g.g=f,a.g.l=d,b}function EM(a){var b=EB(a.g),c=EH(a=a.g,b);if(a=a.h,Bl){var d,e=a;(d=k)||(d=k=new TextDecoder("utf-8",{fatal:!0})),b=c+b,e=0===c&&b===e.length?e:e.subarray(c,b);try{var f=d.decode(e)}catch(a){if(void 0===j){try{d.decode(new Uint8Array([128]))}catch(a){}try{d.decode(new Uint8Array([97])),j=!0}catch(a){j=!1}}throw j||(k=void 0),a}}else{b=(f=c)+b,c=[];let h,i=null;for(;f<b;){var g=a[f++];g<128?c.push(g):g<224?f>=b?Bj():(h=a[f++],g<194||128!=(192&h)?(f--,Bj()):c.push((31&g)<<6|63&h)):g<240?f>=b-1?Bj():128!=(192&(h=a[f++]))||224===g&&h<160||237===g&&h>=160||128!=(192&(d=a[f++]))?(f--,Bj()):c.push((15&g)<<12|(63&h)<<6|63&d):g<=244?f>=b-2?Bj():128!=(192&(h=a[f++]))||h-144+(g<<28)>>30!=0||128!=(192&(d=a[f++]))||128!=(192&(e=a[f++]))?(f--,Bj()):(g=((7&g)<<18|(63&h)<<12|(63&d)<<6|63&e)-65536,c.push(55296+(g>>10&1023),56320+(1023&g))):Bj(),c.length>=8192&&(i=Bk(i,c),c.length=0)}f=Bk(i,c)}return f}function EN(a){let b=EB(a.g);return EI(a.g,b)}function EO(a,b,c){var d=EB(a.g);for(d=a.g.g+d;a.g.g<d;)c.push(b(a.g))}var EP=[];function EQ(a,b,c){b.g?b.m(a,b.g,b.h,c):b.m(a,b.h,c)}var ER=class{constructor(a,b){this.u=DT(a,b)}toJSON(){try{var a=DR(this)}finally{p=void 0}return a}l(){return HE.g?HE.l(this,HE.g,HE.h):HE.l(this,HE.h,HE.defaultValue)}clone(){let a=this.u;return new this.constructor(DU(a,0|a[Cw],!1))}O(){return!!(2&this.u[Cw])}};function ES(a){return a?/^\d+$/.test(a)?(Db(a),new ET(C1,C2)):null:s||=new ET(0,0)}ER.prototype.W=CH,ER.prototype.toString=function(){return this.u.toString()};var ET=class{constructor(a,b){this.h=a>>>0,this.g=b>>>0}};function EU(a){return a?/^-?\d+$/.test(a)?(Db(a),new EV(C1,C2)):null:t||=new EV(0,0)}var EV=class{constructor(a,b){this.h=a>>>0,this.g=b>>>0}};function EW(a,b,c){for(;c>0||b>127;)a.g.push(127&b|128),b=(b>>>7|c<<25)>>>0,c>>>=7;a.g.push(b)}function EX(a,b){for(;b>127;)a.g.push(127&b|128),b>>>=7;a.g.push(b)}function EY(a,b){if(b>=0)EX(a,b);else{for(let c=0;c<9;c++)a.g.push(127&b|128),b>>=7;a.g.push(1)}}function EZ(a,b){a.g.push(b>>>0&255),a.g.push(b>>>8&255),a.g.push(b>>>16&255),a.g.push(b>>>24&255)}function E$(a,b){0!==b.length&&(a.l.push(b),a.h+=b.length)}function E_(a,b,c){EX(a.g,8*b+c)}function E0(a,b){return E_(a,b,2),b=a.g.end(),E$(a,b),b.push(a.h),b}function E1(a,b){var c=b.pop();for(c=a.h+a.g.length()-c;c>127;)b.push(127&c|128),c>>>=7,a.h++;b.push(c),a.h++}function E2(a,b,c){E_(a,b,2),EX(a.g,c.length),E$(a,a.g.end()),E$(a,c)}function E3(a,b,c,d){null!=c&&(b=E0(a,b),d(c,a),E1(a,b))}function E4(){let a=class{constructor(){throw Error()}};return Object.setPrototypeOf(a,a.prototype),a}var E5=E4(),E6=E4(),E7=E4(),E8=E4(),E9=E4(),Fa=E4(),Fb=E4(),Fc=E4(),Fd=E4(),Fe=class{constructor(a,b,c){this.g=a,this.h=b,a=E5,this.l=!!a&&c===a}};function Ff(a,b){return new Fe(a,b,E5)}function Fg(a,b,c,d,e){E3(a,c,Fp(b,d),e)}let Fh=Ff(function(a,b,c,d,e){return 2===a.h&&(EL(a,Ec(b,d,c),e),!0)},Fg),Fi=Ff(function(a,b,c,d,e){return 2===a.h&&(EL(a,Ec(b,d,c),e),!0)},Fg);var Fj=Symbol(),Fk=Symbol(),Fl=Symbol(),Fm=Symbol();function Fn(a,b,c,d){var e=d[a];if(e)return e;(e={}).Ma=d,e.T=function(a){switch(typeof a){case"boolean":return q||=[0,void 0,!0];case"number":return a>0?void 0:0===a?r||=[0,void 0]:[-a,void 0];case"string":return[0,a];case"object":return a}}(d[0]);var f=d[1];let g=1;f&&f.constructor===Object&&(e.ga=f,"function"==typeof(f=d[++g])&&(e.la=!0,u??=f,v??=d[g+1],f=d[g+=2]));let h={};for(;f&&Array.isArray(f)&&f.length&&"number"==typeof f[0]&&f[0]>0;){for(var i=0;i<f.length;i++)h[f[i]]=f;f=d[++g]}for(i=1;void 0!==f;){let a;"number"==typeof f&&(i+=f,f=d[++g]);var j=void 0;if(f instanceof Fe?a=f:(a=Fh,g--),a?.l){f=d[++g],j=d;var k=g;"function"==typeof f&&(f=f(),j[k]=f),j=f}for(k=i+1,"number"==typeof(f=d[++g])&&f<0&&(k-=f,f=d[++g]);i<k;i++){let d=h[i];j?c(e,i,a,j,d):b(e,i,a,d)}}return d[a]=e}function Fo(a){return Array.isArray(a)?a[0]instanceof Fe?a:[Fi,a]:[a,void 0]}function Fp(a,b){return a instanceof ER?a.u:Array.isArray(a)?DS(a,b,!1):void 0}function Fq(a,b,c,d){let e=c.g;a[b]=d?(a,b,c)=>e(a,b,c,d):e}function Fr(a,b,c,d,e){let f,g,h=c.g;a[b]=(a,b,c)=>h(a,b,c,g||=Fn(Fk,Fq,Fr,d).T,f||=Fs(d),e)}function Fs(a){let b=a[Fl];if(null!=b)return b;let c=Fn(Fk,Fq,Fr,a);return b=c.la?(a,b)=>u(a,b,c):(a,b)=>{let d=0|a[Cw];for(;EK(b)&&4!=b.h;){var e=b.m,f=c[e];if(null==f){var g=c.ga;g&&(g=g[e])&&null!=(g=function(a){let b=(a=Fo(a))[0].g;if(a=a[1]){let c=Fs(a),d=Fn(Fk,Fq,Fr,a).T;return(a,e,f)=>b(a,e,f,d,c)}return b}(g))&&(f=c[e]=g)}null!=f&&f(b,a,e)||(e=(f=b).l,function a(b){switch(b.h){case 0:0!=b.h?a(b):Ez(b.g);break;case 1:EG(b=b.g,b.g+8);break;case 2:if(2!=b.h)a(b);else{var c=EB(b.g);EG(b=b.g,b.g+c)}break;case 5:EG(b=b.g,b.g+4);break;case 3:for(c=b.m;;){if(!EK(b))throw Error("Unmatched start-group tag: stream EOF");if(4==b.h){if(b.m!=c)throw Error("Unmatched end-group tag");break}a(b)}break;default:throw Eu(b.h,b.l)}}(f),f.fa?f=void 0:(g=f.g.g-e,f.g.g=e,f=EI(f.g,g)),e=a,f&&((g=e[Ct])?g.push(f):e[Ct]=[f]))}return 8192&d&&CB(a),!0},a[Fl]=b}function Ft(a,b,c){a[b]=c.h}function Fu(a,b,c,d){let e,f,g=c.h;a[b]=(a,b,c)=>g(a,b,c,f||=Fn(Fj,Ft,Fu,d).T,e||=Fv(d))}function Fv(a){let b=a[Fm];if(!b){let c=Fn(Fj,Ft,Fu,a);b=(a,b)=>Fw(a,b,c),a[Fm]=b}return b}function Fw(a,b,c){!function(a,b,c){let d=512&b?0:-1,e=a.length,f=e+((b=64&b?256&b:!!e&&CI(a[e-1]))?-1:0);for(let b=0;b<f;b++)c(b-d,a[b]);if(b)for(let b in a=a[e-1])isNaN(b)||c(+b,a[b])}(a,a[Cw]|512*!!c.T[1],(a,d)=>{if(null!=d){var e=function(a,b){var c=a[b];if(c)return c;if((c=a.ga)&&(c=c[b])){var d=(c=Fo(c))[0].h;if(c=c[1]){let b=Fv(c),e=Fn(Fj,Ft,Fu,c).T;c=a.la?v(e,b):(a,c,f)=>d(a,c,f,e,b)}else c=d;return a[b]=c}}(c,a);e&&e(b,d,a)}}),(a=CN(a))&&function(a,b){E$(a,a.g.end());for(let c=0;c<b.length;c++)E$(a,Ci(b[c])||new Uint8Array(0))}(b,a)}function Fx(a,b){if(Array.isArray(b)){var c=0|b[Cw];if(4&c)return b;for(var d=0,e=0;d<b.length;d++){let c=a(b[d]);null!=c&&(b[e++]=c)}return e<d&&(b.length=e),CA(b,-6145&(5|c)),2&c&&Object.freeze(b),b}}function Fy(a,b,c){return new Fe(a,b,c)}function Fz(a,b,c){return new Fe(a,b,c)}function FA(a,b,c){DZ(a,0|a[Cw],b,c)}var FB=Ff(function(a,b,c,d,e){return 2===a.h&&(a=EL(a,DS([void 0,void 0],d,!0),e),CL(d=0|b[Cw]),(e=DX(b,d,c))instanceof DI?0!=(2&e.M)?((e=e.da()).push(a),DZ(b,d,c,e)):e.Ja(a):Array.isArray(e)?(2&e[Cw]&&DZ(b,d,c,e=D5(e)),e.push(a)):DZ(b,d,c,[a]),!0)},function(a,b,c,d,e){if(b instanceof DI)b.forEach((b,f)=>{E3(a,c,DS([f,b],d,!1),e)});else if(Array.isArray(b))for(let f=0;f<b.length;f++){let g=b[f];Array.isArray(g)&&E3(a,c,DS(g,d,!1),e)}});function FC(a,b,c){if(null!=(b=function(a){if(null==a)return a;let b=typeof a;if("bigint"===b)return String(Dd(64,a));if(Dm(a)){if("string"===b)return Dt(a);if("number"===b)return Ds(a)}}(b))&&("string"==typeof b&&EU(b),null!=b))switch(E_(a,c,0),typeof b){case"number":a=a.g,C4(b),EW(a,C1,C2);break;case"bigint":c=new EV(Number((c=BigInt.asUintN(64,b))&BigInt(0xffffffff)),Number(c>>BigInt(32))),EW(a.g,c.h,c.g);break;default:c=EU(b),EW(a.g,c.h,c.g)}}function FD(a,b,c){null!=(b=Dn(b))&&null!=b&&(E_(a,c,0),EY(a.g,b))}function FE(a,b,c){null!=(b=Dk(b))&&(E_(a,c,0),a.g.g.push(+!!b))}function FF(a,b,c){null!=(b=Dz(b))&&E2(a,c,Bn(b))}function FG(a,b,c,d,e){E3(a,c,Fp(b,d),e)}function FH(a,b,c){null==b||"string"==typeof b||b instanceof Cj||(Cf(b)?Cf(b)&&Cn(Cv):b=void 0),null!=b&&E2(a,c,Ex(b).buffer)}function FI(a,b,c){return(5===a.h||2===a.h)&&(b=D7(b,0|b[Cw],c,!1),2==a.h?EO(a,ED,b):b.push(ED(a.g)),!0)}var FJ=Fy(function(a,b,c){if(1!==a.h)return!1;var d=a.g;a=EC(d);let e=EC(d);d=2*(e>>31)+1;let f=e>>>20&2047;return a=0x100000000*(1048575&e)+a,FA(b,c,2047==f?a?NaN:1/0*d:0==f?5e-324*d*a:d*Math.pow(2,f-1075)*(a+0x10000000000000)),!0},function(a,b,c){null!=(b=Dj(b))&&(E_(a,c,1),a=a.g,(c=C0||=new DataView(new ArrayBuffer(8))).setFloat64(0,+b,!0),C1=c.getUint32(0,!0),C2=c.getUint32(4,!0),EZ(a,C1),EZ(a,C2))},E4()),FK=Fy(function(a,b,c){return 5===a.h&&(FA(b,c,ED(a.g)),!0)},function(a,b,c){null!=(b=Dj(b))&&(E_(a,c,5),a=a.g,C5(b),EZ(a,C1))},Fb),FL=Fz(FI,function(a,b,c){if(null!=(b=Fx(Dj,b)))for(let f=0;f<b.length;f++){var d=a,e=b[f];null!=e&&(E_(d,c,5),d=d.g,C5(e),EZ(d,C1))}},Fb),FM=Fz(FI,function(a,b,c){if(null!=(b=Fx(Dj,b))&&b.length){E_(a,c,2),EX(a.g,4*b.length);for(let d=0;d<b.length;d++)c=a.g,C5(b[d]),EZ(c,C1)}},Fb),FN=Fy(function(a,b,c){return 0===a.h&&(FA(b,c,Ey(a.g,C7)),!0)},FC,Fa),FO=Fy(function(a,b,c){return 0===a.h&&(FA(b,c,0===(a=Ey(a.g,C7))?void 0:a),!0)},FC,Fa),FP=Fy(function(a,b,c){return 0===a.h&&(FA(b,c,Ey(a.g,C6)),!0)},function(a,b,c){if(null!=(b=function(a){if(null==a)return a;var b=typeof a;if("bigint"===b)return String(De(64,a));if(Dm(a)){if("string"===b)return Df(b=Dh(Number(a)))&&b>=0?a=String(b):(-1!==(b=a.indexOf("."))&&(a=a.substring(0,b)),Dp(a)||(Db(a),a=C8(C1,C2))),a;if("number"===b)return(a=Dh(a))>=0&&Df(a)?a:function(a){if(a<0){C4(a);var b=C8(C1,C2);return Df(a=Number(b))?a:b}return Dp(b=String(a))?b:(C4(a),C6(C1,C2))}(a)}}(b))&&("string"==typeof b&&ES(b),null!=b))switch(E_(a,c,0),typeof b){case"number":a=a.g,C4(b),EW(a,C1,C2);break;case"bigint":c=new ET(Number((c=BigInt.asUintN(64,b))&BigInt(0xffffffff)),Number(c>>BigInt(32))),EW(a.g,c.h,c.g);break;default:c=ES(b),EW(a.g,c.h,c.g)}},E4()),FQ=Fy(function(a,b,c){return 0===a.h&&(FA(b,c,EA(a.g)),!0)},FD,E8),FR=Fz(function(a,b,c){return(0===a.h||2===a.h)&&(b=D7(b,0|b[Cw],c,!1),2==a.h?EO(a,EA,b):b.push(EA(a.g)),!0)},function(a,b,c){if(null!=(b=Fx(Dn,b))&&b.length){c=E0(a,c);for(let c=0;c<b.length;c++)EY(a.g,b[c]);E1(a,c)}},E8),FS=Fy(function(a,b,c){return 0===a.h&&(FA(b,c,0===(a=EA(a.g))?void 0:a),!0)},FD,E8),FT=Fy(function(a,b,c){return 0===a.h&&(FA(b,c,Ez(a.g)),!0)},FE,E6),FU=Fy(function(a,b,c){return 0===a.h&&(FA(b,c,!1===(a=Ez(a.g))?void 0:a),!0)},FE,E6),FV=Fz(function(a,b,c){return 2===a.h&&(a=EM(a),D7(b,0|b[Cw],c,!1).push(a),!0)},function(a,b,c){if(null!=(b=Fx(Dz,b)))for(let e=0;e<b.length;e++){var d=b[e];null!=d&&E2(a,c,Bn(d))}},E7),FW=Fy(function(a,b,c){return 2===a.h&&(FA(b,c,""===(a=EM(a))?void 0:a),!0)},FF,E7),FX=Fy(function(a,b,c){return 2===a.h&&(FA(b,c,EM(a)),!0)},FF,E7),FY=function(a,b,c=E5){return new Fe(a,b,c)}(function(a,b,c,d,e){return 2===a.h&&(d=DS(void 0,d,!0),D7(b,0|b[Cw],c,!0).push(d),EL(a,d,e),!0)},function(a,b,c,d,e){if(Array.isArray(b))for(let f=0;f<b.length;f++)FG(a,b[f],c,d,e)}),FZ=Ff(function(a,b,c,d,e,f){return 2===a.h&&(Ea(b,0|b[Cw],f,c),EL(a,b=Ec(b,d,c),e),!0)},FG),F$=Fy(function(a,b,c){return 2===a.h&&(FA(b,c,EN(a)),!0)},FH,Fc),F_=Fz(function(a,b,c){return(0===a.h||2===a.h)&&(b=D7(b,0|b[Cw],c,!1),2==a.h?EO(a,EB,b):b.push(EB(a.g)),!0)},function(a,b,c){if(null!=(b=Fx(Do,b)))for(let e=0;e<b.length;e++){var d=b[e];null!=d&&(E_(a,c,0),EX(a.g,d))}},E9),F0=Fy(function(a,b,c){return 0===a.h&&(FA(b,c,0===(a=EB(a.g))?void 0:a),!0)},function(a,b,c){null!=(b=Do(b))&&null!=b&&(E_(a,c,0),EX(a.g,b))},E9),F1=Fy(function(a,b,c){return 0===a.h&&(FA(b,c,EA(a.g)),!0)},function(a,b,c){null!=(b=Dn(b))&&(b=parseInt(b,10),E_(a,c,0),EY(a.g,b))},Fd);class F2{constructor(a,b){this.h=a,this.g=b,this.l=Ee,this.m=Eh,this.defaultValue=void 0}register(){B3(this)}}function F3(a,b){return new F2(a,b)}function F4(a,b){return(c,d)=>{if(EP.length){let a=EP.pop();a.o(d),EF(a.g,c,d),c=a}else c=new class{constructor(a,b){if(EJ.length){const c=EJ.pop();EF(c,a,b),a=c}else a=new class{constructor(a,b){this.h=null,this.m=!1,this.g=this.l=this.j=0,EF(this,a,b)}clear(){this.h=null,this.m=!1,this.g=this.l=this.j=0,this.aa=!1}}(a,b);this.g=a,this.l=this.g.g,this.h=this.m=-1,this.o(b)}o({fa:a=!1}={}){this.fa=a}}(c,d);try{let d=new a,f=d.u;Fs(b)(f,c);var e=d}finally{c.g.clear(),c.m=-1,c.h=-1,EP.length<100&&EP.push(c)}return e}}function F5(a){return function(){let b=new class{constructor(){this.l=[],this.h=0,this.g=new class{constructor(){this.g=[]}length(){return this.g.length}end(){let a=this.g;return this.g=[],a}}}};Fw(this.u,b,Fn(Fj,Ft,Fu,a)),E$(b,b.g.end());let c=new Uint8Array(b.h),d=b.l,e=d.length,f=0;for(let a=0;a<e;a++){let b=d[a];c.set(b,f),f+=b.length}return b.l=[c],c}}var F6=class extends ER{constructor(a){super(a)}},F7=[0,FW,Fy(function(a,b,c){return 2===a.h&&(FA(b,c,(a=EN(a))===Ch()?void 0:a),!0)},function(a,b,c){if(null!=b){if(b instanceof ER){let d=b.Oa;return void(d&&null!=(b=d(b))&&E2(a,c,Ex(b).buffer))}if(Array.isArray(b))return}FH(a,b,c)},Fc)];let F8,F9=globalThis.trustedTypes;function Ga(a){void 0===F8&&(F8=function(){let a=null;if(!F9)return a;try{let b=a=>a;a=F9.createPolicy("goog#html",{createHTML:b,createScript:b,createScriptURL:b})}catch(a){}return a}());var b=F8;return new class{constructor(a){this.g=a}toString(){return this.g+""}}(b?b.createScriptURL(a):a)}function Gb(a,...b){if(0===b.length)return Ga(a[0]);let c=a[0];for(let d=0;d<b.length;d++)c+=encodeURIComponent(b[d])+a[d+1];return Ga(c)}var Gc=[0,FQ,F1,FT,-1,FR,F1,-1],Gd=class extends ER{constructor(a){super(a)}},Ge=[0,FT,FX,FT,F1,-1,Fz(function(a,b,c){return(0===a.h||2===a.h)&&(b=D7(b,0|b[Cw],c,!1),2==a.h?EO(a,EE,b):b.push(EA(a.g)),!0)},function(a,b,c){if(null!=(b=Fx(Dn,b))&&b.length){c=E0(a,c);for(let c=0;c<b.length;c++)EY(a.g,b[c]);E1(a,c)}},Fd),FX,-1,[0,FT,-1],F1,FT,-1],Gf=[0,FX,-2],Gg=class extends ER{constructor(a){super(a)}},Gh=[0],Gi=[0,FQ,FT,1,FT,-3],Gj=class extends ER{constructor(a){super(a,2)}},Gk={};Gk[0x1412e9f7]=[0,FX,FT,-1,FQ,[0,[1,2,3,4,5,6,7,8,9],FZ,Gh,FZ,Ge,FZ,Gf,FZ,Gi,FZ,Gc,FZ,[0,FX,-2],FZ,[0,FX,F1],FZ,[0,F1,FX,-1],FZ,[0,F1,-1]],[0,FX],FT,[0,[1,3],[2,4],FZ,[0,FR],-1,FZ,[0,FV],-1,FY,[0,FX,-1]],FX];var Gl=[0,FO,-1,FU,-3,FO,FR,FW,FS,FO,-1,FU,FS,FU,-2,FW];function Gm(a,b){D6(a,2,Dy(b),"")}function Gn(a,b){El(a,3,b)}function Go(a,b){El(a,4,b)}var Gp=class extends ER{constructor(a){super(a,500)}o(a){return Eh(this,0,7,a)}},Gq=[-1,{}],Gr=[0,FX,1,Gq],Gs=[0,FX,FV,Gq];function Gt(a,b){Em(a,1,Gp,b)}function Gu(a,b){El(a,10,b)}function Gv(a,b){El(a,15,b)}var Gw=class extends ER{constructor(a){super(a,500)}o(a){return Eh(this,0,1001,a)}},Gx=[-500,FY,[-500,FW,-1,FV,-3,[-2,Gk,FT],FY,F7,FS,-1,Gr,Gs,FY,[0,FW,FU],FW,Gl,FS,FV,987,FV],4,FY,[-500,FX,-1,[-1,{}],998,FX],FY,[-500,FX,FV,-1,[-2,{},FT],997,FV,-1],FS,FY,[-500,FX,FV,Gq,998,FV],FV,FS,Gr,Gs,FY,[0,FW,-1,Gq],FV,-2,Gl,FW,-1,FU,[0,FU,F0],978,Gq,FY,F7];Gw.prototype.g=F5(Gx);var Gy=F4(Gw,Gx),Gz=class extends ER{constructor(a){super(a)}},GA=class extends ER{constructor(a){super(a)}g(){return Eg(this,Gz,1)}},GB=[0,FY,[0,FQ,FK,FX,-1]],GC=F4(GA,GB),GD=class extends ER{constructor(a){super(a)}},GE=class extends ER{constructor(a){super(a)}},GF=class extends ER{constructor(a){super(a)}h(){return Ee(this,GD,2)}g(){return Eg(this,GE,5)}},GG=F4(class extends ER{constructor(a){super(a)}},[0,FV,FR,FM,[0,F1,[0,FQ,-3],[0,FK,-3],[0,FQ,-1,[0,FY,[0,FQ,-2]]],FY,[0,FK,-1,FX,FK]],FX,-1,FN,FY,[0,FQ,FK],FV,FN]),GH=class extends ER{constructor(a){super(a)}},GI=F4(class extends ER{constructor(a){super(a)}},[0,FY,[0,FK,-4]]),GJ=class extends ER{constructor(a){super(a)}},GK=F4(class extends ER{constructor(a){super(a)}},[0,FY,[0,FK,-4]]),GL=class extends ER{constructor(a){super(a)}},GM=[0,FQ,-1,FM,F1],GN=class extends ER{constructor(a){super(a)}};GN.prototype.g=F5([0,FK,-4,FN]);var GO=class extends ER{constructor(a){super(a)}},GP=F4(class extends ER{constructor(a){super(a)}},[0,FY,[0,1,FQ,FX,GB],FN]),GQ=class extends ER{constructor(a){super(a)}},GR=class extends ER{constructor(a){super(a)}ma(){let a=D_(this);return null==a?Ch():a}},GS=class extends ER{constructor(a){super(a)}},GT=[1,2],GU=F4(class extends ER{constructor(a){super(a)}},[0,FY,[0,GT,FZ,[0,FM],FZ,[0,F$],FQ,FX],FN]),GV=class extends ER{constructor(a){super(a)}},GW=[0,FX,FQ,FK,FV,-1],GX=class extends ER{constructor(a){super(a)}},GY=[0,FT,-1],GZ=class extends ER{constructor(a){super(a)}},G$=[1,2,3,4,5],G_=class extends ER{constructor(a){super(a)}g(){return null!=D_(this)}h(){return null!=Eo(this,2)}},G0=class extends ER{constructor(a){super(a)}g(){return Dk(DW(this,2))??!1}},G1=[0,F$,FX,[0,FQ,FN,-1],[0,FP,FN]],G2=[0,G1,FT,[0,G$,FZ,Gi,FZ,Ge,FZ,Gc,FZ,Gh,FZ,Gf],F1],G3=class extends ER{constructor(a){super(a)}},G4=[0,G2,FK,-1,FQ],G5=F3(0x1dee13c9,G3);Gk[0x1dee13c9]=G4;var G6=F4(class extends ER{constructor(a){super(a)}},[0,[0,F1,-1,FL,F_],GM]),G7=class extends ER{constructor(a){super(a)}},G8=class extends ER{constructor(a){super(a)}},G9=[0,G2,FK,[0,G2],FT],Ha=[0,G2,G4,G9,FK,[0,[0,G1]]],Hb=F3(0x1e563cd6,G8);Gk[0x1e563cd6]=Ha,Gk[0x1e563cd5]=G9;var Hc=class extends ER{constructor(a){super(a)}},Hd=F3(0x1ea1bd3c,Hc);Gk[0x1ea1bd3c]=[0,G2,Ha,FQ];var He=class extends ER{constructor(a){super(a)}h(){return Ee(this,GV,2)}g(){DY(this,2)}},Hf=[0,G2,GW];Gk[0x1c8a4bf9]=Hf;var Hg=class extends ER{constructor(a){super(a)}},Hh=class extends ER{constructor(a){super(a)}},Hi=class extends ER{constructor(a){super(a)}},Hj=class extends ER{constructor(a){super(a)}},Hk=class extends ER{constructor(a){super(a)}},Hl=[0,G2,[0,G2],Hf,-1],Hm=[0,G2,FK,FQ],Hn=[0,G2,FK],Ho=[0,G2,Hm,Hn,FK],Hp=F3(0x1c8e70de,Hk);Gk[0x1c8e70de]=[0,G2,Ho,Hl],Gk[0x1b9e78d4]=Hl,Gk[0x1bb54420]=Hm;var Hq=F3(0x1b947172,Hj);Gk[0x1b947172]=Ho,Gk[0x1c47e016]=Hn;var Hr=class extends ER{constructor(a){super(a)}},Hs=class extends ER{constructor(a){super(a)}},Ht=class extends ER{constructor(a){super(a)}},Hu=class extends ER{constructor(a){super(a)}},Hv=[0,G2,FK,-1,FQ],Hw=[0,G2,FK,FT];Hu.prototype.g=F5([0,G2,Hn,[0,G2],G4,G9,Hv,Hw]);var Hx=class extends ER{constructor(a){super(a)}},Hy=F3(0x1b33db97,Hx);Gk[0x1b33db97]=[0,G2,GW];var Hz=class extends ER{constructor(a){super(a)}},HA=F3(0x1c647f1b,Hz);Gk[0x1c647f1b]=[0,G2,GY];var HB=class extends ER{constructor(a){super(a)}},HC=class extends ER{constructor(a){super(a)}},HD=[0,F1,-1],HE=F3(0x1b4e2414,class extends ER{constructor(a){super(a)}g(){var a=this.u;let b=0|a[Cw],c=2&b;return a=function(a,b,c){var d=HC;let e=2&b,f=!1;if(null==c){if(e)return DM();c=[]}else if(c.constructor===DI){if(0==(2&c.M)||e)return c;c=c.da()}else Array.isArray(c)?f=!!(2&c[Cw]):c=[];if(e){if(!c.length)return DM();f||(f=!0,CB(c))}else f&&(f=!1,c=D5(c));return f||(64&c[Cw]?c[Cw]&=-33:32&b&&Cz(c,32)),DZ(a,b,2,d=new DI(c,d,DB,void 0)),d}(a,b,DX(a,b,2)),!c&&HC&&(a.pa=!0),a}});Gk[0x1b4e2414]=[0,HD,FB,[!0,FN,[0,FX,-1,FV]]];var HF=class extends ER{constructor(a){super(a)}},HG=F3(0x1b4e239e,HF);Gk[0x1b4e239e]=[0,G2,FX,HD];var HH=class extends ER{constructor(a){super(a)}},HI=F3(0x1a6e638a,HH);Gk[0x1a6e638a]=[0,G2,FX,FQ,FK,FV,-1,FT,FK],Gk[0x1eaed71d]=Hv;var HJ=class extends ER{constructor(a){super(a)}},HK=F3(0x1eca7ede,HJ);function HL(a,b){return b=b?b.clone():new GV,void 0!==a.displayNamesLocale?DY(b,1,Dy(a.displayNamesLocale)):void 0===a.displayNamesLocale&&DY(b,1),void 0!==a.maxResults?Er(b,2,a.maxResults):"maxResults"in a&&DY(b,2),void 0!==a.scoreThreshold?Es(b,3,a.scoreThreshold):"scoreThreshold"in a&&DY(b,3),void 0!==a.categoryAllowlist?Et(b,4,a.categoryAllowlist):"categoryAllowlist"in a&&DY(b,4),void 0!==a.categoryDenylist?Et(b,5,a.categoryDenylist):"categoryDenylist"in a&&DY(b,5),b}function HM(a,b=-1,c=""){return{categories:a.map(a=>({index:En(a,1)??0??-1,score:Ep(a,2)??0,categoryName:Eo(a,3)??""??"",displayName:Eo(a,4)??""??""})),headIndex:b,headName:c}}function HN(a){var b=D1(a,3,Dj,D0()),c=D1(a,2,Dn,D0()),d=D1(a,1,Dz,D0()),e=D1(a,9,Dz,D0());let f={categories:[],keypoints:[]};for(let a=0;a<b.length;a++)f.categories.push({score:b[a],index:c[a]??-1,categoryName:d[a]??"",displayName:e[a]??""});if((b=Ee(a,GF,4)?.h())&&(f.boundingBox={originX:En(b,1)??0,originY:En(b,2)??0,width:En(b,3)??0,height:En(b,4)??0,angle:0}),Ee(a,GF,4)?.g().length)for(let b of Ee(a,GF,4).g())f.keypoints.push({x:D$(b,1)??0,y:D$(b,2)??0,score:D$(b,4)??0,label:Eo(b,3)??""});return f}function HO(a){let b=[];for(let c of Eg(a,GJ,1))b.push({x:Ep(c,1)??0,y:Ep(c,2)??0,z:Ep(c,3)??0,visibility:Ep(c,4)??0});return b}function HP(a){let b=[];for(let c of Eg(a,GH,1))b.push({x:Ep(c,1)??0,y:Ep(c,2)??0,z:Ep(c,3)??0,visibility:Ep(c,4)??0});return b}function HQ(a){return Array.from(a,a=>a>127?a-256:a)}function HR(a,b){if(a.length!==b.length)throw Error(`Cannot compute cosine similarity between embeddings of different sizes (${a.length} vs. ${b.length}).`);let c=0,d=0,e=0;for(let f=0;f<a.length;f++)c+=a[f]*b[f],d+=a[f]*a[f],e+=b[f]*b[f];if(d<=0||e<=0)throw Error("Cannot compute cosine similarity on embedding with 0 norm.");return c/Math.sqrt(d*e)}Gk[0x1eca7ede]=[0,G2,Hv,Hw,FK],Gk[0x1eee3800]=Hw;let HS=new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,10,1,8,0,65,0,253,15,253,98,11]);async function HT(){if(void 0===w)try{await WebAssembly.instantiate(HS),w=!0}catch{w=!1}return w}async function HU(a,b=Gb``){let c=await HT()?"wasm_internal":"wasm_nosimd_internal";return{wasmLoaderPath:`${b}/${a}_${c}.js`,wasmBinaryPath:`${b}/${a}_${c}.wasm`}}var HV=class{};function HW(){var a=navigator;return"undefined"!=typeof OffscreenCanvas&&(!function(a=navigator){return(a=a.userAgent).includes("Safari")&&!a.includes("Chrome")}(a)||!!((a=a.userAgent.match(/Version\/([\d]+).*Safari/))&&a.length>=1&&Number(a[1])>=17))}async function HX(a){if("function"!=typeof importScripts){let b=document.createElement("script");return b.src=a.toString(),b.crossOrigin="anonymous",new Promise((a,c)=>{b.addEventListener("load",()=>{a()},!1),b.addEventListener("error",a=>{c(a)},!1),document.body.appendChild(b)})}importScripts(a.toString())}function HY(a){return void 0!==a.videoWidth?[a.videoWidth,a.videoHeight]:void 0!==a.naturalWidth?[a.naturalWidth,a.naturalHeight]:void 0!==a.displayWidth?[a.displayWidth,a.displayHeight]:[a.width,a.height]}function HZ(a,b,c){a.m||console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target"),c(b=a.i.stringToNewUTF8(b)),a.i._free(b)}function H$(a,b,c){if(!a.i.canvas)throw Error("No OpenGL canvas configured.");if(c?a.i._bindTextureToStream(c):a.i._bindTextureToCanvas(),!(c=a.i.canvas.getContext("webgl2")||a.i.canvas.getContext("webgl")))throw Error("Failed to obtain WebGL context from the provided canvas. `getContext()` should only be invoked with `webgl` or `webgl2`.");a.i.gpuOriginForWebTexturesIsBottomLeft&&c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!0),c.texImage2D(c.TEXTURE_2D,0,c.RGBA,c.RGBA,c.UNSIGNED_BYTE,b),a.i.gpuOriginForWebTexturesIsBottomLeft&&c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!1);let[d,e]=HY(b);return a.l&&(d!==a.i.canvas.width||e!==a.i.canvas.height)&&(a.i.canvas.width=d,a.i.canvas.height=e),[d,e]}function H_(a,b,c){a.m||console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target");let d=new Uint32Array(b.length);for(let c=0;c<b.length;c++)d[c]=a.i.stringToNewUTF8(b[c]);for(let e of(b=a.i._malloc(4*d.length),a.i.HEAPU32.set(d,b>>2),c(b),d))a.i._free(e);a.i._free(b)}function H0(a,b,c){a.i.simpleListeners=a.i.simpleListeners||{},a.i.simpleListeners[b]=c}function H1(a,b,c){let d=[];a.i.simpleListeners=a.i.simpleListeners||{},a.i.simpleListeners[b]=(a,b,e)=>{b?(c(d,e),d=[]):d.push(a)}}async function H2(a,b,c,d){return a=await (async(a,b,c,d,e)=>{if(b&&await HX(b),!self.ModuleFactory||c&&(await HX(c),!self.ModuleFactory))throw Error("ModuleFactory not set.");return self.Module&&e&&((b=self.Module).locateFile=e.locateFile,e.mainScriptUrlOrBlob&&(b.mainScriptUrlOrBlob=e.mainScriptUrlOrBlob)),e=await self.ModuleFactory(self.Module||e),self.ModuleFactory=self.Module=void 0,new a(e,d)})(a,c.wasmLoaderPath,c.assetLoaderPath,b,{locateFile:a=>a.endsWith(".wasm")?c.wasmBinaryPath.toString():c.assetBinaryPath&&a.endsWith(".data")?c.assetBinaryPath.toString():a}),await a.o(d),a}function H3(a,b){let c=Ee(a.baseOptions,G_,1)||new G_;"string"==typeof b?(DY(c,2,Dy(b)),DY(c,1)):b instanceof Uint8Array&&(DY(c,1,CJ(b,!1)),DY(c,2)),Eh(a.baseOptions,0,1,c)}function H4(a){try{let b=a.G.length;if(1===b)throw Error(a.G[0].message);if(b>1)throw Error("Encountered multiple errors: "+a.G.map(a=>a.message).join(", "))}finally{a.G=[]}}function H5(a,b){a.B=Math.max(a.B,b)}function H6(a,b){a.A=new Gp,Gm(a.A,"PassThroughCalculator"),Gn(a.A,"free_memory"),Go(a.A,"free_memory_unused_out"),Gu(b,"free_memory"),Gt(b,a.A)}function H7(a,b){Gn(a.A,b),Go(a.A,b+"_unused_out")}function H8(a){a.g.addBoolToStream(!0,"free_memory",a.B)}HV.forVisionTasks=function(a){return HU("vision",a)},HV.forTextTasks=function(a){return HU("text",a)},HV.forGenAiExperimentalTasks=function(a){return HU("genai_experimental",a)},HV.forGenAiTasks=function(a){return HU("genai",a)},HV.forAudioTasks=function(a){return HU("audio",a)},HV.isSimdSupported=function(){return HT()};var H9=class{constructor(a){this.g=a,this.G=[],this.B=0,this.g.setAutoRenderToScreen(!1)}l(a,b=!0){if(b){let b=a.baseOptions||{};if(a.baseOptions?.modelAssetBuffer&&a.baseOptions?.modelAssetPath)throw Error("Cannot set both baseOptions.modelAssetPath and baseOptions.modelAssetBuffer");if(!(Ee(this.baseOptions,G_,1)?.g()||Ee(this.baseOptions,G_,1)?.h()||a.baseOptions?.modelAssetBuffer||a.baseOptions?.modelAssetPath))throw Error("Either baseOptions.modelAssetPath or baseOptions.modelAssetBuffer must be set");if(function(a,b){let c=Ee(a.baseOptions,GZ,3);if(!c){var d=c=new GZ;Ei(d,4,G$,new Gg)}"delegate"in b&&("GPU"===b.delegate?Ei(b=c,2,G$,d=new Gd):Ei(b=c,4,G$,d=new Gg)),Eh(a.baseOptions,0,3,c)}(this,b),b.modelAssetPath)return fetch(b.modelAssetPath.toString()).then(a=>{if(a.ok)return a.arrayBuffer();throw Error(`Failed to fetch model: ${b.modelAssetPath} (${a.status})`)}).then(a=>{try{this.g.i.FS_unlink("/model.dat")}catch{}this.g.i.FS_createDataFile("/","model.dat",new Uint8Array(a),!0,!1,!1),H3(this,"/model.dat"),this.m(),this.J()});if(b.modelAssetBuffer instanceof Uint8Array)H3(this,b.modelAssetBuffer);else if(b.modelAssetBuffer)return(async function(a){let b=[];for(var c=0;;){let{done:d,value:e}=await a.read();if(d)break;b.push(e),c+=e.length}if(0===b.length)return new Uint8Array(0);if(1===b.length)return b[0];for(let d of(a=new Uint8Array(c),c=0,b))a.set(d,c),c+=d.length;return a})(b.modelAssetBuffer).then(a=>{H3(this,a),this.m(),this.J()})}return this.m(),this.J(),Promise.resolve()}J(){}ca(){let a;if(this.g.ca(b=>{a=Gy(b)}),!a)throw Error("Failed to retrieve CalculatorGraphConfig");return a}setGraph(a,b){this.g.attachErrorListener((a,b)=>{this.G.push(Error(b))}),this.g.Ha(),this.g.setGraph(a,b),this.A=void 0,H4(this)}finishProcessing(){this.g.finishProcessing(),H4(this)}close(){this.A=void 0,this.g.closeGraph()}};function Ia(a,b){if(!a)throw Error(`Unable to obtain required WebGL resource: ${b}`);return a}H9.prototype.close=H9.prototype.close;class Ib{constructor(a,b,c,d){this.g=a,this.h=b,this.m=c,this.l=d}bind(){this.g.bindVertexArray(this.h)}close(){this.g.deleteVertexArray(this.h),this.g.deleteBuffer(this.m),this.g.deleteBuffer(this.l)}}function Ic(a,b,c){let d=a.g;if(c=Ia(d.createShader(c),"Failed to create WebGL shader"),d.shaderSource(c,b),d.compileShader(c),!d.getShaderParameter(c,d.COMPILE_STATUS))throw Error(`Could not compile WebGL shader: ${d.getShaderInfoLog(c)}`);return d.attachShader(a.h,c),c}function Id(a,b){let c=a.g,d=Ia(c.createVertexArray(),"Failed to create vertex array");c.bindVertexArray(d);let e=Ia(c.createBuffer(),"Failed to create buffer");c.bindBuffer(c.ARRAY_BUFFER,e),c.enableVertexAttribArray(a.P),c.vertexAttribPointer(a.P,2,c.FLOAT,!1,0,0),c.bufferData(c.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),c.STATIC_DRAW);let f=Ia(c.createBuffer(),"Failed to create buffer");return c.bindBuffer(c.ARRAY_BUFFER,f),c.enableVertexAttribArray(a.J),c.vertexAttribPointer(a.J,2,c.FLOAT,!1,0,0),c.bufferData(c.ARRAY_BUFFER,new Float32Array(b?[0,1,0,0,1,0,1,1]:[0,0,0,1,1,1,1,0]),c.STATIC_DRAW),c.bindBuffer(c.ARRAY_BUFFER,null),c.bindVertexArray(null),new Ib(c,d,e,f)}function Ie(a,b){if(a.g){if(b!==a.g)throw Error("Cannot change GL context once initialized")}else a.g=b}function If(a,b,c,d){return Ie(a,b),a.h||(a.m(),a.C()),c?(a.s||(a.s=Id(a,!0)),c=a.s):(a.v||(a.v=Id(a,!1)),c=a.v),b.useProgram(a.h),c.bind(),a.l(),a=d(),c.g.bindVertexArray(null),a}function Ig(a,b,c){return Ie(a,b),a=Ia(b.createTexture(),"Failed to create texture"),b.bindTexture(b.TEXTURE_2D,a),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,c??b.LINEAR),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,c??b.LINEAR),b.bindTexture(b.TEXTURE_2D,null),a}function Ih(a,b,c){Ie(a,b),a.A||(a.A=Ia(b.createFramebuffer(),"Failed to create framebuffe.")),b.bindFramebuffer(b.FRAMEBUFFER,a.A),b.framebufferTexture2D(b.FRAMEBUFFER,b.COLOR_ATTACHMENT0,b.TEXTURE_2D,c,0)}function Ii(a){a.g?.bindFramebuffer(a.g.FRAMEBUFFER,null)}var Ij=class{G(){return"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D inputTexture;\n  void main() {\n    gl_FragColor = texture2D(inputTexture, vTex);\n  }\n "}m(){let a=this.g;if(this.h=Ia(a.createProgram(),"Failed to create WebGL program"),this.Z=Ic(this,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",a.VERTEX_SHADER),this.Y=Ic(this,this.G(),a.FRAGMENT_SHADER),a.linkProgram(this.h),!a.getProgramParameter(this.h,a.LINK_STATUS))throw Error(`Error during program linking: ${a.getProgramInfoLog(this.h)}`);this.P=a.getAttribLocation(this.h,"aVertex"),this.J=a.getAttribLocation(this.h,"aTex")}C(){}l(){}close(){if(this.h){let a=this.g;a.deleteProgram(this.h),a.deleteShader(this.Z),a.deleteShader(this.Y)}this.A&&this.g.deleteFramebuffer(this.A),this.v&&this.v.close(),this.s&&this.s.close()}},Ik=class extends Ij{G(){return"\n  precision mediump float;\n  uniform sampler2D backgroundTexture;\n  uniform sampler2D maskTexture;\n  uniform sampler2D colorMappingTexture;\n  varying vec2 vTex;\n  void main() {\n    vec4 backgroundColor = texture2D(backgroundTexture, vTex);\n    float category = texture2D(maskTexture, vTex).r;\n    vec4 categoryColor = texture2D(colorMappingTexture, vec2(category, 0.0));\n    gl_FragColor = mix(backgroundColor, categoryColor, categoryColor.a);\n  }\n "}C(){let a=this.g;a.activeTexture(a.TEXTURE1),this.B=Ig(this,a,a.LINEAR),a.activeTexture(a.TEXTURE2),this.j=Ig(this,a,a.NEAREST)}m(){super.m();let a=this.g;this.L=Ia(a.getUniformLocation(this.h,"backgroundTexture"),"Uniform location"),this.U=Ia(a.getUniformLocation(this.h,"colorMappingTexture"),"Uniform location"),this.K=Ia(a.getUniformLocation(this.h,"maskTexture"),"Uniform location")}l(){super.l();let a=this.g;a.uniform1i(this.K,0),a.uniform1i(this.L,1),a.uniform1i(this.U,2)}close(){this.B&&this.g.deleteTexture(this.B),this.j&&this.g.deleteTexture(this.j),super.close()}},Il=class extends Ij{G(){return"\n  precision mediump float;\n  uniform sampler2D maskTexture;\n  uniform sampler2D defaultTexture;\n  uniform sampler2D overlayTexture;\n  varying vec2 vTex;\n  void main() {\n    float confidence = texture2D(maskTexture, vTex).r;\n    vec4 defaultColor = texture2D(defaultTexture, vTex);\n    vec4 overlayColor = texture2D(overlayTexture, vTex);\n    // Apply the alpha from the overlay and merge in the default color\n    overlayColor = mix(defaultColor, overlayColor, overlayColor.a);\n    gl_FragColor = mix(defaultColor, overlayColor, confidence);\n  }\n "}C(){let a=this.g;a.activeTexture(a.TEXTURE1),this.j=Ig(this,a),a.activeTexture(a.TEXTURE2),this.B=Ig(this,a)}m(){super.m();let a=this.g;this.K=Ia(a.getUniformLocation(this.h,"defaultTexture"),"Uniform location"),this.L=Ia(a.getUniformLocation(this.h,"overlayTexture"),"Uniform location"),this.H=Ia(a.getUniformLocation(this.h,"maskTexture"),"Uniform location")}l(){super.l();let a=this.g;a.uniform1i(this.H,0),a.uniform1i(this.K,1),a.uniform1i(this.L,2)}close(){this.j&&this.g.deleteTexture(this.j),this.B&&this.g.deleteTexture(this.B),super.close()}};function Im(a,b){switch(b){case 0:return a.g.find(a=>a instanceof Uint8Array);case 1:return a.g.find(a=>a instanceof Float32Array);case 2:return a.g.find(a=>"undefined"!=typeof WebGLTexture&&a instanceof WebGLTexture);default:throw Error(`Type is not supported: ${b}`)}}function In(a){var b=Im(a,1);if(!b){if(b=Im(a,0))b=new Float32Array(b).map(a=>a/255);else{b=new Float32Array(a.width*a.height);let d=Ip(a);var c=Ir(a);if(Ih(c,d,Io(a)),"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"document"in self&&"ontouchend"in self.document){c=new Float32Array(a.width*a.height*4),d.readPixels(0,0,a.width,a.height,d.RGBA,d.FLOAT,c);for(let a=0,d=0;a<b.length;++a,d+=4)b[a]=c[d]}else d.readPixels(0,0,a.width,a.height,d.RED,d.FLOAT,b)}a.g.push(b)}return b}function Io(a){let b=Im(a,2);if(!b){let c=Ip(a);b=Is(a);let d=In(a),e=Iq(a);c.texImage2D(c.TEXTURE_2D,0,e,a.width,a.height,0,c.RED,c.FLOAT,d),It(a)}return b}function Ip(a){if(!a.canvas)throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");return a.h||(a.h=Ia(a.canvas.getContext("webgl2"),"You cannot use a canvas that is already bound to a different type of rendering context.")),a.h}function Iq(a){if(a=Ip(a),!Iu)if(a.getExtension("EXT_color_buffer_float")&&a.getExtension("OES_texture_float_linear")&&a.getExtension("EXT_float_blend"))Iu=a.R32F;else{if(!a.getExtension("EXT_color_buffer_half_float"))throw Error("GPU does not fully support 4-channel float32 or float16 formats");Iu=a.R16F}return Iu}function Ir(a){return a.l||(a.l=new Ij),a.l}function Is(a){let b=Ip(a);b.viewport(0,0,a.width,a.height),b.activeTexture(b.TEXTURE0);let c=Im(a,2);return c||(c=Ig(Ir(a),b,a.m?b.LINEAR:b.NEAREST),a.g.push(c),a.j=!0),b.bindTexture(b.TEXTURE_2D,c),c}function It(a){a.h.bindTexture(a.h.TEXTURE_2D,null)}var Iu,Iv=class{constructor(a,b,c,d,e,f,g){this.g=a,this.m=b,this.j=c,this.canvas=d,this.l=e,this.width=f,this.height=g,this.j&&0==--Iw&&console.error("You seem to be creating MPMask instances without invoking .close(). This leaks resources.")}Da(){return!!Im(this,0)}ja(){return!!Im(this,1)}R(){return!!Im(this,2)}ia(){var a;return(a=Im(this,0))||(a=new Uint8Array((a=In(this)).map(a=>255*a)),this.g.push(a)),a}ha(){return In(this)}N(){return Io(this)}clone(){let a=[];for(let b of this.g){let c;if(b instanceof Uint8Array)c=new Uint8Array(b);else if(b instanceof Float32Array)c=new Float32Array(b);else{if(!(b instanceof WebGLTexture))throw Error(`Type is not supported: ${b}`);{let a=Ip(this),b=Ir(this);a.activeTexture(a.TEXTURE1),c=Ig(b,a,this.m?a.LINEAR:a.NEAREST),a.bindTexture(a.TEXTURE_2D,c);let d=Iq(this);a.texImage2D(a.TEXTURE_2D,0,d,this.width,this.height,0,a.RED,a.FLOAT,null),a.bindTexture(a.TEXTURE_2D,null),Ih(b,a,c),If(b,a,!1,()=>{Is(this),a.clearColor(0,0,0,0),a.clear(a.COLOR_BUFFER_BIT),a.drawArrays(a.TRIANGLE_FAN,0,4),It(this)}),Ii(b),It(this)}}a.push(c)}return new Iv(a,this.m,this.R(),this.canvas,this.l,this.width,this.height)}close(){this.j&&Ip(this).deleteTexture(Im(this,2)),Iw=-1}};Iv.prototype.close=Iv.prototype.close,Iv.prototype.clone=Iv.prototype.clone,Iv.prototype.getAsWebGLTexture=Iv.prototype.N,Iv.prototype.getAsFloat32Array=Iv.prototype.ha,Iv.prototype.getAsUint8Array=Iv.prototype.ia,Iv.prototype.hasWebGLTexture=Iv.prototype.R,Iv.prototype.hasFloat32Array=Iv.prototype.ja,Iv.prototype.hasUint8Array=Iv.prototype.Da;var Iw=250;let Ix={color:"white",lineWidth:4,radius:6};function Iy(a){return{...Ix,fillColor:(a=a||{}).color,...a}}function Iz(a,b){return a instanceof Function?a(b):a}function IA(a,b,c){return Math.max(Math.min(b,c),Math.min(Math.max(b,c),a))}function IB(a){if(!a.l)throw Error("CPU rendering requested but CanvasRenderingContext2D not provided.");return a.l}function IC(a){if(!a.j)throw Error("GPU rendering requested but WebGL2RenderingContext not provided.");return a.j}function ID(a,b,c){if(b.R())c(b.N());else{let d=b.ja()?b.ha():b.ia();a.m=a.m??new Ij;let e=IC(a);c((a=new Iv([d],b.m,!1,e.canvas,a.m,b.width,b.height)).N()),a.close()}}function IE(a,b,c,d){let e=(a.g||(a.g=new Ik),a.g),f=IC(a),g=Array.isArray(c)?new ImageData(new Uint8ClampedArray(c),1,1):c;If(e,f,!0,()=>{!function(a,b,c,d){let e=a.g;if(e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,b),e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,a.B),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,c),a.H&&function(a,b){if(a!==b)return!1;for(let[d,e]of(a=a.entries(),b=b.entries(),a)){a=d;var c=b.next();if(c.done)return!1;let[f,g]=c.value;if(c=g,a!==f||e[0]!==c[0]||e[1]!==c[1]||e[2]!==c[2]||e[3]!==c[3])return!1}return!!b.next().done}(a.H,d))e.activeTexture(e.TEXTURE2),e.bindTexture(e.TEXTURE_2D,a.j);else{a.H=d;let b=Array(1024).fill(0);d.forEach((a,c)=>{if(4!==a.length)throw Error(`Color at index ${c} is not a four-channel value.`);b[4*c]=a[0],b[4*c+1]=a[1],b[4*c+2]=a[2],b[4*c+3]=a[3]}),e.activeTexture(e.TEXTURE2),e.bindTexture(e.TEXTURE_2D,a.j),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,256,1,0,e.RGBA,e.UNSIGNED_BYTE,new Uint8Array(b))}}(e,b,g,d),f.clearColor(0,0,0,0),f.clear(f.COLOR_BUFFER_BIT),f.drawArrays(f.TRIANGLE_FAN,0,4);let a=e.g;a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,null),a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,null),a.activeTexture(a.TEXTURE2),a.bindTexture(a.TEXTURE_2D,null)})}function IF(a,b,c,d){let e=IC(a),f=(a.h||(a.h=new Il),a.h),g=Array.isArray(c)?new ImageData(new Uint8ClampedArray(c),1,1):c,h=Array.isArray(d)?new ImageData(new Uint8ClampedArray(d),1,1):d;If(f,e,!0,()=>{var a=f.g;a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,b),a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,f.j),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,g),a.activeTexture(a.TEXTURE2),a.bindTexture(a.TEXTURE_2D,f.B),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,h),e.clearColor(0,0,0,0),e.clear(e.COLOR_BUFFER_BIT),e.drawArrays(e.TRIANGLE_FAN,0,4),e.bindTexture(e.TEXTURE_2D,null),(a=f.g).activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,null),a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,null),a.activeTexture(a.TEXTURE2),a.bindTexture(a.TEXTURE_2D,null)})}var IG=class{constructor(a,b){"undefined"!=typeof CanvasRenderingContext2D&&a instanceof CanvasRenderingContext2D||a instanceof OffscreenCanvasRenderingContext2D?(this.l=a,this.j=b):this.j=a}wa(a,b){if(a){var c=IB(this);b=Iy(b),c.save();var d=c.canvas,e=0;for(let f of a)c.fillStyle=Iz(b.fillColor,{index:e,from:f}),c.strokeStyle=Iz(b.color,{index:e,from:f}),c.lineWidth=Iz(b.lineWidth,{index:e,from:f}),(a=new Path2D).arc(f.x*d.width,f.y*d.height,Iz(b.radius,{index:e,from:f}),0,2*Math.PI),c.fill(a),c.stroke(a),++e;c.restore()}}va(a,b,c){if(a&&b){var d=IB(this);c=Iy(c),d.save();var e=d.canvas,f=0;for(let g of b){d.beginPath(),b=a[g.start];let h=a[g.end];b&&h&&(d.strokeStyle=Iz(c.color,{index:f,from:b,to:h}),d.lineWidth=Iz(c.lineWidth,{index:f,from:b,to:h}),d.moveTo(b.x*e.width,b.y*e.height),d.lineTo(h.x*e.width,h.y*e.height)),++f,d.stroke()}d.restore()}}sa(a,b){let c=IB(this);b=Iy(b),c.save(),c.beginPath(),c.lineWidth=Iz(b.lineWidth,{}),c.strokeStyle=Iz(b.color,{}),c.fillStyle=Iz(b.fillColor,{}),c.moveTo(a.originX,a.originY),c.lineTo(a.originX+a.width,a.originY),c.lineTo(a.originX+a.width,a.originY+a.height),c.lineTo(a.originX,a.originY+a.height),c.lineTo(a.originX,a.originY),c.stroke(),c.fill(),c.restore()}ta(a,b,c=[0,0,0,255]){var d;let e;this.l?(d=this,e=IC(d),ID(d,a,a=>{IE(d,a,c,b),(a=IB(d)).drawImage(e.canvas,0,0,a.canvas.width,a.canvas.height)})):IE(this,a.N(),c,b)}ua(a,b,c){var d;let e;this.l?(d=this,e=IC(d),ID(d,a,a=>{IF(d,a,b,c),(a=IB(d)).drawImage(e.canvas,0,0,a.canvas.width,a.canvas.height)})):IF(this,a.N(),b,c)}close(){this.g?.close(),this.g=void 0,this.h?.close(),this.h=void 0,this.m?.close(),this.m=void 0}};function IH(a,b){switch(b){case 0:return a.g.find(a=>a instanceof ImageData);case 1:return a.g.find(a=>"undefined"!=typeof ImageBitmap&&a instanceof ImageBitmap);case 2:return a.g.find(a=>"undefined"!=typeof WebGLTexture&&a instanceof WebGLTexture);default:throw Error(`Type is not supported: ${b}`)}}function II(a){var b=IH(a,0);if(!b){b=IK(a);let c=IL(a),d=new Uint8Array(a.width*a.height*4);Ih(c,b,IJ(a)),b.readPixels(0,0,a.width,a.height,b.RGBA,b.UNSIGNED_BYTE,d),Ii(c),b=new ImageData(new Uint8ClampedArray(d.buffer),a.width,a.height),a.g.push(b)}return b}function IJ(a){let b=IH(a,2);if(!b){let c=IK(a);b=IM(a);let d=IH(a,1)||II(a);c.texImage2D(c.TEXTURE_2D,0,c.RGBA,c.RGBA,c.UNSIGNED_BYTE,d),IN(a)}return b}function IK(a){if(!a.canvas)throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");return a.h||(a.h=Ia(a.canvas.getContext("webgl2"),"You cannot use a canvas that is already bound to a different type of rendering context.")),a.h}function IL(a){return a.l||(a.l=new Ij),a.l}function IM(a){let b=IK(a);b.viewport(0,0,a.width,a.height),b.activeTexture(b.TEXTURE0);let c=IH(a,2);return c||(c=Ig(IL(a),b),a.g.push(c),a.m=!0),b.bindTexture(b.TEXTURE_2D,c),c}function IN(a){a.h.bindTexture(a.h.TEXTURE_2D,null)}function IO(a){let b=IK(a);return If(IL(a),b,!0,()=>(function(a,b){let c=a.canvas;if(c.width===a.width&&c.height===a.height)return b();let d=c.width,e=c.height;return c.width=a.width,c.height=a.height,a=b(),c.width=d,c.height=e,a})(a,()=>{if(b.bindFramebuffer(b.FRAMEBUFFER,null),b.clearColor(0,0,0,0),b.clear(b.COLOR_BUFFER_BIT),b.drawArrays(b.TRIANGLE_FAN,0,4),!(a.canvas instanceof OffscreenCanvas))throw Error("Conversion to ImageBitmap requires that the MediaPipe Tasks is initialized with an OffscreenCanvas");return a.canvas.transferToImageBitmap()}))}IG.prototype.close=IG.prototype.close,IG.prototype.drawConfidenceMask=IG.prototype.ua,IG.prototype.drawCategoryMask=IG.prototype.ta,IG.prototype.drawBoundingBox=IG.prototype.sa,IG.prototype.drawConnectors=IG.prototype.va,IG.prototype.drawLandmarks=IG.prototype.wa,IG.lerp=function(a,b,c,d,e){return IA(d*(1-(a-b)/(c-b))+e*(1-(c-a)/(c-b)),d,e)},IG.clamp=IA;var IP=class{constructor(a,b,c,d,e,f,g){this.g=a,this.j=b,this.m=c,this.canvas=d,this.l=e,this.width=f,this.height=g,(this.j||this.m)&&0==--IQ&&console.error("You seem to be creating MPImage instances without invoking .close(). This leaks resources.")}Ca(){return!!IH(this,0)}ka(){return!!IH(this,1)}R(){return!!IH(this,2)}Aa(){return II(this)}za(){var a=IH(this,1);return a||(IJ(this),IM(this),a=IO(this),IN(this),this.g.push(a),this.j=!0),a}N(){return IJ(this)}clone(){let a=[];for(let b of this.g){let c;if(b instanceof ImageData)c=new ImageData(b.data,this.width,this.height);else if(b instanceof WebGLTexture){let a=IK(this),b=IL(this);a.activeTexture(a.TEXTURE1),c=Ig(b,a),a.bindTexture(a.TEXTURE_2D,c),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,this.width,this.height,0,a.RGBA,a.UNSIGNED_BYTE,null),a.bindTexture(a.TEXTURE_2D,null),Ih(b,a,c),If(b,a,!1,()=>{IM(this),a.clearColor(0,0,0,0),a.clear(a.COLOR_BUFFER_BIT),a.drawArrays(a.TRIANGLE_FAN,0,4),IN(this)}),Ii(b),IN(this)}else{if(!(b instanceof ImageBitmap))throw Error(`Type is not supported: ${b}`);IJ(this),IM(this),c=IO(this),IN(this)}a.push(c)}return new IP(a,this.ka(),this.R(),this.canvas,this.l,this.width,this.height)}close(){this.j&&IH(this,1).close(),this.m&&IK(this).deleteTexture(IH(this,2)),IQ=-1}};IP.prototype.close=IP.prototype.close,IP.prototype.clone=IP.prototype.clone,IP.prototype.getAsWebGLTexture=IP.prototype.N,IP.prototype.getAsImageBitmap=IP.prototype.za,IP.prototype.getAsImageData=IP.prototype.Aa,IP.prototype.hasWebGLTexture=IP.prototype.R,IP.prototype.hasImageBitmap=IP.prototype.ka,IP.prototype.hasImageData=IP.prototype.Ca;var IQ=250;function IR(...a){return a.map(([a,b])=>({start:a,end:b}))}let IS=(IU=class{constructor(a,b){this.l=!0,this.i=a,this.g=null,this.h=0,this.m="function"==typeof this.i._addIntToInputStream,void 0!==b?this.i.canvas=b:HW()?this.i.canvas=new OffscreenCanvas(1,1):(console.warn("OffscreenCanvas not supported and GraphRunner constructor glCanvas parameter is undefined. Creating backup canvas."),this.i.canvas=document.createElement("canvas"))}async initializeGraph(a){let b=await (await fetch(a)).arrayBuffer();a=!(a.endsWith(".pbtxt")||a.endsWith(".textproto")),this.setGraph(new Uint8Array(b),a)}setGraphFromString(a){this.setGraph((new TextEncoder).encode(a),!1)}setGraph(a,b){let c=a.length,d=this.i._malloc(c);this.i.HEAPU8.set(a,d),b?this.i._changeBinaryGraph(c,d):this.i._changeTextGraph(c,d),this.i._free(d)}configureAudio(a,b,c,d,e){this.i._configureAudio||console.warn('Attempting to use configureAudio without support for input audio. Is build dep ":gl_graph_runner_audio" missing?'),HZ(this,d||"input_audio",d=>{HZ(this,e=e||"audio_header",e=>{this.i._configureAudio(d,e,a,b??0,c)})})}setAutoResizeCanvas(a){this.l=a}setAutoRenderToScreen(a){this.i._setAutoRenderToScreen(a)}setGpuBufferVerticalFlip(a){this.i.gpuOriginForWebTexturesIsBottomLeft=a}ca(a){H0(this,"__graph_config__",b=>{a(b)}),HZ(this,"__graph_config__",a=>{this.i._getGraphConfig(a,void 0)}),delete this.i.simpleListeners.__graph_config__}attachErrorListener(a){this.i.errorListener=a}attachEmptyPacketListener(a,b){this.i.emptyPacketListeners=this.i.emptyPacketListeners||{},this.i.emptyPacketListeners[a]=b}addAudioToStream(a,b,c){this.addAudioToStreamWithShape(a,0,0,b,c)}addAudioToStreamWithShape(a,b,c,d,e){let f=4*a.length;this.h!==f&&(this.g&&this.i._free(this.g),this.g=this.i._malloc(f),this.h=f),this.i.HEAPF32.set(a,this.g/4),HZ(this,d,a=>{this.i._addAudioToInputStream(this.g,b,c,a,e)})}addGpuBufferToStream(a,b,c){HZ(this,b,b=>{let[d,e]=H$(this,a,b);this.i._addBoundTextureToStream(b,d,e,c)})}addBoolToStream(a,b,c){HZ(this,b,b=>{this.i._addBoolToInputStream(a,b,c)})}addDoubleToStream(a,b,c){HZ(this,b,b=>{this.i._addDoubleToInputStream(a,b,c)})}addFloatToStream(a,b,c){HZ(this,b,b=>{this.i._addFloatToInputStream(a,b,c)})}addIntToStream(a,b,c){HZ(this,b,b=>{this.i._addIntToInputStream(a,b,c)})}addUintToStream(a,b,c){HZ(this,b,b=>{this.i._addUintToInputStream(a,b,c)})}addStringToStream(a,b,c){HZ(this,b,b=>{HZ(this,a,a=>{this.i._addStringToInputStream(a,b,c)})})}addStringRecordToStream(a,b,c){HZ(this,b,b=>{H_(this,Object.keys(a),d=>{H_(this,Object.values(a),e=>{this.i._addFlatHashMapToInputStream(d,e,Object.keys(a).length,b,c)})})})}addProtoToStream(a,b,c,d){HZ(this,c,c=>{HZ(this,b,b=>{let e=this.i._malloc(a.length);this.i.HEAPU8.set(a,e),this.i._addProtoToInputStream(e,a.length,b,c,d),this.i._free(e)})})}addEmptyPacketToStream(a,b){HZ(this,a,a=>{this.i._addEmptyPacketToInputStream(a,b)})}addBoolVectorToStream(a,b,c){HZ(this,b,b=>{let d=this.i._allocateBoolVector(a.length);if(!d)throw Error("Unable to allocate new bool vector on heap.");for(let b of a)this.i._addBoolVectorEntry(d,b);this.i._addBoolVectorToInputStream(d,b,c)})}addDoubleVectorToStream(a,b,c){HZ(this,b,b=>{let d=this.i._allocateDoubleVector(a.length);if(!d)throw Error("Unable to allocate new double vector on heap.");for(let b of a)this.i._addDoubleVectorEntry(d,b);this.i._addDoubleVectorToInputStream(d,b,c)})}addFloatVectorToStream(a,b,c){HZ(this,b,b=>{let d=this.i._allocateFloatVector(a.length);if(!d)throw Error("Unable to allocate new float vector on heap.");for(let b of a)this.i._addFloatVectorEntry(d,b);this.i._addFloatVectorToInputStream(d,b,c)})}addIntVectorToStream(a,b,c){HZ(this,b,b=>{let d=this.i._allocateIntVector(a.length);if(!d)throw Error("Unable to allocate new int vector on heap.");for(let b of a)this.i._addIntVectorEntry(d,b);this.i._addIntVectorToInputStream(d,b,c)})}addUintVectorToStream(a,b,c){HZ(this,b,b=>{let d=this.i._allocateUintVector(a.length);if(!d)throw Error("Unable to allocate new unsigned int vector on heap.");for(let b of a)this.i._addUintVectorEntry(d,b);this.i._addUintVectorToInputStream(d,b,c)})}addStringVectorToStream(a,b,c){HZ(this,b,b=>{let d=this.i._allocateStringVector(a.length);if(!d)throw Error("Unable to allocate new string vector on heap.");for(let b of a)HZ(this,b,a=>{this.i._addStringVectorEntry(d,a)});this.i._addStringVectorToInputStream(d,b,c)})}addBoolToInputSidePacket(a,b){HZ(this,b,b=>{this.i._addBoolToInputSidePacket(a,b)})}addDoubleToInputSidePacket(a,b){HZ(this,b,b=>{this.i._addDoubleToInputSidePacket(a,b)})}addFloatToInputSidePacket(a,b){HZ(this,b,b=>{this.i._addFloatToInputSidePacket(a,b)})}addIntToInputSidePacket(a,b){HZ(this,b,b=>{this.i._addIntToInputSidePacket(a,b)})}addUintToInputSidePacket(a,b){HZ(this,b,b=>{this.i._addUintToInputSidePacket(a,b)})}addStringToInputSidePacket(a,b){HZ(this,b,b=>{HZ(this,a,a=>{this.i._addStringToInputSidePacket(a,b)})})}addProtoToInputSidePacket(a,b,c){HZ(this,c,c=>{HZ(this,b,b=>{let d=this.i._malloc(a.length);this.i.HEAPU8.set(a,d),this.i._addProtoToInputSidePacket(d,a.length,b,c),this.i._free(d)})})}addBoolVectorToInputSidePacket(a,b){HZ(this,b,b=>{let c=this.i._allocateBoolVector(a.length);if(!c)throw Error("Unable to allocate new bool vector on heap.");for(let b of a)this.i._addBoolVectorEntry(c,b);this.i._addBoolVectorToInputSidePacket(c,b)})}addDoubleVectorToInputSidePacket(a,b){HZ(this,b,b=>{let c=this.i._allocateDoubleVector(a.length);if(!c)throw Error("Unable to allocate new double vector on heap.");for(let b of a)this.i._addDoubleVectorEntry(c,b);this.i._addDoubleVectorToInputSidePacket(c,b)})}addFloatVectorToInputSidePacket(a,b){HZ(this,b,b=>{let c=this.i._allocateFloatVector(a.length);if(!c)throw Error("Unable to allocate new float vector on heap.");for(let b of a)this.i._addFloatVectorEntry(c,b);this.i._addFloatVectorToInputSidePacket(c,b)})}addIntVectorToInputSidePacket(a,b){HZ(this,b,b=>{let c=this.i._allocateIntVector(a.length);if(!c)throw Error("Unable to allocate new int vector on heap.");for(let b of a)this.i._addIntVectorEntry(c,b);this.i._addIntVectorToInputSidePacket(c,b)})}addUintVectorToInputSidePacket(a,b){HZ(this,b,b=>{let c=this.i._allocateUintVector(a.length);if(!c)throw Error("Unable to allocate new unsigned int vector on heap.");for(let b of a)this.i._addUintVectorEntry(c,b);this.i._addUintVectorToInputSidePacket(c,b)})}addStringVectorToInputSidePacket(a,b){HZ(this,b,b=>{let c=this.i._allocateStringVector(a.length);if(!c)throw Error("Unable to allocate new string vector on heap.");for(let b of a)HZ(this,b,a=>{this.i._addStringVectorEntry(c,a)});this.i._addStringVectorToInputSidePacket(c,b)})}attachBoolListener(a,b){H0(this,a,b),HZ(this,a,a=>{this.i._attachBoolListener(a)})}attachBoolVectorListener(a,b){H1(this,a,b),HZ(this,a,a=>{this.i._attachBoolVectorListener(a)})}attachIntListener(a,b){H0(this,a,b),HZ(this,a,a=>{this.i._attachIntListener(a)})}attachIntVectorListener(a,b){H1(this,a,b),HZ(this,a,a=>{this.i._attachIntVectorListener(a)})}attachUintListener(a,b){H0(this,a,b),HZ(this,a,a=>{this.i._attachUintListener(a)})}attachUintVectorListener(a,b){H1(this,a,b),HZ(this,a,a=>{this.i._attachUintVectorListener(a)})}attachDoubleListener(a,b){H0(this,a,b),HZ(this,a,a=>{this.i._attachDoubleListener(a)})}attachDoubleVectorListener(a,b){H1(this,a,b),HZ(this,a,a=>{this.i._attachDoubleVectorListener(a)})}attachFloatListener(a,b){H0(this,a,b),HZ(this,a,a=>{this.i._attachFloatListener(a)})}attachFloatVectorListener(a,b){H1(this,a,b),HZ(this,a,a=>{this.i._attachFloatVectorListener(a)})}attachStringListener(a,b){H0(this,a,b),HZ(this,a,a=>{this.i._attachStringListener(a)})}attachStringVectorListener(a,b){H1(this,a,b),HZ(this,a,a=>{this.i._attachStringVectorListener(a)})}attachProtoListener(a,b,c){H0(this,a,b),HZ(this,a,a=>{this.i._attachProtoListener(a,c||!1)})}attachProtoVectorListener(a,b,c){H1(this,a,b),HZ(this,a,a=>{this.i._attachProtoVectorListener(a,c||!1)})}attachAudioListener(a,b,c){this.i._attachAudioListener||console.warn('Attempting to use attachAudioListener without support for output audio. Is build dep ":gl_graph_runner_audio_out" missing?'),H0(this,a,(a,c)=>{b(a=new Float32Array(a.buffer,a.byteOffset,a.length/4),c)}),HZ(this,a,a=>{this.i._attachAudioListener(a,c||!1)})}finishProcessing(){this.i._waitUntilIdle()}closeGraph(){this.i._closeGraph(),this.i.simpleListeners=void 0,this.i.emptyPacketListeners=void 0}},IT=class extends IU{get ea(){return this.i}oa(a,b,c){HZ(this,b,b=>{let[d,e]=H$(this,a,b);this.ea._addBoundTextureAsImageToStream(b,d,e,c)})}V(a,b){H0(this,a,b),HZ(this,a,a=>{this.ea._attachImageListener(a)})}ba(a,b){H1(this,a,b),HZ(this,a,a=>{this.ea._attachImageVectorListener(a)})}},class extends IT{Ha(){this.i._registerModelResourcesGraphService()}});var IT,IU,IV=class extends IS{};async function IW(a,b,c){return async function(a,b,c,d){return H2(a,b,c,d)}(a,c.canvas??(HW()?void 0:document.createElement("canvas")),b,c)}function IX(a,b,c,d){if(a.U){let f=new GN;if(c?.regionOfInterest){if(!a.na)throw Error("This task doesn't support region-of-interest.");var e=c.regionOfInterest;if(e.left>=e.right||e.top>=e.bottom)throw Error("Expected RectF with left < right and top < bottom.");if(e.left<0||e.top<0||e.right>1||e.bottom>1)throw Error("Expected RectF values to be in [0,1].");Es(f,1,(e.left+e.right)/2),Es(f,2,(e.top+e.bottom)/2),Es(f,4,e.right-e.left),Es(f,3,e.bottom-e.top)}else Es(f,1,.5),Es(f,2,.5),Es(f,4,1),Es(f,3,1);if(c?.rotationDegrees){if(c?.rotationDegrees%90!=0)throw Error("Expected rotation to be a multiple of 90.");if(Es(f,5,-Math.PI*c.rotationDegrees/180),c?.rotationDegrees%180!=0){let[a,d]=HY(b);c=Ep(f,3)*d/a,e=Ep(f,4)*a/d,Es(f,4,c),Es(f,3,e)}}a.g.addProtoToStream(f.g(),"mediapipe.NormalizedRect",a.U,d)}a.g.oa(b,a.Z,d??performance.now()),a.finishProcessing()}function IY(a,b,c){if(a.baseOptions?.g())throw Error("Task is not initialized with image mode. 'runningMode' must be set to 'IMAGE'.");IX(a,b,c,a.B+1)}function IZ(a,b,c,d){if(!a.baseOptions?.g())throw Error("Task is not initialized with video mode. 'runningMode' must be set to 'VIDEO'.");IX(a,b,c,d)}function I$(a,b,c,d){var e=b.data;let f=b.width,g=f*(b=b.height);if((e instanceof Uint8Array||e instanceof Float32Array)&&e.length!==g)throw Error("Unsupported channel count: "+e.length/g);return a=new Iv([e],c,!1,a.g.i.canvas,a.P,f,b),d?a.clone():a}var I_=class extends H9{constructor(a,b,c,d){super(a),this.g=a,this.Z=b,this.U=c,this.na=d,this.P=new Ij}l(a,b=!0){if("runningMode"in a&&Eq(this.baseOptions,2,!!a.runningMode&&"IMAGE"!==a.runningMode),void 0!==a.canvas&&this.g.i.canvas!==a.canvas)throw Error("You must create a new task to reset the canvas.");return super.l(a,b)}close(){this.P.close(),super.close()}};I_.prototype.close=I_.prototype.close;var I0=class extends I_{constructor(a,b){super(new IV(a,b),"image_in","norm_rect_in",!1),this.j={detections:[]},Eh(a=this.h=new G3,0,1,b=new G0),Es(this.h,2,.5),Es(this.h,3,.3)}get baseOptions(){return Ee(this.h,G0,1)}set baseOptions(a){Eh(this.h,0,1,a)}o(a){return"minDetectionConfidence"in a&&Es(this.h,2,a.minDetectionConfidence??.5),"minSuppressionThreshold"in a&&Es(this.h,3,a.minSuppressionThreshold??.3),this.l(a)}D(a,b){return this.j={detections:[]},IY(this,a,b),this.j}F(a,b,c){return this.j={detections:[]},IZ(this,a,c,b),this.j}m(){var a=new Gw;Gu(a,"image_in"),Gu(a,"norm_rect_in"),Gv(a,"detections");let b=new Gj;EQ(b,G5,this.h);let c=new Gp;Gm(c,"mediapipe.tasks.vision.face_detector.FaceDetectorGraph"),Gn(c,"IMAGE:image_in"),Gn(c,"NORM_RECT:norm_rect_in"),Go(c,"DETECTIONS:detections"),c.o(b),Gt(a,c),this.g.attachProtoVectorListener("detections",(a,b)=>{for(let b of a)a=GG(b),this.j.detections.push(HN(a));H5(this,b)}),this.g.attachEmptyPacketListener("detections",a=>{H5(this,a)}),a=a.g(),this.setGraph(new Uint8Array(a),!0)}};I0.prototype.detectForVideo=I0.prototype.F,I0.prototype.detect=I0.prototype.D,I0.prototype.setOptions=I0.prototype.o,I0.createFromModelPath=async function(a,b){return IW(I0,a,{baseOptions:{modelAssetPath:b}})},I0.createFromModelBuffer=function(a,b){return IW(I0,a,{baseOptions:{modelAssetBuffer:b}})},I0.createFromOptions=function(a,b){return IW(I0,a,b)};var I1=IR([61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]),I2=IR([263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]),I3=IR([276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]),I4=IR([474,475],[475,476],[476,477],[477,474]),I5=IR([33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]),I6=IR([46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]),I7=IR([469,470],[470,471],[471,472],[472,469]),I8=IR([10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]),I9=[...I1,...I2,...I3,...I5,...I6,...I8],Ja=IR([127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]);function Jb(a){a.j={faceLandmarks:[],faceBlendshapes:[],facialTransformationMatrixes:[]}}var Jc=class extends I_{constructor(a,b){super(new IV(a,b),"image_in","norm_rect",!1),this.j={faceLandmarks:[],faceBlendshapes:[],facialTransformationMatrixes:[]},this.outputFacialTransformationMatrixes=this.outputFaceBlendshapes=!1,Eh(a=this.h=new G8,0,1,b=new G0),this.v=new G7,Eh(this.h,0,3,this.v),this.s=new G3,Eh(this.h,0,2,this.s),Er(this.s,4,1),Es(this.s,2,.5),Es(this.v,2,.5),Es(this.h,4,.5)}get baseOptions(){return Ee(this.h,G0,1)}set baseOptions(a){Eh(this.h,0,1,a)}o(a){return"numFaces"in a&&Er(this.s,4,a.numFaces??1),"minFaceDetectionConfidence"in a&&Es(this.s,2,a.minFaceDetectionConfidence??.5),"minTrackingConfidence"in a&&Es(this.h,4,a.minTrackingConfidence??.5),"minFacePresenceConfidence"in a&&Es(this.v,2,a.minFacePresenceConfidence??.5),"outputFaceBlendshapes"in a&&(this.outputFaceBlendshapes=!!a.outputFaceBlendshapes),"outputFacialTransformationMatrixes"in a&&(this.outputFacialTransformationMatrixes=!!a.outputFacialTransformationMatrixes),this.l(a)}D(a,b){return Jb(this),IY(this,a,b),this.j}F(a,b,c){return Jb(this),IZ(this,a,c,b),this.j}m(){var a=new Gw;Gu(a,"image_in"),Gu(a,"norm_rect"),Gv(a,"face_landmarks");let b=new Gj;EQ(b,Hb,this.h);let c=new Gp;Gm(c,"mediapipe.tasks.vision.face_landmarker.FaceLandmarkerGraph"),Gn(c,"IMAGE:image_in"),Gn(c,"NORM_RECT:norm_rect"),Go(c,"NORM_LANDMARKS:face_landmarks"),c.o(b),Gt(a,c),this.g.attachProtoVectorListener("face_landmarks",(a,b)=>{for(let b of a)a=GK(b),this.j.faceLandmarks.push(HO(a));H5(this,b)}),this.g.attachEmptyPacketListener("face_landmarks",a=>{H5(this,a)}),this.outputFaceBlendshapes&&(Gv(a,"blendshapes"),Go(c,"BLENDSHAPES:blendshapes"),this.g.attachProtoVectorListener("blendshapes",(a,b)=>{if(this.outputFaceBlendshapes)for(let b of a)a=GC(b),this.j.faceBlendshapes.push(HM(a.g()??[]));H5(this,b)}),this.g.attachEmptyPacketListener("blendshapes",a=>{H5(this,a)})),this.outputFacialTransformationMatrixes&&(Gv(a,"face_geometry"),Go(c,"FACE_GEOMETRY:face_geometry"),this.g.attachProtoVectorListener("face_geometry",(a,b)=>{if(this.outputFacialTransformationMatrixes)for(let b of a)(a=Ee(G6(b),GL,2))&&this.j.facialTransformationMatrixes.push({rows:En(a,1)??0??0,columns:En(a,2)??0??0,data:D1(a,3,Dj,D0()).slice()??[]});H5(this,b)}),this.g.attachEmptyPacketListener("face_geometry",a=>{H5(this,a)})),a=a.g(),this.setGraph(new Uint8Array(a),!0)}};Jc.prototype.detectForVideo=Jc.prototype.F,Jc.prototype.detect=Jc.prototype.D,Jc.prototype.setOptions=Jc.prototype.o,Jc.createFromModelPath=function(a,b){return IW(Jc,a,{baseOptions:{modelAssetPath:b}})},Jc.createFromModelBuffer=function(a,b){return IW(Jc,a,{baseOptions:{modelAssetBuffer:b}})},Jc.createFromOptions=function(a,b){return IW(Jc,a,b)},Jc.FACE_LANDMARKS_LIPS=I1,Jc.FACE_LANDMARKS_LEFT_EYE=I2,Jc.FACE_LANDMARKS_LEFT_EYEBROW=I3,Jc.FACE_LANDMARKS_LEFT_IRIS=I4,Jc.FACE_LANDMARKS_RIGHT_EYE=I5,Jc.FACE_LANDMARKS_RIGHT_EYEBROW=I6,Jc.FACE_LANDMARKS_RIGHT_IRIS=I7,Jc.FACE_LANDMARKS_FACE_OVAL=I8,Jc.FACE_LANDMARKS_CONTOURS=I9,Jc.FACE_LANDMARKS_TESSELATION=Ja;var Jd=class extends I_{constructor(a,b){super(new IV(a,b),"image_in","norm_rect",!0),Eh(a=this.j=new Hc,0,1,b=new G0)}get baseOptions(){return Ee(this.j,G0,1)}set baseOptions(a){Eh(this.j,0,1,a)}o(a){return super.l(a)}Ka(a,b,c){if(this.h="function"==typeof b?b:c,IY(this,a,("function"!=typeof b?b:{})??{}),!this.h)return this.s}m(){var a=new Gw;Gu(a,"image_in"),Gu(a,"norm_rect"),Gv(a,"stylized_image");let b=new Gj;EQ(b,Hd,this.j);let c=new Gp;Gm(c,"mediapipe.tasks.vision.face_stylizer.FaceStylizerGraph"),Gn(c,"IMAGE:image_in"),Gn(c,"NORM_RECT:norm_rect"),Go(c,"STYLIZED_IMAGE:stylized_image"),c.o(b),Gt(a,c),this.g.V("stylized_image",(a,b)=>{var c=!this.h,d=a.data,e=a.width;let f=e*(a=a.height);if(d instanceof Uint8Array)if(d.length===3*f){let b=new Uint8ClampedArray(4*f);for(let a=0;a<f;++a)b[4*a]=d[3*a],b[4*a+1]=d[3*a+1],b[4*a+2]=d[3*a+2],b[4*a+3]=255;d=new ImageData(b,e,a)}else{if(d.length!==4*f)throw Error("Unsupported channel count: "+d.length/f);d=new ImageData(new Uint8ClampedArray(d.buffer,d.byteOffset,d.length),e,a)}else if(!(d instanceof WebGLTexture))throw Error(`Unsupported format: ${d.constructor.name}`);e=new IP([d],!1,!1,this.g.i.canvas,this.P,e,a),this.s=c=c?e.clone():e,this.h&&this.h(c),H5(this,b)}),this.g.attachEmptyPacketListener("stylized_image",a=>{this.s=null,this.h&&this.h(null),H5(this,a)}),a=a.g(),this.setGraph(new Uint8Array(a),!0)}};Jd.prototype.stylize=Jd.prototype.Ka,Jd.prototype.setOptions=Jd.prototype.o,Jd.createFromModelPath=function(a,b){return IW(Jd,a,{baseOptions:{modelAssetPath:b}})},Jd.createFromModelBuffer=function(a,b){return IW(Jd,a,{baseOptions:{modelAssetBuffer:b}})},Jd.createFromOptions=function(a,b){return IW(Jd,a,b)};var Je=IR([0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[0,17],[17,18],[18,19],[19,20]);function Jf(a){a.gestures=[],a.landmarks=[],a.worldLandmarks=[],a.handedness=[]}function Jg(a){return 0===a.gestures.length?{gestures:[],landmarks:[],worldLandmarks:[],handedness:[],handednesses:[]}:{gestures:a.gestures,landmarks:a.landmarks,worldLandmarks:a.worldLandmarks,handedness:a.handedness,handednesses:a.handedness}}function Jh(a,b=!0){let c=[];for(let e of a){var d=GC(e);for(let c of(a=[],d.g()))d=b&&null!=En(c,1)?En(c,1)??0:-1,a.push({score:Ep(c,2)??0,index:d,categoryName:Eo(c,3)??""??"",displayName:Eo(c,4)??""??""});c.push(a)}return c}var Ji=class extends I_{constructor(a,b){super(new IV(a,b),"image_in","norm_rect",!1),this.gestures=[],this.landmarks=[],this.worldLandmarks=[],this.handedness=[],Eh(a=this.j=new Hk,0,1,b=new G0),this.s=new Hj,Eh(this.j,0,2,this.s),this.C=new Hi,Eh(this.s,0,3,this.C),this.v=new Hh,Eh(this.s,0,2,this.v),this.h=new Hg,Eh(this.j,0,3,this.h),Es(this.v,2,.5),Es(this.s,4,.5),Es(this.C,2,.5)}get baseOptions(){return Ee(this.j,G0,1)}set baseOptions(a){Eh(this.j,0,1,a)}o(a){if(Er(this.v,3,a.numHands??1),"minHandDetectionConfidence"in a&&Es(this.v,2,a.minHandDetectionConfidence??.5),"minTrackingConfidence"in a&&Es(this.s,4,a.minTrackingConfidence??.5),"minHandPresenceConfidence"in a&&Es(this.C,2,a.minHandPresenceConfidence??.5),a.cannedGesturesClassifierOptions){var b=new He,c=b,d=HL(a.cannedGesturesClassifierOptions,Ee(this.h,He,3)?.h());Eh(c,0,2,d),Eh(this.h,0,3,b)}else void 0===a.cannedGesturesClassifierOptions&&Ee(this.h,He,3)?.g();return a.customGesturesClassifierOptions?(Eh(c=b=new He,0,2,d=HL(a.customGesturesClassifierOptions,Ee(this.h,He,4)?.h())),Eh(this.h,0,4,b)):void 0===a.customGesturesClassifierOptions&&Ee(this.h,He,4)?.g(),this.l(a)}Fa(a,b){return Jf(this),IY(this,a,b),Jg(this)}Ga(a,b,c){return Jf(this),IZ(this,a,c,b),Jg(this)}m(){var a=new Gw;Gu(a,"image_in"),Gu(a,"norm_rect"),Gv(a,"hand_gestures"),Gv(a,"hand_landmarks"),Gv(a,"world_hand_landmarks"),Gv(a,"handedness");let b=new Gj;EQ(b,Hp,this.j);let c=new Gp;Gm(c,"mediapipe.tasks.vision.gesture_recognizer.GestureRecognizerGraph"),Gn(c,"IMAGE:image_in"),Gn(c,"NORM_RECT:norm_rect"),Go(c,"HAND_GESTURES:hand_gestures"),Go(c,"LANDMARKS:hand_landmarks"),Go(c,"WORLD_LANDMARKS:world_hand_landmarks"),Go(c,"HANDEDNESS:handedness"),c.o(b),Gt(a,c),this.g.attachProtoVectorListener("hand_landmarks",(a,b)=>{for(let b of a){a=GK(b);let c=[];for(let b of Eg(a,GJ,1))c.push({x:Ep(b,1)??0,y:Ep(b,2)??0,z:Ep(b,3)??0,visibility:Ep(b,4)??0});this.landmarks.push(c)}H5(this,b)}),this.g.attachEmptyPacketListener("hand_landmarks",a=>{H5(this,a)}),this.g.attachProtoVectorListener("world_hand_landmarks",(a,b)=>{for(let b of a){a=GI(b);let c=[];for(let b of Eg(a,GH,1))c.push({x:Ep(b,1)??0,y:Ep(b,2)??0,z:Ep(b,3)??0,visibility:Ep(b,4)??0});this.worldLandmarks.push(c)}H5(this,b)}),this.g.attachEmptyPacketListener("world_hand_landmarks",a=>{H5(this,a)}),this.g.attachProtoVectorListener("hand_gestures",(a,b)=>{this.gestures.push(...Jh(a,!1)),H5(this,b)}),this.g.attachEmptyPacketListener("hand_gestures",a=>{H5(this,a)}),this.g.attachProtoVectorListener("handedness",(a,b)=>{this.handedness.push(...Jh(a)),H5(this,b)}),this.g.attachEmptyPacketListener("handedness",a=>{H5(this,a)}),a=a.g(),this.setGraph(new Uint8Array(a),!0)}};function Jj(a){return{landmarks:a.landmarks,worldLandmarks:a.worldLandmarks,handednesses:a.handedness,handedness:a.handedness}}Ji.prototype.recognizeForVideo=Ji.prototype.Ga,Ji.prototype.recognize=Ji.prototype.Fa,Ji.prototype.setOptions=Ji.prototype.o,Ji.createFromModelPath=function(a,b){return IW(Ji,a,{baseOptions:{modelAssetPath:b}})},Ji.createFromModelBuffer=function(a,b){return IW(Ji,a,{baseOptions:{modelAssetBuffer:b}})},Ji.createFromOptions=function(a,b){return IW(Ji,a,b)},Ji.HAND_CONNECTIONS=Je;var Jk=class extends I_{constructor(a,b){super(new IV(a,b),"image_in","norm_rect",!1),this.landmarks=[],this.worldLandmarks=[],this.handedness=[],Eh(a=this.h=new Hj,0,1,b=new G0),this.s=new Hi,Eh(this.h,0,3,this.s),this.j=new Hh,Eh(this.h,0,2,this.j),Er(this.j,3,1),Es(this.j,2,.5),Es(this.s,2,.5),Es(this.h,4,.5)}get baseOptions(){return Ee(this.h,G0,1)}set baseOptions(a){Eh(this.h,0,1,a)}o(a){return"numHands"in a&&Er(this.j,3,a.numHands??1),"minHandDetectionConfidence"in a&&Es(this.j,2,a.minHandDetectionConfidence??.5),"minTrackingConfidence"in a&&Es(this.h,4,a.minTrackingConfidence??.5),"minHandPresenceConfidence"in a&&Es(this.s,2,a.minHandPresenceConfidence??.5),this.l(a)}D(a,b){return this.landmarks=[],this.worldLandmarks=[],this.handedness=[],IY(this,a,b),Jj(this)}F(a,b,c){return this.landmarks=[],this.worldLandmarks=[],this.handedness=[],IZ(this,a,c,b),Jj(this)}m(){var a=new Gw;Gu(a,"image_in"),Gu(a,"norm_rect"),Gv(a,"hand_landmarks"),Gv(a,"world_hand_landmarks"),Gv(a,"handedness");let b=new Gj;EQ(b,Hq,this.h);let c=new Gp;Gm(c,"mediapipe.tasks.vision.hand_landmarker.HandLandmarkerGraph"),Gn(c,"IMAGE:image_in"),Gn(c,"NORM_RECT:norm_rect"),Go(c,"LANDMARKS:hand_landmarks"),Go(c,"WORLD_LANDMARKS:world_hand_landmarks"),Go(c,"HANDEDNESS:handedness"),c.o(b),Gt(a,c),this.g.attachProtoVectorListener("hand_landmarks",(a,b)=>{for(let b of a)a=GK(b),this.landmarks.push(HO(a));H5(this,b)}),this.g.attachEmptyPacketListener("hand_landmarks",a=>{H5(this,a)}),this.g.attachProtoVectorListener("world_hand_landmarks",(a,b)=>{for(let b of a)a=GI(b),this.worldLandmarks.push(HP(a));H5(this,b)}),this.g.attachEmptyPacketListener("world_hand_landmarks",a=>{H5(this,a)}),this.g.attachProtoVectorListener("handedness",(a,b)=>{var c=this.handedness,d=c.push;let e=[];for(let b of a){a=GC(b);let c=[];for(let b of a.g())c.push({score:Ep(b,2)??0,index:En(b,1)??0??-1,categoryName:Eo(b,3)??""??"",displayName:Eo(b,4)??""??""});e.push(c)}d.call(c,...e),H5(this,b)}),this.g.attachEmptyPacketListener("handedness",a=>{H5(this,a)}),a=a.g(),this.setGraph(new Uint8Array(a),!0)}};Jk.prototype.detectForVideo=Jk.prototype.F,Jk.prototype.detect=Jk.prototype.D,Jk.prototype.setOptions=Jk.prototype.o,Jk.createFromModelPath=function(a,b){return IW(Jk,a,{baseOptions:{modelAssetPath:b}})},Jk.createFromModelBuffer=function(a,b){return IW(Jk,a,{baseOptions:{modelAssetBuffer:b}})},Jk.createFromOptions=function(a,b){return IW(Jk,a,b)},Jk.HAND_CONNECTIONS=Je;var Jl=IR([0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]);function Jm(a){a.h={faceLandmarks:[],faceBlendshapes:[],poseLandmarks:[],poseWorldLandmarks:[],poseSegmentationMasks:[],leftHandLandmarks:[],leftHandWorldLandmarks:[],rightHandLandmarks:[],rightHandWorldLandmarks:[]}}function Jn(a){try{if(!a.C)return a.h;a.C(a.h)}finally{H8(a)}}function Jo(a,b){a=GK(a),b.push(HO(a))}var Jp=class extends I_{constructor(a,b){super(new IV(a,b),"input_frames_image",null,!1),this.h={faceLandmarks:[],faceBlendshapes:[],poseLandmarks:[],poseWorldLandmarks:[],poseSegmentationMasks:[],leftHandLandmarks:[],leftHandWorldLandmarks:[],rightHandLandmarks:[],rightHandWorldLandmarks:[]},this.outputPoseSegmentationMasks=this.outputFaceBlendshapes=!1,Eh(a=this.j=new Hu,0,1,b=new G0),this.K=new Hi,Eh(this.j,0,2,this.K),this.Y=new Hr,Eh(this.j,0,3,this.Y),this.s=new G3,Eh(this.j,0,4,this.s),this.H=new G7,Eh(this.j,0,5,this.H),this.v=new Hs,Eh(this.j,0,6,this.v),this.L=new Ht,Eh(this.j,0,7,this.L),Es(this.s,2,.5),Es(this.s,3,.3),Es(this.H,2,.5),Es(this.v,2,.5),Es(this.v,3,.3),Es(this.L,2,.5),Es(this.K,2,.5)}get baseOptions(){return Ee(this.j,G0,1)}set baseOptions(a){Eh(this.j,0,1,a)}o(a){return"minFaceDetectionConfidence"in a&&Es(this.s,2,a.minFaceDetectionConfidence??.5),"minFaceSuppressionThreshold"in a&&Es(this.s,3,a.minFaceSuppressionThreshold??.3),"minFacePresenceConfidence"in a&&Es(this.H,2,a.minFacePresenceConfidence??.5),"outputFaceBlendshapes"in a&&(this.outputFaceBlendshapes=!!a.outputFaceBlendshapes),"minPoseDetectionConfidence"in a&&Es(this.v,2,a.minPoseDetectionConfidence??.5),"minPoseSuppressionThreshold"in a&&Es(this.v,3,a.minPoseSuppressionThreshold??.3),"minPosePresenceConfidence"in a&&Es(this.L,2,a.minPosePresenceConfidence??.5),"outputPoseSegmentationMasks"in a&&(this.outputPoseSegmentationMasks=!!a.outputPoseSegmentationMasks),"minHandLandmarksConfidence"in a&&Es(this.K,2,a.minHandLandmarksConfidence??.5),this.l(a)}D(a,b,c){return this.C="function"==typeof b?b:c,Jm(this),IY(this,a,"function"!=typeof b?b:{}),Jn(this)}F(a,b,c,d){return this.C="function"==typeof c?c:d,Jm(this),IZ(this,a,"function"!=typeof c?c:{},b),Jn(this)}m(){var a=new Gw;Gu(a,"input_frames_image"),Gv(a,"pose_landmarks"),Gv(a,"pose_world_landmarks"),Gv(a,"face_landmarks"),Gv(a,"left_hand_landmarks"),Gv(a,"left_hand_world_landmarks"),Gv(a,"right_hand_landmarks"),Gv(a,"right_hand_world_landmarks");let b=new Gj,c=new F6;D6(c,1,Dy("type.googleapis.com/mediapipe.tasks.vision.holistic_landmarker.proto.HolisticLandmarkerGraphOptions"),""),function(a,b){if(null!=b)if(Array.isArray(b))DY(a,2,DO(b,DQ,void 0,void 0,!1));else{if(!("string"==typeof b||b instanceof Cj||Cf(b)))throw Error("invalid value in Any.value field: "+b+" expected a ByteString, a base64 encoded string, a Uint8Array or a jspb array");D6(a,2,CJ(b,!1),Ch())}}(c,this.j.g());let d=new Gp;Gm(d,"mediapipe.tasks.vision.holistic_landmarker.HolisticLandmarkerGraph"),Em(d,8,F6,c),Gn(d,"IMAGE:input_frames_image"),Go(d,"POSE_LANDMARKS:pose_landmarks"),Go(d,"POSE_WORLD_LANDMARKS:pose_world_landmarks"),Go(d,"FACE_LANDMARKS:face_landmarks"),Go(d,"LEFT_HAND_LANDMARKS:left_hand_landmarks"),Go(d,"LEFT_HAND_WORLD_LANDMARKS:left_hand_world_landmarks"),Go(d,"RIGHT_HAND_LANDMARKS:right_hand_landmarks"),Go(d,"RIGHT_HAND_WORLD_LANDMARKS:right_hand_world_landmarks"),d.o(b),Gt(a,d),H6(this,a),this.g.attachProtoListener("pose_landmarks",(a,b)=>{Jo(a,this.h.poseLandmarks),H5(this,b)}),this.g.attachEmptyPacketListener("pose_landmarks",a=>{H5(this,a)}),this.g.attachProtoListener("pose_world_landmarks",(a,b)=>{var c=this.h.poseWorldLandmarks;a=GI(a),c.push(HP(a)),H5(this,b)}),this.g.attachEmptyPacketListener("pose_world_landmarks",a=>{H5(this,a)}),this.outputPoseSegmentationMasks&&(Go(d,"POSE_SEGMENTATION_MASK:pose_segmentation_mask"),H7(this,"pose_segmentation_mask"),this.g.V("pose_segmentation_mask",(a,b)=>{this.h.poseSegmentationMasks=[I$(this,a,!0,!this.C)],H5(this,b)}),this.g.attachEmptyPacketListener("pose_segmentation_mask",a=>{this.h.poseSegmentationMasks=[],H5(this,a)})),this.g.attachProtoListener("face_landmarks",(a,b)=>{Jo(a,this.h.faceLandmarks),H5(this,b)}),this.g.attachEmptyPacketListener("face_landmarks",a=>{H5(this,a)}),this.outputFaceBlendshapes&&(Gv(a,"extra_blendshapes"),Go(d,"FACE_BLENDSHAPES:extra_blendshapes"),this.g.attachProtoListener("extra_blendshapes",(a,b)=>{var c=this.h.faceBlendshapes;this.outputFaceBlendshapes&&(a=GC(a),c.push(HM(a.g()??[]))),H5(this,b)}),this.g.attachEmptyPacketListener("extra_blendshapes",a=>{H5(this,a)})),this.g.attachProtoListener("left_hand_landmarks",(a,b)=>{Jo(a,this.h.leftHandLandmarks),H5(this,b)}),this.g.attachEmptyPacketListener("left_hand_landmarks",a=>{H5(this,a)}),this.g.attachProtoListener("left_hand_world_landmarks",(a,b)=>{var c=this.h.leftHandWorldLandmarks;a=GI(a),c.push(HP(a)),H5(this,b)}),this.g.attachEmptyPacketListener("left_hand_world_landmarks",a=>{H5(this,a)}),this.g.attachProtoListener("right_hand_landmarks",(a,b)=>{Jo(a,this.h.rightHandLandmarks),H5(this,b)}),this.g.attachEmptyPacketListener("right_hand_landmarks",a=>{H5(this,a)}),this.g.attachProtoListener("right_hand_world_landmarks",(a,b)=>{var c=this.h.rightHandWorldLandmarks;a=GI(a),c.push(HP(a)),H5(this,b)}),this.g.attachEmptyPacketListener("right_hand_world_landmarks",a=>{H5(this,a)}),a=a.g(),this.setGraph(new Uint8Array(a),!0)}};Jp.prototype.detectForVideo=Jp.prototype.F,Jp.prototype.detect=Jp.prototype.D,Jp.prototype.setOptions=Jp.prototype.o,Jp.createFromModelPath=function(a,b){return IW(Jp,a,{baseOptions:{modelAssetPath:b}})},Jp.createFromModelBuffer=function(a,b){return IW(Jp,a,{baseOptions:{modelAssetBuffer:b}})},Jp.createFromOptions=function(a,b){return IW(Jp,a,b)},Jp.HAND_CONNECTIONS=Je,Jp.POSE_CONNECTIONS=Jl,Jp.FACE_LANDMARKS_LIPS=I1,Jp.FACE_LANDMARKS_LEFT_EYE=I2,Jp.FACE_LANDMARKS_LEFT_EYEBROW=I3,Jp.FACE_LANDMARKS_LEFT_IRIS=I4,Jp.FACE_LANDMARKS_RIGHT_EYE=I5,Jp.FACE_LANDMARKS_RIGHT_EYEBROW=I6,Jp.FACE_LANDMARKS_RIGHT_IRIS=I7,Jp.FACE_LANDMARKS_FACE_OVAL=I8,Jp.FACE_LANDMARKS_CONTOURS=I9,Jp.FACE_LANDMARKS_TESSELATION=Ja;var Jq=class extends I_{constructor(a,b){super(new IV(a,b),"input_image","norm_rect",!0),this.j={classifications:[]},Eh(a=this.h=new Hx,0,1,b=new G0)}get baseOptions(){return Ee(this.h,G0,1)}set baseOptions(a){Eh(this.h,0,1,a)}o(a){return Eh(this.h,0,2,HL(a,Ee(this.h,GV,2))),this.l(a)}qa(a,b){return this.j={classifications:[]},IY(this,a,b),this.j}ra(a,b,c){return this.j={classifications:[]},IZ(this,a,c,b),this.j}m(){var a=new Gw;Gu(a,"input_image"),Gu(a,"norm_rect"),Gv(a,"classifications");let b=new Gj;EQ(b,Hy,this.h);let c=new Gp;Gm(c,"mediapipe.tasks.vision.image_classifier.ImageClassifierGraph"),Gn(c,"IMAGE:input_image"),Gn(c,"NORM_RECT:norm_rect"),Go(c,"CLASSIFICATIONS:classifications"),c.o(b),Gt(a,c),this.g.attachProtoListener("classifications",(a,b)=>{var c;let d;this.j=(d={classifications:Eg(c=GP(a),GO,1).map(a=>HM(Ee(a,GA,4)?.g()??[],En(a,2)??0,Eo(a,3)??""))},null!=Dw(DW(c,2))&&(d.timestampMs=Dw(DW(c,2))??0),d),H5(this,b)}),this.g.attachEmptyPacketListener("classifications",a=>{H5(this,a)}),a=a.g(),this.setGraph(new Uint8Array(a),!0)}};Jq.prototype.classifyForVideo=Jq.prototype.ra,Jq.prototype.classify=Jq.prototype.qa,Jq.prototype.setOptions=Jq.prototype.o,Jq.createFromModelPath=function(a,b){return IW(Jq,a,{baseOptions:{modelAssetPath:b}})},Jq.createFromModelBuffer=function(a,b){return IW(Jq,a,{baseOptions:{modelAssetBuffer:b}})},Jq.createFromOptions=function(a,b){return IW(Jq,a,b)};var Jr=class extends I_{constructor(a,b){super(new IV(a,b),"image_in","norm_rect",!0),this.h=new Hz,this.embeddings={embeddings:[]},Eh(a=this.h,0,1,b=new G0)}get baseOptions(){return Ee(this.h,G0,1)}set baseOptions(a){Eh(this.h,0,1,a)}o(a){var b=this.h,c=Ee(this.h,GX,2);return c=c?c.clone():new GX,void 0!==a.l2Normalize?Eq(c,1,a.l2Normalize):"l2Normalize"in a&&DY(c,1),void 0!==a.quantize?Eq(c,2,a.quantize):"quantize"in a&&DY(c,2),Eh(b,0,2,c),this.l(a)}xa(a,b){return IY(this,a,b),this.embeddings}ya(a,b,c){return IZ(this,a,c,b),this.embeddings}m(){var a=new Gw;Gu(a,"image_in"),Gu(a,"norm_rect"),Gv(a,"embeddings_out");let b=new Gj;EQ(b,HA,this.h);let c=new Gp;Gm(c,"mediapipe.tasks.vision.image_embedder.ImageEmbedderGraph"),Gn(c,"IMAGE:image_in"),Gn(c,"NORM_RECT:norm_rect"),Go(c,"EMBEDDINGS:embeddings_out"),c.o(b),Gt(a,c),this.g.attachProtoListener("embeddings_out",(a,b)=>{var c;a=GU(a),this.embeddings={embeddings:Eg(c=a,GS,1).map(a=>{let b={headIndex:En(a,3)??0??-1,headName:Eo(a,4)??""??""};if(void 0!==Ed(a,GQ,D8(a,1)))b.floatEmbedding=(a=D1(a=Ee(a,GQ,D8(a,1)),1,Dj,D0())).slice();else{let c=new Uint8Array(0);b.quantizedEmbedding=Ee(a,GR,D8(a,2))?.ma()?.h()??c}return b}),timestampMs:Dw(DW(c,2))??0},H5(this,b)}),this.g.attachEmptyPacketListener("embeddings_out",a=>{H5(this,a)}),a=a.g(),this.setGraph(new Uint8Array(a),!0)}};Jr.cosineSimilarity=function(a,b){if(a.floatEmbedding&&b.floatEmbedding)a=HR(a.floatEmbedding,b.floatEmbedding);else{if(!a.quantizedEmbedding||!b.quantizedEmbedding)throw Error("Cannot compute cosine similarity between quantized and float embeddings.");a=HR(HQ(a.quantizedEmbedding),HQ(b.quantizedEmbedding))}return a},Jr.prototype.embedForVideo=Jr.prototype.ya,Jr.prototype.embed=Jr.prototype.xa,Jr.prototype.setOptions=Jr.prototype.o,Jr.createFromModelPath=function(a,b){return IW(Jr,a,{baseOptions:{modelAssetPath:b}})},Jr.createFromModelBuffer=function(a,b){return IW(Jr,a,{baseOptions:{modelAssetBuffer:b}})},Jr.createFromOptions=function(a,b){return IW(Jr,a,b)};var Js=class{constructor(a,b,c){this.confidenceMasks=a,this.categoryMask=b,this.qualityScores=c}close(){this.confidenceMasks?.forEach(a=>{a.close()}),this.categoryMask?.close()}};function Jt(a){a.categoryMask=void 0,a.confidenceMasks=void 0,a.qualityScores=void 0}function Ju(a){try{let b=new Js(a.confidenceMasks,a.categoryMask,a.qualityScores);if(!a.j)return b;a.j(b)}finally{H8(a)}}Js.prototype.close=Js.prototype.close;var Jv=class extends I_{constructor(a,b){super(new IV(a,b),"image_in","norm_rect",!1),this.s=[],this.outputCategoryMask=!1,this.outputConfidenceMasks=!0,this.h=new HF,this.v=new HB,Eh(this.h,0,3,this.v),Eh(a=this.h,0,1,b=new G0)}get baseOptions(){return Ee(this.h,G0,1)}set baseOptions(a){Eh(this.h,0,1,a)}o(a){return void 0!==a.displayNamesLocale?DY(this.h,2,Dy(a.displayNamesLocale)):"displayNamesLocale"in a&&DY(this.h,2),"outputCategoryMask"in a&&(this.outputCategoryMask=a.outputCategoryMask??!1),"outputConfidenceMasks"in a&&(this.outputConfidenceMasks=a.outputConfidenceMasks??!0),super.l(a)}J(){var a=this;let b=Eg(a.ca(),Gp,1).filter(a=>(Eo(a,1)??"").includes("mediapipe.tasks.TensorsToSegmentationCalculator"));if(a.s=[],b.length>1)throw Error("The graph has more than one mediapipe.tasks.TensorsToSegmentationCalculator.");1===b.length&&(Ee(b[0],Gj,7)?.l()?.g()??new Map).forEach((b,c)=>{a.s[Number(c)]=Eo(b,1)??""})}segment(a,b,c){return this.j="function"==typeof b?b:c,Jt(this),IY(this,a,"function"!=typeof b?b:{}),Ju(this)}Ia(a,b,c,d){return this.j="function"==typeof c?c:d,Jt(this),IZ(this,a,"function"!=typeof c?c:{},b),Ju(this)}Ba(){return this.s}m(){var a=new Gw;Gu(a,"image_in"),Gu(a,"norm_rect");let b=new Gj;EQ(b,HG,this.h);let c=new Gp;Gm(c,"mediapipe.tasks.vision.image_segmenter.ImageSegmenterGraph"),Gn(c,"IMAGE:image_in"),Gn(c,"NORM_RECT:norm_rect"),c.o(b),Gt(a,c),H6(this,a),this.outputConfidenceMasks&&(Gv(a,"confidence_masks"),Go(c,"CONFIDENCE_MASKS:confidence_masks"),H7(this,"confidence_masks"),this.g.ba("confidence_masks",(a,b)=>{this.confidenceMasks=a.map(a=>I$(this,a,!0,!this.j)),H5(this,b)}),this.g.attachEmptyPacketListener("confidence_masks",a=>{this.confidenceMasks=[],H5(this,a)})),this.outputCategoryMask&&(Gv(a,"category_mask"),Go(c,"CATEGORY_MASK:category_mask"),H7(this,"category_mask"),this.g.V("category_mask",(a,b)=>{this.categoryMask=I$(this,a,!1,!this.j),H5(this,b)}),this.g.attachEmptyPacketListener("category_mask",a=>{this.categoryMask=void 0,H5(this,a)})),Gv(a,"quality_scores"),Go(c,"QUALITY_SCORES:quality_scores"),this.g.attachFloatVectorListener("quality_scores",(a,b)=>{this.qualityScores=a,H5(this,b)}),this.g.attachEmptyPacketListener("quality_scores",a=>{this.categoryMask=void 0,H5(this,a)}),a=a.g(),this.setGraph(new Uint8Array(a),!0)}};Jv.prototype.getLabels=Jv.prototype.Ba,Jv.prototype.segmentForVideo=Jv.prototype.Ia,Jv.prototype.segment=Jv.prototype.segment,Jv.prototype.setOptions=Jv.prototype.o,Jv.createFromModelPath=function(a,b){return IW(Jv,a,{baseOptions:{modelAssetPath:b}})},Jv.createFromModelBuffer=function(a,b){return IW(Jv,a,{baseOptions:{modelAssetBuffer:b}})},Jv.createFromOptions=function(a,b){return IW(Jv,a,b)};var Jw=class{constructor(a,b,c){this.confidenceMasks=a,this.categoryMask=b,this.qualityScores=c}close(){this.confidenceMasks?.forEach(a=>{a.close()}),this.categoryMask?.close()}};Jw.prototype.close=Jw.prototype.close;var Jx=class extends ER{constructor(a){super(a)}},Jy=[0,FQ,-2],Jz=[0,FJ,-3,FT,FJ,-1],JA=[0,Jz],JB=[0,Jz,FQ,-1],JC=class extends ER{constructor(a){super(a)}},JD=[0,FJ,-1,FT],JE=class extends ER{constructor(a){super(a)}},JF=class extends ER{constructor(a){super(a)}},JG=[1,2,3,4,5,6,7,8,9,10,14,15],JH=class extends ER{constructor(a){super(a)}};JH.prototype.g=F5([0,FY,[0,JG,FZ,Jz,FZ,[0,Jz,Jy],FZ,JA,FZ,[0,JA,Jy],FZ,JD,FZ,[0,FJ,-3,FT,F1],FZ,[0,FJ,-3,FT],FZ,[0,FX,FJ,-2,FT,FQ,FT,-1,2,FJ,Jy],FZ,JB,FZ,[0,JB,Jy],FJ,Jy,FX,FZ,[0,FJ,-3,FT,Jy,-1],FZ,[0,FY,JD]],FX,[0,FX,FQ,-1,FT]]);var JI=class extends I_{constructor(a,b){super(new IV(a,b),"image_in","norm_rect_in",!1),this.outputCategoryMask=!1,this.outputConfidenceMasks=!0,this.h=new HF,this.s=new HB,Eh(this.h,0,3,this.s),Eh(a=this.h,0,1,b=new G0)}get baseOptions(){return Ee(this.h,G0,1)}set baseOptions(a){Eh(this.h,0,1,a)}o(a){return"outputCategoryMask"in a&&(this.outputCategoryMask=a.outputCategoryMask??!1),"outputConfidenceMasks"in a&&(this.outputConfidenceMasks=a.outputConfidenceMasks??!0),super.l(a)}segment(a,b,c,d){let e="function"!=typeof c?c:{};this.j="function"==typeof c?c:d,this.qualityScores=this.categoryMask=this.confidenceMasks=void 0,c=this.B+1,d=new JH;let f=new JF;var g=new Jx;if(Er(g,1,255),Eh(f,0,12,g),b.keypoint&&b.scribble)throw Error("Cannot provide both keypoint and scribble.");if(b.keypoint){var h=new JC;Eq(h,3,!0),Es(h,1,b.keypoint.x),Es(h,2,b.keypoint.y),Ei(f,5,JG,h)}else{if(!b.scribble)throw Error("Must provide either a keypoint or a scribble.");for(h of(g=new JE,b.scribble))Eq(b=new JC,3,!0),Es(b,1,h.x),Es(b,2,h.y),Em(g,1,JC,b);Ei(f,15,JG,g)}Em(d,1,JF,f),this.g.addProtoToStream(d.g(),"drishti.RenderData","roi_in",c),IY(this,a,e);a:{try{let a=new Jw(this.confidenceMasks,this.categoryMask,this.qualityScores);if(!this.j){var i=a;break a}this.j(a)}finally{H8(this)}i=void 0}return i}m(){var a=new Gw;Gu(a,"image_in"),Gu(a,"roi_in"),Gu(a,"norm_rect_in");let b=new Gj;EQ(b,HG,this.h);let c=new Gp;Gm(c,"mediapipe.tasks.vision.interactive_segmenter.InteractiveSegmenterGraph"),Gn(c,"IMAGE:image_in"),Gn(c,"ROI:roi_in"),Gn(c,"NORM_RECT:norm_rect_in"),c.o(b),Gt(a,c),H6(this,a),this.outputConfidenceMasks&&(Gv(a,"confidence_masks"),Go(c,"CONFIDENCE_MASKS:confidence_masks"),H7(this,"confidence_masks"),this.g.ba("confidence_masks",(a,b)=>{this.confidenceMasks=a.map(a=>I$(this,a,!0,!this.j)),H5(this,b)}),this.g.attachEmptyPacketListener("confidence_masks",a=>{this.confidenceMasks=[],H5(this,a)})),this.outputCategoryMask&&(Gv(a,"category_mask"),Go(c,"CATEGORY_MASK:category_mask"),H7(this,"category_mask"),this.g.V("category_mask",(a,b)=>{this.categoryMask=I$(this,a,!1,!this.j),H5(this,b)}),this.g.attachEmptyPacketListener("category_mask",a=>{this.categoryMask=void 0,H5(this,a)})),Gv(a,"quality_scores"),Go(c,"QUALITY_SCORES:quality_scores"),this.g.attachFloatVectorListener("quality_scores",(a,b)=>{this.qualityScores=a,H5(this,b)}),this.g.attachEmptyPacketListener("quality_scores",a=>{this.categoryMask=void 0,H5(this,a)}),a=a.g(),this.setGraph(new Uint8Array(a),!0)}};JI.prototype.segment=JI.prototype.segment,JI.prototype.setOptions=JI.prototype.o,JI.createFromModelPath=function(a,b){return IW(JI,a,{baseOptions:{modelAssetPath:b}})},JI.createFromModelBuffer=function(a,b){return IW(JI,a,{baseOptions:{modelAssetBuffer:b}})},JI.createFromOptions=function(a,b){return IW(JI,a,b)};var JJ=class extends I_{constructor(a,b){super(new IV(a,b),"input_frame_gpu","norm_rect",!1),this.j={detections:[]},Eh(a=this.h=new HH,0,1,b=new G0)}get baseOptions(){return Ee(this.h,G0,1)}set baseOptions(a){Eh(this.h,0,1,a)}o(a){return void 0!==a.displayNamesLocale?DY(this.h,2,Dy(a.displayNamesLocale)):"displayNamesLocale"in a&&DY(this.h,2),void 0!==a.maxResults?Er(this.h,3,a.maxResults):"maxResults"in a&&DY(this.h,3),void 0!==a.scoreThreshold?Es(this.h,4,a.scoreThreshold):"scoreThreshold"in a&&DY(this.h,4),void 0!==a.categoryAllowlist?Et(this.h,5,a.categoryAllowlist):"categoryAllowlist"in a&&DY(this.h,5),void 0!==a.categoryDenylist?Et(this.h,6,a.categoryDenylist):"categoryDenylist"in a&&DY(this.h,6),this.l(a)}D(a,b){return this.j={detections:[]},IY(this,a,b),this.j}F(a,b,c){return this.j={detections:[]},IZ(this,a,c,b),this.j}m(){var a=new Gw;Gu(a,"input_frame_gpu"),Gu(a,"norm_rect"),Gv(a,"detections");let b=new Gj;EQ(b,HI,this.h);let c=new Gp;Gm(c,"mediapipe.tasks.vision.ObjectDetectorGraph"),Gn(c,"IMAGE:input_frame_gpu"),Gn(c,"NORM_RECT:norm_rect"),Go(c,"DETECTIONS:detections"),c.o(b),Gt(a,c),this.g.attachProtoVectorListener("detections",(a,b)=>{for(let b of a)a=GG(b),this.j.detections.push(HN(a));H5(this,b)}),this.g.attachEmptyPacketListener("detections",a=>{H5(this,a)}),a=a.g(),this.setGraph(new Uint8Array(a),!0)}};JJ.prototype.detectForVideo=JJ.prototype.F,JJ.prototype.detect=JJ.prototype.D,JJ.prototype.setOptions=JJ.prototype.o,JJ.createFromModelPath=async function(a,b){return IW(JJ,a,{baseOptions:{modelAssetPath:b}})},JJ.createFromModelBuffer=function(a,b){return IW(JJ,a,{baseOptions:{modelAssetBuffer:b}})},JJ.createFromOptions=function(a,b){return IW(JJ,a,b)};var JK=class{constructor(a,b,c){this.landmarks=a,this.worldLandmarks=b,this.segmentationMasks=c}close(){this.segmentationMasks?.forEach(a=>{a.close()})}};function JL(a){a.landmarks=[],a.worldLandmarks=[],a.segmentationMasks=void 0}function JM(a){try{let b=new JK(a.landmarks,a.worldLandmarks,a.segmentationMasks);if(!a.s)return b;a.s(b)}finally{H8(a)}}JK.prototype.close=JK.prototype.close;var JN=class extends I_{constructor(a,b){super(new IV(a,b),"image_in","norm_rect",!1),this.landmarks=[],this.worldLandmarks=[],this.outputSegmentationMasks=!1,Eh(a=this.h=new HJ,0,1,b=new G0),this.v=new Ht,Eh(this.h,0,3,this.v),this.j=new Hs,Eh(this.h,0,2,this.j),Er(this.j,4,1),Es(this.j,2,.5),Es(this.v,2,.5),Es(this.h,4,.5)}get baseOptions(){return Ee(this.h,G0,1)}set baseOptions(a){Eh(this.h,0,1,a)}o(a){return"numPoses"in a&&Er(this.j,4,a.numPoses??1),"minPoseDetectionConfidence"in a&&Es(this.j,2,a.minPoseDetectionConfidence??.5),"minTrackingConfidence"in a&&Es(this.h,4,a.minTrackingConfidence??.5),"minPosePresenceConfidence"in a&&Es(this.v,2,a.minPosePresenceConfidence??.5),"outputSegmentationMasks"in a&&(this.outputSegmentationMasks=a.outputSegmentationMasks??!1),this.l(a)}D(a,b,c){return this.s="function"==typeof b?b:c,JL(this),IY(this,a,"function"!=typeof b?b:{}),JM(this)}F(a,b,c,d){return this.s="function"==typeof c?c:d,JL(this),IZ(this,a,"function"!=typeof c?c:{},b),JM(this)}m(){var a=new Gw;Gu(a,"image_in"),Gu(a,"norm_rect"),Gv(a,"normalized_landmarks"),Gv(a,"world_landmarks"),Gv(a,"segmentation_masks");let b=new Gj;EQ(b,HK,this.h);let c=new Gp;Gm(c,"mediapipe.tasks.vision.pose_landmarker.PoseLandmarkerGraph"),Gn(c,"IMAGE:image_in"),Gn(c,"NORM_RECT:norm_rect"),Go(c,"NORM_LANDMARKS:normalized_landmarks"),Go(c,"WORLD_LANDMARKS:world_landmarks"),c.o(b),Gt(a,c),H6(this,a),this.g.attachProtoVectorListener("normalized_landmarks",(a,b)=>{for(let b of(this.landmarks=[],a))a=GK(b),this.landmarks.push(HO(a));H5(this,b)}),this.g.attachEmptyPacketListener("normalized_landmarks",a=>{this.landmarks=[],H5(this,a)}),this.g.attachProtoVectorListener("world_landmarks",(a,b)=>{for(let b of(this.worldLandmarks=[],a))a=GI(b),this.worldLandmarks.push(HP(a));H5(this,b)}),this.g.attachEmptyPacketListener("world_landmarks",a=>{this.worldLandmarks=[],H5(this,a)}),this.outputSegmentationMasks&&(Go(c,"SEGMENTATION_MASK:segmentation_masks"),H7(this,"segmentation_masks"),this.g.ba("segmentation_masks",(a,b)=>{this.segmentationMasks=a.map(a=>I$(this,a,!0,!this.s)),H5(this,b)}),this.g.attachEmptyPacketListener("segmentation_masks",a=>{this.segmentationMasks=[],H5(this,a)})),a=a.g(),this.setGraph(new Uint8Array(a),!0)}};async function JO(){}function JP(){return null}async function JQ(){}function JR(){return null}async function JS(a){return null}JN.prototype.detectForVideo=JN.prototype.F,JN.prototype.detect=JN.prototype.D,JN.prototype.setOptions=JN.prototype.o,JN.createFromModelPath=function(a,b){return IW(JN,a,{baseOptions:{modelAssetPath:b}})},JN.createFromModelBuffer=function(a,b){return IW(JN,a,{baseOptions:{modelAssetBuffer:b}})},JN.createFromOptions=function(a,b){return IW(JN,a,b)},JN.POSE_CONNECTIONS=Jl,a.s(["ensureFaceMeshLoaded",()=>JQ,"getFaceMeshModel",()=>JR,"getObjectDetector",()=>JP,"loadModels",()=>JO,"runFaceMesh",()=>JS],708720);let JT=new class{audioContext=null;oscillator=null;gainNode=null;constructor(){}initAudio=()=>{if(!this.audioContext)try{this.audioContext=new(window.AudioContext||window.webkitAudioContext),this.gainNode=this.audioContext.createGain(),this.gainNode.gain.value=.3,this.gainNode.connect(this.audioContext.destination)}catch(a){console.warn("Web Audio API not supported",a)}};play(){this.audioContext||this.initAudio(),this.audioContext&&this.gainNode&&(this.oscillator&&this.oscillator.stop(),this.oscillator=this.audioContext.createOscillator(),this.oscillator.type="sine",this.oscillator.frequency.setValueAtTime(880,this.audioContext.currentTime),this.oscillator.frequency.exponentialRampToValueAtTime(440,this.audioContext.currentTime+.5),this.oscillator.connect(this.gainNode),this.oscillator.start(),this.oscillator.stop(this.audioContext.currentTime+1))}},JU=[33,160,158,133,153,144],JV=[263,387,385,362,380,373];class JW{minCutoff;beta;dCutoff;dxPrev=0;xPrev=null;tPrev=null;constructor(a=1,b=0,c=1){this.minCutoff=a,this.beta=b,this.dCutoff=c}filter(a,b=Date.now()){if(null===this.xPrev||null===this.tPrev)return this.xPrev=a,this.tPrev=b,a;let c=(b-this.tPrev)/1e3;if(0===c)return this.xPrev;let d=this.smoothingFactor(c,this.dCutoff),e=(a-this.xPrev)/c,f=this.exponentialSmoothing(d,e,this.dxPrev),g=this.minCutoff+this.beta*Math.abs(f),h=this.smoothingFactor(c,g),i=this.exponentialSmoothing(h,a,this.xPrev);return this.xPrev=i,this.dxPrev=f,this.tPrev=b,i}smoothingFactor(a,b){let c=2*Math.PI*b;return c*a/(1+c*a)}exponentialSmoothing(a,b,c){return a*b+(1-a)*c}reset(){this.xPrev=null,this.tPrev=null,this.dxPrev=0}}class JX{calibration={openBaseline:.3,closedBaseline:.1,isInitialized:!1,samples:0};opennessFilter=new JW(2,.01,1);velocityFilter=new JW(10,0);lastMetric=.3;lastTime=0;blinkStartTime=null;microsleepStartTime=null;constructor(){this.lastTime=Date.now()}processFrame(a){let b=Date.now(),c=this.getEyeGeometry(a,JU),d=this.getEyeGeometry(a,JV);if(!c||!d)return null;let e=(c.ear+d.ear)/2;this.updateCalibration(e);let f=this.computePerceptualOpenness(e),g=this.opennessFilter.filter(f,b),h=(b-this.lastTime)/1e3,i=0;h>0&&(i=(g-this.lastMetric)/h),this.lastMetric=g,this.lastTime=b;let j=this.detectEvents(g,i,b);return{opennessPercent:g,rawOpennessMetric:e,velocity:i,...j}}getEyeGeometry(a,b){let c=b.map(b=>a[b]);if(c.some(a=>!a))return null;let[d,e,f,g,h,i]=c,j=this.distance(e,i),k=this.distance(f,h),l=this.distance(d,g);return l<1e-4?null:{ear:(j+k)/(2*l),verticalDist:(j+k)/2,horizontalWith:l,upperLidCurvature:0}}distance(a,b){return Math.sqrt(Math.pow(a.x-b.x,2)+Math.pow(a.y-b.y,2))}updateCalibration(a){if(!this.calibration.isInitialized)if(this.calibration.samples<60){this.calibration.openBaseline=Math.max(.25,Math.max(this.calibration.openBaseline,a)),this.calibration.closedBaseline=Math.min(.15,Math.min(this.calibration.closedBaseline,a)),this.calibration.samples++;return}else this.calibration.isInitialized=!0;a>.2&&(a>this.calibration.openBaseline?this.calibration.openBaseline=.05*a+.95*this.calibration.openBaseline:this.calibration.openBaseline=this.calibration.openBaseline-.001*this.calibration.openBaseline),a<.2&&(a<this.calibration.closedBaseline?this.calibration.closedBaseline=.05*a+.95*this.calibration.closedBaseline:this.calibration.closedBaseline=this.calibration.closedBaseline+.001*this.calibration.closedBaseline),this.calibration.openBaseline=Math.max(.24,Math.min(.45,this.calibration.openBaseline)),this.calibration.closedBaseline=Math.max(.05,Math.min(.18,this.calibration.closedBaseline)),this.calibration.openBaseline-this.calibration.closedBaseline<.1&&(this.calibration.openBaseline=this.calibration.closedBaseline+.1)}computePerceptualOpenness(a){let{openBaseline:b,closedBaseline:c}=this.calibration;if(a<.15||a<=c)return 0;if(a>=b)return 100;let d=(a-c)/(b-c);return d<.2?d/.2*5:d<.6?5+(d-.2)/.4*65:70+(d-.6)/.4*30}detectEvents(a,b,c){let d=!1,e=!1,f=!1;return a<15?(this.blinkStartTime||(this.blinkStartTime=c),d=!0,c-this.blinkStartTime>500&&(e=!0)):a>30&&(this.blinkStartTime=null),a>15&&a<60&&10>Math.abs(b)&&(f=!0),e&&(f=!0),{isBlink:d,isMicrosleep:e,isDrowsy:f,confidence:1}}}class JY{tracks=new Map;nextTrackId=1;frameCount=0;constructor(){}process(a,b,c){this.frameCount++;let d=Date.now(),e=a.filter(a=>this.isValidCandidate(a)),f=this.associateTracks(e),g=[];return f.matches.forEach(a=>{let b=this.tracks.get(a.trackId),c=e[a.detIndex];if(this.updateTrack(b,c,d),this.isConfirmed(b)){let d=this.assessThreat(b);if("safe"!==d){let e=b.objectClass,f=c.severity;"wrong_way"===d&&(e="wrong_way_vehicle",f="critical"),g.push({...c,id:`trk_${a.trackId}`,objectClass:e,severity:f})}}}),f.unmatchedDetections.forEach(a=>{let b=e[a],c=this.createTrack(b,d);this.isConfirmed(c)&&"safe"!==this.assessThreat(c)&&g.push({...b,id:`trk_${c.id}`})}),f.unmatchedTracks.forEach(a=>{let b=this.tracks.get(a);b.missCounter++,b.missCounter>2&&this.tracks.delete(a)}),g}isValidCandidate(a){let b=a.bbox;if(a.objectClass,b.width<.02)return!1;let c=b.x+b.width/2,d=b.y+b.height;return!!this.isInTrapezoid(c,d)}assessThreat(a){let b=a.objectClass;if(["pothole","debris","fallen_tree","pedestrian","cow","animal","wrong_way_vehicle"].some(a=>b.includes(a)))return"hazard";if(this.isVehicle(b)&&("wrong_way_vehicle"===b||a.isApproaching&&.2>Math.abs(a.box.x+a.box.width/2-.5)))return"wrong_way";return"safe"}isVehicle(a){return["vehicle","wrong_way_vehicle","broken_vehicle","car","truck","bus","motorcycle"].includes(a)}isInTrapezoid(a,b){if(b<.45||b>1)return!1;let c=(b-.45)/.55;return a>=.4+-.4*c&&a<=.6+.4*c}associateTracks(a){let b=[],c=[],d=new Set(this.tracks.keys());for(let e of a.map((a,b)=>b).sort((b,c)=>a[c].confidence-a[b].confidence)){let f=a[e],g=-1,h=null;for(let a of d){let b=this.tracks.get(a),c=this.computeIoU(f.bbox,b.box);c>.3&&c>g&&(g=c,h=a)}h?(b.push({trackId:h,detIndex:e}),d.delete(h)):c.push(e)}return{matches:b,unmatchedDetections:c,unmatchedTracks:Array.from(d)}}updateTrack(a,b,c){let d=a.box,e=b.bbox,f=e.y-d.y,g=e.width-d.width;a.velocityY=.7*a.velocityY+.3*f,a.expansionRate=.7*a.expansionRate+.3*g,a.isApproaching=a.velocityY>.001&&a.expansionRate>.001,a.hitCounter++,a.missCounter=0,a.lastSeen=c,a.box=b.bbox,a.confidenceHistory.push(b.confidence),a.confidenceHistory.length>5&&a.confidenceHistory.shift()}createTrack(a,b){let c=(this.nextTrackId++).toString(),d={id:c,firstSeen:b,lastSeen:b,hitCounter:1,missCounter:0,objectClass:a.objectClass,box:a.bbox,confidenceHistory:[a.confidence],confirmed:!1,velocityX:0,velocityY:0,expansionRate:0,isApproaching:!1};return this.tracks.set(c,d),d}isConfirmed(a){if(a.confirmed)return!0;let b=a.confidenceHistory.reduce((a,b)=>a+b,0)/a.confidenceHistory.length;if(["person","car","truck","bus","motorcycle","cow","pedestrian","animal_large"].some(b=>a.objectClass.includes(b))){if(b>.6||a.hitCounter>=2)return a.confirmed=!0,!0}else if(a.hitCounter>=3)return a.confirmed=!0,!0;return!1}computeIoU(a,b){let c=Math.max(a.x,b.x),d=Math.max(a.y,b.y),e=Math.min(a.x+a.width,b.x+b.width),f=Math.min(a.y+a.height,b.y+b.height);if(e<c||f<d)return 0;let g=(e-c)*(f-d);return g/(a.width*a.height+b.width*b.height-g)}}let JZ=new JY,J$=null,J_=new JX,J0=0,J1=!1,J2=0,J3=null,J4=null,J5=0,J6={frameCount:0};function J7(a){let b=Date.now();a===J4&&b-J2<1e4||(a!==J3&&JT.play(),J3=a,J4=a,J2=b,setTimeout(()=>{J3===a&&(J3=null)},5e3))}function J8(){return J3}async function J9(a){if(!a||a.readyState<2||(await (!J$&&(J$=dB.ready()),J$),await JQ(),!JR()))return null;try{let b=await JS(a);if(!b||b.length<2)return null;let[c,d]=b,e=await c.array();await d.arraySync(),c.dispose(),d.dispose();let f=Array.isArray(e[0])?e[0]:e;if(!f||f.length<1404)return++J5,null;J5=0;let g=[];for(let a=0;a<f.length;a+=3)g.push({x:f[a],y:f[a+1],z:f[a+2]});let h=J_.processFrame(g);if(!h)return null;let i=Date.now();h.isBlink&&!J1?(J0++,J1=!0):h.isBlink||(J1=!1);let j=!h.isDrowsy&&!h.isMicrosleep;return J6.frameCount++%30==0&&console.log("Biometric Eye State:",{openness:h.opennessPercent.toFixed(1)+"%",raw:h.rawOpennessMetric.toFixed(3),isBlink:h.isBlink,isMicrosleep:h.isMicrosleep,state:j?"ALERT":"DROWSY"}),{alertnessScore:Math.round(h.opennessPercent),eyeAspectRatio:h.rawOpennessMetric,blinkCount:J0,blinkFrequency:0,isAlert:j,headTilt:null,lookingAway:!1,yawning:!1,lastUpdated:i}}catch(a){return console.warn("FaceMesh detection failed:",a),null}}let Ka={person:"pedestrian",bicycle:"cyclist",car:"vehicle",motorcycle:"vehicle",airplane:"other",bus:"vehicle",train:"vehicle",truck:"vehicle",boat:"other",bench:"fallen_tree",chair:"fallen_tree",couch:"fallen_tree",bed:"fallen_tree",diningtable:"fallen_tree",pottedplant:"fallen_tree",backpack:"pothole",handbag:"pothole",suitcase:"debris",umbrella:"debris",bottle:"pothole",cup:"pothole",bowl:"pothole",bird:"animal",cat:"animal",dog:"dog",horse:"animal_large",sheep:"animal_large",cow:"cow",elephant:"animal_large",bear:"bear",zebra:"animal_large",giraffe:"animal_large",traffic_light:"other",fire_hydrant:"road_barrier",stop_sign:"road_barrier",parking_meter:"road_barrier",tie:"other",frisbee:"debris",skis:"debris",snowboard:"debris",sports_ball:"debris",kite:"debris",baseball_bat:"debris",baseball_glove:"debris",skateboard:"debris",surfboard:"debris",tennis_racket:"debris",wine_glass:"debris",fork:"debris",knife:"debris",spoon:"debris",banana:"debris",apple:"debris",sandwich:"debris",orange:"debris",broccoli:"debris",carrot:"debris",hot_dog:"debris",pizza:"debris",donut:"debris",cake:"debris",toilet:"debris",tv:"debris",laptop:"debris",mouse:"debris",remote:"debris",keyboard:"debris",cell_phone:"debris",microwave:"debris",oven:"debris",toaster:"debris",sink:"debris",refrigerator:"debris",book:"debris",clock:"debris",vase:"debris",scissors:"debris",teddy_bear:"debris",hair_drier:"debris",toothbrush:"debris"};async function Kb(a){if(!a)return[];await JO();let b=JP();if(!b)return[];try{let c=Date.now(),d=b.detectForVideo(a,c);if(!d||!d.detections)return[];let e=[];for(let b=0;b<d.detections.length;b++){let f=d.detections[b],g=f.categories[0];if(!g||g.score<.2)continue;let h=Ka[(g.categoryName?.toLowerCase()||"unknown").toLowerCase().replace(" ","_")]??"other";if("other"===h)continue;let i=f.boundingBox;i&&e.push({id:`${c}-${b}`,objectClass:h,confidence:g.score,severity:"pedestrian"===h||"cow"===h||"wrong_way_vehicle"===h?"critical":"high",bbox:{x:i.originX/a.videoWidth,y:i.originY/a.videoHeight,width:i.width/a.videoWidth,height:i.height/a.videoHeight},timestamp:c})}return JZ.process(e,a.videoWidth,a.videoHeight)}catch(a){return console.error("Hazard detection failed:",a),[]}}a.s(["getCurrentAlert",()=>J8,"runRealDrowsinessDetection",()=>J9,"runRealHazardDetection",()=>Kb,"triggerAlert",()=>J7],409e3)}];

//# sourceMappingURL=%5Broot-of-the-server%5D__d2cb7e51._.js.map